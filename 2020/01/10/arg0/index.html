<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>《程序员代码面试指南》 | SHIVAKASU</title><meta name="description" content="《程序员代码面试指南》"><meta name="keywords" content="算法,面试"><meta name="author" content="w.k.x.,wkx1996@foxmail.com"><meta name="copyright" content="w.k.x."><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="http://file.shivakasu.cn/eb8581b76ec032ab0db8/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《程序员代码面试指南》"><meta name="twitter:description" content="《程序员代码面试指南》"><meta name="twitter:image" content="http://file.shivakasu.cn/5f37cb297aa622ca620e/interview0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《程序员代码面试指南》"><meta property="og:url" content="http://shivakasu.github.io/2020/01/10/arg0/"><meta property="og:site_name" content="SHIVAKASU"><meta property="og:description" content="《程序员代码面试指南》"><meta property="og:image" content="http://file.shivakasu.cn/5f37cb297aa622ca620e/interview0.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://shivakasu.github.io/2020/01/10/arg0/"><link rel="prev" title="字符串匹配算法总结" href="http://shivakasu.github.io/2020/01/11/arg1/"><link rel="next" title="流畅的Python Chapter 7：函数装饰器和闭包" href="http://shivakasu.github.io/2019/02/10/fpy4/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QBXC0PXLIT","apiKey":"517431eabeeedb8d3792391b21e8cf20","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: w.k.x.","link":"链接: http://shivakasu.github.io/2020/01/10/arg0/","source":"来源: SHIVAKASU","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="SHIVAKASU" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">SHIVAKASU</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="http://file.shivakasu.cn/cb7049104af4685e7289/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第一章-栈和队列"><span class="toc_mobile_items-text">第一章 栈和队列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-1-getmin-栈"><span class="toc_mobile_items-text">1.1  $getmin$ 栈</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-2-两个栈组成队列"><span class="toc_mobile_items-text">1.2 两个栈组成队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-3-用递归函数和栈逆序一个栈"><span class="toc_mobile_items-text">1.3 用递归函数和栈逆序一个栈</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-4-猫狗队列"><span class="toc_mobile_items-text">1.4 猫狗队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-5-用一个栈实现另一个栈的排序"><span class="toc_mobile_items-text">1.5 用一个栈实现另一个栈的排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-6-用栈求解汉诺塔"><span class="toc_mobile_items-text">1.6 用栈求解汉诺塔</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-7-生成窗口最大值数组"><span class="toc_mobile_items-text">1.7 生成窗口最大值数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-8-maxtree"><span class="toc_mobile_items-text">1.8 maxtree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-9-最大子矩阵"><span class="toc_mobile_items-text">1.9 最大子矩阵</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-10-最大值减最小值小于等于-num-的子数组数量"><span class="toc_mobile_items-text">1.10 最大值减最小值小于等于 $num$ 的子数组数量</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第二章-链表问题"><span class="toc_mobile_items-text">第二章 链表问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-1-打印两个有序链表的公共部分"><span class="toc_mobile_items-text">2.1 打印两个有序链表的公共部分</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-2-在单链表和双向链表中删除倒数第k个节点"><span class="toc_mobile_items-text">2.2 在单链表和双向链表中删除倒数第k个节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-3-删除链表的中间节点"><span class="toc_mobile_items-text">2.3 删除链表的中间节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-4-反转单向和双向链表"><span class="toc_mobile_items-text">2.4 反转单向和双向链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-5-反转部分单向链表"><span class="toc_mobile_items-text">2.5 反转部分单向链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-6-环形链表的约瑟夫问题"><span class="toc_mobile_items-text">2.6 环形链表的约瑟夫问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-7-判断链表是否回文"><span class="toc_mobile_items-text">2.7 判断链表是否回文</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-8-单链表划分成左边小中间相等右边大"><span class="toc_mobile_items-text">2.8 单链表划分成左边小中间相等右边大</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-9-复制含有随机指针节点的链表"><span class="toc_mobile_items-text">2.9 复制含有随机指针节点的链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-10-两个单链表模拟整数相加"><span class="toc_mobile_items-text">2.10 两个单链表模拟整数相加</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-11-一个链表是否有环"><span class="toc_mobile_items-text">2.11 一个链表是否有环</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-12-两个无环链表是否相交"><span class="toc_mobile_items-text">2.12 两个无环链表是否相交</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-13-两个有环链表是否相交"><span class="toc_mobile_items-text">2.13 两个有环链表是否相交</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-14-将单链表每k个节点之间逆序"><span class="toc_mobile_items-text">2.14 将单链表每k个节点之间逆序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-15-删除无序单链表中值重复的节点"><span class="toc_mobile_items-text">2.15 删除无序单链表中值重复的节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-16-单链表删除指定值的节点"><span class="toc_mobile_items-text">2.16 单链表删除指定值的节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-17-二叉树转双向链表"><span class="toc_mobile_items-text">2.17 二叉树转双向链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-18-单链表选择排序"><span class="toc_mobile_items-text">2.18 单链表选择排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-19-怪异的节点删除方式"><span class="toc_mobile_items-text">2.19 怪异的节点删除方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-20-向有序环形单链表插入新节点"><span class="toc_mobile_items-text">2.20 向有序环形单链表插入新节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-21-合并两个有序单链表"><span class="toc_mobile_items-text">2.21 合并两个有序单链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-22-按照左右半区重新组合单链表"><span class="toc_mobile_items-text">2.22 按照左右半区重新组合单链表</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第三章-二叉树问题"><span class="toc_mobile_items-text">第三章 二叉树问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-1-非递归二叉树先序遍历"><span class="toc_mobile_items-text">3.1 非递归二叉树先序遍历</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-2-非递归二叉树中序遍历"><span class="toc_mobile_items-text">3.2 非递归二叉树中序遍历</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-3-非递归二叉树后序遍历"><span class="toc_mobile_items-text">3.3 非递归二叉树后序遍历</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-4-打印二叉树边界节点"><span class="toc_mobile_items-text">3.4 打印二叉树边界节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-5-直观打印二叉树"><span class="toc_mobile_items-text">3.5 直观打印二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-6-二叉树的序列化和反序列化"><span class="toc_mobile_items-text">3.6 二叉树的序列化和反序列化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-7-遍历二叉树的神级方法"><span class="toc_mobile_items-text">3.7 遍历二叉树的神级方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-8-在二叉树中找到累加和为指定值的最长路径长度"><span class="toc_mobile_items-text">3.8 在二叉树中找到累加和为指定值的最长路径长度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-9-找到二叉树中的最大搜索二叉子树"><span class="toc_mobile_items-text">3.9 找到二叉树中的最大搜索二叉子树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构"><span class="toc_mobile_items-text">3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-11-二叉树按层打印和-zigzag-打印"><span class="toc_mobile_items-text">3.11 二叉树按层打印和 $zigzag$ 打印</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-12-调整搜索二叉树中两个错误节点"><span class="toc_mobile_items-text">3.12 调整搜索二叉树中两个错误节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-13-判断-t1-树是否包含-t2-树全部的拓扑结构"><span class="toc_mobile_items-text">3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树"><span class="toc_mobile_items-text">3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-15-判断二叉树是否是平衡二叉树"><span class="toc_mobile_items-text">3.15 判断二叉树是否是平衡二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-16-根据后序数组重建搜索二叉树"><span class="toc_mobile_items-text">3.16 根据后序数组重建搜索二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树"><span class="toc_mobile_items-text">3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-18-通过有序数组生成平衡搜索二叉树"><span class="toc_mobile_items-text">3.18 通过有序数组生成平衡搜索二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-19-在二叉树中找到一个节点中序遍历的后继节点"><span class="toc_mobile_items-text">3.19 在二叉树中找到一个节点中序遍历的后继节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-20-在二叉树中找到两个节点的最近公共祖先"><span class="toc_mobile_items-text">3.20 在二叉树中找到两个节点的最近公共祖先</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题"><span class="toc_mobile_items-text">3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-22-二叉树节点间的最大距离"><span class="toc_mobile_items-text">3.22 二叉树节点间的最大距离</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-23-先中后序数组两两结合重构二叉树"><span class="toc_mobile_items-text">3.23 先中后序数组两两结合重构二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-24-通过先序和中序数组生成后序数组"><span class="toc_mobile_items-text">3.24 通过先序和中序数组生成后序数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-25-统计和生成所有不同的二叉树"><span class="toc_mobile_items-text">3.25 统计和生成所有不同的二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-26-统计完全二叉树的节点数"><span class="toc_mobile_items-text">3.26 统计完全二叉树的节点数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第四章-递归和动态规划"><span class="toc_mobile_items-text">第四章 递归和动态规划</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-1-求斐波那契第N项"><span class="toc_mobile_items-text">4.1 求斐波那契第N项</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-2-斐波那契求奶牛数量"><span class="toc_mobile_items-text">4.2 斐波那契求奶牛数量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-3-矩阵的最小路径和"><span class="toc_mobile_items-text">4.3 矩阵的最小路径和</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-4-换钱的最少货币数"><span class="toc_mobile_items-text">4.4 换钱的最少货币数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-5-换钱的方法数"><span class="toc_mobile_items-text">4.5 换钱的方法数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-6-最长递增子序列"><span class="toc_mobile_items-text">4.6 最长递增子序列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-7-汉诺塔"><span class="toc_mobile_items-text">4.7 汉诺塔</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-8-判断给的状态是不是汉诺塔最优过程中的某个状态"><span class="toc_mobile_items-text">4.8 判断给的状态是不是汉诺塔最优过程中的某个状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-9-最长公共子序列"><span class="toc_mobile_items-text">4.9 最长公共子序列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-10-最长公共子串"><span class="toc_mobile_items-text">4.10 最长公共子串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-11-最小编辑代价"><span class="toc_mobile_items-text">4.11 最小编辑代价</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-12-字符串的交错组成"><span class="toc_mobile_items-text">4.12 字符串的交错组成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-13-龙与地下城"><span class="toc_mobile_items-text">4.13 龙与地下城</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-14-数字字符串转换为字母组合的种数"><span class="toc_mobile_items-text">4.14 数字字符串转换为字母组合的种数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-15-表达式得到期望结果的组合种数"><span class="toc_mobile_items-text">4.15 表达式得到期望结果的组合种数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-16-排成一条线的纸牌博弈问题"><span class="toc_mobile_items-text">4.16 排成一条线的纸牌博弈问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-17-跳跃问题"><span class="toc_mobile_items-text">4.17 跳跃问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-18-数组中的最长连续序列"><span class="toc_mobile_items-text">4.18 数组中的最长连续序列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-19-N-皇后问题"><span class="toc_mobile_items-text">4.19  $N$ 皇后问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第五章-字符串问题"><span class="toc_mobile_items-text">第五章 字符串问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-1-判断两个字符串是否互为变形词"><span class="toc_mobile_items-text">5.1 判断两个字符串是否互为变形词</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-2-字符串中数字子串的求和"><span class="toc_mobile_items-text">5.2 字符串中数字子串的求和</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-3-去掉字符串中连续出现k个0的子串"><span class="toc_mobile_items-text">5.3 去掉字符串中连续出现k个0的子串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-4-判断两个字符串是否互为旋转词"><span class="toc_mobile_items-text">5.4 判断两个字符串是否互为旋转词</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-5-将整数字符串转成整数值"><span class="toc_mobile_items-text">5.5 将整数字符串转成整数值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-6-替换字符串中连续出现的指定字符串"><span class="toc_mobile_items-text">5.6 替换字符串中连续出现的指定字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-7-字符串的统计字符串"><span class="toc_mobile_items-text">5.7 字符串的统计字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-8-判断字符数组中是否所有的字符都只出现过一次"><span class="toc_mobile_items-text">5.8 判断字符数组中是否所有的字符都只出现过一次</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-9-在有序但含有空的数组中查找字符串"><span class="toc_mobile_items-text">5.9 在有序但含有空的数组中查找字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-10-字符串的调整与替换"><span class="toc_mobile_items-text">5.10 字符串的调整与替换</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-11-翻转字符串"><span class="toc_mobile_items-text">5.11 翻转字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-12-数组中两个字符串的最小距离"><span class="toc_mobile_items-text">5.12 数组中两个字符串的最小距离</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-13-添加最少字符使字符串整体都是回文字符串"><span class="toc_mobile_items-text">5.13 添加最少字符使字符串整体都是回文字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"><span class="toc_mobile_items-text">5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-15-括号字符串的有效性和最长有效长度"><span class="toc_mobile_items-text">5.15 括号字符串的有效性和最长有效长度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-16-公式字符串求值"><span class="toc_mobile_items-text">5.16 公式字符串求值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-17-0-左边必有-1-的二进制字符串数量"><span class="toc_mobile_items-text">5.17  $0$ 左边必有 $1$ 的二进制字符串数量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-18-拼接所有字符串产生字典顺序最小的大写字符串"><span class="toc_mobile_items-text">5.18 拼接所有字符串产生字典顺序最小的大写字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-19-找到字符串的最长无重复字符子串"><span class="toc_mobile_items-text">5.19 找到字符串的最长无重复字符子串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-20-找到被指的新类型字符"><span class="toc_mobile_items-text">5.20 找到被指的新类型字符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-21-最小包含子串的长度"><span class="toc_mobile_items-text">5.21 最小包含子串的长度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-22-回文最少分割数"><span class="toc_mobile_items-text">5.22 回文最少分割数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-23-字符串匹配问题"><span class="toc_mobile_items-text">5.23 字符串匹配问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-24-字典树的实现"><span class="toc_mobile_items-text">5.24 字典树的实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第六章-大数据和空间限制"><span class="toc_mobile_items-text">第六章 大数据和空间限制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-1-布隆过滤器"><span class="toc_mobile_items-text">6.1 布隆过滤器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-2-找到出现最多的数"><span class="toc_mobile_items-text">6.2 找到出现最多的数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-3-找到没出现的数"><span class="toc_mobile_items-text">6.3 找到没出现的数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-4-找到所有重复的-url"><span class="toc_mobile_items-text">6.4 找到所有重复的 $url$</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-5-统计词汇-top-k"><span class="toc_mobile_items-text">6.5 统计词汇 $top_k$</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-6-找到出现两次的数"><span class="toc_mobile_items-text">6.6 找到出现两次的数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-7-找中位数"><span class="toc_mobile_items-text">6.7 找中位数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-8-一致性哈希算法"><span class="toc_mobile_items-text">6.8 一致性哈希算法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第七章-位运算"><span class="toc_mobile_items-text">第七章 位运算</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-1-不用额外变量交换两个整数的值"><span class="toc_mobile_items-text">7.1 不用额外变量交换两个整数的值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-2-不用任何比较判断找出两个数中较大的数"><span class="toc_mobile_items-text">7.2 不用任何比较判断找出两个数中较大的数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出"><span class="toc_mobile_items-text">7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-4-整数的二进制表达中有多少个-1"><span class="toc_mobile_items-text">7.4 整数的二进制表达中有多少个 $1$</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-5-在其他数都出现偶数次的数组中找到出现奇数次的数"><span class="toc_mobile_items-text">7.5 在其他数都出现偶数次的数组中找到出现奇数次的数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-6-在其他数都出现-k-次的数组中找到只出现一次的数"><span class="toc_mobile_items-text">7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第八章-数组和矩阵问题"><span class="toc_mobile_items-text">第八章 数组和矩阵问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-1-转圈打印矩阵"><span class="toc_mobile_items-text">8.1 转圈打印矩阵</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-2-将正方形矩阵顺时针旋转-90-deg"><span class="toc_mobile_items-text">8.2 将正方形矩阵顺时针旋转 90&amp;deg;</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-3-之字形打印矩阵"><span class="toc_mobile_items-text">8.3 之字形打印矩阵</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-4-找到无序数组中最小的-k-个数"><span class="toc_mobile_items-text">8.4 找到无序数组中最小的 $k$ 个数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-5-需要排序的最短子数组长度"><span class="toc_mobile_items-text">8.5 需要排序的最短子数组长度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-6-在数组中找到出现次数大于-N-K-的数"><span class="toc_mobile_items-text">8.6 在数组中找到出现次数大于 $N&#x2F;K$ 的数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-7-在行列都排好序的矩阵中找数"><span class="toc_mobile_items-text">8.7 在行列都排好序的矩阵中找数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-8-最长的可整合子数组的长度"><span class="toc_mobile_items-text">8.8 最长的可整合子数组的长度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><span class="toc_mobile_items-text">8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-10-未排序正数数组中累加和为给定值的最长子数组长度"><span class="toc_mobile_items-text">8.10 未排序正数数组中累加和为给定值的最长子数组长度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-11-未排序数组中最长子数组系列问题"><span class="toc_mobile_items-text">8.11 未排序数组中最长子数组系列问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-12-未排序数组中累加和小于或等于给定值的最长子数组长度"><span class="toc_mobile_items-text">8.12 未排序数组中累加和小于或等于给定值的最长子数组长度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-13-计算数组的小和"><span class="toc_mobile_items-text">8.13 计算数组的小和</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-14-自然数数组的排序"><span class="toc_mobile_items-text">8.14 自然数数组的排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-15-奇数下标都是奇数或者偶数下标都是偶数"><span class="toc_mobile_items-text">8.15 奇数下标都是奇数或者偶数下标都是偶数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-16-子数组的最大累加和问题"><span class="toc_mobile_items-text">8.16 子数组的最大累加和问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-17-子矩阵的最大累加和问题"><span class="toc_mobile_items-text">8.17 子矩阵的最大累加和问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-18-在数组中找到一个局部最小的位置"><span class="toc_mobile_items-text">8.18 在数组中找到一个局部最小的位置</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-19-数组中子数组的最大累乘积"><span class="toc_mobile_items-text">8.19 数组中子数组的最大累乘积</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-20-打印-N-个数组整体最大的-topK"><span class="toc_mobile_items-text">8.20 打印 $N$ 个数组整体最大的 $topK$</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-21-边界都是-1-的最大正方形大小"><span class="toc_mobile_items-text">8.21 边界都是 $1$ 的最大正方形大小</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-22-不包含本位置值的累乘数组"><span class="toc_mobile_items-text">8.22 不包含本位置值的累乘数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-23-数组的-partition-调整"><span class="toc_mobile_items-text">8.23 数组的 $partition$ 调整</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-24-求最短通路值"><span class="toc_mobile_items-text">8.24 求最短通路值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-25-数组中未出现的最小正整数"><span class="toc_mobile_items-text">8.25 数组中未出现的最小正整数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-26-数组排序之后相邻数的最大差值"><span class="toc_mobile_items-text">8.26 数组排序之后相邻数的最大差值</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第九章-其他题目"><span class="toc_mobile_items-text">第九章 其他题目</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-1-从-5-随机到-7-随机及其扩展"><span class="toc_mobile_items-text">9.1 从 $5$ 随机到 $7$ 随机及其扩展</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-2-一行代码求两个数的最大公约数"><span class="toc_mobile_items-text">9.2 一行代码求两个数的最大公约数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-3-有关阶乘的两个问题"><span class="toc_mobile_items-text">9.3 有关阶乘的两个问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-4-判断一个点是否在矩形内部"><span class="toc_mobile_items-text">9.4 判断一个点是否在矩形内部</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-5-判断一个点是否在三角形内部"><span class="toc_mobile_items-text">9.5 判断一个点是否在三角形内部</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-6-折纸问题"><span class="toc_mobile_items-text">9.6 折纸问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-7-蓄水池算法"><span class="toc_mobile_items-text">9.7 蓄水池算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-8-设计有-setAll-功能的哈希表"><span class="toc_mobile_items-text">9.8 设计有 $setAll$ 功能的哈希表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-9-最大的-leftMax-与-rightMax-之差的绝对值"><span class="toc_mobile_items-text">9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-10-设计可以变更的缓存结构"><span class="toc_mobile_items-text">9.10 设计可以变更的缓存结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-11-设计-RandomPool-结构"><span class="toc_mobile_items-text">9.11 设计 $RandomPool$ 结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-12-调整-0-x-区间上的数出现的概率"><span class="toc_mobile_items-text">9.12 调整 $[0,x)$ 区间上的数出现的概率</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-13-路径数组变为统计数组"><span class="toc_mobile_items-text">9.13 路径数组变为统计数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-14-正数数组的最小不可组成和"><span class="toc_mobile_items-text">9.14 正数数组的最小不可组成和</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-14-一种字符串和数字的对应关系"><span class="toc_mobile_items-text">9.14 一种字符串和数字的对应关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-15-1-到-n-中-1-出现的次数"><span class="toc_mobile_items-text">9.15  $1$ 到 $n$ 中 $1$ 出现的次数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-16-从-N-个数中等概率打印-M-个数"><span class="toc_mobile_items-text">9.16 从 $N$ 个数中等概率打印 $M$ 个数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-17-判断一个数是否是回文数"><span class="toc_mobile_items-text">9.17 判断一个数是否是回文数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-18-在有序旋转数组中找到最小值"><span class="toc_mobile_items-text">9.18 在有序旋转数组中找到最小值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-19-在有序旋转数组中找到一个数"><span class="toc_mobile_items-text">9.19 在有序旋转数组中找到一个数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-20-数字的英文表达和中文表达"><span class="toc_mobile_items-text">9.20 数字的英文表达和中文表达</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-21-分糖果问题"><span class="toc_mobile_items-text">9.21 分糖果问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-22-一种消息接受并打印的结构设计"><span class="toc_mobile_items-text">9.22 一种消息接受并打印的结构设计</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-23-设计一个没有扩容负担的堆结构"><span class="toc_mobile_items-text">9.23 设计一个没有扩容负担的堆结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-24-随时找到数据流的中位数"><span class="toc_mobile_items-text">9.24 随时找到数据流的中位数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-25-在两个长度相等的排序数组中找到上中位数"><span class="toc_mobile_items-text">9.25 在两个长度相等的排序数组中找到上中位数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-26-在两个排序数组中找到第-K-小的数"><span class="toc_mobile_items-text">9.26 在两个排序数组中找到第 $K$ 小的数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-27-两个有序数组间相加和的-TOPK-问题"><span class="toc_mobile_items-text">9.27 两个有序数组间相加和的 $TOPK$ 问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-28-出现次数的-TOPK-问题"><span class="toc_mobile_items-text">9.28 出现次数的 $TOPK$ 问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-29-Manacher-算法"><span class="toc_mobile_items-text">9.29  $Manacher$ 算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-30-KMP-算法"><span class="toc_mobile_items-text">9.30  $KMP$ 算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-31-丢棋子问题"><span class="toc_mobile_items-text">9.31 丢棋子问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-32-画匠问题"><span class="toc_mobile_items-text">9.32 画匠问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-33-邮局选址问题"><span class="toc_mobile_items-text">9.33 邮局选址问题</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-栈和队列"><span class="toc-text">第一章 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-getmin-栈"><span class="toc-text">1.1  $getmin$ 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-两个栈组成队列"><span class="toc-text">1.2 两个栈组成队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-用递归函数和栈逆序一个栈"><span class="toc-text">1.3 用递归函数和栈逆序一个栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-猫狗队列"><span class="toc-text">1.4 猫狗队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-用一个栈实现另一个栈的排序"><span class="toc-text">1.5 用一个栈实现另一个栈的排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-用栈求解汉诺塔"><span class="toc-text">1.6 用栈求解汉诺塔</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-生成窗口最大值数组"><span class="toc-text">1.7 生成窗口最大值数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-maxtree"><span class="toc-text">1.8 maxtree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-最大子矩阵"><span class="toc-text">1.9 最大子矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-最大值减最小值小于等于-num-的子数组数量"><span class="toc-text">1.10 最大值减最小值小于等于 $num$ 的子数组数量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-链表问题"><span class="toc-text">第二章 链表问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-打印两个有序链表的公共部分"><span class="toc-text">2.1 打印两个有序链表的公共部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-在单链表和双向链表中删除倒数第k个节点"><span class="toc-text">2.2 在单链表和双向链表中删除倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-删除链表的中间节点"><span class="toc-text">2.3 删除链表的中间节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-反转单向和双向链表"><span class="toc-text">2.4 反转单向和双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-反转部分单向链表"><span class="toc-text">2.5 反转部分单向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-环形链表的约瑟夫问题"><span class="toc-text">2.6 环形链表的约瑟夫问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-判断链表是否回文"><span class="toc-text">2.7 判断链表是否回文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-单链表划分成左边小中间相等右边大"><span class="toc-text">2.8 单链表划分成左边小中间相等右边大</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-复制含有随机指针节点的链表"><span class="toc-text">2.9 复制含有随机指针节点的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-两个单链表模拟整数相加"><span class="toc-text">2.10 两个单链表模拟整数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-一个链表是否有环"><span class="toc-text">2.11 一个链表是否有环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-两个无环链表是否相交"><span class="toc-text">2.12 两个无环链表是否相交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-两个有环链表是否相交"><span class="toc-text">2.13 两个有环链表是否相交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-将单链表每k个节点之间逆序"><span class="toc-text">2.14 将单链表每k个节点之间逆序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-删除无序单链表中值重复的节点"><span class="toc-text">2.15 删除无序单链表中值重复的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16-单链表删除指定值的节点"><span class="toc-text">2.16 单链表删除指定值的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-17-二叉树转双向链表"><span class="toc-text">2.17 二叉树转双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-18-单链表选择排序"><span class="toc-text">2.18 单链表选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-19-怪异的节点删除方式"><span class="toc-text">2.19 怪异的节点删除方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-20-向有序环形单链表插入新节点"><span class="toc-text">2.20 向有序环形单链表插入新节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-21-合并两个有序单链表"><span class="toc-text">2.21 合并两个有序单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-22-按照左右半区重新组合单链表"><span class="toc-text">2.22 按照左右半区重新组合单链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-二叉树问题"><span class="toc-text">第三章 二叉树问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-非递归二叉树先序遍历"><span class="toc-text">3.1 非递归二叉树先序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-非递归二叉树中序遍历"><span class="toc-text">3.2 非递归二叉树中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-非递归二叉树后序遍历"><span class="toc-text">3.3 非递归二叉树后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-打印二叉树边界节点"><span class="toc-text">3.4 打印二叉树边界节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-直观打印二叉树"><span class="toc-text">3.5 直观打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-二叉树的序列化和反序列化"><span class="toc-text">3.6 二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-遍历二叉树的神级方法"><span class="toc-text">3.7 遍历二叉树的神级方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-在二叉树中找到累加和为指定值的最长路径长度"><span class="toc-text">3.8 在二叉树中找到累加和为指定值的最长路径长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-找到二叉树中的最大搜索二叉子树"><span class="toc-text">3.9 找到二叉树中的最大搜索二叉子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构"><span class="toc-text">3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-二叉树按层打印和-zigzag-打印"><span class="toc-text">3.11 二叉树按层打印和 $zigzag$ 打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-调整搜索二叉树中两个错误节点"><span class="toc-text">3.12 调整搜索二叉树中两个错误节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-判断-t1-树是否包含-t2-树全部的拓扑结构"><span class="toc-text">3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树"><span class="toc-text">3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-15-判断二叉树是否是平衡二叉树"><span class="toc-text">3.15 判断二叉树是否是平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-16-根据后序数组重建搜索二叉树"><span class="toc-text">3.16 根据后序数组重建搜索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树"><span class="toc-text">3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-18-通过有序数组生成平衡搜索二叉树"><span class="toc-text">3.18 通过有序数组生成平衡搜索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-19-在二叉树中找到一个节点中序遍历的后继节点"><span class="toc-text">3.19 在二叉树中找到一个节点中序遍历的后继节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-20-在二叉树中找到两个节点的最近公共祖先"><span class="toc-text">3.20 在二叉树中找到两个节点的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题"><span class="toc-text">3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-22-二叉树节点间的最大距离"><span class="toc-text">3.22 二叉树节点间的最大距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-23-先中后序数组两两结合重构二叉树"><span class="toc-text">3.23 先中后序数组两两结合重构二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-24-通过先序和中序数组生成后序数组"><span class="toc-text">3.24 通过先序和中序数组生成后序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-25-统计和生成所有不同的二叉树"><span class="toc-text">3.25 统计和生成所有不同的二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-26-统计完全二叉树的节点数"><span class="toc-text">3.26 统计完全二叉树的节点数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-递归和动态规划"><span class="toc-text">第四章 递归和动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-求斐波那契第N项"><span class="toc-text">4.1 求斐波那契第N项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-斐波那契求奶牛数量"><span class="toc-text">4.2 斐波那契求奶牛数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-矩阵的最小路径和"><span class="toc-text">4.3 矩阵的最小路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-换钱的最少货币数"><span class="toc-text">4.4 换钱的最少货币数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-换钱的方法数"><span class="toc-text">4.5 换钱的方法数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-最长递增子序列"><span class="toc-text">4.6 最长递增子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-汉诺塔"><span class="toc-text">4.7 汉诺塔</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-判断给的状态是不是汉诺塔最优过程中的某个状态"><span class="toc-text">4.8 判断给的状态是不是汉诺塔最优过程中的某个状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-最长公共子序列"><span class="toc-text">4.9 最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-最长公共子串"><span class="toc-text">4.10 最长公共子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-最小编辑代价"><span class="toc-text">4.11 最小编辑代价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12-字符串的交错组成"><span class="toc-text">4.12 字符串的交错组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-龙与地下城"><span class="toc-text">4.13 龙与地下城</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-14-数字字符串转换为字母组合的种数"><span class="toc-text">4.14 数字字符串转换为字母组合的种数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-15-表达式得到期望结果的组合种数"><span class="toc-text">4.15 表达式得到期望结果的组合种数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-16-排成一条线的纸牌博弈问题"><span class="toc-text">4.16 排成一条线的纸牌博弈问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-17-跳跃问题"><span class="toc-text">4.17 跳跃问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-18-数组中的最长连续序列"><span class="toc-text">4.18 数组中的最长连续序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-19-N-皇后问题"><span class="toc-text">4.19  $N$ 皇后问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-字符串问题"><span class="toc-text">第五章 字符串问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-判断两个字符串是否互为变形词"><span class="toc-text">5.1 判断两个字符串是否互为变形词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-字符串中数字子串的求和"><span class="toc-text">5.2 字符串中数字子串的求和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-去掉字符串中连续出现k个0的子串"><span class="toc-text">5.3 去掉字符串中连续出现k个0的子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-判断两个字符串是否互为旋转词"><span class="toc-text">5.4 判断两个字符串是否互为旋转词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-将整数字符串转成整数值"><span class="toc-text">5.5 将整数字符串转成整数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-替换字符串中连续出现的指定字符串"><span class="toc-text">5.6 替换字符串中连续出现的指定字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-字符串的统计字符串"><span class="toc-text">5.7 字符串的统计字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-判断字符数组中是否所有的字符都只出现过一次"><span class="toc-text">5.8 判断字符数组中是否所有的字符都只出现过一次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-在有序但含有空的数组中查找字符串"><span class="toc-text">5.9 在有序但含有空的数组中查找字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-字符串的调整与替换"><span class="toc-text">5.10 字符串的调整与替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-11-翻转字符串"><span class="toc-text">5.11 翻转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-12-数组中两个字符串的最小距离"><span class="toc-text">5.12 数组中两个字符串的最小距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-13-添加最少字符使字符串整体都是回文字符串"><span class="toc-text">5.13 添加最少字符使字符串整体都是回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"><span class="toc-text">5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-15-括号字符串的有效性和最长有效长度"><span class="toc-text">5.15 括号字符串的有效性和最长有效长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-16-公式字符串求值"><span class="toc-text">5.16 公式字符串求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-17-0-左边必有-1-的二进制字符串数量"><span class="toc-text">5.17  $0$ 左边必有 $1$ 的二进制字符串数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-18-拼接所有字符串产生字典顺序最小的大写字符串"><span class="toc-text">5.18 拼接所有字符串产生字典顺序最小的大写字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-19-找到字符串的最长无重复字符子串"><span class="toc-text">5.19 找到字符串的最长无重复字符子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-20-找到被指的新类型字符"><span class="toc-text">5.20 找到被指的新类型字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-21-最小包含子串的长度"><span class="toc-text">5.21 最小包含子串的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-22-回文最少分割数"><span class="toc-text">5.22 回文最少分割数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-23-字符串匹配问题"><span class="toc-text">5.23 字符串匹配问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-24-字典树的实现"><span class="toc-text">5.24 字典树的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-大数据和空间限制"><span class="toc-text">第六章 大数据和空间限制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-布隆过滤器"><span class="toc-text">6.1 布隆过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-找到出现最多的数"><span class="toc-text">6.2 找到出现最多的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-找到没出现的数"><span class="toc-text">6.3 找到没出现的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-找到所有重复的-url"><span class="toc-text">6.4 找到所有重复的 $url$</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-统计词汇-top-k"><span class="toc-text">6.5 统计词汇 $top_k$</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-找到出现两次的数"><span class="toc-text">6.6 找到出现两次的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-找中位数"><span class="toc-text">6.7 找中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-一致性哈希算法"><span class="toc-text">6.8 一致性哈希算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-位运算"><span class="toc-text">第七章 位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-不用额外变量交换两个整数的值"><span class="toc-text">7.1 不用额外变量交换两个整数的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-不用任何比较判断找出两个数中较大的数"><span class="toc-text">7.2 不用任何比较判断找出两个数中较大的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出"><span class="toc-text">7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-整数的二进制表达中有多少个-1"><span class="toc-text">7.4 整数的二进制表达中有多少个 $1$</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-在其他数都出现偶数次的数组中找到出现奇数次的数"><span class="toc-text">7.5 在其他数都出现偶数次的数组中找到出现奇数次的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-在其他数都出现-k-次的数组中找到只出现一次的数"><span class="toc-text">7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章-数组和矩阵问题"><span class="toc-text">第八章 数组和矩阵问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-转圈打印矩阵"><span class="toc-text">8.1 转圈打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-将正方形矩阵顺时针旋转-90-deg"><span class="toc-text">8.2 将正方形矩阵顺时针旋转 90&amp;deg;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-之字形打印矩阵"><span class="toc-text">8.3 之字形打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-找到无序数组中最小的-k-个数"><span class="toc-text">8.4 找到无序数组中最小的 $k$ 个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-需要排序的最短子数组长度"><span class="toc-text">8.5 需要排序的最短子数组长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-在数组中找到出现次数大于-N-K-的数"><span class="toc-text">8.6 在数组中找到出现次数大于 $N&#x2F;K$ 的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-在行列都排好序的矩阵中找数"><span class="toc-text">8.7 在行列都排好序的矩阵中找数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-最长的可整合子数组的长度"><span class="toc-text">8.8 最长的可整合子数组的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><span class="toc-text">8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-未排序正数数组中累加和为给定值的最长子数组长度"><span class="toc-text">8.10 未排序正数数组中累加和为给定值的最长子数组长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-11-未排序数组中最长子数组系列问题"><span class="toc-text">8.11 未排序数组中最长子数组系列问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-12-未排序数组中累加和小于或等于给定值的最长子数组长度"><span class="toc-text">8.12 未排序数组中累加和小于或等于给定值的最长子数组长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-13-计算数组的小和"><span class="toc-text">8.13 计算数组的小和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-14-自然数数组的排序"><span class="toc-text">8.14 自然数数组的排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-15-奇数下标都是奇数或者偶数下标都是偶数"><span class="toc-text">8.15 奇数下标都是奇数或者偶数下标都是偶数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-16-子数组的最大累加和问题"><span class="toc-text">8.16 子数组的最大累加和问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-17-子矩阵的最大累加和问题"><span class="toc-text">8.17 子矩阵的最大累加和问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-18-在数组中找到一个局部最小的位置"><span class="toc-text">8.18 在数组中找到一个局部最小的位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-19-数组中子数组的最大累乘积"><span class="toc-text">8.19 数组中子数组的最大累乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-20-打印-N-个数组整体最大的-topK"><span class="toc-text">8.20 打印 $N$ 个数组整体最大的 $topK$</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-21-边界都是-1-的最大正方形大小"><span class="toc-text">8.21 边界都是 $1$ 的最大正方形大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-22-不包含本位置值的累乘数组"><span class="toc-text">8.22 不包含本位置值的累乘数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-23-数组的-partition-调整"><span class="toc-text">8.23 数组的 $partition$ 调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-24-求最短通路值"><span class="toc-text">8.24 求最短通路值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-25-数组中未出现的最小正整数"><span class="toc-text">8.25 数组中未出现的最小正整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-26-数组排序之后相邻数的最大差值"><span class="toc-text">8.26 数组排序之后相邻数的最大差值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章-其他题目"><span class="toc-text">第九章 其他题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-从-5-随机到-7-随机及其扩展"><span class="toc-text">9.1 从 $5$ 随机到 $7$ 随机及其扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-一行代码求两个数的最大公约数"><span class="toc-text">9.2 一行代码求两个数的最大公约数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-有关阶乘的两个问题"><span class="toc-text">9.3 有关阶乘的两个问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-判断一个点是否在矩形内部"><span class="toc-text">9.4 判断一个点是否在矩形内部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-判断一个点是否在三角形内部"><span class="toc-text">9.5 判断一个点是否在三角形内部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-折纸问题"><span class="toc-text">9.6 折纸问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-蓄水池算法"><span class="toc-text">9.7 蓄水池算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-设计有-setAll-功能的哈希表"><span class="toc-text">9.8 设计有 $setAll$ 功能的哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-最大的-leftMax-与-rightMax-之差的绝对值"><span class="toc-text">9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10-设计可以变更的缓存结构"><span class="toc-text">9.10 设计可以变更的缓存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-11-设计-RandomPool-结构"><span class="toc-text">9.11 设计 $RandomPool$ 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-12-调整-0-x-区间上的数出现的概率"><span class="toc-text">9.12 调整 $[0,x)$ 区间上的数出现的概率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-13-路径数组变为统计数组"><span class="toc-text">9.13 路径数组变为统计数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-14-正数数组的最小不可组成和"><span class="toc-text">9.14 正数数组的最小不可组成和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-14-一种字符串和数字的对应关系"><span class="toc-text">9.14 一种字符串和数字的对应关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-15-1-到-n-中-1-出现的次数"><span class="toc-text">9.15  $1$ 到 $n$ 中 $1$ 出现的次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-16-从-N-个数中等概率打印-M-个数"><span class="toc-text">9.16 从 $N$ 个数中等概率打印 $M$ 个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-17-判断一个数是否是回文数"><span class="toc-text">9.17 判断一个数是否是回文数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-18-在有序旋转数组中找到最小值"><span class="toc-text">9.18 在有序旋转数组中找到最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-19-在有序旋转数组中找到一个数"><span class="toc-text">9.19 在有序旋转数组中找到一个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-20-数字的英文表达和中文表达"><span class="toc-text">9.20 数字的英文表达和中文表达</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-21-分糖果问题"><span class="toc-text">9.21 分糖果问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-22-一种消息接受并打印的结构设计"><span class="toc-text">9.22 一种消息接受并打印的结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-23-设计一个没有扩容负担的堆结构"><span class="toc-text">9.23 设计一个没有扩容负担的堆结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-24-随时找到数据流的中位数"><span class="toc-text">9.24 随时找到数据流的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-25-在两个长度相等的排序数组中找到上中位数"><span class="toc-text">9.25 在两个长度相等的排序数组中找到上中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-26-在两个排序数组中找到第-K-小的数"><span class="toc-text">9.26 在两个排序数组中找到第 $K$ 小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-27-两个有序数组间相加和的-TOPK-问题"><span class="toc-text">9.27 两个有序数组间相加和的 $TOPK$ 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-28-出现次数的-TOPK-问题"><span class="toc-text">9.28 出现次数的 $TOPK$ 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-29-Manacher-算法"><span class="toc-text">9.29  $Manacher$ 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-30-KMP-算法"><span class="toc-text">9.30  $KMP$ 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-31-丢棋子问题"><span class="toc-text">9.31 丢棋子问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-32-画匠问题"><span class="toc-text">9.32 画匠问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-33-邮局选址问题"><span class="toc-text">9.33 邮局选址问题</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(http://file.shivakasu.cn/5f37cb297aa622ca620e/interview0.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">《程序员代码面试指南》</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-01-10<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-06-20</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">14.2k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 48 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2020/01/10/arg0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/01/10/arg0/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="第一章-栈和队列"><a href="#第一章-栈和队列" class="headerlink" title="第一章 栈和队列"></a>第一章 栈和队列</h1><h2 id="1-1-getmin-栈"><a href="#1-1-getmin-栈" class="headerlink" title="1.1  $getmin$ 栈"></a>1.1  $getmin$ 栈</h2><p>用两个栈， $A$ 正常使用， $B$ 在 $A$ 的 $push$ 和 $pop$ 时保持栈顶是 $A$ 的最小值</p>
<h2 id="1-2-两个栈组成队列"><a href="#1-2-两个栈组成队列" class="headerlink" title="1.2 两个栈组成队列"></a>1.2 两个栈组成队列</h2><p>两个栈方向相反， $A$ 压栈代表入队， $B$ 退栈代表出队，当 $B$ 为空时，把 $A$ 反向导入 $B$ </p>
<p>问题是不能保证出队 $O(1)$ ？</p>
<h2 id="1-3-用递归函数和栈逆序一个栈"><a href="#1-3-用递归函数和栈逆序一个栈" class="headerlink" title="1.3 用递归函数和栈逆序一个栈"></a>1.3 用递归函数和栈逆序一个栈</h2><p>两个递归函数， $A$ 递归 $pop$ 栈中所有元素，返回最后一个元素，再把剩下的 $push$ 回去。 $B$ 递归调用 $A$ ，把 $A$ 返回的 $push$ 回去</p>
<h2 id="1-4-猫狗队列"><a href="#1-4-猫狗队列" class="headerlink" title="1.4 猫狗队列"></a>1.4 猫狗队列</h2><p>一个队列存猫，一个队列存狗，一个数组用01标注存放顺序</p>
<h2 id="1-5-用一个栈实现另一个栈的排序"><a href="#1-5-用一个栈实现另一个栈的排序" class="headerlink" title="1.5 用一个栈实现另一个栈的排序"></a>1.5 用一个栈实现另一个栈的排序</h2><p>把A栈的依次 $pop$ ，如果比B栈顶大就 $push$ 到 $B$ ，否则把 $B$ $pop$ 并 $push$ 回 $A$ 直到比 $B$ 栈顶大，核心就是利用两个栈来回倒，用一个临时变量做插入排序</p>
<h2 id="1-6-用栈求解汉诺塔"><a href="#1-6-用栈求解汉诺塔" class="headerlink" title="1.6 用栈求解汉诺塔"></a>1.6 用栈求解汉诺塔</h2><p>递归思路：把 $1\sim N$ 从左移动到右，相当于把 $1\sim(N-1)$ 从左移动到中，再把 $N$ 从左移动到右，再把 $1\sim(N-1)$ 从中移动到右</p>
<p><span id="jump"></span></p>
<h2 id="1-7-生成窗口最大值数组"><a href="#1-7-生成窗口最大值数组" class="headerlink" title="1.7 生成窗口最大值数组"></a>1.7 生成窗口最大值数组</h2><p>维护一个最大长度为 $k$ 的队列，保证队头是当前位置往前 $k$ 个数的从大到小的下标，遇到较大值就弃掉前边比他小的</p>
<h2 id="1-8-maxtree"><a href="#1-8-maxtree" class="headerlink" title="1.8 maxtree"></a>1.8 maxtree</h2><p>对每一个元素，从左边和右边各选择第一个比这个元素大的值，选择值较小的元素作为父节点。证明过程就是先证明结果只有一棵树，再证明数组里每个元素在左右两侧最多分别有一个孩子</p>
<h2 id="1-9-最大子矩阵"><a href="#1-9-最大子矩阵" class="headerlink" title="1.9 最大子矩阵"></a>1.9 最大子矩阵</h2><p>以每一行为底，算出每行的纵向向上连续高度，根据高度差找最大矩阵</p>
<h2 id="1-10-最大值减最小值小于等于-num-的子数组数量"><a href="#1-10-最大值减最小值小于等于-num-的子数组数量" class="headerlink" title="1.10 最大值减最小值小于等于 $num$ 的子数组数量"></a>1.10 最大值减最小值小于等于 $num$ 的子数组数量</h2><p>仿照 <a href="#jump">1.7</a> 维护两个队列，分别存储最大值和最小值的下标，若 $a[i,j]$ 满足/不满足条件，她的所有子数组也满足/不满足条件，因此只需要两个 $flag$ 遍历数组， $j$ 向后遍历，遇到不满足的就让 $i+1$ ，再接着遍历 $j$ </p>
<h1 id="第二章-链表问题"><a href="#第二章-链表问题" class="headerlink" title="第二章 链表问题"></a>第二章 链表问题</h1><h2 id="2-1-打印两个有序链表的公共部分"><a href="#2-1-打印两个有序链表的公共部分" class="headerlink" title="2.1 打印两个有序链表的公共部分"></a>2.1 打印两个有序链表的公共部分</h2><p>因为是有序的，所以就交错遍历，遇到相等就打印</p>
<h2 id="2-2-在单链表和双向链表中删除倒数第k个节点"><a href="#2-2-在单链表和双向链表中删除倒数第k个节点" class="headerlink" title="2.2 在单链表和双向链表中删除倒数第k个节点"></a>2.2 在单链表和双向链表中删除倒数第k个节点</h2><p>遍历两次</p>
<h2 id="2-3-删除链表的中间节点"><a href="#2-3-删除链表的中间节点" class="headerlink" title="2.3 删除链表的中间节点"></a>2.3 删除链表的中间节点</h2><p>立个 $flag$ 表示中点，一边遍历一边移动 $flag$ </p>
<p><span id="jump2"></span></p>
<h2 id="2-4-反转单向和双向链表"><a href="#2-4-反转单向和双向链表" class="headerlink" title="2.4 反转单向和双向链表"></a>2.4 反转单向和双向链表</h2><p>维护三个指针，每次反转一条边</p>
<h2 id="2-5-反转部分单向链表"><a href="#2-5-反转部分单向链表" class="headerlink" title="2.5 反转部分单向链表"></a>2.5 反转部分单向链表</h2><p>把中间那段提出来仿照 <a href="#jump2">2.4</a> 反转，再反过来拼接上</p>
<h2 id="2-6-环形链表的约瑟夫问题"><a href="#2-6-环形链表的约瑟夫问题" class="headerlink" title="2.6 环形链表的约瑟夫问题"></a>2.6 环形链表的约瑟夫问题</h2><p>简单版：模拟过程转圈找   </p>
<p>进阶版：总结出递归表达式提前算出答案</p>
<h2 id="2-7-判断链表是否回文"><a href="#2-7-判断链表是否回文" class="headerlink" title="2.7 判断链表是否回文"></a>2.7 判断链表是否回文</h2><p>简单版：遍历两次，空间 $O(N)$   </p>
<p>进阶版：反转后半部分指向中间节点，从两头同时遍历，空间 $O(1)$ </p>
<h2 id="2-8-单链表划分成左边小中间相等右边大"><a href="#2-8-单链表划分成左边小中间相等右边大" class="headerlink" title="2.8 单链表划分成左边小中间相等右边大"></a>2.8 单链表划分成左边小中间相等右边大</h2><p>遍历一遍，把链表拆成三段，再把三段拼起来，因为是对原链表的指针操作，所以空间 $O(1)$ </p>
<h2 id="2-9-复制含有随机指针节点的链表"><a href="#2-9-复制含有随机指针节点的链表" class="headerlink" title="2.9 复制含有随机指针节点的链表"></a>2.9 复制含有随机指针节点的链表</h2><p>简单版：遍历两次，使用哈希表确定节点 </p>
<p>进阶版：遍历两次，第一次在每个节点后边生成复制节点，第二次复制连接，最后分离原始链表和复制链表，不必使用额外数据结构</p>
<h2 id="2-10-两个单链表模拟整数相加"><a href="#2-10-两个单链表模拟整数相加" class="headerlink" title="2.10 两个单链表模拟整数相加"></a>2.10 两个单链表模拟整数相加</h2><p>用栈或反转链表，目的是实现低位到高位的计算</p>
<h2 id="2-11-一个链表是否有环"><a href="#2-11-一个链表是否有环" class="headerlink" title="2.11 一个链表是否有环"></a>2.11 一个链表是否有环</h2><p>快慢指针追逐法，第一次相遇后快指针变慢指针从头跑，两个慢指针会在入环点相遇</p>
<h2 id="2-12-两个无环链表是否相交"><a href="#2-12-两个无环链表是否相交" class="headerlink" title="2.12 两个无环链表是否相交"></a>2.12 两个无环链表是否相交</h2><p>因为是单链表，所以一旦相交，后续将合并成一个链表，因此只需要对比两个链表的尾结点</p>
<h2 id="2-13-两个有环链表是否相交"><a href="#2-13-两个有环链表是否相交" class="headerlink" title="2.13 两个有环链表是否相交"></a>2.13 两个有环链表是否相交</h2><p>找到两个入环点，追逐法判断是否是同一个环</p>
<h2 id="2-14-将单链表每k个节点之间逆序"><a href="#2-14-将单链表每k个节点之间逆序" class="headerlink" title="2.14 将单链表每k个节点之间逆序"></a>2.14 将单链表每k个节点之间逆序</h2><p>计数反转后拼接</p>
<h2 id="2-15-删除无序单链表中值重复的节点"><a href="#2-15-删除无序单链表中值重复的节点" class="headerlink" title="2.15 删除无序单链表中值重复的节点"></a>2.15 删除无序单链表中值重复的节点</h2><p>方法一：哈希表，遍历一遍，时间空间都是 $O(N)$   </p>
<p>方法二：从每个节点遍历一遍，时间 $O(N^2)$ ，空间 $O(1)$ </p>
<h2 id="2-16-单链表删除指定值的节点"><a href="#2-16-单链表删除指定值的节点" class="headerlink" title="2.16 单链表删除指定值的节点"></a>2.16 单链表删除指定值的节点</h2><p>直接遍历，时间 $O(N)$ ，空间 $O(1)$ </p>
<h2 id="2-17-二叉树转双向链表"><a href="#2-17-二叉树转双向链表" class="headerlink" title="2.17 二叉树转双向链表"></a>2.17 二叉树转双向链表</h2><p>用队列保存中序遍历，再依次出队重连</p>
<h2 id="2-18-单链表选择排序"><a href="#2-18-单链表选择排序" class="headerlink" title="2.18 单链表选择排序"></a>2.18 单链表选择排序</h2><p>时间 $O(N^2)$ ，空间 $O(1)$ </p>
<h2 id="2-19-怪异的节点删除方式"><a href="#2-19-怪异的节点删除方式" class="headerlink" title="2.19 怪异的节点删除方式"></a>2.19 怪异的节点删除方式</h2><p>要删除节点 $A$ ，可以先把 $A.next$ 的数据复制到 $A$ ，把 $A$ 指向 $A.next.next$ ，本质上只是复制数据，没有删除节点</p>
<h2 id="2-20-向有序环形单链表插入新节点"><a href="#2-20-向有序环形单链表插入新节点" class="headerlink" title="2.20 向有序环形单链表插入新节点"></a>2.20 向有序环形单链表插入新节点</h2><p>遍历，插入</p>
<h2 id="2-21-合并两个有序单链表"><a href="#2-21-合并两个有序单链表" class="headerlink" title="2.21 合并两个有序单链表"></a>2.21 合并两个有序单链表</h2><p>一个插到另一个里，时间 $O(M+N)$ ，空间 $O(1)$ </p>
<h2 id="2-22-按照左右半区重新组合单链表"><a href="#2-22-按照左右半区重新组合单链表" class="headerlink" title="2.22 按照左右半区重新组合单链表"></a>2.22 按照左右半区重新组合单链表</h2><p>提前知道链表长度，找到左右半区的头节点，交叉拼接</p>
<h1 id="第三章-二叉树问题"><a href="#第三章-二叉树问题" class="headerlink" title="第三章 二叉树问题"></a>第三章 二叉树问题</h1><h2 id="3-1-非递归二叉树先序遍历"><a href="#3-1-非递归二叉树先序遍历" class="headerlink" title="3.1 非递归二叉树先序遍历"></a>3.1 非递归二叉树先序遍历</h2><p>一个栈，压入头节点，[ 弹，右，左，弹 ] 循环</p>
<h2 id="3-2-非递归二叉树中序遍历"><a href="#3-2-非递归二叉树中序遍历" class="headerlink" title="3.2 非递归二叉树中序遍历"></a>3.2 非递归二叉树中序遍历</h2><p>一个栈，循环压左到 $null$ ，弹出栈顶节点并转到他的右节点，这两步循环</p>
<h2 id="3-3-非递归二叉树后序遍历"><a href="#3-3-非递归二叉树后序遍历" class="headerlink" title="3.3 非递归二叉树后序遍历"></a>3.3 非递归二叉树后序遍历</h2><p>两个栈， $A$ 栈中，弹，左，右循环，弹出到 $B$ 栈，最后 $B$ 全部弹出</p>
<h2 id="3-4-打印二叉树边界节点"><a href="#3-4-打印二叉树边界节点" class="headerlink" title="3.4 打印二叉树边界节点"></a>3.4 打印二叉树边界节点</h2><p>得到二叉树每层的左右边界：遍历得到树的高度 $h$ ，建立二维数组 $edge[h][2]$ ，递归先序遍历，数组第一位保存每层最先遍历到的节点，也就是左边界，每遍历到新的节点就更新数组的第二位，最终保存的就是右边界  </p>
<h2 id="3-5-直观打印二叉树"><a href="#3-5-直观打印二叉树" class="headerlink" title="3.5 直观打印二叉树"></a>3.5 直观打印二叉树</h2><p>右中左遍历并打印，因为纵向看，每一个节点都可以占单独的一列，无脑输出换行就行</p>
<h2 id="3-6-二叉树的序列化和反序列化"><a href="#3-6-二叉树的序列化和反序列化" class="headerlink" title="3.6 二叉树的序列化和反序列化"></a>3.6 二叉树的序列化和反序列化</h2><p>先序遍历+分隔符，把 $null$ 也记录下，方便计算子树在字符串中的范围。核心思想是用 $null$ 占位变成满二叉树，节点位置就可以计算了</p>
<h2 id="3-7-遍历二叉树的神级方法"><a href="#3-7-遍历二叉树的神级方法" class="headerlink" title="3.7 遍历二叉树的神级方法"></a>3.7 遍历二叉树的神级方法</h2><p>$Morris$ 遍历法，不使用递归和栈结构保存历史，让每个节点的左子树的最右节点指向该节点，核心思想是修改 $null$ 指针实现遍历时的回溯</p>
<h2 id="3-8-在二叉树中找到累加和为指定值的最长路径长度"><a href="#3-8-在二叉树中找到累加和为指定值的最长路径长度" class="headerlink" title="3.8 在二叉树中找到累加和为指定值的最长路径长度"></a>3.8 在二叉树中找到累加和为指定值的最长路径长度</h2><p>先序遍历二叉树，对每条路径应用 <a href="#jump5">8.11</a> 的方法，但是从左子树转到右子树时要把左子树在哈希表的记录删除，可以通过在哈希表记录节点的所在层次判断</p>
<h2 id="3-9-找到二叉树中的最大搜索二叉子树"><a href="#3-9-找到二叉树中的最大搜索二叉子树" class="headerlink" title="3.9 找到二叉树中的最大搜索二叉子树"></a>3.9 找到二叉树中的最大搜索二叉子树</h2><p>递归后序遍历，遍历完左右子树后，如果都是搜索二叉树，那么最大搜索二叉树要么是包括父节点的整棵树，要么是左右子树里节点多的那个，通过比较节点值可以确定</p>
<h2 id="3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构"><a href="#3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构" class="headerlink" title="3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构"></a>3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构</h2><p>自顶向下法：以每个节点为头节点往下找，满足条件就计数，时间 $O(N^2)$  </p>
<p>自底向上法：后序遍历，记录左右子树对父节点能贡献多少个满足条件的节点，空间 $O(N)$ ，根据树的形状，时间最优 $O(N)$ 最差 $O(NlogN)$ ，证明懒得看</p>
<h2 id="3-11-二叉树按层打印和-zigzag-打印"><a href="#3-11-二叉树按层打印和-zigzag-打印" class="headerlink" title="3.11 二叉树按层打印和 $zigzag$ 打印"></a>3.11 二叉树按层打印和 $zigzag$ 打印</h2><p>按层打印：使用队列，根据当前层的末尾标记出队，出队的时候把其子节点入队，入队同时更新标记下层的最后一个节点，也就是用两个末尾标记实现在队列里区分层次  </p>
<p>$zigzag$ 打印：双端队列，头进尾出和尾进头出交替进行</p>
<h2 id="3-12-调整搜索二叉树中两个错误节点"><a href="#3-12-调整搜索二叉树中两个错误节点" class="headerlink" title="3.12 调整搜索二叉树中两个错误节点"></a>3.12 调整搜索二叉树中两个错误节点</h2><p>中序遍历，如果降序一次，错的就是降序的两个节点，如果降序两次，错的是第一次的大节点和第二次的小节点。交换两个节点时要考虑各种连接情况</p>
<h2 id="3-13-判断-t1-树是否包含-t2-树全部的拓扑结构"><a href="#3-13-判断-t1-树是否包含-t2-树全部的拓扑结构" class="headerlink" title="3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构"></a>3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构</h2><p>把所有头节点与 $t2$ 相同的子树都匹配一遍，时间 $O(M\times N)$ </p>
<h2 id="3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树"><a href="#3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树" class="headerlink" title="3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树"></a>3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树</h2><p>方法一同上，方法二遍历成字符串，看 $t2$ 是不是 $t1$ 子串，时间 $O(M+N)$ </p>
<h2 id="3-15-判断二叉树是否是平衡二叉树"><a href="#3-15-判断二叉树是否是平衡二叉树" class="headerlink" title="3.15 判断二叉树是否是平衡二叉树"></a>3.15 判断二叉树是否是平衡二叉树</h2><p>后序遍历，记录遍历深度，递归检验左右子树是否是平衡二叉树</p>
<h2 id="3-16-根据后序数组重建搜索二叉树"><a href="#3-16-根据后序数组重建搜索二叉树" class="headerlink" title="3.16 根据后序数组重建搜索二叉树"></a>3.16 根据后序数组重建搜索二叉树</h2><p>后序遍历头节点都在末尾，比值确定前面左右子树分界</p>
<h2 id="3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树"><a href="#3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树" class="headerlink" title="3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树"></a>3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树</h2><p>搜索二叉树：中序遍历一遍   </p>
<p>完全二叉树：按层遍历，节点不够时判断是否时靠左排的叶节点</p>
<h2 id="3-18-通过有序数组生成平衡搜索二叉树"><a href="#3-18-通过有序数组生成平衡搜索二叉树" class="headerlink" title="3.18 通过有序数组生成平衡搜索二叉树"></a>3.18 通过有序数组生成平衡搜索二叉树</h2><p>数组中间的节点就是头节点，再递归处理左右子树</p>
<h2 id="3-19-在二叉树中找到一个节点中序遍历的后继节点"><a href="#3-19-在二叉树中找到一个节点中序遍历的后继节点" class="headerlink" title="3.19 在二叉树中找到一个节点中序遍历的后继节点"></a>3.19 在二叉树中找到一个节点中序遍历的后继节点</h2><p>先找右子树，再回溯父节点</p>
<h2 id="3-20-在二叉树中找到两个节点的最近公共祖先"><a href="#3-20-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="3.20 在二叉树中找到两个节点的最近公共祖先"></a>3.20 在二叉树中找到两个节点的最近公共祖先</h2><p>后序遍历，遍历左右子树后返回是否有目标节点，当左右子树都各找到一个目标节点是，当前节点就是最近祖先</p>
<h2 id="3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题"><a href="#3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题" class="headerlink" title="3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题"></a>3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题</h2><p>单独写</p>
<h2 id="3-22-二叉树节点间的最大距离"><a href="#3-22-二叉树节点间的最大距离" class="headerlink" title="3.22 二叉树节点间的最大距离"></a>3.22 二叉树节点间的最大距离</h2><p>最大距离有三种可能：左子树最大距离，右子树最大距离，左子树深度+1+右子树深度。后序遍历一次，同时记录子树最大距离和深度，比值得出结果</p>
<h2 id="3-23-先中后序数组两两结合重构二叉树"><a href="#3-23-先中后序数组两两结合重构二叉树" class="headerlink" title="3.23 先中后序数组两两结合重构二叉树"></a>3.23 先中后序数组两两结合重构二叉树</h2><p>先后序数组根节点在两端，代入中序数组可以区分左右子树。  </p>
<p>只有先后序时，由于左右可以混淆，如果有任一节点只有一个子节点，都无法重构原二叉树，先序中根节点之后就是左子树根节点，后序数组中左子树根节点之前的就是左子树，因此利用先后序数组可以区分左右子树。</p>
<h2 id="3-24-通过先序和中序数组生成后序数组"><a href="#3-24-通过先序和中序数组生成后序数组" class="headerlink" title="3.24 通过先序和中序数组生成后序数组"></a>3.24 通过先序和中序数组生成后序数组</h2><p>用先序数组确定后序数组最右的值，再利用中序数组分离出左右子树的先中序数组，重复这两步，把后序数组从右到左填满</p>
<h2 id="3-25-统计和生成所有不同的二叉树"><a href="#3-25-统计和生成所有不同的二叉树" class="headerlink" title="3.25 统计和生成所有不同的二叉树"></a>3.25 统计和生成所有不同的二叉树</h2><p>中序遍历为 $1\sim N$ 的一定是搜索二叉树，找规律，如果 $i$ 是头节点，则左子树有 $i-1$ 个节点，右子树有 $N-i$ 个节点，所以 $num(N)=\sum_{i=1}^Nnum(i-1)*num(N-i)$ </p>
<h2 id="3-26-统计完全二叉树的节点数"><a href="#3-26-统计完全二叉树的节点数" class="headerlink" title="3.26 统计完全二叉树的节点数"></a>3.26 统计完全二叉树的节点数</h2><p>一直向左遍历可以得到树的深度，因为完全二叉树叶节点靠左排列，所以遍历一个节点的右子树的最左节点，得到右子树的深度，如果等于整个树的深度，说明左子树节点是满的，循环这个步骤遍历右子树，如果深度小于树的深度，说明在这个深度下右子树节点是满的，循环这个步骤遍历左子树</p>
<h1 id="第四章-递归和动态规划"><a href="#第四章-递归和动态规划" class="headerlink" title="第四章 递归和动态规划"></a>第四章 递归和动态规划</h1><p>优化思路：压缩空间，枚举简化</p>
<h2 id="4-1-求斐波那契第N项"><a href="#4-1-求斐波那契第N项" class="headerlink" title="4.1 求斐波那契第N项"></a>4.1 求斐波那契第N项</h2><p>递归向下算，时间 $O(2^N)$   </p>
<p>从左向右依次算每一项，时间 $O(N)$   </p>
<p>用通项公式直接算，时间 $O(logN)$   </p>
<h2 id="4-2-斐波那契求奶牛数量"><a href="#4-2-斐波那契求奶牛数量" class="headerlink" title="4.2 斐波那契求奶牛数量"></a>4.2 斐波那契求奶牛数量</h2><p>$C(n)=C(n-1)+C(n-3)$ ，上一年的都活下来，三年前出生的都生一头小的，状态矩阵是三阶的</p>
<p><span id="jump3"></span></p>
<h2 id="4-3-矩阵的最小路径和"><a href="#4-3-矩阵的最小路径和" class="headerlink" title="4.3 矩阵的最小路径和"></a>4.3 矩阵的最小路径和</h2><p>动态规划，从左上角算到右下角，时间空间都是 $O(M\times N)$ ，只维护一行(列)空间时，向右或向下滚动更新，可以把空间压缩到 $O(min(M,N))$ ，之所以不用维护两行(列)是因为从前到后更新就相当于维护了两行(列)<br>P.S.：一般动态规划问题都可以用压缩空间的优化方法</p>
<h2 id="4-4-换钱的最少货币数"><a href="#4-4-换钱的最少货币数" class="headerlink" title="4.4 换钱的最少货币数"></a>4.4 换钱的最少货币数</h2><p>货币无限+面值不重复：维护二维数组，货币种类数*目标钱数，数组元素表示使用前 $i$ 种货币组成 $j$ 钱数需要的最少张数，遍历到 $dp[i][j]$ 时，枚举所有可能的 $k\geq0$ ，选择使用 $k$ 张当前货币时，最少张数的子问题。   </p>
<p>货币仅一张+面值可重复：和上面一样，只用做一次选择就够了，不用遍历所有 $k$ 。</p>
<h2 id="4-5-换钱的方法数"><a href="#4-5-换钱的方法数" class="headerlink" title="4.5 换钱的方法数"></a>4.5 换钱的方法数</h2><p>暴力搜索： $i$ 张第一+ $j$ 张第二+ $k$ 张第三……，时间最差 $O(aim^N)$  </p>
<p>带记忆的暴力搜索：避免重复计算，时间 $O(N\times aim^2)$     </p>
<p>经典动态规划：和上题一样，把值换成方法数，时间 $O(N\times aim^2)$   </p>
<p>时间复杂度一样是因为记忆搜索和经典动态规划的本质都是避免重复计算   </p>
<p>优化的动态规划(上题也可以用)：枚举所有可能的 $k\geq0$ 可以分成两部分，不用和必用当前货币，不用就是 $dp[i-1][j]$ ，必用本质上是 $dp[i][j-当前货币值]$ ，所以枚举的过程可以省去。时间 $O(N\times aim)$ </p>
<h2 id="4-6-最长递增子序列"><a href="#4-6-最长递增子序列" class="headerlink" title="4.6 最长递增子序列"></a>4.6 最长递增子序列</h2><p>经典： $dp[i]$ 表示以 $arr[i]$ 结尾的最长递增子序列长度，枚举前面所有结尾比 $arr[i]$ 小的 $dp[k]$ ，最后根据 $arr$ 和 $dp$ 数组得出序列， $O(N^2)$   </p>
<p>优化：建立辅助数组，记录长度为k的递增子序列最小结尾数，把枚举转化为在此数组上二分查找， $O(NlogN)$ </p>
<h2 id="4-7-汉诺塔"><a href="#4-7-汉诺塔" class="headerlink" title="4.7 汉诺塔"></a>4.7 汉诺塔</h2><p>递归， $n-1$ 左右中， $1$ 左中右， $n-1$ 中左右，每次在两个柱子间移动要考虑第三个柱子是为了递归的时候变换柱子的位置</p>
<h2 id="4-8-判断给的状态是不是汉诺塔最优过程中的某个状态"><a href="#4-8-判断给的状态是不是汉诺塔最优过程中的某个状态" class="headerlink" title="4.8 判断给的状态是不是汉诺塔最优过程中的某个状态"></a>4.8 判断给的状态是不是汉诺塔最优过程中的某个状态</h2><p>通过 $n$ 的位置可以知道进行到三个步骤中的哪个，然后递归检查 $n-1$ ，最后一定能确定具体步骤</p>
<h2 id="4-9-最长公共子序列"><a href="#4-9-最长公共子序列" class="headerlink" title="4.9 最长公共子序列"></a>4.9 最长公共子序列</h2><p>$dp[i][j]$ 表示 $str1[:i]$ 与 $str2[:j]$ 的最长公共子序列长度，取值为 $max{dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1(当前两个字符相同时)}$ ，获取序列要从右下角回溯，选择了三个值的哪一个就移动到他的位置，如果选择了 $dp[i-1][j-1]+1$ 就把当前字符放进结果</p>
<h2 id="4-10-最长公共子串"><a href="#4-10-最长公共子串" class="headerlink" title="4.10 最长公共子串"></a>4.10 最长公共子串</h2><p>经典： $dp[i][j]$ 表示以 $str1[i]$ 与 $str2[j]$ 结尾的最长公共子串长度，要么是 $0$ ，要么是 $dp[i-1][j-1]+1$ ，根据最大的 $dp$ 值直接得到子串，空间 $O(M\times N)$   </p>
<p>压缩：由于 $dp[i][j]$ 只和左上角的值有关，可以从左上到右下按斜线更新，一次更新一个，空间 $O(1)$ </p>
<h2 id="4-11-最小编辑代价"><a href="#4-11-最小编辑代价" class="headerlink" title="4.11 最小编辑代价"></a>4.11 最小编辑代价</h2><p>$dp[i][j]$ 表示 $str1[0,i-1]$ 编辑成 $str2[0,j-1]$ 的最小代价，第一行和第一列是全添和全删，中间的 $dp[i][j]$ 有四种取值： $dp[i-1][j]+删$ ，表示删去 $str1[i-1]$ 后把 $str1[0,i-2]$ 编辑成 $str2[0,j-1]$ ， $dp[i][j-1]+添$ ，表示把 $str1[0,i-1]$ 编辑成 $str2[0,j-2]$ 后添加 $str2[j-1]$ ， $dp[i-1][j-1]+改$ ，表示把 $str1[0,i-2]$ 编辑成 $str2[0,j-2]$ 后修改最后一个字符， $dp[i-1][j-1]$ ，表示当前两个字符正好相等   </p>
<p>压缩：因为可取值太多，要维护两行(列)</p>
<h2 id="4-12-字符串的交错组成"><a href="#4-12-字符串的交错组成" class="headerlink" title="4.12 字符串的交错组成"></a>4.12 字符串的交错组成</h2><p>$dp[i][j]$ 表示 $aim[0,i+j-1]$ 能否被 $str1[0,i-1]$ 和 $str2[0,j-1]$ 交错组成，第一行和第一列就是和两个字符串单独比较，中间的 $dp[i][j]=true$ 有两种情况： $str1[i-1]=aim[i+j-1]$ 且 $dp[i-1][j]=true$ ， $str2[j-1]=aim[i+j-1]$ 且 $dp[i][j-1]=true$ ，其余情况都是 $false$ </p>
<h2 id="4-13-龙与地下城"><a href="#4-13-龙与地下城" class="headerlink" title="4.13 龙与地下城"></a>4.13 龙与地下城</h2><p>和 <a href="#jump3">4.3</a> 一样，求的是最大值</p>
<h2 id="4-14-数字字符串转换为字母组合的种数"><a href="#4-14-数字字符串转换为字母组合的种数" class="headerlink" title="4.14 数字字符串转换为字母组合的种数"></a>4.14 数字字符串转换为字母组合的种数</h2><p>$dp[i]$ 表示前 $k$ 位不可变时的组合数，从后往前算， $dp[N]=1$ ，当 $str[i+1]=0$ 时 $dp[i]=0$ ，当 $str[i,i+1]$ 可转换时， $dp[i]=dp[i+1]+dp[i+2]$ ，否则 $dp[i]=dp[i+1]$ </p>
<h2 id="4-15-表达式得到期望结果的组合种数"><a href="#4-15-表达式得到期望结果的组合种数" class="headerlink" title="4.15 表达式得到期望结果的组合种数"></a>4.15 表达式得到期望结果的组合种数</h2><p>表达式 $express$ 一定是数字符号交错组成的，每一个奇数位上的符号把式子分成两部分，维护两个 $dp$ 二维数组分别表示 $express[i,j]$ 为 $true$ 和 $false$ 的组合种数， $dp[0,N]=\sum op_k(dp[0,k],dp[k,N-1])$ ，相当于在每个符号做一次分割，这种大分割产生的两组括号是唯一的，所以不同分割下不会出现重复的情况</p>
<h2 id="4-16-排成一条线的纸牌博弈问题"><a href="#4-16-排成一条线的纸牌博弈问题" class="headerlink" title="4.16 排成一条线的纸牌博弈问题"></a>4.16 排成一条线的纸牌博弈问题</h2><p>维护两个二维 $dp$ ， $dp_1[i][j]$ 表示面对 $s[i,j]$ 先拿的人最终能得到多少分， $dp_2[i][j]$ 表示后拿的人最终能得到多少分，只剩一张牌时 $dp_1[k][k]=arr[k]$ ， $dp_2[k][k]=0$ ，从右下往左上算， $dp_1[i][j]$ 可取值有 $arr[i]+dp_2[i+1][j]$ 和 $arr[j]+dp_2[i][j-1]$ ， $dp_2[i][j]$ 可取值有 $dp_1[i+1][j]$ 和 $dp_1[i][j-1]$ ，时间 $O(N^2)$  </p>
<h2 id="4-17-跳跃问题"><a href="#4-17-跳跃问题" class="headerlink" title="4.17 跳跃问题"></a>4.17 跳跃问题</h2><p>从左到右遍历一遍，维护三个临时变量， $jump$ 表示步数， $cur$ 表示以当前为起点能去的最远处， $next$ 表示以遍历过程中的点为起点能去的最远处，当遍历到 $cur$ 时，把 $cur$ 更新成 $next$ ，同时 $jump+1$ </p>
<h2 id="4-18-数组中的最长连续序列"><a href="#4-18-数组中的最长连续序列" class="headerlink" title="4.18 数组中的最长连续序列"></a>4.18 数组中的最长连续序列</h2><p>每次遍历一个数，先使用哈希表去重，然后保存在一个列表里，当列表里出现连续对时，合并成表示范围的二元组 $(left,right)$ ，由于能查询哈希表，检测连续时不需要遍历列表，所以最终时间空间都是 $O(N)$ </p>
<h2 id="4-19-N-皇后问题"><a href="#4-19-N-皇后问题" class="headerlink" title="4.19  $N$ 皇后问题"></a>4.19  $N$ 皇后问题</h2><p>暴力搜索：为减小空间复杂度，递归函数维护一维数组， $record[i]$ 表示第 $i$ 行放置的列数，遍历 $N$ 个列时实时检查该列能不能放</p>
<p>优化：利用位运算加速，用两个 $N$ 位二进制数表示当前哪些位置受列和斜线的影响不能放置，其实只加速了检查的操作</p>
<h1 id="第五章-字符串问题"><a href="#第五章-字符串问题" class="headerlink" title="第五章 字符串问题"></a>第五章 字符串问题</h1><p>子串是连续的，子序列是可以分散的</p>
<h2 id="5-1-判断两个字符串是否互为变形词"><a href="#5-1-判断两个字符串是否互为变形词" class="headerlink" title="5.1 判断两个字符串是否互为变形词"></a>5.1 判断两个字符串是否互为变形词</h2><p>建一个字符集大小的数组计数</p>
<h2 id="5-2-字符串中数字子串的求和"><a href="#5-2-字符串中数字子串的求和" class="headerlink" title="5.2 字符串中数字子串的求和"></a>5.2 字符串中数字子串的求和</h2><p>从左到右遍历，用几个变量标记</p>
<h2 id="5-3-去掉字符串中连续出现k个0的子串"><a href="#5-3-去掉字符串中连续出现k个0的子串" class="headerlink" title="5.3 去掉字符串中连续出现k个0的子串"></a>5.3 去掉字符串中连续出现k个0的子串</h2><p>从左到右遍历，用一个变量标记0的个数</p>
<h2 id="5-4-判断两个字符串是否互为旋转词"><a href="#5-4-判断两个字符串是否互为旋转词" class="headerlink" title="5.4 判断两个字符串是否互为旋转词"></a>5.4 判断两个字符串是否互为旋转词</h2><p>把两个 $str2$ 拼在一起，检查 $str1$ 是否是子串，方法同 $KMP$ 算法</p>
<h2 id="5-5-将整数字符串转成整数值"><a href="#5-5-将整数字符串转成整数值" class="headerlink" title="5.5 将整数字符串转成整数值"></a>5.5 将整数字符串转成整数值</h2><p>从左到右遍历</p>
<h2 id="5-6-替换字符串中连续出现的指定字符串"><a href="#5-6-替换字符串中连续出现的指定字符串" class="headerlink" title="5.6 替换字符串中连续出现的指定字符串"></a>5.6 替换字符串中连续出现的指定字符串</h2><p>从左到右遍历</p>
<h2 id="5-7-字符串的统计字符串"><a href="#5-7-字符串的统计字符串" class="headerlink" title="5.7 字符串的统计字符串"></a>5.7 字符串的统计字符串</h2><p>从左到右遍历</p>
<h2 id="5-8-判断字符数组中是否所有的字符都只出现过一次"><a href="#5-8-判断字符数组中是否所有的字符都只出现过一次" class="headerlink" title="5.8 判断字符数组中是否所有的字符都只出现过一次"></a>5.8 判断字符数组中是否所有的字符都只出现过一次</h2><p>使用哈希保存遍历结果，时间空间都是 $O(N)$   </p>
<p>原地排序，遍历检查，时间 $O(NlogN)$ ，空间 $O(1)$ </p>
<h2 id="5-9-在有序但含有空的数组中查找字符串"><a href="#5-9-在有序但含有空的数组中查找字符串" class="headerlink" title="5.9 在有序但含有空的数组中查找字符串"></a>5.9 在有序但含有空的数组中查找字符串</h2><p>二分查找</p>
<h2 id="5-10-字符串的调整与替换"><a href="#5-10-字符串的调整与替换" class="headerlink" title="5.10 字符串的调整与替换"></a>5.10 字符串的调整与替换</h2><p>从左到右遍历一遍，算出替换后的长度，再从右到左遍历，从尾部更新</p>
<h2 id="5-11-翻转字符串"><a href="#5-11-翻转字符串" class="headerlink" title="5.11 翻转字符串"></a>5.11 翻转字符串</h2><p>翻转单词：先整体逆序，再逐单词逆序   </p>
<p>翻转片段：先逐片段逆序，再整体逆序</p>
<h2 id="5-12-数组中两个字符串的最小距离"><a href="#5-12-数组中两个字符串的最小距离" class="headerlink" title="5.12 数组中两个字符串的最小距离"></a>5.12 数组中两个字符串的最小距离</h2><p>遍历一遍，找到 $str2$ 和他前后最近的两个 $str1$ 。进阶问题查询时间 $O(1)$ 就是先花时间做个查询表，mdzz</p>
<h2 id="5-13-添加最少字符使字符串整体都是回文字符串"><a href="#5-13-添加最少字符使字符串整体都是回文字符串" class="headerlink" title="5.13 添加最少字符使字符串整体都是回文字符串"></a>5.13 添加最少字符使字符串整体都是回文字符串</h2><p>动态规划， $dp[i][j]$ 表示使 $str[i,j]$ 回文需要添加的最少字符数， $dp[i][j]$ 有三种取值：长度为 $1$ 时 $dp$ 是 $0$ ，长度为 $2$ 时 $dp$ 是 $0$ 或 $1$ ，长度大于 $2$ 时，首尾相等 $dp[i][j]=dp[i+1][j-1]$ ，首尾不等时 $dp[i][j]=min{dp[i+1][j],dp[i][j-1]}+1$ ，从对角线向两侧更新 $dp$ ，最后新建长为 $N+dp[0][N-1]$ 的空字符串，从 $dp[0][N-1]$ 回溯填充得到回文串，时间 $O(N^2)$ </p>
<h2 id="5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"><a href="#5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串" class="headerlink" title="5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"></a>5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串</h2><p>新建空字符串，长度为原字符串长度两倍减去回文子序列长度，从原字符串两端同时搜索回文子序列，每搜到一对就把两侧经过的其他字符拼接填充在左侧，逆序后再填充到右侧，时间 $O(N)$ ，回文子序列位置有混淆也不影响，因为最终遍历的回文对数是不变的</p>
<h2 id="5-15-括号字符串的有效性和最长有效长度"><a href="#5-15-括号字符串的有效性和最长有效长度" class="headerlink" title="5.15 括号字符串的有效性和最长有效长度"></a>5.15 括号字符串的有效性和最长有效长度</h2><p>有效性：从左到右遍历计数，右括号始终不能多于左括号且最终相等   </p>
<p>最长有效长度：动态规划， $dp[i]$ 表示以 $str[i]$ 结尾的最长有效长度， $dp[0]=0$ ， $str[i]$ 是左括号时 $dp[i]=0$ ， $str[i]$ 是右括号时，如果 $str[i-1]$ 是左括号直接配对， $dp[i]=dp[i-2]+2$ ，如果 $dp[i-1]$ 不是 $0$ 且 $str[i-dp[i-1]-1]$ 是左括号， $dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]$ ，其余情况 $dp[i]=0$ </p>
<h2 id="5-16-公式字符串求值"><a href="#5-16-公式字符串求值" class="headerlink" title="5.16 公式字符串求值"></a>5.16 公式字符串求值</h2><p>数值栈+符号栈，遇到右括号和乘除尝试计算</p>
<h2 id="5-17-0-左边必有-1-的二进制字符串数量"><a href="#5-17-0-左边必有-1-的二进制字符串数量" class="headerlink" title="5.17  $0$ 左边必有 $1$ 的二进制字符串数量"></a>5.17  $0$ 左边必有 $1$ 的二进制字符串数量</h2><p> $dp[i]$ 表示满足条件的 $i$ 位字符串数量，一个满足条件的字符串后面可以补 $1$ ，但是只有末尾为 $1$ 时可以补 $0$ ，所以 $dp[i+1]=dp[i]+dp_1[i]$ ，而第 $i$ 位为 $1$ 时表示第 $i-1$ 位随意，所以 $dp_1[i]=dp[i-1]$ ，所以 $dp[i+1]=dp[i]+dp[i-1]$ ，是斐波那契数列，最优时间 $O(logN)$ </p>
<h2 id="5-18-拼接所有字符串产生字典顺序最小的大写字符串"><a href="#5-18-拼接所有字符串产生字典顺序最小的大写字符串" class="headerlink" title="5.18 拼接所有字符串产生字典顺序最小的大写字符串"></a>5.18 拼接所有字符串产生字典顺序最小的大写字符串</h2><p>如果 $A+B$ 的字典序小于 $B+A$ ， $A$ 就应该在 $B$ 前边，照这个思路选择排序。</p>
<p>$\color{red}{不理解这个为什么算贪心算法？为什么需要证明？}$</p>
<h2 id="5-19-找到字符串的最长无重复字符子串"><a href="#5-19-找到字符串的最长无重复字符子串" class="headerlink" title="5.19 找到字符串的最长无重复字符子串"></a>5.19 找到字符串的最长无重复字符子串</h2><p>哈希表记录，标记子串头，从左到右遍历，时间 $O(N)$ ，空间 $O(M)$ ， $M$ 是字符集大小</p>
<h2 id="5-20-找到被指的新类型字符"><a href="#5-20-找到被指的新类型字符" class="headerlink" title="5.20 找到被指的新类型字符"></a>5.20 找到被指的新类型字符</h2><p> $str[k-1]$ 小写则结果从 $str[k]$ 开始， $str[k-1]$ 大写时，向左找有几个连续的大写，有偶数个大写则结果从 $str[k]$ 开始，反之结果从 $str[k-1]$ 开始</p>
<h2 id="5-21-最小包含子串的长度"><a href="#5-21-最小包含子串的长度" class="headerlink" title="5.21 最小包含子串的长度"></a>5.21 最小包含子串的长度</h2><p>哈希表记录，左右边界设在起点，右边界向右找到子串，左边界向右缩小范围，得到备选子串，循环该过程不断从右边界重新遍历，选所有备选子串里最短的，时间 $O(N)$ </p>
<h2 id="5-22-回文最少分割数"><a href="#5-22-回文最少分割数" class="headerlink" title="5.22 回文最少分割数"></a>5.22 回文最少分割数</h2><p>动态规划， $dp[i]$ 表示 $str[0,i]$ 的最少分割数，从 $0$ 到 $i$ 找到第一个使 $str[j,i]$ 回文的 $j$ ， $dp[i]=dp[j]+1$ ，判断回文的过程可优化</p>
<h2 id="5-23-字符串匹配问题"><a href="#5-23-字符串匹配问题" class="headerlink" title="5.23 字符串匹配问题"></a>5.23 字符串匹配问题</h2><p>正则匹配原理：有限状态机+递归匹配</p>
<h2 id="5-24-字典树的实现"><a href="#5-24-字典树的实现" class="headerlink" title="5.24 字典树的实现"></a>5.24 字典树的实现</h2><p>简单粗暴，节点属性有共用数、词尾数、子节点集合</p>
<h1 id="第六章-大数据和空间限制"><a href="#第六章-大数据和空间限制" class="headerlink" title="第六章 大数据和空间限制"></a>第六章 大数据和空间限制</h1><p>降低精度或增加时间从而减少空间</p>
<h2 id="6-1-布隆过滤器"><a href="#6-1-布隆过滤器" class="headerlink" title="6.1 布隆过滤器"></a>6.1 布隆过滤器</h2><p>创建一个巨大的长为 $m$ 的 $bit$ 数组，对每条数据使用 $k$ 个哈希函数，分别对 $m$ 取余，把 $bit$ 数组的 $k$ 个 $bit$ 置为 $1$ 。使用时如果输入对应的 $k$ 个位置都为 $1$ 就过滤，只会误杀不会漏杀</p>
<p><span id="jump4"></span></p>
<h2 id="6-2-找到出现最多的数"><a href="#6-2-找到出现最多的数" class="headerlink" title="6.2 找到出现最多的数"></a>6.2 找到出现最多的数</h2><p>读文件不会把整个文件放进内存，但是查哈希表是把整个表放进内存。 把 $N$ 个数的文件用哈希函数分配到 $k$ 个哈希表里，哈希函数能保证相同的数都在同一个表里，每次查找只把一个表放进内存，查完所有表后对比各自频次最多的数，把大的集合分组不仅能减少内存占用，还能减少哈希表里表示键值的比特长度</p>
<h2 id="6-3-找到没出现的数"><a href="#6-3-找到没出现的数" class="headerlink" title="6.3 找到没出现的数"></a>6.3 找到没出现的数</h2><p>只考虑出现与否不需要计数，可以使用 $bit$ 数组减少内存占用，再优化还可以分组统计，每次只检查 $k$ 个数出现与否，但每组都要遍历一遍原文件</p>
<h2 id="6-4-找到所有重复的-url"><a href="#6-4-找到所有重复的-url" class="headerlink" title="6.4 找到所有重复的 $url$"></a>6.4 找到所有重复的 $url$</h2><p>同 <a href="#jump4">6.2</a> ，大文件拆成多个小文件</p>
<h2 id="6-5-统计词汇-top-k"><a href="#6-5-统计词汇-top-k" class="headerlink" title="6.5 统计词汇 $top_k$"></a>6.5 统计词汇 $top_k$</h2><p>同 <a href="#jump4">6.2</a> ，大文件拆成多个小文件，每个小文件 $top_k$ 再排序</p>
<h2 id="6-6-找到出现两次的数"><a href="#6-6-找到出现两次的数" class="headerlink" title="6.6 找到出现两次的数"></a>6.6 找到出现两次的数</h2><p>双倍 $bit$ 数组，每个数用两个 $bit$ 统计出现 $0$ 次、 $1$ 次、 $2$ 次和多次</p>
<h2 id="6-7-找中位数"><a href="#6-7-找中位数" class="headerlink" title="6.7 找中位数"></a>6.7 找中位数</h2><p>先分好 $k$ 个区间，遍历一遍文件得到中位数出现的区间，再遍历一遍在目标区间里接着找，空间不够可以继续分区间</p>
<h2 id="6-8-一致性哈希算法"><a href="#6-8-一致性哈希算法" class="headerlink" title="6.8 一致性哈希算法"></a>6.8 一致性哈希算法</h2><p>环形分配可以减小增删机器时数据迁移的代价，虚拟节点可以减小机器较少时的负载不均衡</p>
<h1 id="第七章-位运算"><a href="#第七章-位运算" class="headerlink" title="第七章 位运算"></a>第七章 位运算</h1><h2 id="7-1-不用额外变量交换两个整数的值"><a href="#7-1-不用额外变量交换两个整数的值" class="headerlink" title="7.1 不用额外变量交换两个整数的值"></a>7.1 不用额外变量交换两个整数的值</h2><p>$a=a\oplus b$ , $b=a\oplus b$ , $a=a\oplus b$ ，第一步把 $a$ 和 $b$ 信息不同的比特位标为 $1$ ，第二步当信息不同且 $b$ 是 $0$ 时结果是 $1$ ，信息相同 $b$ 是 $1$ 是返回 $1$ ，所以结果就是原来的 $a$ ，第三步当信息不同且 $b$ (原来的 $a$ )是 $0$ 时结果是 $1$ ，信息相同 $b$ 是 $1$ (原来的 $a$ )是返回 $1$ ，所以结果就是 $a$ (原来的 $b$ )</p>
<h2 id="7-2-不用任何比较判断找出两个数中较大的数"><a href="#7-2-不用任何比较判断找出两个数中较大的数" class="headerlink" title="7.2 不用任何比较判断找出两个数中较大的数"></a>7.2 不用任何比较判断找出两个数中较大的数</h2><p>二进制最高位是符号位， $1$ 是负数， $0$ 是非负，查看 $a$ 、 $b$ 和 $a-b$ 的符号， $a$ 和 $b$ 符号相反直接返回非负的， $a$ 和 $b$ 符号相同则 $a-b$ 不会溢出，根据 $a-b$ 符号返回结果</p>
<h2 id="7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出"><a href="#7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出" class="headerlink" title="7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)"></a>7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)</h2><p>加法：只相加不进位时 $a+b=a^b$ ，向前进位的序列是 $(a\&amp;b)\ll 1$ ，再以异或序列和进位序列不断循环前两步，直到进位序列全是 $0$   </p>
<p>减法： $a-b=a+(-b)$ ， $b$ 的相反数是把 $b$ 取反加一得到补码，再和 $a$ 做上述加法  </p>
<p>乘法： $a\times b$ 本质是 $a$ 循环累加，把 $b$ 按位拆分，最低位是 $1$ 时结果加 $a$ ，高位都代表 $2$ 的乘方，通过对 $a$ 向左移位可以实现，最终 $a\times b=a\times b<em>0+\sum</em>{i=1}^n(a\ll i)\times b_i$ ，因为 $b_i$ 是 $0$ 或 $1$ ，所以式子里的乘法只是形式上的， $b$ 是负数也成立  </p>
<p>除法： $a\div b$ 本质是 $a$ 循环减去 $b$ ，因此可以对 $b$ 移位比大小得到比 $a$ 小的最大的数。如果 $a$ 、 $b$ 中有负数要先转成非负，最后再考虑符号。一个特例是， $int$ 的最小值的绝对值比最大值大 $1$ ，所以 $int$ 的最小值不能转成正数，当不能直接判断出结果，也就是最小值必须参与计算时，可以把最小值拆成几段分开算，最后用余数再算一次</p>
<h2 id="7-4-整数的二进制表达中有多少个-1"><a href="#7-4-整数的二进制表达中有多少个-1" class="headerlink" title="7.4 整数的二进制表达中有多少个 $1$"></a>7.4 整数的二进制表达中有多少个 $1$</h2><p>方法一：循环 $n=n\And(n-1)$ 或 $n-=n\And(1-n)$ 直到 $n=0$ ，这个操作本质上是去掉 $n$ 最右边的 $1$ ，两个式子右边一个返回去掉末尾 $1$ 的 $n$ ，一个直接返回末尾 $1$  </p>
<p>方法二：平行算法，统计 $1$ 的个数不用把整个二进制序列当成一个数，同时在每个bit上操作既提高了效率又排除了序列里高低位的影响，平行算法采用归并的思路，依次算出每 $2^k$ 位里有多少个 $1$ ，最后一步的结果就是整个序列里有多少个 $1$<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int function(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    n &#x3D; (n &amp; 0x55555555) + ((n&gt;&gt; 1) &amp; 0x55555555); #每2bit为一组相加 </span><br><span class="line">    n &#x3D; (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333); #每4bit为一组相加 </span><br><span class="line">    n &#x3D; (n &amp; 0x0f0f0f0f) + ((n&gt;&gt; 4) &amp; 0x0f0f0f0f); #每2bit为一组相加   </span><br><span class="line">    n &#x3D; (n &amp; 0xff00ff) + ((n&gt;&gt; 8) &amp; 0xff00ff); #每16bit为一组相加      </span><br><span class="line">    n &#x3D; (n &amp; 0xffff) + ((n&gt;&gt; 16) &amp; 0xffff) ; #每32bit为一组相加         </span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h2 id="7-5-在其他数都出现偶数次的数组中找到出现奇数次的数"><a href="#7-5-在其他数都出现偶数次的数组中找到出现奇数次的数" class="headerlink" title="7.5 在其他数都出现偶数次的数组中找到出现奇数次的数"></a>7.5 在其他数都出现偶数次的数组中找到出现奇数次的数</h2><p>一个数奇数次： $n\oplus0=n,n\oplus n=0$ ，所以只要用一个 $0$ 把所有数都异或一遍，剩下的值就是奇数次那个数  </p>
<p>两个数奇数次：用 $0$ 异或一遍结果是 $a\oplus b$ ，两个数不相等结果必有个第 $k$ 位是 $1$ ，再用 $0$ 与第 $k$ 位是 $1$ 的所有数异或一遍，得到的就是 $a$ 或 $b$ </p>
<h2 id="7-6-在其他数都出现-k-次的数组中找到只出现一次的数"><a href="#7-6-在其他数都出现-k-次的数组中找到只出现一次的数" class="headerlink" title="7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数"></a>7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数</h2><p>$k$ 个相同的 $k$ 进制的数无进位相加结果是 $0$ ，因为结果每一位都是 $(k\times a)\%k$ ，所以把所有数转为 $k$ 进制累加，得到的结果就是只出现一次的数</p>
<h1 id="第八章-数组和矩阵问题"><a href="#第八章-数组和矩阵问题" class="headerlink" title="第八章 数组和矩阵问题"></a>第八章 数组和矩阵问题</h1><h2 id="8-1-转圈打印矩阵"><a href="#8-1-转圈打印矩阵" class="headerlink" title="8.1 转圈打印矩阵"></a>8.1 转圈打印矩阵</h2><p>就是从外到内逐层打印，用每一圈的四个角的坐标判断</p>
<h2 id="8-2-将正方形矩阵顺时针旋转-90-deg"><a href="#8-2-将正方形矩阵顺时针旋转-90-deg" class="headerlink" title="8.2 将正方形矩阵顺时针旋转 90&deg;"></a>8.2 将正方形矩阵顺时针旋转 90&deg;</h2><p>方阵里一个数顺时针旋转 90&deg; 就是沿着他所在的一圈顺时针走一条边的距离，和上题一样逐圈操作</p>
<h2 id="8-3-之字形打印矩阵"><a href="#8-3-之字形打印矩阵" class="headerlink" title="8.3 之字形打印矩阵"></a>8.3 之字形打印矩阵</h2><p>算坐标，碰到边界再判断怎么移动</p>
<h2 id="8-4-找到无序数组中最小的-k-个数"><a href="#8-4-找到无序数组中最小的-k-个数" class="headerlink" title="8.4 找到无序数组中最小的 $k$ 个数"></a>8.4 找到无序数组中最小的 $k$ 个数</h2><p>$O(Nlogk)$ 方法：维护一个 $k$ 个节点的大根堆，遍历数组，如果元素小于堆顶就插入堆，其中遍历 $O(N)$ ，堆插入 $O(logk)$    </p>
<p>$O(N)$ 方法： $BFPRT$ 算法可以从数组中找到第 $k$ 小的数，把原数组每五个数分一组，分别求中位数，再递归求中位数的中位数，最终得到一个中位数 $x$ ，用 $x$ 划分原数组中大于 $x$ 和小于 $x$ 的数，在其中一边继续用中位数方法划分，最终能得到 $x$ 在数组中的位置是第 $k$ ，可以用数学证明该过程时间复杂度是 $O(N)$ ，大概意思就是用中位数划分数组效率高，所以能收敛到 $O(N)$ ，所以找到 $k$ 个最小的数总的时间复杂度也是 $O(N)$ </p>
<h2 id="8-5-需要排序的最短子数组长度"><a href="#8-5-需要排序的最短子数组长度" class="headerlink" title="8.5 需要排序的最短子数组长度"></a>8.5 需要排序的最短子数组长度</h2><p>从左到右、从右到左分别遍历，找边界</p>
<h2 id="8-6-在数组中找到出现次数大于-N-K-的数"><a href="#8-6-在数组中找到出现次数大于-N-K-的数" class="headerlink" title="8.6 在数组中找到出现次数大于 $N/K$ 的数"></a>8.6 在数组中找到出现次数大于 $N/K$ 的数</h2><p>遍历一遍数组，循环排除 $K$ 个不同的数，直到剩下的不足 $K$ ，剩下的就是出现次数大于 $N/K$ 的数。具体实现是建立两个长度为 $K-1$ 的数组， $A$ 数组存数组里的数， $B$ 数组存出现次数，当遍历到的 $x$ 与 $A$ 里的都不同时， $B$ 数组都减一同时遍历下一个，就相当于排除了 $K$ 个不同的数，次数归零时用遍历到的数补位，最终时间复杂度 $O(N\times K)$ ，空间复杂度 $O(K)$ </p>
<h2 id="8-7-在行列都排好序的矩阵中找数"><a href="#8-7-在行列都排好序的矩阵中找数" class="headerlink" title="8.7 在行列都排好序的矩阵中找数"></a>8.7 在行列都排好序的矩阵中找数</h2><p>$M\times N$ 的矩阵中，每个以对角线上一点为右下角的一行和一列的组合里，对角线上这个点都是最大的，相当于从左上角到右下角沿着对角线剥洋葱，遍历的最大长度是对角线+一行+一列，时间 $O(M+N)$ </p>
<h2 id="8-8-最长的可整合子数组的长度"><a href="#8-8-最长的可整合子数组的长度" class="headerlink" title="8.8 最长的可整合子数组的长度"></a>8.8 最长的可整合子数组的长度</h2><p>可整合数组就是元素不重复，最大值-最小值+1是元素个数的数组，从左到右以每个元素为起点遍历一次，时间 $O(N^2)$ </p>
<h2 id="8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><a href="#8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组" class="headerlink" title="8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组"></a>8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组</h2><p>二元组：一个左指针一个右指针向中间遍历，时间 $O(N)$   </p>
<p>三元组：从左到右遍历，每遍历到一个元素，就把他后面的当成一个二元组问题求解，时间 $O(N^2)$ </p>
<h2 id="8-10-未排序正数数组中累加和为给定值的最长子数组长度"><a href="#8-10-未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="8.10 未排序正数数组中累加和为给定值的最长子数组长度"></a>8.10 未排序正数数组中累加和为给定值的最长子数组长度</h2><p>左右两个指针从数组头遍历，变量 $sum$ 存两个指针标记的子数组累加和，变量 $len$ 存 $sum$ 为给定值 $k$ 时的最长子数组长度，右指针向右遍历， $sum\geq k$ 时左指针加一</p>
<p><span id="jump5"></span></p>
<h2 id="8-11-未排序数组中最长子数组系列问题"><a href="#8-11-未排序数组中最长子数组系列问题" class="headerlink" title="8.11 未排序数组中最长子数组系列问题"></a>8.11 未排序数组中最长子数组系列问题</h2><p>累加和为 $k$ ： $s[i]$ 表示子数组 $arr[0,i]$ 的累加和，则 $arr[j,i]$ 的累加和就是 $s[i]-s[j-1]$ ，从左到右遍历数组计算累加和，建立哈希表， $key$ 是累加和， $value$ 是最先产生该累加和的数组下标，若 $s[i]=k$ ，就得到了一个满足条件的子数组，若 $s[i]&gt;k$ ，就在表中查找 $s[i]-k$   </p>
<p>正数与负数个数相等：正数变 $1$ ，负数变 $-1$ ，相当于求累加和为 $0$ </p>
<p>数组里只有 $0$ 和 $1$ ，子数组 $0$ 和 $1$ 个数相等： $0$ 变 $-1$ ，求累加和为 $0$ </p>
<h2 id="8-12-未排序数组中累加和小于或等于给定值的最长子数组长度"><a href="#8-12-未排序数组中累加和小于或等于给定值的最长子数组长度" class="headerlink" title="8.12 未排序数组中累加和小于或等于给定值的最长子数组长度"></a>8.12 未排序数组中累加和小于或等于给定值的最长子数组长度</h2><p>建立数组 $s$ 记录累加和，建立数组 $h$ 记录 $s[0,i]$ 之间的最大值，遍历一遍原数组 $O(N)$ ，每遍历一个元素，如果 $s[i]\leq k$ 就更新最长子数组长度，反之就在 $0\sim i$ 之间搜索是否存在 $s[i]-s[j-1]\leq k$ ，即 $s[j-1]\geq s[i]-k$ ，由于 $h$ 是递增数组，结合数组 $s$ 可以实现 $O(logN)$ 的二分查找，最终时间 $O(NlogN)$ ， 空间 $O(N)$ </p>
<h2 id="8-13-计算数组的小和"><a href="#8-13-计算数组的小和" class="headerlink" title="8.13 计算数组的小和"></a>8.13 计算数组的小和</h2><p>在归并排序的过程中计算小和，因为每一步操作的两个数组都是排好序的，所以节省了遍历的时间，对于 $s_1[i]$ ，只要找到第一个 $s_1[i]&lt;s_2[j]$ ，直接给总数组小和加上 $s_1[i]*(len(s_2)-j+1)$ ，时间 $O(NlogN)$ ，空间 $O(N)$ </p>
<h2 id="8-14-自然数数组的排序"><a href="#8-14-自然数数组的排序" class="headerlink" title="8.14 自然数数组的排序"></a>8.14 自然数数组的排序</h2><p>前提是已经知道了一个数应该放在哪里，从左到右遍历，如果一个位置上的数不对，就把他放到正确的位置，替换掉那个位置上的数，然后循环修正替换下来的数，最后会回到原来遍历中止的位置，继续往后遍历</p>
<h2 id="8-15-奇数下标都是奇数或者偶数下标都是偶数"><a href="#8-15-奇数下标都是奇数或者偶数下标都是偶数" class="headerlink" title="8.15 奇数下标都是奇数或者偶数下标都是偶数"></a>8.15 奇数下标都是奇数或者偶数下标都是偶数</h2><p>两个指针从左到右分别遍历数组的奇数和偶数位置，循环检查数组最后一个数，放在相应指针标记的位置，把该位置替换下来的数放在数组尾部，对应指针加二</p>
<h2 id="8-16-子数组的最大累加和问题"><a href="#8-16-子数组的最大累加和问题" class="headerlink" title="8.16 子数组的最大累加和问题"></a>8.16 子数组的最大累加和问题</h2><p>从左到右累加，累加和变成负数就从下个数重新累加，用一个变量记录累加和的最大值</p>
<h2 id="8-17-子矩阵的最大累加和问题"><a href="#8-17-子矩阵的最大累加和问题" class="headerlink" title="8.17 子矩阵的最大累加和问题"></a>8.17 子矩阵的最大累加和问题</h2><p>把矩阵的 $k$ 行累加成一行，转化成子数组的最大累加和问题，结果就是以这 $k$ 行为基础搜索矩阵的列找到的子矩阵，从上到下以每行为起点遍历所有行数的矩阵，搜索最大累加和的子矩阵，最终时间 $O(N^3)$ ，空间 $O(N)$  </p>
<h2 id="8-18-在数组中找到一个局部最小的位置"><a href="#8-18-在数组中找到一个局部最小的位置" class="headerlink" title="8.18 在数组中找到一个局部最小的位置"></a>8.18 在数组中找到一个局部最小的位置</h2><p>先判断首尾有没有，没有就二分查找，如果 $arr[mid]&gt;arr[mid-1]$ ，因为左半边肯定不单调，所以一定存在局部最小，如果 $arr[mid]&gt;arr[mid+1]$ 就在右半边找，最终时间 $O(logN)$ </p>
<h2 id="8-19-数组中子数组的最大累乘积"><a href="#8-19-数组中子数组的最大累乘积" class="headerlink" title="8.19 数组中子数组的最大累乘积"></a>8.19 数组中子数组的最大累乘积</h2><p>从左到右遍历，分别求以每个 $arr[i]$ 结尾的最大累乘积 $max[i]$ 和最小累乘积 $min[i]$ ，通过比较 $max[i-1]\times arr[i]$ 、 $min[i-1]\times arr[i]$ 和  $arr[i]$ 三个数确定最大最小累乘积，再用一个变量保存整个过程中的最大累乘积，时间 $O(N)$ ，空间 $O(1)$ </p>
<h2 id="8-20-打印-N-个数组整体最大的-topK"><a href="#8-20-打印-N-个数组整体最大的-topK" class="headerlink" title="8.20 打印 $N$ 个数组整体最大的 $topK$"></a>8.20 打印 $N$ 个数组整体最大的 $topK$</h2><p>维护一个大根堆，因为数组都是有序的，取 $N$ 个数组的最大值建堆，时间 $O(N)$ ，每次把堆顶加入 $topK$ 并把堆顶元素所在数组的下一个最大值插入堆，每次插入 $O(logN)$ ，插入总时间 $O(KlogN)$ </p>
<h2 id="8-21-边界都是-1-的最大正方形大小"><a href="#8-21-边界都是-1-的最大正方形大小" class="headerlink" title="8.21 边界都是 $1$ 的最大正方形大小"></a>8.21 边界都是 $1$ 的最大正方形大小</h2><p>以每个点为正方形的左上角，对于所有可能的边长，检查正方形的四条边，时间 $O(N^4)$ ，空间 $O(1)$ 。可以通过预处理矩阵把检查四条边的时间变成 $O(1)$ ，预先生成两个矩阵，用来记录每个点向右和向下有多少个连续的 $1$ ，从右下角开始算，每次利用之前计算出的结果，可以把预处理时间降到 $O(N^2)$ ，优化后的总时间是 $O(N^3)$ ，空间 $O(N^2)$ </p>
<h2 id="8-22-不包含本位置值的累乘数组"><a href="#8-22-不包含本位置值的累乘数组" class="headerlink" title="8.22 不包含本位置值的累乘数组"></a>8.22 不包含本位置值的累乘数组</h2><p>使用除法：用总乘积除以每一位</p>
<p>不使用除法：创建两个数组分别存储从左到右和从右到左的累乘，不包含一个数的累乘相当于他的左累乘和右累乘的乘积；或者用异或代替除法</p>
<h2 id="8-23-数组的-partition-调整"><a href="#8-23-数组的-partition-调整" class="headerlink" title="8.23 数组的 $partition$ 调整"></a>8.23 数组的 $partition$ 调整</h2><p>从左到右遍历，交换数值，相当于用一个左指针把数组分成两个区，遍历过程中在区之间做交换。更复杂的问题可以用一个左指针一个右指针把数组分成三个区</p>
<h2 id="8-24-求最短通路值"><a href="#8-24-求最短通路值" class="headerlink" title="8.24 求最短通路值"></a>8.24 求最短通路值</h2><p>广度优先遍历，时间 $O(M\times N)$ </p>
<h2 id="8-25-数组中未出现的最小正整数"><a href="#8-25-数组中未出现的最小正整数" class="headerlink" title="8.25 数组中未出现的最小正整数"></a>8.25 数组中未出现的最小正整数</h2><p>理想情况是数组里存着 $1\sim N$ ，当发现不属于这个范围的数或有重复数时，说明坑位不够了。初始化 $l=0$ 和 $r=N$ 标记空余位置的范围。循环遍历范围头部：<br>若 $arr[l]=l+1$ ，说明正好占对了最左边的坑， $l++$<br>若 $arr[l] &lt; l$ 或 $arr[l]&gt;r$ ，说明有范围外的占坑了，把 $arr[r-1]$ 保存到 $arr[l]$ ，同时 $r—$ ，表示删除一个坑位<br>若 $arr[arr[l]-1]=arr[l]$ ，说明 $arr[l]$ 是合法范围内的数，但是他应该在的位置 $arr[l]-1$ 上已经有相同的数了，说明出现了重复，把 $arr[r-1]$ 保存到 $arr[l]$ ，同时 $r—$ ，表示删除一个坑位<br>若以上错误都没出现，说明 $arr[l]$ 是合法范围内的数，把他和 $arr[l]-1$ 位置上的数交换<br>最终左右指针相遇， $l+1$ 就是未出现的最小正整数</p>
<h2 id="8-26-数组排序之后相邻数的最大差值"><a href="#8-26-数组排序之后相邻数的最大差值" class="headerlink" title="8.26 数组排序之后相邻数的最大差值"></a>8.26 数组排序之后相邻数的最大差值</h2><p>遍历一次找到最大最小值，做桶排序，时间 $O(N)$ </p>
<h1 id="第九章-其他题目"><a href="#第九章-其他题目" class="headerlink" title="第九章 其他题目"></a>第九章 其他题目</h1><h2 id="9-1-从-5-随机到-7-随机及其扩展"><a href="#9-1-从-5-随机到-7-随机及其扩展" class="headerlink" title="9.1 从 $5$ 随机到 $7$ 随机及其扩展"></a>9.1 从 $5$ 随机到 $7$ 随机及其扩展</h2><p>$rand1to5$ 实现 $rand1to7$ ：独立调用两次 $rand1to5$ ， $res=(rand1to5-1)\times 5+(rand1to5-1)$ 等概率随机生成 $0\sim 24$ 之间的数，当结果在 $0\sim 20$ 之间时， $res\%7+1$ 就等概率随机生成 $0\sim 27$ 之间的数 </p>
<p>$rand01p$ 实现 $rand1to6$ ：由于 $rand01p$ 生成 $01$ 和 $10$ 的概率都是 $p(1-p)$ ，所以先通过调用两次 $rand01p$ 实现等概率产生 $0$ 和 $1$ 的 $rand01$ 。 $rand0to3=rand01\times 2+rand01$ 等概率随机生成 $0\sim 3$ ， $res=rand0to3\times 4+rand0to3$ 等概率随机生成 $0\sim 15$ ，当结果在 $0\sim 11$ 之间时， $res\%6+1$ 就等概率随机生成 $0\sim 6$ 之间的数 </p>
<p>$rand1toM$ 实现 $rand1toN$ ：如果 $M&gt;N$ ，调用一次直接筛选 $res$ ，如果 $M&lt;N$ ，调用多次拼接成一个多位的 $M$ 进制数，再筛选 $res$ </p>
<h2 id="9-2-一行代码求两个数的最大公约数"><a href="#9-2-一行代码求两个数的最大公约数" class="headerlink" title="9.2 一行代码求两个数的最大公约数"></a>9.2 一行代码求两个数的最大公约数</h2><p>辗转相除法， $gcd(a,b)=gcd(b,a\%b)$ </p>
<h2 id="9-3-有关阶乘的两个问题"><a href="#9-3-有关阶乘的两个问题" class="headerlink" title="9.3 有关阶乘的两个问题"></a>9.3 有关阶乘的两个问题</h2><p>阶乘末尾 $0$ 的数量：遍历 $1\sim N$ 的所有数，累计每个数的因子 $5$ 的个数，遍历过程可以优化，一个数有多少 $5^k$ 的因子，就能提供多少个 $5$ ，所以因子 $5$ 总数为： $\sum_{k=1} N/5^k$ </p>
<p>阶乘的二进制表示中最右边的 $1$ 的位置：末尾 $0$ 的数量是因子 $2$ 的个数 $\sum_{k=1} N/2^k$ </p>
<h2 id="9-4-判断一个点是否在矩形内部"><a href="#9-4-判断一个点是否在矩形内部" class="headerlink" title="9.4 判断一个点是否在矩形内部"></a>9.4 判断一个点是否在矩形内部</h2><p>比较坐标位置；或者看横纵直线和矩形的交点，一个点在凸多边形的内部，从这个点引出的横纵两条直线与多边形的四个交点一定分布在这个点的上下左右</p>
<h2 id="9-5-判断一个点是否在三角形内部"><a href="#9-5-判断一个点是否在三角形内部" class="headerlink" title="9.5 判断一个点是否在三角形内部"></a>9.5 判断一个点是否在三角形内部</h2><p>同上</p>
<h2 id="9-6-折纸问题"><a href="#9-6-折纸问题" class="headerlink" title="9.6 折纸问题"></a>9.6 折纸问题</h2><p>找规律，每次折叠产生的新折痕都是在上次折叠新产生的每一条折痕前后生成下折痕和上折痕<br>第一次折叠：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;下<br>第二次折叠：&emsp;&emsp;&emsp;下&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;上<br>第三次折叠：&emsp;下&emsp;&emsp;&emsp;上&emsp;&emsp;&emsp;下&emsp;&emsp;&emsp;上<br>第四次折叠：下&emsp;上&emsp;下&emsp;上&emsp;下&emsp;上&emsp;下&emsp;上<br>中序遍历的结果就是折痕顺序</p>
<h2 id="9-7-蓄水池算法"><a href="#9-7-蓄水池算法" class="headerlink" title="9.7 蓄水池算法"></a>9.7 蓄水池算法</h2><p>前 $k$ 个球直接放入，对于第 $i(i&gt;k)$ 个球，以 $k/i$ 的概率决定放入，如果放入了就随机扔掉袋子里的一个球，可以数学证明每个球最终留在袋子里的概率都是 $k/N$ </p>
<h2 id="9-8-设计有-setAll-功能的哈希表"><a href="#9-8-设计有-setAll-功能的哈希表" class="headerlink" title="9.8 设计有 $setAll$ 功能的哈希表"></a>9.8 设计有 $setAll$ 功能的哈希表</h2><p>给每个值附加一个时间戳，创建一个 $key=setAll$ 的条目，每次调用 $setAll$ 方法就更新 $setAll$ 条目的值和时间戳，当查询的值的时间比 $setAll$ 早时，返回 $setAll$ 条目的值，从查询结果看是重置了所有值，其实只是把查询重定向了</p>
<h2 id="9-9-最大的-leftMax-与-rightMax-之差的绝对值"><a href="#9-9-最大的-leftMax-与-rightMax-之差的绝对值" class="headerlink" title="9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值"></a>9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值</h2><p>方法一：创建两个数组，从左到右和从右到左各遍历一遍，记录 $leftMax$ 和 $rightMax$ ，最后再遍历一次直接出结果，时间 $O(N)$ ，空间 $O(N)$ </p>
<p>方法二：遍历一遍找到数组最大值，再和数组首尾两个元素分别算差值，因为当最大值在一侧时，另一侧最小的最大值就是只有一个元素的情况，时间 $O(N)$ ，空间 $O(1)$ </p>
<h2 id="9-10-设计可以变更的缓存结构"><a href="#9-10-设计可以变更的缓存结构" class="headerlink" title="9.10 设计可以变更的缓存结构"></a>9.10 设计可以变更的缓存结构</h2><p>双向队列实现节点的排序，头部存旧节点，尾部存最近访问的节点，当一个节点被访问时就移到尾部，要淘汰节点时直接从头部删除，用哈希表映射节点实现 $O(1)$ 的时间复杂度</p>
<h2 id="9-11-设计-RandomPool-结构"><a href="#9-11-设计-RandomPool-结构" class="headerlink" title="9.11 设计 $RandomPool$ 结构"></a>9.11 设计 $RandomPool$ 结构</h2><p>数据只有 $key$ 没有 $value$ ，所以可以用哈希表给 $key$ 一个 $index$ ，一个哈希表的索引是 $key$ ，另一个的索引是 $index$ ， $getRandom$ 就是在 $0\sim index$ 之间生成一个随机数</p>
<h2 id="9-12-调整-0-x-区间上的数出现的概率"><a href="#9-12-调整-0-x-区间上的数出现的概率" class="headerlink" title="9.12 调整 $[0,x)$ 区间上的数出现的概率"></a>9.12 调整 $[0,x)$ 区间上的数出现的概率</h2><p>分别调用 $k$ 次 $random$ 函数，返回最大的值，因为只要有一次不在 $[0,x)$ 内，结果就不在 $[0,x)$ 内，说明随机到 $[0,x)$ 内的概率是 $x^k$ </p>
<h2 id="9-13-路径数组变为统计数组"><a href="#9-13-路径数组变为统计数组" class="headerlink" title="9.13 路径数组变为统计数组"></a>9.13 路径数组变为统计数组</h2><p>从左到右遍历 $path$ ，如果不是首都就跳到他指向的城市，最终要么跳到首都要么跳到一个已经遍历过的节点，然后反向跳回去，同时设置每一步到首都的距离，遍历一遍后 $path[i]$ 就表示城市 $i$ 到首都的距离。再从左到右遍历 $path$ ，还是用跳跃的方法赋值，先 $path[path[0]]=1$ ，对替换下来的 $path[path[0]]$ 再 $path[path[path[0]]]=1$ ，遍历完后 $path[i]$ 就表示到首都距离为 $i$ 的城市数。两次遍历期间可以用数值的正负来区分数值代表的含义</p>
<h2 id="9-14-正数数组的最小不可组成和"><a href="#9-14-正数数组的最小不可组成和" class="headerlink" title="9.14 正数数组的最小不可组成和"></a>9.14 正数数组的最小不可组成和</h2><p>动态规划，对数组求一次总和 $sum$ ，把 $dp$ 长度设成 $sum$ ， $dp[i]$ 表示存在子数组累加和是 $i$ ，从左到右遍历数组，对于每一个元素 $k$ ，遍历 $dp[i]=1$ 使 $dp[i+k]=1$ ，最后再扫一遍 $dp$ 找最小不可组成和，时间 $O(N\times sum)$ ，空间 $O(sum)$ </p>
<p>已知数组中有 $1$ 时：数组排序，遍历一遍求每个位置 $i$ 的 $range$ ，表示 $[1,range]$ 能够被 $arr[0,i-1]$ 表示，初始 $range=1$ ，如果 $arr[i]&gt;range+1$ ，说明 $range+1$ 无法组成，直接返回结果，如果 $arr[i]\leq range+1$ ，说明 $[1,range+arr[i]]$ 能够被 $arr[0,i]$ 表示，让 $range+=arr[i]$ ，时间 $O(NlogN)$ ，空间 $O(1)$ </p>
<p>$\color{red}{没明白已知有1到底影响了什么}$</p>
<h2 id="9-14-一种字符串和数字的对应关系"><a href="#9-14-一种字符串和数字的对应关系" class="headerlink" title="9.14 一种字符串和数字的对应关系"></a>9.14 一种字符串和数字的对应关系</h2><p>数字转字符串：把字符串看成是伪 $k$ 进制数，每位的范围是 $1\sim k$ ，先用目标数依次减去 $k$ 、 $k^2$ 、 $k^3$ 等，算出字符串需要的位数，再用剩下的数从高位到低位依次赋值</p>
<p>字符串转数字：第 $i$ 位的值表示有多少个 $k^i$ ，所有位求和</p>
<h2 id="9-15-1-到-n-中-1-出现的次数"><a href="#9-15-1-到-n-中-1-出现的次数" class="headerlink" title="9.15  $1$ 到 $n$ 中 $1$ 出现的次数"></a>9.15  $1$ 到 $n$ 中 $1$ 出现的次数</h2><p>找规律，分别算每一位上 $1$ 出现的次数，取右数第 $i$ 位左边的数字(没有就是0)，乘以 $10^{i−1}$ ，得到基础值 $a$ ，取第 $i$ 位数字，计算修正值：<br>如果大于 $1$ ，则结果为 $a+10^{i−1}$<br>如果小于 $1$ ，则结果为 $a$<br>如果等 $1$ ，则取第 $i$ 位右边数字，设为 $b$ ，最后结果为 $a+b+1$   </p>
<h2 id="9-16-从-N-个数中等概率打印-M-个数"><a href="#9-16-从-N-个数中等概率打印-M-个数" class="headerlink" title="9.16 从 $N$ 个数中等概率打印 $M$ 个数"></a>9.16 从 $N$ 个数中等概率打印 $M$ 个数</h2><p>随机打印 $[0,N-1]$ 的一个位置 $a$ 上的 $arr[a]$ ，把 $arr[a]$ 和 $arr[N-1]$ 交换，再随机打印 $[0,N-2]$ 的一个位置 $b$ 上的 $arr[b]$ ，循环该过程直到打印出 $N$ 个数，可以推出来每个数打印的概率都是 $1/N$ </p>
<h2 id="9-17-判断一个数是否是回文数"><a href="#9-17-判断一个数是否是回文数" class="headerlink" title="9.17 判断一个数是否是回文数"></a>9.17 判断一个数是否是回文数</h2><p>左右比较，剥洋葱法</p>
<h2 id="9-18-在有序旋转数组中找到最小值"><a href="#9-18-在有序旋转数组中找到最小值" class="headerlink" title="9.18 在有序旋转数组中找到最小值"></a>9.18 在有序旋转数组中找到最小值</h2><p>递增数组旋转过的数组中间有断点，如果子数组左小右大说明不包含断点，左大右小说明一定包含断点，左右相等时不确定，如 $[3,1,2,3]$ ，此时需要对子数组进行查找，整个过程尽量使用二分查找，最优情况 $O(logN)$ ，最坏情况 $O(N)$  </p>
<h2 id="9-19-在有序旋转数组中找到一个数"><a href="#9-19-在有序旋转数组中找到一个数" class="headerlink" title="9.19 在有序旋转数组中找到一个数"></a>9.19 在有序旋转数组中找到一个数</h2><p>二分查找，根据子数组左中右的值，判断断点可能的位置以及需要继续搜索的子数组</p>
<h2 id="9-20-数字的英文表达和中文表达"><a href="#9-20-数字的英文表达和中文表达" class="headerlink" title="9.20 数字的英文表达和中文表达"></a>9.20 数字的英文表达和中文表达</h2><p>英文三位一组(个十百)，中文四位一组(个十百千)</p>
<h2 id="9-21-分糖果问题"><a href="#9-21-分糖果问题" class="headerlink" title="9.21 分糖果问题"></a>9.21 分糖果问题</h2><p>从左到右遍历，每找到一个上下坡的组合就开始赋值，两个坡最低处都是 $1$ ，两侧上坡都是递增加一，直到两个坡交汇，交汇处的值由坡长的一侧决定</p>
<h2 id="9-22-一种消息接受并打印的结构设计"><a href="#9-22-一种消息接受并打印的结构设计" class="headerlink" title="9.22 一种消息接受并打印的结构设计"></a>9.22 一种消息接受并打印的结构设计</h2><p>创建长度为 $N$ 的数组，接受的数字对号入座，当打印到 $k$ 时就把 $k+1$ 当做下一次打印的标志，一旦接收到就向后打印连续区间值</p>
<h2 id="9-23-设计一个没有扩容负担的堆结构"><a href="#9-23-设计一个没有扩容负担的堆结构" class="headerlink" title="9.23 设计一个没有扩容负担的堆结构"></a>9.23 设计一个没有扩容负担的堆结构</h2><p>二叉树</p>
<h2 id="9-24-随时找到数据流的中位数"><a href="#9-24-随时找到数据流的中位数" class="headerlink" title="9.24 随时找到数据流的中位数"></a>9.24 随时找到数据流的中位数</h2><p>一个大根堆存较小的一半数，一个小根堆存较大的一半数，新的数通过比较堆顶决定加入哪个堆，每次插入后平衡两个堆的大小，保证中位数只和两个堆顶有关</p>
<h2 id="9-25-在两个长度相等的排序数组中找到上中位数"><a href="#9-25-在两个长度相等的排序数组中找到上中位数" class="headerlink" title="9.25 在两个长度相等的排序数组中找到上中位数"></a>9.25 在两个长度相等的排序数组中找到上中位数</h2><p>两个数组分别二分查找，结果是分成了四段数组，比较 $arr1[mid]$ 和 $arr2[mid]$ ，如果二者相等说明 $arr[mid]$ 就是合并后数组的上中位数，如果 $arr1[mid]&gt;arr2[mid]$ ，说明合并后的数组中， $arr1[mid:right]$ 在最右边， $arr2[left:mid]$ 在最左边，把这两部分排除，对 $arr1[left:mid]$ 和 $arr2[mid:right]$ 继续做二分查找，最终时间 $O(logN)$  </p>
<h2 id="9-26-在两个排序数组中找到第-K-小的数"><a href="#9-26-在两个排序数组中找到第-K-小的数" class="headerlink" title="9.26 在两个排序数组中找到第 $K$ 小的数"></a>9.26 在两个排序数组中找到第 $K$ 小的数</h2><p>仿照上题，看第 $K$ 小的数出现在哪部分里，每次对新的子数组二分查找要让 $K$ 减去左边排除掉的部分，最终时间 $O(log(min{M,N}))$ ，因为分别在两个数组上二分查找，复杂度由短的决定</p>
<h2 id="9-27-两个有序数组间相加和的-TOPK-问题"><a href="#9-27-两个有序数组间相加和的-TOPK-问题" class="headerlink" title="9.27 两个有序数组间相加和的 $TOPK$ 问题"></a>9.27 两个有序数组间相加和的 $TOPK$ 问题</h2><p>维护一个大根堆，先把 $arr1[M-1]+arr2[N-1]$ 插入堆，重复以下操作，弹出堆顶，假设是 $arr1[i]+arr2[j]$ ，同时把 $arr1[i-1]+arr2[j]$ 和 $arr1[i]+arr2[j-1]$ 插入堆，也就是每次从堆里弹出一个元素，同时保证还在堆里的元素是数组间相加和最大的几个，每次堆的大小加一，最终大小是 $K$ ，堆插入时间是 $O(logK)$ ，所以总时间 $O(KlogK)$ </p>
<h2 id="9-28-出现次数的-TOPK-问题"><a href="#9-28-出现次数的-TOPK-问题" class="headerlink" title="9.28 出现次数的 $TOPK$ 问题"></a>9.28 出现次数的 $TOPK$ 问题</h2><p>先用哈希表统计词频，再建立小根堆，堆的节点存储字符串和出现次数，遍历哈希表，依次把每条记录插入堆，当堆的大小是 $K$ 时，只有出现次数比堆顶元素多时才插入，最终堆里的元素就是出现次数 $TOPK$ ，时间 $O(NlogK)$  </p>
<p>没有数组，字符串动态添加，实时打印：也是维护一个大小为 $K$ 的小根堆，用一个哈希表 $A$ 存储字符串和节点的映射，再用一个哈希表 $B$ 存储节点到堆中位置的映射，每次添加字符串时，先更新 $A$ 中节点的频次属性，如果是新节点直接插入堆，否则然后通过 $B$ 找到节点在堆中的位置，更新节点的频次属性，调整节点的位置，期间保证哈希表和堆的修改同步，最终添加操作 $O(logK)$ ，打印操作直接按位置顺序打印，时间 $O(K)$  </p>
<h2 id="9-29-Manacher-算法"><a href="#9-29-Manacher-算法" class="headerlink" title="9.29  $Manacher$ 算法"></a>9.29  $Manacher$ 算法</h2><p>单独写</p>
<h2 id="9-30-KMP-算法"><a href="#9-30-KMP-算法" class="headerlink" title="9.30  $KMP$ 算法"></a>9.30  $KMP$ 算法</h2><p>单独写</p>
<h2 id="9-31-丢棋子问题"><a href="#9-31-丢棋子问题" class="headerlink" title="9.31 丢棋子问题"></a>9.31 丢棋子问题</h2><p>方法一： $P(N,K)$ 表示 $N$ 层楼有 $K$ 个棋子在最差情况下扔的最少次数，显然 $P(0,K)=0$ ， $P(N,1)=N$ ，一般情况时，当在第 $i$ 层扔下，如果碎了，结果就是 $1+P(i-1,K-1)$ ，如果没碎，结果就是 $1+P(N-i,K)$ ，最差情况是二者的最大值，所以用递归的方法， $P(N,K)=min{max{P(i-1,K-1),P(N-i,K)}}(1\leq i\leq N)+1$ ，时间复杂度 $O(N!)$</p>
<p>方法二：动态规划， $dp[i][j]=P(i,j)$ ，遍历数组时间 $O(N\times K)$ ，求 $min-max$ 过程 $O(N)$ ，所以总时间 $O(N^2\times K)$   </p>
<p>优化一：压缩空间， $P(N,K)$  的子问题只遍历 $N$ ，所以对于每个 $dp[i][j]$ 只需要维护左边一列和上边一行空间</p>
<p>优化二：用四边形不等式优化枚举，楼层数相同时，棋子少越少，第一个棋子扔的层数就越高，棋子数相同时，楼层数越多，第一个棋子扔的层数就越高，所以第一个棋子扔的位置可以作为边界来减少枚举</p>
<p>$\color{red}{四边形不等式的原理没太看懂}$</p>
<p>最优解： $map[i][j]$ 表示 $i$ 个棋子扔 $j$ 次最多能判断多高的楼层，第一行第一列直接赋值，扔了第一个棋子后，如果碎了就剩 $i-1$ 个棋子扔 $j-1$ 次，如果没碎就剩 $i$ 个棋子扔 $j-1$ 次，再加上第一次扔的这层，有 $map[i][j]=map[i-1][j-1]+map[i][j-1]+1$ ，之所以不需要 $min-max$ 的过程是因为 $map$ 表示能力的上限，第一次扔完以后要么只向下搜索要么只向上搜索，所以能力值应该是两个方向上的总和，而 $P(N,K)$ 表示运气最差的一种情况，所以必须要通过遍历确定唯一的子问题。在棋子数给定时，只需遍历 $map$ 的一行就能搜索到答案</p>
<h2 id="9-32-画匠问题"><a href="#9-32-画匠问题" class="headerlink" title="9.32 画匠问题"></a>9.32 画匠问题</h2><p>方法一： $dp[i][j]$ 表示 $i$ 个画家画 $j$ 幅画的最少时间，有 $dp[i][j]=min{max{dp[i-1][k]+sum[k+1..j]}}(0\leq k\leq j)$ ，时间 $O(N^2\times K)$ </p>
<p>优化：四边形不等式减少枚举，时间 $O(N^2)$  </p>
<p>最优解：规定每个画匠最大工作时间 $limit$ ，遍历一遍数组可以知道至少需要几个画匠， $limit$ 的范围是 $[0,sum(arr)]$ ，比较 $limit$ 限定下画匠人数与题目给出的人数，用二分法确定 $limit$ 的大小，时间 $O(NlogSum(arr))$   </p>
<h2 id="9-33-邮局选址问题"><a href="#9-33-邮局选址问题" class="headerlink" title="9.33 邮局选址问题"></a>9.33 邮局选址问题</h2><p>方法一：假设 $arr[i,j]$ 上只能建一个邮局，一定是建在中点上总距离最小， $w[i][j]$ 表示这个总距离，因为 $arr[i,j-1]$ 变成 $arr[i,j]$ 后中点位置不变，所以有 $w[i][j]=w[i][j-1]+arr[j]-arr[(i+j)/2]$ ，多的就是新增的点到中点的距离。 $dp[i][j]$ 表示在 $arr[0,j]$ 上建 $i+1$ 个邮局的最小总距离，首先有 $dp[0][j]=w[0][j]$ ，一般情况下 $dp[i][j]=min{dp[i-1][k]+w[k+1][j]}(0\leq k\leq N)$ ，表示在 $arr[0,k]$ 建 $i-1$ 个，在 $arr[k+1,j]$ 建 $1$ 个，枚举所有情况选择总距离最小的，时间 $O(N^2\times Num)$   </p>
<p>优化：四边形不等式，时间 $O(N^2)$ </p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:wkx1996@foxmail.com">w.k.x.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://shivakasu.github.io/2020/01/10/arg0/">http://shivakasu.github.io/2020/01/10/arg0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://shivakasu.github.io">SHIVAKASU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法    </a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试    </a></div><div class="post_share"><div class="social-share" data-image="http://file.shivakasu.cn/5f37cb297aa622ca620e/interview0.jpg" data-sites="facebook,twitter,wechat,weibo,qq,qzone,douban,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="http://file.shivakasu.cn/4a84dcfb31806db98b2a/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="http://file.shivakasu.cn/982f781ef31cbc46968b/alipay.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/11/arg1/"><img class="prev_cover lazyload" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>字符串匹配算法总结</span></div></a></div><div class="next-post pull_right"><a href="/2019/02/10/fpy4/"><img class="next_cover lazyload" data-src="http://file.shivakasu.cn/ed83db4944a34b9070aa/fpy.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>流畅的Python Chapter 7：函数装饰器和闭包</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/01/11/arg1/" title="字符串匹配算法总结"><img class="relatedPosts_cover lazyload"data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-11</div><div class="relatedPosts_title">字符串匹配算法总结</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/15/arg2/" title="Manacher 算法"><img class="relatedPosts_cover lazyload"data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-15</div><div class="relatedPosts_title">Manacher 算法</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/28/blockchain0/" title="区块链技术与应用笔记"><img class="relatedPosts_cover lazyload"data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-28</div><div class="relatedPosts_title">区块链技术与应用笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/16/arg3/" title="旅行商问题与最优解搜索算法"><img class="relatedPosts_cover lazyload"data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-16</div><div class="relatedPosts_title">旅行商问题与最优解搜索算法</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/03/leetcode/" title="leetcode (更新中)"><img class="relatedPosts_cover lazyload"data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-03</div><div class="relatedPosts_title">leetcode (更新中)</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'qIfwEiuSjlc5vyminB1rx2qX-gzGzoHsz',
  appKey:'erfVXuW3AybzbWGqxSGxnBRp',
  placeholder:'来都来了，说点儿什么吧~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By w.k.x.</div><div class="framework-info"><span>driven by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>京ICP备19001969号-1</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>