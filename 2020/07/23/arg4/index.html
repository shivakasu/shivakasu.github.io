<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TimSort 在 JDK10 中的实现 | SHIVAKASU</title><meta name="description" content="Timsort 是一种稳定高效的排序算法，混合了合并排序和二分插入排序，旨在很好地处理多种真实数据。它由Tim Peters于2002年实施使用在Python编程语言中。该算法查找已经排序的数据的子序列，并使用该知识更有效地对其余部分进行排序。从版本2.3开始，Timsort一直是Python的标准排序算法。如今，Timsort 已是是 Python、 Java、 Android平台 和 GNU"><meta name="keywords" content="算法,Java"><meta name="author" content="w.k.x.,wkx1996@foxmail.com"><meta name="copyright" content="w.k.x."><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://file.shivakasu.cn/eb8581b76ec032ab0db8/favicon.ico"><link rel="canonical" href="https://shivakasu.cn/2020/07/23/arg4/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="TimSort 在 JDK10 中的实现"><meta property="og:url" content="https://shivakasu.cn/2020/07/23/arg4/"><meta property="og:site_name" content="SHIVAKASU"><meta property="og:description" content="Timsort 是一种稳定高效的排序算法，混合了合并排序和二分插入排序，旨在很好地处理多种真实数据。它由Tim Peters于2002年实施使用在Python编程语言中。该算法查找已经排序的数据的子序列，并使用该知识更有效地对其余部分进行排序。从版本2.3开始，Timsort一直是Python的标准排序算法。如今，Timsort 已是是 Python、 Java、 Android平台 和 GNU"><meta property="og:image" content="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><meta property="article:published_time" content="2020-07-23T07:00:20.000Z"><meta property="article:modified_time" content="2020-07-23T15:34:20.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="叶秀山版《西方哲学史》笔记之第二卷：古希腊罗马哲学" href="https://shivakasu.cn/2020/06/29/phi4/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: w.k.x.","link":"链接: ","source":"来源: SHIVAKASU","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: true    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: false
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="SHIVAKASU" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://file.shivakasu.cn/cb7049104af4685e7289/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">46</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SHIVAKASU</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">TimSort 在 JDK10 中的实现</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-23 15:00:20"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-23</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-23 23:34:20"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-23</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/">日常专业学习</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">8.6k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 42 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/2020/07/23/arg4/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/07/23/arg4/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><ul>
<li>Timsort 是一种稳定高效的排序算法，混合了合并排序和二分插入排序，旨在很好地处理多种真实数据。它由Tim Peters于2002年实施使用在Python编程语言中。该算法查找已经排序的数据的子序列，并使用该知识更有效地对其余部分进行排序。从版本2.3开始，Timsort一直是Python的标准排序算法。如今，Timsort 已是是 Python、 Java、 Android平台 和 GNU Octave 的默认排序算法。</li>
<li>大致思路是：因为二分插入排序处理短序列的效率比较高，所以就把待排序的长序列切分成多个短序列，每个短序列独立执行二分插入排序，最后再对排好序的短序列做归并排序。在归并排序时，通过检测序列中已经排好序的片段，巧妙地把这些片段直接作为排序结果，跳过归并操作，从而减少了归并排序时的迭代次数。</li>
<li>复杂度比较(借用网上的图，<a href="http://i.umumble.com/img/topic-1323165248.png" target="_blank" rel="noopener">原图地址</a>)：</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://file.shivakasu.cn/cacd6e8f0c740bcf46f6/arg4.png" alt=""></p>
<ul>
<li>jdk/lib/src.zip/java.base/java/util/TimSort.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A stable, adaptive, iterative mergesort that requires far fewer than</span></span><br><span class="line"><span class="comment"> * n lg(n) comparisons when running on partially sorted arrays, while</span></span><br><span class="line"><span class="comment"> * offering performance comparable to a traditional mergesort when run</span></span><br><span class="line"><span class="comment"> * on random arrays.  Like all proper mergesorts, this sort is stable and</span></span><br><span class="line"><span class="comment"> * runs O(n log n) time (worst case).  In the worst case, this sort requires</span></span><br><span class="line"><span class="comment"> * temporary storage space for n/2 object references; in the best case,</span></span><br><span class="line"><span class="comment"> * it requires only a small constant amount of space.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This implementation was adapted from Tim Peters's list sort for</span></span><br><span class="line"><span class="comment"> * Python, which is described in detail here:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   http://svn.python.org/projects/python/trunk/Objects/listsort.txt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Tim's C code may be found here:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   http://svn.python.org/projects/python/trunk/Objects/listobject.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The underlying techniques are described in this paper (and may have</span></span><br><span class="line"><span class="comment"> * even earlier origins):</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  "Optimistic Sorting and Information Theoretic Complexity"</span></span><br><span class="line"><span class="comment"> *  Peter McIlroy</span></span><br><span class="line"><span class="comment"> *  SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),</span></span><br><span class="line"><span class="comment"> *  pp 467-474, Austin, Texas, 25-27 January 1993.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * While the API to this class consists solely of static methods, it is</span></span><br><span class="line"><span class="comment"> * (privately) instantiable; a TimSort instance holds the state of an ongoing</span></span><br><span class="line"><span class="comment"> * sort, assuming the input array is large enough to warrant the full-blown</span></span><br><span class="line"><span class="comment"> * TimSort. Small arrays are sorted in place, using a binary insertion sort.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Bloch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the minimum sized sequence that will be merged.  Shorter</span></span><br><span class="line"><span class="comment">     * sequences will be lengthened by calling binarySort.  If the entire</span></span><br><span class="line"><span class="comment">     * array is less than this length, no merges will be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This constant should be a power of two.  It was 64 in Tim Peter's C</span></span><br><span class="line"><span class="comment">     * implementation, but 32 was empirically determined to work better in</span></span><br><span class="line"><span class="comment">     * this implementation.  In the unlikely event that you set this constant</span></span><br><span class="line"><span class="comment">     * to be a number that's not a power of two, you'll need to change the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #minRunLength&#125; computation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you decrease this constant, you must change the stackLen</span></span><br><span class="line"><span class="comment">     * computation in the TimSort constructor, or you risk an</span></span><br><span class="line"><span class="comment">     * ArrayOutOfBounds exception.  See listsort.txt for a discussion</span></span><br><span class="line"><span class="comment">     * of the minimum stack length required as a function of the length</span></span><br><span class="line"><span class="comment">     * of the array being sorted and the minimum merge sequence length.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_MERGE = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array being sorted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The comparator for this sort.</span></span><br><span class="line"><span class="comment">     * 比较器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> T&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When we get into galloping mode, we stay there until both runs win less</span></span><br><span class="line"><span class="comment">     * often than MIN_GALLOP consecutive times.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  MIN_GALLOP = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This controls when we get *into* galloping mode.  It is initialized</span></span><br><span class="line"><span class="comment">     * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for</span></span><br><span class="line"><span class="comment">     * random data, and lower for highly structured data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minGallop = MIN_GALLOP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Maximum initial size of tmp array, which is used for merging.  The array</span></span><br><span class="line"><span class="comment">     * can grow to accommodate demand.</span></span><br><span class="line"><span class="comment">     * 归并排序中临时数组的初始长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Unlike Tim's original C version, we do not allocate this much storage</span></span><br><span class="line"><span class="comment">     * when sorting smaller arrays.  This change was required for performance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_TMP_STORAGE_LENGTH = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Temp storage for merges. A workspace array may optionally be</span></span><br><span class="line"><span class="comment">     * provided in constructor, and if so will be used as long as it</span></span><br><span class="line"><span class="comment">     * is big enough.</span></span><br><span class="line"><span class="comment">     * 归并排序的临时数组，tmpBase是数组中有效数据的起始下标，tmpLen是有效数据的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] tmp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tmpBase; <span class="comment">// base of tmp array slice </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tmpLen;  <span class="comment">// length of tmp array slice</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A stack of pending runs yet to be merged.  Run i starts at</span></span><br><span class="line"><span class="comment">     * address base[i] and extends for len[i] elements.  It's always</span></span><br><span class="line"><span class="comment">     * true (so long as the indices are in bounds) that:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     runBase[i] + runLen[i] == runBase[i + 1]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * so we could cut the storage for this, but it's a minor amount,</span></span><br><span class="line"><span class="comment">     * and keeping all the info explicit simplifies the code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackSize = <span class="number">0</span>;  <span class="comment">// Number of pending runs on stack</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] runBase;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] runLen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a TimSort instance to maintain the state of an ongoing sort.</span></span><br><span class="line"><span class="comment">     * 构造函数是私有的，单例模式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the comparator to determine the order of the sort</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> work a workspace array (slice)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workBase origin of usable space in work array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workLen usable size of work array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TimSort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c, T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allocate temp storage (which may be increased later if necessary)</span></span><br><span class="line">        <span class="comment">// 确定临时数组的初始长度，如果低于默认值256的2倍，则空间大小为原始数组a的长度的一半，否则为默认长度256</span></span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">int</span> tlen = (len &lt; <span class="number">2</span> * INITIAL_TMP_STORAGE_LENGTH) ?</span><br><span class="line">            len &gt;&gt;&gt; <span class="number">1</span> : INITIAL_TMP_STORAGE_LENGTH;</span><br><span class="line">        <span class="comment">// 排序需要的临时数组长度是tlen，如果给定的work数组无法容纳tlen长度的数据，就创建新的临时数组，否则就直接把work数组当临时数组用</span></span><br><span class="line">        <span class="comment">// work数组貌似没什么用，只有在ArraysParallelSortHelpers.java中会设置work，绝大多数的类调用TimSort时work参数都是null，所以没必要看了</span></span><br><span class="line">        <span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; tlen || workBase + tlen &gt; work.length) &#123;</span><br><span class="line">            <span class="comment">// 屏蔽泛型数组转型产生的警告</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"UnnecessaryLocalVariable"</span>&#125;)</span><br><span class="line">            T[] newArray = (T[])java.lang.reflect.Array.newInstance</span><br><span class="line">                (a.getClass().getComponentType(), tlen);</span><br><span class="line">            tmp = newArray;</span><br><span class="line">            tmpBase = <span class="number">0</span>;</span><br><span class="line">            tmpLen = tlen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = work;</span><br><span class="line">            tmpBase = workBase;</span><br><span class="line">            tmpLen = workLen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Allocate runs-to-be-merged stack (which cannot be expanded).  The</span></span><br><span class="line"><span class="comment">         * stack length requirements are described in listsort.txt.  The C</span></span><br><span class="line"><span class="comment">         * version always uses the same stack length (85), but this was</span></span><br><span class="line"><span class="comment">         * measured to be too expensive when sorting "mid-sized" arrays (e.g.,</span></span><br><span class="line"><span class="comment">         * 100 elements) in Java.  Therefore, we use smaller (but sufficiently</span></span><br><span class="line"><span class="comment">         * large) stack lengths for smaller arrays.  The "magic numbers" in the</span></span><br><span class="line"><span class="comment">         * computation below must be changed if MIN_MERGE is decreased.  See</span></span><br><span class="line"><span class="comment">         * the MIN_MERGE declaration above for more information.</span></span><br><span class="line"><span class="comment">         * The maximum value of 49 allows for an array up to length</span></span><br><span class="line"><span class="comment">         * Integer.MAX_VALUE-4, if array is filled by the worst case stack size</span></span><br><span class="line"><span class="comment">         * increasing scenario. More explanations are given in section 4 of:</span></span><br><span class="line"><span class="comment">         * http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * 存储run的栈，不能在运行时动态扩展。一个长数组会被切分成多个短数组分别排序，run存储的就是每个子数组的长度和在原数组中的起始下标，在最后归并的时候用来定位子数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> stackLen = (len &lt;    <span class="number">120</span>  ?  <span class="number">5</span> :</span><br><span class="line">                        len &lt;   <span class="number">1542</span>  ? <span class="number">10</span> :</span><br><span class="line">                        len &lt; <span class="number">119151</span>  ? <span class="number">24</span> : <span class="number">49</span>);</span><br><span class="line">        runBase = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br><span class="line">        runLen = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The next method (package private and static) constitutes the</span></span><br><span class="line"><span class="comment">     * entire API of this class.</span></span><br><span class="line"><span class="comment">     * sort方法是TimSort类对外暴露的唯一方法，其余都是私有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sorts the given range, using the given workspace array slice</span></span><br><span class="line"><span class="comment">     * for temp storage when possible. This method is designed to be</span></span><br><span class="line"><span class="comment">     * invoked from public methods (in class Arrays) after performing</span></span><br><span class="line"><span class="comment">     * any necessary array bounds checks and expanding parameters into</span></span><br><span class="line"><span class="comment">     * the required forms.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对数组a中的[lo, hi)片段做排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lo the index of the first element, inclusive, to be sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hi the index of the last element, exclusive, to be sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the comparator to use</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> work a workspace array (slice)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workBase origin of usable space in work array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workLen usable size of work array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                         T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="keyword">null</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line">        <span class="comment">// 待排序的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">        <span class="comment">// 待排序元素只有0个或1个，不需要排序</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If array is small, do a "mini-TimSort" with no merges</span></span><br><span class="line">        <span class="comment">// 如果待排序元素少于归并排序的最小元素数量，就执行不包含归并排序的版本</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="comment">// 获取从a[lo]开始的最长有序连续片段的长度，如果片段是递减的会被反转成递增，得到的initRunLen就是从a[lo]开始已经排好序的长度</span></span><br><span class="line">            <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            <span class="comment">// 调用二分插入排序，对a[lo + initRunLen]到a[hi]的所有元素执行插入</span></span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * March over the array once, left to right, finding natural runs,</span></span><br><span class="line"><span class="comment">         * extending short natural runs to minRun elements, and merging runs</span></span><br><span class="line"><span class="comment">         * to maintain stack invariant.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 创建TimSort实例，保存中间结果</span></span><br><span class="line">        TimSort&lt;T&gt; ts = <span class="keyword">new</span> TimSort&lt;&gt;(a, c, work, workBase, workLen);</span><br><span class="line">        <span class="comment">// 切分子数组的最小长度</span></span><br><span class="line">        <span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// Identify next run</span></span><br><span class="line">            <span class="comment">// a[lo]开始已经排好序的长度</span></span><br><span class="line">            <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">            <span class="comment">// 切分子数组，如果剩余长度不足最小长度，就只排序剩余长度的子数组。</span></span><br><span class="line">            <span class="comment">// 为什么minRun会被解释成minimum length呢？当nRemaining &lt;= minRun时，子数组长度就是nRemaining，说明minRun不是长度的下限，而是上限。</span></span><br><span class="line">            <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">                <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">                <span class="comment">// 对切分出的a[lo, lo+force]片段执行二分插入排序，从a[lo+runLen]元素开始执行插入</span></span><br><span class="line">                binarySort(a, lo, lo + force, lo + runLen, c);</span><br><span class="line">                runLen = force;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">            <span class="comment">// 记录当前子数组的run信息</span></span><br><span class="line">            ts.pushRun(lo, runLen);</span><br><span class="line">            <span class="comment">// 每生成一个run后，尝试做归并</span></span><br><span class="line">            ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Advance to find next run</span></span><br><span class="line">            <span class="comment">// 把lo后移到下个待切分的子数组头部</span></span><br><span class="line">            lo += runLen;</span><br><span class="line">            nRemaining -= runLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">        <span class="comment">// 所有切分都完成后，lo一定等于hi</span></span><br><span class="line">        <span class="keyword">assert</span> lo == hi;</span><br><span class="line">        <span class="comment">// 做最终的归并</span></span><br><span class="line">        ts.mergeForceCollapse();</span><br><span class="line">        <span class="comment">// 归并完成后只有一个run</span></span><br><span class="line">        <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sorts the specified portion of the specified array using a binary</span></span><br><span class="line"><span class="comment">     * insertion sort.  This is the best method for sorting small numbers</span></span><br><span class="line"><span class="comment">     * of elements.  It requires O(n log n) compares, but O(n^2) data</span></span><br><span class="line"><span class="comment">     * movement (worst case).</span></span><br><span class="line"><span class="comment">     * 二分插入排序，对于小片段排序是最优算法</span></span><br><span class="line"><span class="comment">     * 在调用binarySort前已经调用过countRunAndMakeAscending，确保[lo, start)的片段已经排好序了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the initial part of the specified range is already sorted,</span></span><br><span class="line"><span class="comment">     * this method can take advantage of it: the method assumes that the</span></span><br><span class="line"><span class="comment">     * elements from index &#123;<span class="doctag">@code</span> lo&#125;, inclusive, to &#123;<span class="doctag">@code</span> start&#125;,</span></span><br><span class="line"><span class="comment">     * exclusive are already sorted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array in which a range is to be sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lo the index of the first element in the range to be sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hi the index after the last element in the range to be sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start the index of the first element in the range that is</span></span><br><span class="line"><span class="comment">     *        not already known to be sorted (&#123;<span class="doctag">@code</span> lo &lt;= start &lt;= hi&#125;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c comparator to used for the sort</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 屏蔽与switch陈述式中遗漏break相关的警告</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"fallthrough"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 感觉这种assert毫无意义</span></span><br><span class="line">        <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">        <span class="keyword">if</span> (start == lo)</span><br><span class="line">            start++;</span><br><span class="line">        <span class="comment">//从start开始，逐个进行插入，start是递增的</span></span><br><span class="line">        <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">            <span class="comment">// pivot是当前待插入的元素</span></span><br><span class="line">            T pivot = a[start];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">            <span class="comment">// a[lo, start)片段是排好序的，a[start]是待排序的，所以每一轮的插入实际就是把a[start]插入到a[lo, start)中，插入的结果就是a[lo, start]是排好序的，因为start是循环变量，所以最后一轮插入完成后，排好序的a[lo, start]就是a[lo, hi]</span></span><br><span class="line">            <span class="comment">// 在调用binarySort前确定a[lo, start)排好序，就省掉了a[lo+1]到a[start-1]这些元素的插入操作，对于有很多有序片段的数组排序效率很高</span></span><br><span class="line">            <span class="keyword">int</span> left = lo;</span><br><span class="line">            <span class="keyword">int</span> right = start;</span><br><span class="line">            <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Invariants:</span></span><br><span class="line"><span class="comment">             *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">             *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 二分查找确定插入位置</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(pivot, a[mid]) &lt; <span class="number">0</span>)</span><br><span class="line">                    right = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> left == right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * The invariants still hold: pivot &gt;= all in [lo, left) and</span></span><br><span class="line"><span class="comment">             * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span></span><br><span class="line"><span class="comment">             * that if there are elements equal to pivot, left points to the</span></span><br><span class="line"><span class="comment">             * first slot after them -- that's why this sort is stable.</span></span><br><span class="line"><span class="comment">             * Slide elements over to make room for pivot.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 插入位置是left，所以包含a[left]在内的后面所有元素都要后移一位</span></span><br><span class="line">            <span class="keyword">int</span> n = start - left;  <span class="comment">// The number of elements to move</span></span><br><span class="line">            <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">            <span class="comment">// 一旦case匹配，会无条件执行后面所有case直到遇到break，所以case2和case1要么都执行要么都不执行</span></span><br><span class="line">            <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">                <span class="comment">// 要移动的元素小于等于2个，直接用赋值方式移动</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 要移动的元素大于2个，用arraycopy把a[left, start-1]写到a[left+1, start]，直接复制内存</span></span><br><span class="line">                <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入pivot</span></span><br><span class="line">            a[left] = pivot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the length of the run beginning at the specified position in</span></span><br><span class="line"><span class="comment">     * the specified array and reverses the run if it is descending (ensuring</span></span><br><span class="line"><span class="comment">     * that the run will always be ascending when the method returns).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A run is the longest ascending sequence with:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    a[lo] &lt;= a[lo + 1] &lt;= a[lo + 2] &lt;= ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * or the longest descending sequence with:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    a[lo] &gt;  a[lo + 1] &gt;  a[lo + 2] &gt;  ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For its intended use in a stable mergesort, the strictness of the</span></span><br><span class="line"><span class="comment">     * definition of "descending" is needed so that the call can safely</span></span><br><span class="line"><span class="comment">     * reverse a descending sequence without violating stability.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array in which a run is to be counted and possibly reversed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lo index of the first element in the run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hi index after the last element that may be contained in the run.</span></span><br><span class="line"><span class="comment">              It is required that &#123;<span class="doctag">@code</span> lo &lt; hi&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the comparator to used for the sort</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the length of the run beginning at the specified position in</span></span><br><span class="line"><span class="comment">     *          the specified array</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 返回从a[lo]开始的最长有序连续片段的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">        <span class="comment">// hi-lo&lt;2 的情况在调用countRunAndMakeAscending前已经判断过了，这里没必要</span></span><br><span class="line">        <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// Descending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">            <span class="comment">// 默认的排序结果是递增，所以如果从a[lo]开始是递减的，要把最长递减片段反转</span></span><br><span class="line">            <span class="comment">// 因为runHi++了，所以反转的范围是[lo, runHi)</span></span><br><span class="line">            reverseRange(a, lo, runHi);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// Ascending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> runHi - lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the specified range of the specified array.</span></span><br><span class="line"><span class="comment">     * 反转数组a中[lo, hi)的片段，因为调用reverseRange前hi多++了一次，所以反转不包含a[hi]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array in which a range is to be reversed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lo the index of the first element in the range to be reversed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hi the index after the last element in the range to be reversed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseRange</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        hi--;</span><br><span class="line">        <span class="comment">// 反转过程就是逐层交换两端的值</span></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            Object t = a[lo];</span><br><span class="line">            a[lo++] = a[hi];</span><br><span class="line">            a[hi--] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the minimum acceptable run length for an array of the specified</span></span><br><span class="line"><span class="comment">     * length. Natural runs shorter than this will be extended with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #binarySort&#125;.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 根据待排序的元素数量，返回参与归并的子数组的最小长度，也就是执行二分插入排序的子数组的最小长度。因为二分插入排序适合小片段排序，所以对于长的数组，要拆分成多个子数组，分别执行二分插入排序，最后再归并</span></span><br><span class="line"><span class="comment">     * 调用minRunLength前已经判断过nRemaining &lt; MIN_MERGE的情况，所以这里的n一定是大于等于MIN_MERGE的。如果n是2的幂次，返回的就是MIN_MERGE/2，否则返回的是[MIN_MERGE/2, MIN_MERGE]内的一个值</span></span><br><span class="line"><span class="comment">     * Roughly speaking, the computation is:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  If n &lt; MIN_MERGE, return n (it's too small to bother with fancy stuff).</span></span><br><span class="line"><span class="comment">     *  Else if n is an exact power of 2, return MIN_MERGE/2.</span></span><br><span class="line"><span class="comment">     *  Else return an int k, MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE, such that n/k</span></span><br><span class="line"><span class="comment">     *   is close to, but strictly less than, an exact power of 2.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For the rationale, see listsort.txt.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n the length of the array to be sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the length of the minimum run to be merged</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minRunLength</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> n &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;      <span class="comment">// Becomes 1 if any 1 bits are shifted off</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt;= MIN_MERGE) &#123;</span><br><span class="line">            r |= (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pushes the specified run onto the pending-run stack.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runBase index of the first element in the run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runLen  the number of elements in the run</span></span><br><span class="line"><span class="comment">     * stack不能扩容，所以这里会有越界的风险</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushRun</span><span class="params">(<span class="keyword">int</span> runBase, <span class="keyword">int</span> runLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runBase[stackSize] = runBase;</span><br><span class="line">        <span class="keyword">this</span>.runLen[stackSize] = runLen;</span><br><span class="line">        stackSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Examines the stack of runs waiting to be merged and merges adjacent runs</span></span><br><span class="line"><span class="comment">     * until the stack invariants are reestablished:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     1. runLen[i - 3] &gt; runLen[i - 2] + runLen[i - 1]</span></span><br><span class="line"><span class="comment">     *     2. runLen[i - 2] &gt; runLen[i - 1]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method is called each time a new run is pushed onto the stack,</span></span><br><span class="line"><span class="comment">     * so the invariants are guaranteed to hold for i &lt; stackSize upon</span></span><br><span class="line"><span class="comment">     * entry to the method.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 每次生成一个新的run后，都要尝试做一次归并，让stack中的run序列满足上面两个式子，大概意思就是保证越靠前的run长度越长。因为归并排序的最优情况就是先归并短序列，再归并长序列，对于这里的stack，最终的归并是从后往前按顺序归并的，如果run的分布长短交错，就会经常遇到一个长序列和一个短序列做归并，效率非常低，所以每生成一个run后都要尝试做归并，尽量把相邻的短序列提早归并掉，来保证最终做归并时待归并的序列越来越长。</span></span><br><span class="line"><span class="comment">     * 因为每次插入新的run后，stackSize最后都加一，所以最后一个run的下标是stackSize-1，从后往前归并时先归并下标是stackSize-2和stackSize-1的两个run，也就是调用mergeAt(stackSize-2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeCollapse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n-<span class="number">1</span>] &lt;= runLen[n] + runLen[n+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>])</span><br><span class="line">                    n--;</span><br><span class="line">                mergeAt(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runLen[n] &lt;= runLen[n + <span class="number">1</span>]) &#123;</span><br><span class="line">                mergeAt(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// Invariant is established</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merges all runs on the stack until only one remains.  This method is</span></span><br><span class="line"><span class="comment">     * called once, to complete the sort.</span></span><br><span class="line"><span class="comment">     * 最终的归并，在stack中从后往前按顺序归并所有的run</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeForceCollapse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>])</span><br><span class="line">                n--;</span><br><span class="line">            mergeAt(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merges the two runs at stack indices i and i+1.  Run i must be</span></span><br><span class="line"><span class="comment">     * the penultimate or antepenultimate run on the stack.  In other words,</span></span><br><span class="line"><span class="comment">     * i must be equal to stackSize-2 or stackSize-3.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 归并下标是i和i+1的两个run，要保证i是stackSize-2或stackSize-3，也就是保证归并的两个run在stack的尾部，在调用mergeCollapse时可能会跳过最后一个run，归并倒数第二个和第三个run，所以i也可以是stackSize-3。因为每次归并完stackSize都会减小，所以i和stackSize的关系会始终如此。</span></span><br><span class="line"><span class="comment">     * 归并的结果就是两个子数组原地排好序，同时在stack中两个run合并成一个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i stack index of the first of the two runs to merge</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> stackSize &gt;= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">assert</span> i &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> i == stackSize - <span class="number">2</span> || i == stackSize - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> base1 = runBase[i];</span><br><span class="line">        <span class="keyword">int</span> len1 = runLen[i];</span><br><span class="line">        <span class="keyword">int</span> base2 = runBase[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len2 = runLen[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 为什么要加一堆assert，debug忘删了？</span></span><br><span class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> base1 + len1 == base2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Record the length of the combined runs; if i is the 3rd-last</span></span><br><span class="line"><span class="comment">         * run now, also slide over the last run (which isn't involved</span></span><br><span class="line"><span class="comment">         * in this merge).  The current run (i+1) goes away in any case.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 归并之前，先把runBase、runLen、stackSize更新到归并后的结果，反正当前的值已经保存在临时变量中了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        runLen[i] = len1 + len2;</span><br><span class="line">        <span class="keyword">if</span> (i == stackSize - <span class="number">3</span>) &#123;</span><br><span class="line">            runBase[i + <span class="number">1</span>] = runBase[i + <span class="number">2</span>];</span><br><span class="line">            runLen[i + <span class="number">1</span>] = runLen[i + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        stackSize--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Find where the first element of run2 goes in run1. Prior elements</span></span><br><span class="line"><span class="comment">         * in run1 can be ignored (because they're already in place).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 查找run2的第一个元素a[base2]在run1中的插入位置，有相同元素时插入位置靠后</span></span><br><span class="line">        <span class="keyword">int</span> k = gallopRight(a[base2], a, base1, len1, <span class="number">0</span>, c);</span><br><span class="line">        <span class="keyword">assert</span> k &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// run2的第一个元素插入到run1的第k个位置，所以归并后a[base1, base1+k)一定在开头，不需要参与归并的过程，直接略过</span></span><br><span class="line">        <span class="comment">// 之所以有相同元素时插入位置靠后，就是保证略过的元素尽量多，提高效率</span></span><br><span class="line">        base1 += k;</span><br><span class="line">        len1 -= k;</span><br><span class="line">        <span class="comment">// 如果略过了整个run1，说明排序的结果就是整个run2都在run1的后面，已经排好了，不需要再执行归并</span></span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Find where the last element of run1 goes in run2. Subsequent elements</span></span><br><span class="line"><span class="comment">         * in run2 can be ignored (because they're already in place).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 查找run1的最后一个元素a[base1 + len1 - 1]在run2中的插入位置，有相同元素时插入位置靠前</span></span><br><span class="line">        len2 = gallopLeft(a[base1 + len1 - <span class="number">1</span>], a, base2, len2, len2 - <span class="number">1</span>, c);</span><br><span class="line">        <span class="comment">// run1的最后一个元素插入到run2的第len2个位置，所以归并后a(base2+len2, base2+oldlen2]一定在末尾，不需要参与归并的过程，直接略过</span></span><br><span class="line">        <span class="comment">// 之所以有相同元素时插入位置靠前，也是保证略过的元素尽量多</span></span><br><span class="line">        <span class="keyword">assert</span> len2 &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge remaining runs, using tmp array with min(len1, len2) elements</span></span><br><span class="line">        <span class="comment">// run1和run2挨着，要想原地排序就一定要把其中一个run放入临时数组，空出一些位置来存放排好序的元素，否则就需要各种复杂的原地交换操作。</span></span><br><span class="line">        <span class="comment">// 为了节省空间，选择把run1和run2中较短的一个放入临时数组。如果run1放入临时数组，空出的位置就在前面，所以mergeLo的归并顺序就是从base1往后按从小到大的顺序存放归并的元素。如果run2放入临时数组，空出的位置就在后面，所以mergeHi的归并顺序就是从base2+len2往前按从大到小的顺序存放归并的元素</span></span><br><span class="line">        <span class="keyword">if</span> (len1 &lt;= len2)</span><br><span class="line">            mergeLo(base1, len1, base2, len2);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mergeHi(base1, len1, base2, len2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Locates the position at which to insert the specified key into the</span></span><br><span class="line"><span class="comment">     * specified sorted range; if the range contains an element equal to key,</span></span><br><span class="line"><span class="comment">     * returns the index of the leftmost equal element.</span></span><br><span class="line"><span class="comment">     * 把key插入到base和len对应的run中，返回插入位置。</span></span><br><span class="line"><span class="comment">     * 如果遇到与key相同的元素，就会插到相同元素的前面，因为判定条件中左侧是严格大于，右侧是小于等于</span></span><br><span class="line"><span class="comment">     * hint是开始查找的位置，是子数组从0开始的下标，0 &lt;= hint &lt; n，所以是从a[base + hint]开始比较</span></span><br><span class="line"><span class="comment">     * 返回值是子数组从0开始的下标，而不是原数组中的下标</span></span><br><span class="line"><span class="comment">     * 为什么不直接二分查找呢？效率会差很多？</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key whose insertion point to search for</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array in which to search</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base the index of the first element in the range</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len the length of the range; must be &gt; 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hint the index at which to begin the search, 0 &lt;= hint &lt; n.</span></span><br><span class="line"><span class="comment">     *     The closer hint is to the result, the faster this method will run.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the comparator used to order the range, and to search</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt; key &lt;= a[b + k],</span></span><br><span class="line"><span class="comment">     *    pretending that a[b - 1] is minus infinity and a[b + n] is infinity.</span></span><br><span class="line"><span class="comment">     *    In other words, key belongs at index b + k; or in other words,</span></span><br><span class="line"><span class="comment">     *    the first k elements of a should precede key, and the last n - k</span></span><br><span class="line"><span class="comment">     *    should follow it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">gallopLeft</span><span class="params">(T key, T[] a, <span class="keyword">int</span> base, <span class="keyword">int</span> len, <span class="keyword">int</span> hint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> len &gt; <span class="number">0</span> &amp;&amp; hint &gt;= <span class="number">0</span> &amp;&amp; hint &lt; len;</span><br><span class="line">        <span class="keyword">int</span> lastOfs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ofs = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// key &gt; a[base + hint]</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(key, a[base + hint]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Gallop right until a[base+hint+lastOfs] &lt; key &lt;= a[base+hint+ofs]</span></span><br><span class="line">            <span class="keyword">int</span> maxOfs = len - hint;</span><br><span class="line">            <span class="comment">// 从a[base+hint+1]开始向右遍历，直到 key &lt;= a[base+hint+ofs]，lastOfs是上一轮迭代的ofs，所以就有a[base+hint+lastOfs] &lt; key &lt;= a[base+hint+ofs]</span></span><br><span class="line">            <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint + ofs]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lastOfs = ofs;</span><br><span class="line">                <span class="comment">// 偏移ofs是按照1、3、7、15这样指数级增长的，因为a[base, base+len]已经是有序的了，所以不怕步子太大漏掉</span></span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果ofs整型溢出了，就直接设为maxOfs，把右边界拉到a[base+hint+len]</span></span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>)   <span class="comment">// int overflow</span></span><br><span class="line">                    ofs = maxOfs;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ofs &gt; maxOfs)</span><br><span class="line">                ofs = maxOfs;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make offsets relative to base</span></span><br><span class="line">            <span class="comment">// ofs是从hint开始算的偏移量，这里加上hint以后，ofs就变成子数组的下标了，后面就不需要hint了</span></span><br><span class="line">            lastOfs += hint;</span><br><span class="line">            ofs += hint;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// key &lt;= a[base + hint]</span></span><br><span class="line">            <span class="comment">// Gallop left until a[base+hint-ofs] &lt; key &lt;= a[base+hint-lastOfs]</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> maxOfs = hint + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 从a[base+hint-1]开始向左遍历，直到 key &gt; a[base+hint-ofs]，lastOfs是上一轮迭代的ofs，所以就有a[base+hint-ofs] &lt; key &lt;= a[base+hint-lastOfs]</span></span><br><span class="line">            <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint - ofs]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                lastOfs = ofs;</span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>)   <span class="comment">// int overflow</span></span><br><span class="line">                    ofs = maxOfs;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ofs &gt; maxOfs)</span><br><span class="line">                ofs = maxOfs;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make offsets relative to base</span></span><br><span class="line">            <span class="comment">// 因为是向左遍历，lastOfs应该在ofs的右边，这里为了和上面的结果保持一致，交换了lastOfs和ofs，让lastOfs在ofs的左边</span></span><br><span class="line">            <span class="keyword">int</span> tmp = lastOfs;</span><br><span class="line">            lastOfs = hint - ofs;</span><br><span class="line">            ofs = hint - tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lastOfs不可能是负数吧？</span></span><br><span class="line">        <span class="keyword">assert</span> -<span class="number">1</span> &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Now a[base+lastOfs] &lt; key &lt;= a[base+ofs], so key belongs somewhere</span></span><br><span class="line"><span class="comment">         * to the right of lastOfs but no farther right than ofs.  Do a binary</span></span><br><span class="line"><span class="comment">         * search, with invariant a[base + lastOfs - 1] &lt; key &lt;= a[base + ofs].</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 到此已经确定了a[base+lastOfs] &lt; key &lt;= a[base+ofs]，在这个范围里进行二分查找确定key的插入位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        lastOfs++;</span><br><span class="line">        <span class="keyword">while</span> (lastOfs &lt; ofs) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c.compare(key, a[base + m]) &gt; <span class="number">0</span>)</span><br><span class="line">                lastOfs = m + <span class="number">1</span>;  <span class="comment">// a[base + m] &lt; key</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ofs = m;          <span class="comment">// key &lt;= a[base + m]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> lastOfs == ofs;    <span class="comment">// so a[base + ofs - 1] &lt; key &lt;= a[base + ofs]</span></span><br><span class="line">        <span class="keyword">return</span> ofs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Like gallopLeft, except that if the range contains an element equal to</span></span><br><span class="line"><span class="comment">     * key, gallopRight returns the index after the rightmost equal element.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 和gallopLeft差不多，区别是如果遇到与key相同的元素，就会插到相同元素的后面，因为判定条件中左侧是大于等于，右侧是严格小于</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key whose insertion point to search for</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array in which to search</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base the index of the first element in the range</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len the length of the range; must be &gt; 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hint the index at which to begin the search, 0 &lt;= hint &lt; n.</span></span><br><span class="line"><span class="comment">     *     The closer hint is to the result, the faster this method will run.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the comparator used to order the range, and to search</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the int k,  0 &lt;= k &lt;= n such that a[b + k - 1] &lt;= key &lt; a[b + k]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">gallopRight</span><span class="params">(T key, T[] a, <span class="keyword">int</span> base, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> hint, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> len &gt; <span class="number">0</span> &amp;&amp; hint &gt;= <span class="number">0</span> &amp;&amp; hint &lt; len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ofs = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lastOfs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c.compare(key, a[base + hint]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Gallop left until a[b+hint - ofs] &lt;= key &lt; a[b+hint - lastOfs]</span></span><br><span class="line">            <span class="keyword">int</span> maxOfs = hint + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint - ofs]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                lastOfs = ofs;</span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>)   <span class="comment">// int overflow</span></span><br><span class="line">                    ofs = maxOfs;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ofs &gt; maxOfs)</span><br><span class="line">                ofs = maxOfs;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make offsets relative to b</span></span><br><span class="line">            <span class="keyword">int</span> tmp = lastOfs;</span><br><span class="line">            lastOfs = hint - ofs;</span><br><span class="line">            ofs = hint - tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// a[b + hint] &lt;= key</span></span><br><span class="line">            <span class="comment">// Gallop right until a[b+hint + lastOfs] &lt;= key &lt; a[b+hint + ofs]</span></span><br><span class="line">            <span class="keyword">int</span> maxOfs = len - hint;</span><br><span class="line">            <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; c.compare(key, a[base + hint + ofs]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                lastOfs = ofs;</span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>)   <span class="comment">// int overflow</span></span><br><span class="line">                    ofs = maxOfs;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ofs &gt; maxOfs)</span><br><span class="line">                ofs = maxOfs;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make offsets relative to b</span></span><br><span class="line">            lastOfs += hint;</span><br><span class="line">            ofs += hint;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> -<span class="number">1</span> &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Now a[b + lastOfs] &lt;= key &lt; a[b + ofs], so key belongs somewhere to</span></span><br><span class="line"><span class="comment">         * the right of lastOfs but no farther right than ofs.  Do a binary</span></span><br><span class="line"><span class="comment">         * search, with invariant a[b + lastOfs - 1] &lt;= key &lt; a[b + ofs].</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        lastOfs++;</span><br><span class="line">        <span class="keyword">while</span> (lastOfs &lt; ofs) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c.compare(key, a[base + m]) &lt; <span class="number">0</span>)</span><br><span class="line">                ofs = m;          <span class="comment">// key &lt; a[b + m]</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lastOfs = m + <span class="number">1</span>;  <span class="comment">// a[b + m] &lt;= key</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> lastOfs == ofs;    <span class="comment">// so a[b + ofs - 1] &lt;= key &lt; a[b + ofs]</span></span><br><span class="line">        <span class="keyword">return</span> ofs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merges two adjacent runs in place, in a stable fashion.  The first</span></span><br><span class="line"><span class="comment">     * element of the first run must be greater than the first element of the</span></span><br><span class="line"><span class="comment">     * second run (a[base1] &gt; a[base2]), and the last element of the first run</span></span><br><span class="line"><span class="comment">     * (a[base1 + len1-1]) must be greater than all elements of the second run.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For performance, this method should be called only when len1 &lt;= len2;</span></span><br><span class="line"><span class="comment">     * its twin, mergeHi should be called if len1 &gt;= len2.  (Either method</span></span><br><span class="line"><span class="comment">     * may be called if len1 == len2.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base1 index of first element in first run to be merged</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len1  length of first run to be merged (must be &gt; 0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base2 index of first element in second run to be merged</span></span><br><span class="line"><span class="comment">     *        (must be aBase + aLen)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len2  length of second run to be merged (must be &gt; 0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeLo</span><span class="params">(<span class="keyword">int</span> base1, <span class="keyword">int</span> len1, <span class="keyword">int</span> base2, <span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span> &amp;&amp; base1 + len1 == base2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Copy first run into temp array</span></span><br><span class="line">        T[] a = <span class="keyword">this</span>.a; <span class="comment">// For performance</span></span><br><span class="line">        <span class="comment">// 检查临时数组的长度，必要时扩容</span></span><br><span class="line">        T[] tmp = ensureCapacity(len1);</span><br><span class="line">        <span class="keyword">int</span> cursor1 = tmpBase; <span class="comment">// Indexes into tmp array</span></span><br><span class="line">        <span class="keyword">int</span> cursor2 = base2;   <span class="comment">// Indexes int a</span></span><br><span class="line">        <span class="keyword">int</span> dest = base1;      <span class="comment">// Indexes int a</span></span><br><span class="line">        <span class="comment">// 把run1写入临时数组</span></span><br><span class="line">        System.arraycopy(a, base1, tmp, cursor1, len1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move first element of second run and deal with degenerate cases</span></span><br><span class="line">        <span class="comment">// 因为run1前面一部分被略过了，剩下的部分里一定是run2的第一个元素在开头</span></span><br><span class="line">        a[dest++] = a[cursor2++];</span><br><span class="line">        <span class="comment">// 如果run2只有一个元素，插入到头部，剩下的run1直接后移一位，排序就完成了</span></span><br><span class="line">        <span class="keyword">if</span> (--len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(tmp, cursor1, a, dest, len1);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为run2后面一部分被略过了，剩下的部分里一定是run1的最后一个元素在末尾</span></span><br><span class="line">        <span class="comment">// 如果run1只有一个元素，插入到末尾，剩下的run2直接前移一位，排序就完成了</span></span><br><span class="line">        <span class="comment">// 直接return了，所以len1归不归零都无所谓</span></span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;</span><br><span class="line">            System.arraycopy(a, cursor2, a, dest, len2);</span><br><span class="line">            a[dest + len2] = tmp[cursor1]; <span class="comment">// Last elt of run 1 to end of merge</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> T&gt; c = <span class="keyword">this</span>.c;  <span class="comment">// Use local variable for performance</span></span><br><span class="line">        <span class="comment">// 用新的变量，本次对阈值minGallop的修改不会影响下次归并</span></span><br><span class="line">        <span class="keyword">int</span> minGallop = <span class="keyword">this</span>.minGallop;    <span class="comment">//  "    "       "     "      "</span></span><br><span class="line">    outer:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = <span class="number">0</span>; <span class="comment">// run1连续比run2小多少次</span></span><br><span class="line">            <span class="keyword">int</span> count2 = <span class="number">0</span>; <span class="comment">// run2连续比run1小多少次</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Do the straightforward thing until (if ever) one run starts</span></span><br><span class="line"><span class="comment">             * winning consistently.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 正常的归并操作，但是如果其中一个run的头部连续minGallop次都比另一个run小，就先中止当前的归并，退出循环做一些优化</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(a[cursor2], tmp[cursor1]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    a[dest++] = a[cursor2++];</span><br><span class="line">                    count2++;</span><br><span class="line">                    count1 = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//如果其中一个run空了，表示归并完成，退出最外层循环</span></span><br><span class="line">                    <span class="keyword">if</span> (--len2 == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[dest++] = tmp[cursor1++];</span><br><span class="line">                    count1++;</span><br><span class="line">                    count2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--len1 == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// count1和count2总有一个是0，或运算得到的就是不为0的那个</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((count1 | count2) &lt; minGallop);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * One run is winning so consistently that galloping may be a</span></span><br><span class="line"><span class="comment">             * huge win. So try that, and continue galloping until (if ever)</span></span><br><span class="line"><span class="comment">             * neither run appears to be winning consistently anymore.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 如果runA的头部连续minGallop次比runB小，那么很可能其后面很长一部分都比runB的头部小。这时逐个元素进行归并效率就比较低。所以调用gallop方法，找到runB的头部在runA中插入的位置，使用arraycopy直接把runA中该位置之前的片段一次性复制到a中排好序的位置上，比归并的效率高</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">                count1 = gallopRight(a[cursor2], tmp, cursor1, len1, <span class="number">0</span>, c);</span><br><span class="line">                <span class="keyword">if</span> (count1 != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.arraycopy(tmp, cursor1, a, dest, count1);</span><br><span class="line">                    dest += count1;</span><br><span class="line">                    cursor1 += count1;</span><br><span class="line">                    len1 -= count1;</span><br><span class="line">                    <span class="comment">// run1最后一个元素一定是放在末尾，只剩一个元素就不需要归并了，如果run1空了，说明出了bug</span></span><br><span class="line">                    <span class="keyword">if</span> (len1 &lt;= <span class="number">1</span>) <span class="comment">// len1 == 1 || len1 == 0</span></span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                a[dest++] = a[cursor2++];</span><br><span class="line">                <span class="keyword">if</span> (--len2 == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                <span class="comment">// 找完run1的头部序列，顺便找run2的头部序列，因为如果run1头部很多元素比run2小，在除去这些元素后，就很有可能run2的头部有很多元素比run1大。</span></span><br><span class="line">                <span class="comment">// 又不是找尾部序列，为什么要调用gallopLeft？</span></span><br><span class="line">                count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, <span class="number">0</span>, c);</span><br><span class="line">                <span class="keyword">if</span> (count2 != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.arraycopy(a, cursor2, a, dest, count2);</span><br><span class="line">                    dest += count2;</span><br><span class="line">                    cursor2 += count2;</span><br><span class="line">                    len2 -= count2;</span><br><span class="line">                    <span class="keyword">if</span> (len2 == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                a[dest++] = tmp[cursor1++];</span><br><span class="line">                <span class="keyword">if</span> (--len1 == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                <span class="comment">// 动态调整阈值，可能是根据经验觉得会有效吧</span></span><br><span class="line">                minGallop--;</span><br><span class="line">            <span class="comment">// 如果连续性还是很大，就继续调用gallop替代归并</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span><br><span class="line">            <span class="keyword">if</span> (minGallop &lt; <span class="number">0</span>)</span><br><span class="line">                minGallop = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 跳出循环，说明连续性没那么高了，可以适当提高阈值</span></span><br><span class="line">            minGallop += <span class="number">2</span>;  <span class="comment">// Penalize for leaving gallop mode</span></span><br><span class="line">        &#125;  <span class="comment">// End of "outer" loop</span></span><br><span class="line">        <span class="keyword">this</span>.minGallop = minGallop &lt; <span class="number">1</span> ? <span class="number">1</span> : minGallop;  <span class="comment">// Write back to field</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳出循环只有两种情况，要么run1只剩一个元素，要么run2空了</span></span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">assert</span> len2 &gt; <span class="number">0</span>;</span><br><span class="line">            System.arraycopy(a, cursor2, a, dest, len2);</span><br><span class="line">            a[dest + len2] = tmp[cursor1]; <span class="comment">//  Last elt of run 1 to end of merge</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// run1最后一个元素一定是放在末尾，如果run1空了，说明出了bug</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Comparison method violates its general contract!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> len2 == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">assert</span> len1 &gt; <span class="number">1</span>;</span><br><span class="line">            System.arraycopy(tmp, cursor1, a, dest, len1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Like mergeLo, except that this method should be called only if</span></span><br><span class="line"><span class="comment">     * len1 &gt;= len2; mergeLo should be called if len1 &lt;= len2.  (Either method</span></span><br><span class="line"><span class="comment">     * may be called if len1 == len2.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base1 index of first element in first run to be merged</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len1  length of first run to be merged (must be &gt; 0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base2 index of first element in second run to be merged</span></span><br><span class="line"><span class="comment">     *        (must be aBase + aLen)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len2  length of second run to be merged (must be &gt; 0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeHi</span><span class="params">(<span class="keyword">int</span> base1, <span class="keyword">int</span> len1, <span class="keyword">int</span> base2, <span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span> &amp;&amp; base1 + len1 == base2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Copy second run into temp array</span></span><br><span class="line">        T[] a = <span class="keyword">this</span>.a; <span class="comment">// For performance</span></span><br><span class="line">        T[] tmp = ensureCapacity(len2);</span><br><span class="line">        <span class="keyword">int</span> tmpBase = <span class="keyword">this</span>.tmpBase;</span><br><span class="line">        System.arraycopy(a, base2, tmp, tmpBase, len2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cursor1 = base1 + len1 - <span class="number">1</span>;  <span class="comment">// Indexes into a</span></span><br><span class="line">        <span class="keyword">int</span> cursor2 = tmpBase + len2 - <span class="number">1</span>; <span class="comment">// Indexes into tmp array</span></span><br><span class="line">        <span class="keyword">int</span> dest = base2 + len2 - <span class="number">1</span>;     <span class="comment">// Indexes into a</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move last element of first run and deal with degenerate cases</span></span><br><span class="line">        a[dest--] = a[cursor1--];</span><br><span class="line">        <span class="keyword">if</span> (--len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(tmp, tmpBase, a, dest - (len2 - <span class="number">1</span>), len2);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">1</span>) &#123;</span><br><span class="line">            dest -= len1;</span><br><span class="line">            cursor1 -= len1;</span><br><span class="line">            System.arraycopy(a, cursor1 + <span class="number">1</span>, a, dest + <span class="number">1</span>, len1);</span><br><span class="line">            a[dest] = tmp[cursor2];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> T&gt; c = <span class="keyword">this</span>.c;  <span class="comment">// Use local variable for performance</span></span><br><span class="line">        <span class="keyword">int</span> minGallop = <span class="keyword">this</span>.minGallop;    <span class="comment">//  "    "       "     "      "</span></span><br><span class="line">    outer:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = <span class="number">0</span>; <span class="comment">// Number of times in a row that first run won</span></span><br><span class="line">            <span class="keyword">int</span> count2 = <span class="number">0</span>; <span class="comment">// Number of times in a row that second run won</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Do the straightforward thing until (if ever) one run</span></span><br><span class="line"><span class="comment">             * appears to win consistently.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(tmp[cursor2], a[cursor1]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    a[dest--] = a[cursor1--];</span><br><span class="line">                    count1++;</span><br><span class="line">                    count2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--len1 == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[dest--] = tmp[cursor2--];</span><br><span class="line">                    count2++;</span><br><span class="line">                    count1 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--len2 == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((count1 | count2) &lt; minGallop);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * One run is winning so consistently that galloping may be a</span></span><br><span class="line"><span class="comment">             * huge win. So try that, and continue galloping until (if ever)</span></span><br><span class="line"><span class="comment">             * neither run appears to be winning consistently anymore.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">1</span>;</span><br><span class="line">                count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - <span class="number">1</span>, c);</span><br><span class="line">                <span class="keyword">if</span> (count1 != <span class="number">0</span>) &#123;</span><br><span class="line">                    dest -= count1;</span><br><span class="line">                    cursor1 -= count1;</span><br><span class="line">                    len1 -= count1;</span><br><span class="line">                    System.arraycopy(a, cursor1 + <span class="number">1</span>, a, dest + <span class="number">1</span>, count1);</span><br><span class="line">                    <span class="keyword">if</span> (len1 == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                a[dest--] = tmp[cursor2--];</span><br><span class="line">                <span class="keyword">if</span> (--len2 == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line"></span><br><span class="line">                count2 = len2 - gallopLeft(a[cursor1], tmp, tmpBase, len2, len2 - <span class="number">1</span>, c);</span><br><span class="line">                <span class="keyword">if</span> (count2 != <span class="number">0</span>) &#123;</span><br><span class="line">                    dest -= count2;</span><br><span class="line">                    cursor2 -= count2;</span><br><span class="line">                    len2 -= count2;</span><br><span class="line">                    System.arraycopy(tmp, cursor2 + <span class="number">1</span>, a, dest + <span class="number">1</span>, count2);</span><br><span class="line">                    <span class="keyword">if</span> (len2 &lt;= <span class="number">1</span>)  <span class="comment">// len2 == 1 || len2 == 0</span></span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                a[dest--] = a[cursor1--];</span><br><span class="line">                <span class="keyword">if</span> (--len1 == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                minGallop--;</span><br><span class="line">            &#125; <span class="keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span><br><span class="line">            <span class="keyword">if</span> (minGallop &lt; <span class="number">0</span>)</span><br><span class="line">                minGallop = <span class="number">0</span>;</span><br><span class="line">            minGallop += <span class="number">2</span>;  <span class="comment">// Penalize for leaving gallop mode</span></span><br><span class="line">        &#125;  <span class="comment">// End of "outer" loop</span></span><br><span class="line">        <span class="keyword">this</span>.minGallop = minGallop &lt; <span class="number">1</span> ? <span class="number">1</span> : minGallop;  <span class="comment">// Write back to field</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">assert</span> len1 &gt; <span class="number">0</span>;</span><br><span class="line">            dest -= len1;</span><br><span class="line">            cursor1 -= len1;</span><br><span class="line">            System.arraycopy(a, cursor1 + <span class="number">1</span>, a, dest + <span class="number">1</span>, len1);</span><br><span class="line">            a[dest] = tmp[cursor2];  <span class="comment">// Move first elt of run2 to front of merge</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Comparison method violates its general contract!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> len1 == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">assert</span> len2 &gt; <span class="number">0</span>;</span><br><span class="line">            System.arraycopy(tmp, tmpBase, a, dest - (len2 - <span class="number">1</span>), len2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensures that the external array tmp has at least the specified</span></span><br><span class="line"><span class="comment">     * number of elements, increasing its size if necessary.  The size</span></span><br><span class="line"><span class="comment">     * increases exponentially to ensure amortized linear time complexity.</span></span><br><span class="line"><span class="comment">     * 保证临时数组tmp能够容纳下minCapacity个元素，不足时扩容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the minimum required capacity of the tmp array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> tmp, whether or not it grew</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] ensureCapacity(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">        <span class="comment">// 只有长度不够才需要扩容，足够时tmp不需要修改</span></span><br><span class="line">        <span class="keyword">if</span> (tmpLen &lt; minCapacity) &#123;</span><br><span class="line">            <span class="comment">// Compute smallest power of 2 &gt; minCapacity</span></span><br><span class="line">            <span class="comment">// 计算最小的大于minCapacity的2的幂，花里胡哨的位运算，相当于把minCapacity最高位的1后面全置为1，最后newSize++，让最高位的1左移一位，后面全变成0，就得到了2的幂。因为java的int是32位，所以到&gt;&gt; 16就截止了。</span></span><br><span class="line">            <span class="keyword">int</span> newSize = minCapacity;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">2</span>;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">4</span>;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">8</span>;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">16</span>;</span><br><span class="line">            newSize++;</span><br><span class="line">            <span class="comment">// 小于0是溢出了？</span></span><br><span class="line">            <span class="keyword">if</span> (newSize &lt; <span class="number">0</span>) <span class="comment">// Not bloody likely!</span></span><br><span class="line">                newSize = minCapacity;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// minCapacity是归并的两个子数组里较短的子数组的长度，所以不可能超过a.length/2</span></span><br><span class="line">                newSize = Math.min(newSize, a.length &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据扩容后的长度重新创建临时数组</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"UnnecessaryLocalVariable"</span>&#125;)</span><br><span class="line">            T[] newArray = (T[])java.lang.reflect.Array.newInstance</span><br><span class="line">                (a.getClass().getComponentType(), newSize);</span><br><span class="line">            tmp = newArray;</span><br><span class="line">            tmpLen = newSize;</span><br><span class="line">            tmpBase = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为什么tmpLen和tmpBase可以直接修改，tmp要作为返回值返回，因为tmp是数组？？？</span></span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:wkx1996@foxmail.com">w.k.x.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shivakasu.cn/2020/07/23/arg4/">https://shivakasu.cn/2020/07/23/arg4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shivakasu.cn" target="_blank">SHIVAKASU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg" data-sites="facebook,twitter,wechat,weibo,qq,qzone,douban,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://file.shivakasu.cn/4a84dcfb31806db98b2a/wechat.png" alt="微信" onclick="window.open('https://file.shivakasu.cn/4a84dcfb31806db98b2a/wechat.png')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://file.shivakasu.cn/982f781ef31cbc46968b/alipay.jpg" alt="支付宝" onclick="window.open('https://file.shivakasu.cn/982f781ef31cbc46968b/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/06/29/phi4/"><img class="next-cover" data-src="http://file.shivakasu.cn/11b6eb34f8286c1cd02c/phi0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">叶秀山版《西方哲学史》笔记之第二卷：古希腊罗马哲学</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/01/11/arg1/" title="字符串匹配算法总结"><img class="relatedPosts_cover" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-11</div><div class="relatedPosts_title">字符串匹配算法总结</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/15/arg2/" title="Manacher 算法"><img class="relatedPosts_cover" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-15</div><div class="relatedPosts_title">Manacher 算法</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/10/arg0/" title="《程序员代码面试指南》"><img class="relatedPosts_cover" data-src="http://file.shivakasu.cn/5f37cb297aa622ca620e/interview0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-10</div><div class="relatedPosts_title">《程序员代码面试指南》</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/28/blockchain0/" title="区块链技术与应用笔记"><img class="relatedPosts_cover" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-28</div><div class="relatedPosts_title">区块链技术与应用笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/16/arg3/" title="旅行商问题与最优解搜索算法"><img class="relatedPosts_cover" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-16</div><div class="relatedPosts_title">旅行商问题与最优解搜索算法</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/03/leetcode/" title="leetcode (更新中)"><img class="relatedPosts_cover" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-03</div><div class="relatedPosts_title">leetcode (更新中)</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'qIfwEiuSjlc5vyminB1rx2qX-gzGzoHsz',
  appKey: 'erfVXuW3AybzbWGqxSGxnBRp',
  placeholder: '来都来了，说点儿什么吧~',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: true,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By w.k.x.</div><div class="framework-info"><span>DrivenBy </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>京ICP备19001969号-1</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
  pangu.autoSpacingPage()
})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>