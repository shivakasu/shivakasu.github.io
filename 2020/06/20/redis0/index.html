<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>redis源码阅读(更新中) | SHIVAKASU</title><meta name="description" content="redis源码阅读(更新中)"><meta name="keywords" content="redis,数据库"><meta name="author" content="w.k.x.,wkx1996@foxmail.com"><meta name="copyright" content="w.k.x."><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="http://file.shivakasu.cn/eb8581b76ec032ab0db8/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="redis源码阅读(更新中)"><meta name="twitter:description" content="redis源码阅读(更新中)"><meta name="twitter:image" content="http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png"><meta property="og:type" content="article"><meta property="og:title" content="redis源码阅读(更新中)"><meta property="og:url" content="http://shivakasu.github.io/2020/06/20/redis0/"><meta property="og:site_name" content="SHIVAKASU"><meta property="og:description" content="redis源码阅读(更新中)"><meta property="og:image" content="http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://shivakasu.github.io/2020/06/20/redis0/"><link rel="next" title="Haskell Programming From First Principles notes (更新中)" href="http://shivakasu.github.io/2020/06/14/haskell0/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QBXC0PXLIT","apiKey":"517431eabeeedb8d3792391b21e8cf20","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="SHIVAKASU" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">SHIVAKASU</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="http://file.shivakasu.cn/cb7049104af4685e7289/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1-概述"><span class="toc_mobile_items-text">1 概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2-数据结构相关"><span class="toc_mobile_items-text">2 数据结构相关</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-1-内存分配"><span class="toc_mobile_items-text">2.1 内存分配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#config-h"><span class="toc_mobile_items-text">config.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#zmalloc-h"><span class="toc_mobile_items-text">zmalloc.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#zmalloc-c"><span class="toc_mobile_items-text">zmalloc.c</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-2-动态字符串"><span class="toc_mobile_items-text">2.2 动态字符串</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sds-h"><span class="toc_mobile_items-text">sds.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sds-c"><span class="toc_mobile_items-text">sds.c</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-3-双端链表"><span class="toc_mobile_items-text">2.3 双端链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#adlist-h"><span class="toc_mobile_items-text">adlist.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#adlist-c"><span class="toc_mobile_items-text">adlist.c</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#3-内存编码结构相关"><span class="toc_mobile_items-text">3 内存编码结构相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#4-数据类型相关"><span class="toc_mobile_items-text">4 数据类型相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#5-单机数据库相关"><span class="toc_mobile_items-text">5 单机数据库相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#6-客户端和服务器端相关"><span class="toc_mobile_items-text">6 客户端和服务器端相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#7-多机数据库相关"><span class="toc_mobile_items-text">7 多机数据库相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#8-测试类文件"><span class="toc_mobile_items-text">8 测试类文件</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#testhelp-h"><span class="toc_mobile_items-text">testhelp.h</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#9-工具类文件"><span class="toc_mobile_items-text">9 工具类文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#10-封装类文件"><span class="toc_mobile_items-text">10 封装类文件</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-text">1 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-数据结构相关"><span class="toc-text">2 数据结构相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-内存分配"><span class="toc-text">2.1 内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#config-h"><span class="toc-text">config.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zmalloc-h"><span class="toc-text">zmalloc.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zmalloc-c"><span class="toc-text">zmalloc.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-动态字符串"><span class="toc-text">2.2 动态字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sds-h"><span class="toc-text">sds.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sds-c"><span class="toc-text">sds.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-双端链表"><span class="toc-text">2.3 双端链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#adlist-h"><span class="toc-text">adlist.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adlist-c"><span class="toc-text">adlist.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-内存编码结构相关"><span class="toc-text">3 内存编码结构相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-数据类型相关"><span class="toc-text">4 数据类型相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-单机数据库相关"><span class="toc-text">5 单机数据库相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-客户端和服务器端相关"><span class="toc-text">6 客户端和服务器端相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-多机数据库相关"><span class="toc-text">7 多机数据库相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-测试类文件"><span class="toc-text">8 测试类文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#testhelp-h"><span class="toc-text">testhelp.h</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-工具类文件"><span class="toc-text">9 工具类文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-封装类文件"><span class="toc-text">10 封装类文件</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png)"><div id="post-info"><div id="post-title"><div class="posttitle">redis源码阅读(更新中)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-06-20<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-06-21</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/">日常专业学习</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.8k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 35 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2020/06/20/redis0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/20/redis0/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul>
<li>redis版本：2.2.15</li>
<li>阅读顺序参考自博文 <a href="https://blog.csdn.net/terence1212/article/details/53541908" target="_blank" rel="noopener">https://blog.csdn.net/terence1212/article/details/53541908</a></li>
</ul>
<h1 id="2-数据结构相关"><a href="#2-数据结构相关" class="headerlink" title="2 数据结构相关"></a>2 数据结构相关</h1><h2 id="2-1-内存分配"><a href="#2-1-内存分配" class="headerlink" title="2.1 内存分配"></a>2.1 内存分配</h2><h3 id="config-h"><a href="#config-h" class="headerlink" title="config.h"></a>config.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;AvailabilityMacros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use tcmalloc's malloc_size() when available.</span></span><br><span class="line"><span class="comment"> * When tcmalloc is used, native OSX malloc_size() may never be used because</span></span><br><span class="line"><span class="comment"> * this expects a different allocation scheme. Therefore, *exclusively* use</span></span><br><span class="line"><span class="comment"> * either tcmalloc or OSX's malloc_size()! */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果系统中存在Google的TC_MALLOC库，redis_malloc_size函数就当做tc_malloc_size函数使用</span></span><br><span class="line"><span class="comment">//tc_malloc比原始的malloc性能好</span></span><br><span class="line"><span class="comment">//redis_malloc_size的功能是获得参数p所指向的内存块的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TC_VERSION_MAJOR &gt;= 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6</span></span><br><span class="line"><span class="comment">//HAVE_MALLOC_SIZE用来标记是否定义了redis_malloc_size函数</span></span><br><span class="line"><span class="comment">//可是为什么不直接检查redis_malloc_size是否存在，还要额外定义一个标记呢？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_malloc_size(p) tc_malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//或者，如果系统是Mac系统，那么redis_malloc_size函数就当做原始的malloc_size函数使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_malloc_size(p) malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define redis_fstat to fstat or fstat64() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) &amp;&amp; !defined(MAC_OS_X_VERSION_10_6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_fstat fstat64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_stat stat64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_fstat fstat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_stat stat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for proc filesystem */</span></span><br><span class="line"><span class="comment">//如果是linux系统，当前文件系统就是procfs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_PROCFS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for task_info() */</span></span><br><span class="line"><span class="comment">//如果是unix系统，就可以使用task_info，macos是基于unix的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_TASKINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for backtrace() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__linux__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_BACKTRACE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for polling API */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(__APPLE__) &amp;&amp; defined(MAC_OS_X_VERSION_10_6)) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__NetBSD__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_KQUEUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define aof_fsync to fdatasync() in Linux and fsync() for all the rest */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fdatasync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fsync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="zmalloc-h"><a href="#zmalloc-h" class="headerlink" title="zmalloc.h"></a>zmalloc.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ZMALLOC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ZMALLOC_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_enable_thread_safeness</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ZMALLOC_H */</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="zmalloc-c"><a href="#zmalloc-c" class="headerlink" title="zmalloc.c"></a>zmalloc.c</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zmalloc - total amount of allocated memory aware version of malloc()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//redis是基于内存的数据库，所以内存管理很重要。</span></span><br><span class="line"><span class="comment">//redis把C语言的内存分配函数封装成zmalloc、zfree等z开头的函数，来屏蔽各底层平台的差异。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果定义了HAVE_MALLOC_SIZE，即定义了redis_malloc_size函数，PREFIX_SIZE就是0</span></span><br><span class="line"><span class="comment">//PREFIX_SIZE用于在分配到的的空间头部存储原本申请空间的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//如果没有定义HAVE_MALLOC_SIZE，且当前系统是Solaris，PREFIX_SIZE就是long long类型的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//否则，PREFIX_SIZE就是size_t的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Explicitly override malloc/free etc when using tcmalloc. */</span></span><br><span class="line"><span class="comment">//如果使用了tcmalloc库，就用tcmalloc库函数替换原始的malloc库函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) tc_malloc(size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) tc_calloc(count,size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) tc_realloc(ptr,size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) tc_free(ptr)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//update_zmalloc_stat_alloc用于在分配内存的时候更新已分配大小</span></span><br><span class="line"><span class="comment">//__n是实际分配到的空间大小，__size是程序原本请求的空间大小</span></span><br><span class="line"><span class="comment">//__size应该是改了代码以后忘记删掉的参数</span></span><br><span class="line"><span class="comment">//使用do-while(0)封装成代码块，防止宏定义展开的时候出问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n,__size) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="comment">//64位系统中，sizeof(long)通常是8</span></span><br><span class="line">    <span class="comment">//malloc分配的内存是8字节对齐的，如果请求分配的内存不是8的倍数，那么malloc就会多分配一点来凑成8的倍数</span></span><br><span class="line">    <span class="comment">//如果_n值不是内存分配单元(sizeof(long))的整数倍，说明当前分配的内存大小有碎片，为了与malloc的实际结果匹配，需要补齐到8的整数倍</span></span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</span><br><span class="line">        <span class="comment">//如果要考虑线程安全，先加锁再修改used_memory</span></span><br><span class="line">        pthread_mutex_lock(&amp;used_memory_mutex);  \</span><br><span class="line">        used_memory += _n; \</span><br><span class="line">        pthread_mutex_unlock(&amp;used_memory_mutex); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        <span class="comment">//不考虑线程安全时，直接修改used_memory</span></span><br><span class="line">        used_memory += _n; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//update_zmalloc_stat_free用于释放已经分配的空间</span></span><br><span class="line"><span class="comment">//__n是待释放的空间大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</span><br><span class="line">        pthread_mutex_lock(&amp;used_memory_mutex);  \</span><br><span class="line">        used_memory -= _n; \</span><br><span class="line">        pthread_mutex_unlock(&amp;used_memory_mutex); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        used_memory -= _n; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配得到的内存大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//是否要考虑线程安全，默认不考虑</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//保证线程安全的锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//oom的错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把错误信息输出到stderr流文件中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    <span class="comment">//刷新缓冲，把stderr中的数据发给错误输出设备</span></span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="comment">//终止当前进程，但不清理任何对象</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 是分配的内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际多申请了PREFIX_SIZE大小的空间</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line">    <span class="comment">// 如果分配失败，调用zmalloc_oom函数打印oom的错误信息，然后退出进程</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">//如果已经定义了redis_malloc_size函数，直接计算ptr的实际大小，然后更新used_memory</span></span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(ptr),size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//否则，先在分配到的空间的第一个字长处保存住原本请求的空间大小size</span></span><br><span class="line">    <span class="comment">//然后只能默认size+PREFIX_SIZE是已分配的大小(大概没有malloc_size算出来的靠谱)，更新used_memory</span></span><br><span class="line">    <span class="comment">//多申请的PREFIX_SIZE空间就是用来存储size的，所以当定义了redis_malloc_size函数时PREFIX_SIZE就是0，因为已经不需要存储size了</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对calloc的封装，更新了used_memory</span></span><br><span class="line"><span class="comment">//调用calloc时，第一个参数固定为1，所以每次只会分配一个size+PREFIX_SIZE大小的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(ptr),size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对realloc的封装，重新分配内存，重置并更新了used_memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = redis_malloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom(size);</span><br><span class="line"></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(newptr),size);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom(size);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(size,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对free的封装，重置了used_memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(redis_malloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对strdup的封装，复制一个字符串到新的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前的used_memory</span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) pthread_mutex_lock(&amp;used_memory_mutex);</span><br><span class="line">    um = used_memory;</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) pthread_mutex_unlock(&amp;used_memory_mutex);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在vm.c中被调用，当系统支持多线程时，要保证线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_enable_thread_safeness</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zmalloc_thread_safe = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the RSS information in an OS-specific way.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: the function zmalloc_get_rss() is not designed to be fast</span></span><br><span class="line"><span class="comment"> * and may not be called in the busy loops where Redis tries to release</span></span><br><span class="line"><span class="comment"> * memory expiring or swapping out objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For this kind of "fast RSS reporting" usages use instead the</span></span><br><span class="line"><span class="comment"> * function RedisEstimateRSS() that is a much faster (and less precise)</span></span><br><span class="line"><span class="comment"> * version of the funciton. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//zmalloc_get_rss用于获取当前进程实际所驻留在内存中的空间大小</span></span><br><span class="line"><span class="comment">//rss全称是Resident Set Size，即驻留集。因为程序申请的内存空间不会全部常驻于内存，系统会把其中暂时不用的部分从内存中置换到swap区，所以rss表示的就是不包括swap区的实际驻留在内存中的空间大小</span></span><br><span class="line"><span class="comment">//在linux系统中，可以通过读取/proc/pid/stat文件获取，该文件的第24个字段是rss的信息，pid为当前进程的进程号。读取到的不是byte数，而是内存页数。通过系统调用sysconf(_SC_PAGESIZE)可以获得当前系统的内存页大小。</span></span><br><span class="line"><span class="comment">//Unix系统可以直接通过task_info直接获取rss，比linux系统简单的多。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是linux的procfs文件系统，就读取/proc/pid/stat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PROCFS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">//获取内存页大小</span></span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">size_t</span> rss;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//snprintf的作用是把stat文件的绝对路径复制到filename</span></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">"/proc/%d/stat"</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为什么只读4096个字符呢？</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    <span class="comment">//第24个字段是rss的信息，所以找到第23个空格，后面就是rss</span></span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串转换成10进制的数</span></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    rss *= page;</span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是unix系统，就使用task_info获取rss</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAVE_TASKINFO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">task_t</span> task = MACH_PORT_NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_basic_info</span> <span class="title">t_info</span>;</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> t_info_count = TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task_for_pid(current_task(), getpid(), &amp;task) != KERN_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    task_info(task, TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>)&amp;t_info, &amp;t_info_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t_info.resident_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">/* If we can't get the RSS in an OS-specific way for this system just</span></span><br><span class="line"><span class="comment">     * return the memory usage we estimated in zmalloc()..</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Fragmentation will appear to be always 1 (no fragmentation)</span></span><br><span class="line"><span class="comment">     * of course... */</span></span><br><span class="line">    <span class="comment">//获取不到rss，说明当前系统就不用考虑碎片</span></span><br><span class="line">    <span class="keyword">return</span> zmalloc_used_memory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fragmentation = RSS / allocated-bytes */</span></span><br><span class="line"><span class="comment">//获得进程的RSS后，可以计算目前的内存碎片率，直接用rss除以used_memory。rss包含进程的所有内存使用，包括代码，共享库，堆栈等。但是由于通常情况下redis在内存中数据的量要远远大于这些数据所占用的内存，因此这个简单的计算还是比较准确的。</span></span><br><span class="line"><span class="comment">//之所以会产生碎片，是因为malloc并不是严格按照参数的值来分配内存。比如程序只请求一个byte的内存，malloc通常会基于内存对齐等方面的考虑而分配4个byte。malloc进行小内存分配是很浪费的，浪费的空间因为用不上就不会在rss中</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)zmalloc_get_rss()/zmalloc_used_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-2-动态字符串"><a href="#2-2-动态字符串" class="headerlink" title="2.2 动态字符串"></a>2.2 动态字符串</h2><h3 id="sds-h"><a href="#sds-h" class="headerlink" title="sds.h"></a>sds.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDSLib, A C dynamic strings library</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SDS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SDS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//记录buf数组中已使用字节的数量，有效字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="comment">//C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存，所以sizeof(struct sdshdr)==8。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> sdslen(<span class="keyword">const</span> sds s);</span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> sdsavail(sds s);</span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果用的gcc编译器，需要提醒编译器检查可变参数的类型或者个数是否正确</span></span></span><br><span class="line"><span class="function">    __<span class="title">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(sds s1, sds s2)</span></span>;</span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="sds-c"><a href="#sds-c" class="headerlink" title="sds.c"></a>sds.c</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDSLib, A C dynamic strings library</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_ABORT_ON_OOM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sds.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//oom错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sdsOomAbort</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"SDS: Out Of Memory (SDS_ABORT_ON_OOM defined)\n"</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据初始化的字符串init和给定的字符串长度initlen，创建新的sdshdr</span></span><br><span class="line"><span class="comment">//const void *init表示可以修改指针本身的指向，但不能修改指针指向的内容</span></span><br><span class="line"><span class="comment">//void * const init指的才是不能修改指针本身</span></span><br><span class="line"><span class="comment">//返回值类型sds定义成了char指针的别名</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//buf数组不被计算在sizeof里，所以initlen要单独加上，再多分配一个字节给'\0'</span></span><br><span class="line">    sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//已经明确define过SDS_ABORT_ON_OOM了还做判断，莫名其妙</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//内存分配失败就报oom的error</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据initlen把init复制到sh的buf数组中</span></span><br><span class="line">    <span class="keyword">if</span> (initlen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (init) <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,initlen);</span><br><span class="line">    &#125;</span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">//返回的是buf数组而不是结构体</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成只包含'\0'的空的sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定字符串init并调用sdsnewlen，来创建sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回sdshdr结构体中len字段的值</span></span><br><span class="line"><span class="keyword">size_t</span> sdslen(<span class="keyword">const</span> sds s) &#123;</span><br><span class="line">    <span class="comment">//参数s是sdshdr结构体末尾的buf数组的指针，需要重建sdshdr结构体才能得到len字段的值</span></span><br><span class="line">    <span class="comment">//给结构体分配的内存空间是连续的，因此只需要将s指针回退一段距离就是原始结构体的头地址，回退的长度是len和free两个字段的大小，也就是sizeof(struct sdshdr)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定buf数组创建新的sdshdr，相当于复制原始的sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放sdshdr对象的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//s指针回退得到指向sdshdr对象头部的指针，调用zfree释放空间</span></span><br><span class="line">    zfree(s-<span class="keyword">sizeof</span>(struct sdshdr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回sdshdr结构体中free字段的值</span></span><br><span class="line"><span class="keyword">size_t</span> sdsavail(sds s) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据buf数组的内容调整len和free的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到结构体对象的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="comment">//计算真实长度</span></span><br><span class="line">    <span class="keyword">int</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">//根据真实长度调整free和len</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> += (sh-&gt;len-reallen);</span><br><span class="line">    sh-&gt;len = reallen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使buf数组有足够的额外空间容纳addlen个字节的数据</span></span><br><span class="line"><span class="comment">//静态函数，只能本文件内调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若剩余空间已经足够，不做修改直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//实际分配的数组大小是申请的两倍，减少可能的重分配次数</span></span><br><span class="line">    newlen = (len+addlen)*<span class="number">2</span>;</span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//空间不足报oom的error</span></span><br><span class="line">    <span class="comment">//空间不足为什么不试试只申请len+addlen的空间呢？</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//len是不变的，扩容只是增加free</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grow the sds to have the specified length. Bytes that were not part of</span></span><br><span class="line"><span class="comment"> * the original length of the sds will be set to zero. */</span></span><br><span class="line"><span class="comment">//将buf数组扩容到指定长度，指定len字段的值，并用0填充新空间</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen, curlen = sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若目标长度比当前长度小，就不用了扩容了</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//实际增加的长度是(curlen+len-curlen)*2==len*2</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure added region doesn't contain garbage */</span></span><br><span class="line">    sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//增加了2个len长度，实际只对一个len长度填充0</span></span><br><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span><br><span class="line">    totlen = sh-&gt;len+sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//指定len字段的值</span></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">//这个free值有什么意义？</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-sh-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长度为len的字符串t追加到sdshdr的有效字符串末尾</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先对buf数组扩容</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="comment">//返回NULL表示空间不足</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//从有效字符串的末尾开始，将长度为len的字符串t复制到指针指向的位置</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="comment">//有效字符串长度增加len</span></span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    <span class="comment">//剩余空间减少len</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求个字符串长度而已，多此一举</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用长度为len的字符串t从头覆盖buf数组</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;</span><br><span class="line">        <span class="comment">//若buf数组长度比要存的字符串短，先扩容，但是扩容的长度不是与buf数组总长度的差，而是与有效字符串长度的差</span></span><br><span class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从buf数组头部开始覆盖</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span><br><span class="line">    <span class="comment">//标记新有效字符串的末尾</span></span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">//后面存的是什么都无所谓了，反正都算free</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样的多此一举</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把ap里的所有参数格式化后拼接到buf数组s的后面</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    va_list cpy;</span><br><span class="line">    <span class="keyword">char</span> *buf, *t;</span><br><span class="line">    <span class="comment">//缓冲区初始长度设为16</span></span><br><span class="line">    <span class="keyword">size_t</span> buflen = <span class="number">16</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        buf = zmalloc(buflen);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//缓冲区的倒数第二位设为结束符</span></span><br><span class="line">        <span class="comment">//为什么不是最后一位？</span></span><br><span class="line">        buf[buflen<span class="number">-2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">//把ap指针复制到cpy，之后回到sdscatprintf函数里ap指针还要free掉，所以这里不能直接用</span></span><br><span class="line">        va_copy(cpy,ap);</span><br><span class="line">        <span class="comment">//把可变参数表格式化并输出到缓冲区</span></span><br><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span><br><span class="line">        <span class="comment">//如果缓冲区的结束符被覆盖了，说明缓冲区长度不够，直接free掉，加大长度重新zmalloc</span></span><br><span class="line">        <span class="keyword">if</span> (buf[buflen<span class="number">-2</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            zfree(buf);</span><br><span class="line">            buflen *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把缓冲区数据追加到s末尾</span></span><br><span class="line">    t = sdscat(s, buf);</span><br><span class="line">    zfree(buf);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据fmt格式化参数列表，结果追加到s末尾并返回。使用了可变参数，所以要在&lt;sds.h&gt;中提示编译器检查可变参数</span></span><br><span class="line"><span class="comment">//s只是作为一个容器而已，原本的内容不会被修改</span></span><br><span class="line"><span class="comment">//va_开头的是&lt;stdarg.h&gt;中定义的结构和函数</span></span><br><span class="line"><span class="comment">//va_list是用于存放参数列表的结构，实际上是char*的别名，通过移动指针取参数</span></span><br><span class="line"><span class="comment">//va_start函数根据fmt指针来初始化参数列表ap，其实就是让ap指向可变参数表里面的第一个参数。因为fmt是紧挨着可变参数表的前一个参数，所以就让ap指向fmt后面的第一个参数</span></span><br><span class="line"><span class="comment">//va_end函数负责清理参数列表，因为ap是字符指针，所以最后需要释放</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("Sum is: ");</span></span><br><span class="line"><span class="comment"> * s = sdscatprintf(s,"%d+%d = %d",a,b,a+b)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    t = sdscatvprintf(s,fmt,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从s数组左右两端分别移除所有在cset字符串中出现过的字符，也就是保证s两端的两个字符不在cset中</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s,"Aa. :");  =&gt; "Hello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头标记和尾标记设为s的两端</span></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//两端分别逐位判断字符是否在cset中，一旦匹配失败就退出</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//用sp到ep的子串从头覆盖buf数组，因为是子串所以不用判断溢出</span></span><br><span class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</span><br><span class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用s中start到end的子串覆盖原始的s</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("Hello World");</span></span><br><span class="line"><span class="comment"> * sdsrange(s,1,-1); =&gt; "ello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> newlen, len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//先把负下标换成正数</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start = len+start;</span><br><span class="line">        <span class="comment">//负过头了就归0</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        end = len+end;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子串的长度</span></span><br><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newlen != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//若start超出buf的有效字符串长度，则子串不存在，长度设为0</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            newlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若end越界超出buf的有效字符串长度，则退回到有效字符串末尾</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            end = len<span class="number">-1</span>;</span><br><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用子串覆盖buf数组</span></span><br><span class="line">    <span class="keyword">if</span> (start &amp;&amp; newlen) memmove(sh-&gt;buf, sh-&gt;buf+start, newlen);</span><br><span class="line">    <span class="comment">//结束符为什么不是'\0'</span></span><br><span class="line">    sh-&gt;buf[newlen] = <span class="number">0</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-newlen);</span><br><span class="line">    sh-&gt;len = newlen;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组转小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">tolower</span>(s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组转大写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">toupper</span>(s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(sds s1, sds s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l1, l2, minlen;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">    l1 = sdslen(s1);</span><br><span class="line">    l2 = sdslen(s2);</span><br><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span><br><span class="line">    cmp = <span class="built_in">memcmp</span>(s1,s2,minlen);</span><br><span class="line">    <span class="comment">//相等应该直接返回0，为什么多此一举非要算出个0？</span></span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> l1-l2;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split 's' with separator in 'sep'. An array</span></span><br><span class="line"><span class="comment"> * of sds strings is returned. *count will be set</span></span><br><span class="line"><span class="comment"> * by reference to the number of tokens returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On out of memory, zero length string, zero length</span></span><br><span class="line"><span class="comment"> * separator, NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that 'sep' is able to split a string using</span></span><br><span class="line"><span class="comment"> * a multi-character separator. For example</span></span><br><span class="line"><span class="comment"> * sdssplit("foo_-_bar","_-_"); will return two</span></span><br><span class="line"><span class="comment"> * elements "foo" and "bar".</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This version of the function is binary-safe but</span></span><br><span class="line"><span class="comment"> * requires length arguments. sdssplit() is just the</span></span><br><span class="line"><span class="comment"> * same function but for zero-terminated strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用分隔符(字符串)sep分割字符串s，返回一个sds数组，同时count存放分割后子串数量，因为是指针所以能修改数值</span></span><br><span class="line"><span class="comment">//len是s的长度，seplen是sep的长度</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>, slots = <span class="number">5</span>, start = <span class="number">0</span>, j;</span><br><span class="line">    <span class="comment">//slots是预设的子串数量，因为要申请空间所以要先预设，不够再扩容</span></span><br><span class="line">    <span class="comment">//sds本身是char*，所以tokens实际上是指针数组的指针</span></span><br><span class="line">    sds *tokens = zmalloc(<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//空间不足就返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span> || tokens == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//s为空，则返回空的tokens，count设为0</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (len-(seplen<span class="number">-1</span>)); j++) &#123;</span><br><span class="line">        <span class="comment">/* make sure there is room for the next element and the final one */</span></span><br><span class="line">        <span class="comment">//tokens数组要有至少存放两个sds的空位，不够就扩容成两倍</span></span><br><span class="line">        <span class="comment">//因为后面在循环体内部要存入一个sds，又因为循环下标截止到len-(seplen-1)，循环结束后还会存入最后一个sds，所以要预留两个空位</span></span><br><span class="line">        <span class="keyword">if</span> (slots &lt; elements+<span class="number">2</span>) &#123;</span><br><span class="line">            sds *newtokens;</span><br><span class="line"></span><br><span class="line">            slots *= <span class="number">2</span>;</span><br><span class="line">            newtokens = zrealloc(tokens,<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line">            <span class="comment">//若空间不足扩容失败，报错并释放tokens指针</span></span><br><span class="line">            <span class="keyword">if</span> (newtokens == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            tokens = newtokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* search the separator */</span></span><br><span class="line">        <span class="comment">//sep只有一个字符时直接比较，有多个字符时用memcmp比较</span></span><br><span class="line">        <span class="keyword">if</span> ((seplen == <span class="number">1</span> &amp;&amp; *(s+j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s+j,sep,seplen) == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//构造新的sds，空间不足就退出</span></span><br><span class="line">            tokens[elements] = sdsnewlen(s+start,j-start);</span><br><span class="line">            <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下标加一</span></span><br><span class="line">            elements++;</span><br><span class="line">            start = j+seplen;</span><br><span class="line">            j = j+seplen<span class="number">-1</span>; <span class="comment">/* skip the separator */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add the final element. We are sure there is room in the tokens array. */</span></span><br><span class="line">    <span class="comment">//存入最后一个子串</span></span><br><span class="line">    tokens[elements] = sdsnewlen(s+start,len-start);</span><br><span class="line">    <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    elements++;</span><br><span class="line">    *count = elements;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line"><span class="comment">//tokens是指针数组的指针，所以tokens指针和其内部的指针元素要分别释放</span></span><br><span class="line">cleanup:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) sdsfree(tokens[i]);</span><br><span class="line">        zfree(tokens);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和cleanup基本重复了，如果sdssplitlen里直接用count计数而不用额外的elements计数，就能合并了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tokens) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">        sdsfree(tokens[count]);</span><br><span class="line">    zfree(tokens);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长整型数据转成字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//buf和p的作用重复了，没必要</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>], *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">    v = (value &lt; <span class="number">0</span>) ? -value : value;</span><br><span class="line">    <span class="comment">//其实long long int最长就20位，没必要留这么多位置</span></span><br><span class="line">    <span class="comment">//从后往前赋值，最后p就指向了字符串头部</span></span><br><span class="line">    p = buf+<span class="number">31</span>; <span class="comment">/* point to the last character */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *p-- = <span class="string">'0'</span>+(v%<span class="number">10</span>);</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) *p-- = <span class="string">'-'</span>;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="comment">//指定p和p的长度创建sds</span></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(p,<span class="number">32</span>-(p-buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长度为len的字符串p以带引号的格式追加到s的末尾，也就是添加引用字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s末尾添加'"'，作为引用字符串的开头</span></span><br><span class="line">    s = sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">        <span class="comment">//把non-printable characters转换成printable characters</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">            s = sdscatprintf(s,<span class="string">"\\%c"</span>,*p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>: s = sdscatlen(s,<span class="string">"\\n"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>: s = sdscatlen(s,<span class="string">"\\r"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>: s = sdscatlen(s,<span class="string">"\\t"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\a'</span>: s = sdscatlen(s,<span class="string">"\\a"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\b'</span>: s = sdscatlen(s,<span class="string">"\\b"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//isprint判断是否为printable character</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isprint</span>(*p))</span><br><span class="line">                s = sdscatprintf(s,<span class="string">"%c"</span>,*p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//不可打印的用两位十六进制字符串表示</span></span><br><span class="line">                s = sdscatprintf(s,<span class="string">"\\x%02x"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后添加'"'，作为引用字符串的结束</span></span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Helper function for sdssplitargs() that returns non zero if 'c'</span></span><br><span class="line"><span class="comment"> * is a valid hex digit. */</span></span><br><span class="line"><span class="comment">//判断一个给定字符是否是十六进制数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_hex_digit</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) ||</span><br><span class="line">           (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Helper function for sdssplitargs() that converts an hex digit into an</span></span><br><span class="line"><span class="comment"> * integer from 0 to 15 */</span></span><br><span class="line"><span class="comment">//把单个十六进制字符转换为相应的十进制数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex_digit_to_int</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'1'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>: <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'4'</span>: <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'5'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'6'</span>: <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'7'</span>: <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'8'</span>: <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'9'</span>: <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>: <span class="keyword">case</span> <span class="string">'B'</span>: <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>: <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'d'</span>: <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'E'</span>: <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'f'</span>: <span class="keyword">case</span> <span class="string">'F'</span>: <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split a line into arguments, where every argument can be in the</span></span><br><span class="line"><span class="comment"> * following programming-language REPL-alike form:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * foo bar "newline are supported\n" and "\xff\x00otherstuff"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The number of arguments is stored into *argc, and an array</span></span><br><span class="line"><span class="comment"> * of sds is returned. The caller should sdsfree() all the returned</span></span><br><span class="line"><span class="comment"> * strings and finally zfree() the array itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that sdscatrepr() is able to convert back a string into</span></span><br><span class="line"><span class="comment"> * a quoted string in the same format sdssplitargs() is able to parse.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//命令行解析，argc存放解析后的参数个数</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = line;</span><br><span class="line">    <span class="keyword">char</span> *current = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> **<span class="built_in">vector</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* skip blanks */</span></span><br><span class="line">        <span class="keyword">while</span>(*p &amp;&amp; <span class="built_in">isspace</span>(*p)) p++;</span><br><span class="line">        <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">            <span class="comment">/* get a token */</span></span><br><span class="line">            <span class="keyword">int</span> inq=<span class="number">0</span>; <span class="comment">/* set to 1 if we are in "quotes" */</span></span><br><span class="line">            <span class="keyword">int</span> done=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面已经把current重置成NULL了，这个判断多此一举</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) current = sdsempty();</span><br><span class="line">            <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">                <span class="comment">//双引号内的解析</span></span><br><span class="line">                <span class="comment">//在双引号内部不关心分隔符，读到右双引号才算读完一个参数</span></span><br><span class="line">                <span class="keyword">if</span> (inq) &#123;</span><br><span class="line">                    <span class="comment">//读到一个以'\x'开头的表示两位十六进制整数的字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="string">'x'</span> &amp;&amp;</span><br><span class="line">                                             is_hex_digit(*(p+<span class="number">2</span>)) &amp;&amp;</span><br><span class="line">                                             is_hex_digit(*(p+<span class="number">3</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</span><br><span class="line">                        <span class="comment">//转换成十进制格式的字符串</span></span><br><span class="line">                        byte = (hex_digit_to_int(*(p+<span class="number">2</span>))*<span class="number">16</span>)+</span><br><span class="line">                                hex_digit_to_int(*(p+<span class="number">3</span>));</span><br><span class="line">                        <span class="comment">//追加到current尾部</span></span><br><span class="line">                        current = sdscatlen(current,(<span class="keyword">char</span>*)&amp;byte,<span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//跳过这个十六进制的数，接着读下个字符</span></span><br><span class="line">                        p += <span class="number">3</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="comment">//处理'\'开头的特殊字符</span></span><br><span class="line">                        <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">                        p++;</span><br><span class="line">                        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'n'</span>: c = <span class="string">'\n'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'r'</span>: c = <span class="string">'\r'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'t'</span>: c = <span class="string">'\t'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'b'</span>: c = <span class="string">'\b'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'a'</span>: c = <span class="string">'\a'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: c = *p; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//特殊字符也追加到current尾部，因为都在一个双引号的引用内</span></span><br><span class="line">                        current = sdscatlen(current,&amp;c,<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'"'</span>) &#123;</span><br><span class="line">                        <span class="comment">/* closing quote must be followed by a space */</span></span><br><span class="line">                        <span class="comment">//读到右双引号表示读取完毕，跳出循环，但是与下个参数的分隔符必须是空格，否则报错</span></span><br><span class="line">                        <span class="keyword">if</span> (*(p+<span class="number">1</span>) &amp;&amp; !<span class="built_in">isspace</span>(*(p+<span class="number">1</span>))) <span class="keyword">goto</span> err;</span><br><span class="line">                        done=<span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!*p) &#123;</span><br><span class="line">                        <span class="comment">/* unterminated quotes */</span></span><br><span class="line">                        <span class="comment">//没读到右双引号就读完了，说明命令行参数写错了，报error</span></span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//剩下的情况就是一般字符，直接追加到current尾部</span></span><br><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//双引号外的解析</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">                    <span class="comment">//读到分割符，done=1表示当前参数解析完毕</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\0'</span>:</span><br><span class="line">                        done=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//读到双引号</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                        inq=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">//如果是一般字符，就追加到current尾部，跳出循环开始读下个字符</span></span><br><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没有break就接着读下个字符</span></span><br><span class="line">                <span class="keyword">if</span> (*p) p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* add the token to the vector */</span></span><br><span class="line">            <span class="comment">//事先不知道能解析出多少个参数，只能读到一个就扩容一个空位</span></span><br><span class="line">            <span class="built_in">vector</span> = zrealloc(<span class="built_in">vector</span>,((*argc)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">            <span class="comment">//读出的参数先是保存在current中，再存入vector中</span></span><br><span class="line">            <span class="built_in">vector</span>[*argc] = current;</span><br><span class="line">            (*argc)++;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//返回解析出的参数列表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="comment">//和上面的tokens一样，指针数组的指针要内外分别释放</span></span><br><span class="line">    <span class="keyword">while</span>((*argc)--)</span><br><span class="line">        sdsfree(<span class="built_in">vector</span>[*argc]);</span><br><span class="line">    zfree(<span class="built_in">vector</span>);</span><br><span class="line">    <span class="keyword">if</span> (current) sdsfree(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_TEST_MAIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"testhelp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//功能测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        sds x = sdsnew(<span class="string">"foo"</span>), y;</span><br><span class="line"></span><br><span class="line">        test_cond(<span class="string">"Create a string and obtain the length"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">3</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"foo\0"</span>,<span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnewlen(<span class="string">"foo"</span>,<span class="number">2</span>);</span><br><span class="line">        test_cond(<span class="string">"Create a string with specified length"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">2</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"fo\0"</span>,<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        x = sdscat(x,<span class="string">"bar"</span>);</span><br><span class="line">        test_cond(<span class="string">"Strings concatenation"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">5</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"fobar\0"</span>,<span class="number">6</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        x = sdscpy(x,<span class="string">"a"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscpy() against an originally longer string"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">1</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"a\0"</span>,<span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        x = sdscpy(x,<span class="string">"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscpy() against an originally shorter string"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">33</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">memcmp</span>(x,<span class="string">"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\0"</span>,<span class="number">33</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdscatprintf(sdsempty(),<span class="string">"%d"</span>,<span class="number">123</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscatprintf() seems working in the base case"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">3</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"123\0"</span>,<span class="number">4</span>) ==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdstrim(sdsnew(<span class="string">"xxciaoyyy"</span>),<span class="string">"xy"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdstrim() correctly trims characters"</span>,</span><br><span class="line">            sdslen(x) == <span class="number">4</span> &amp;&amp; <span class="built_in">memcmp</span>(x,<span class="string">"ciao\0"</span>,<span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        y = sdsrange(sdsdup(x),<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,1,1)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">1</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"i\0"</span>,<span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsrange(sdsdup(x),<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,1,-1)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">3</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"iao\0"</span>,<span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsrange(sdsdup(x),<span class="number">-2</span>,<span class="number">-1</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,-2,-1)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">2</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"ao\0"</span>,<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsrange(sdsdup(x),<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,2,1)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">0</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"\0"</span>,<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsrange(sdsdup(x),<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,1,100)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">3</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"iao\0"</span>,<span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        y = sdsrange(sdsdup(x),<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">        test_cond(<span class="string">"sdsrange(...,100,100)"</span>,</span><br><span class="line">            sdslen(y) == <span class="number">0</span> &amp;&amp; <span class="built_in">memcmp</span>(y,<span class="string">"\0"</span>,<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">"foo"</span>);</span><br><span class="line">        y = sdsnew(<span class="string">"foa"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscmp(foo,foa)"</span>, sdscmp(x,y) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">"bar"</span>);</span><br><span class="line">        y = sdsnew(<span class="string">"bar"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscmp(bar,bar)"</span>, sdscmp(x,y) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        sdsfree(y);</span><br><span class="line">        sdsfree(x);</span><br><span class="line">        x = sdsnew(<span class="string">"aar"</span>);</span><br><span class="line">        y = sdsnew(<span class="string">"bar"</span>);</span><br><span class="line">        test_cond(<span class="string">"sdscmp(bar,bar)"</span>, sdscmp(x,y) &lt; <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    test_report()</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<h2 id="2-3-双端链表"><a href="#2-3-双端链表" class="headerlink" title="2.3 双端链表"></a>2.3 双端链表</h2><h3 id="adlist-h"><a href="#adlist-h" class="headerlink" title="adlist.h"></a>adlist.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="adlist-c"><a href="#adlist-c" class="headerlink" title="adlist.c"></a>adlist.c</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h1 id="3-内存编码结构相关"><a href="#3-内存编码结构相关" class="headerlink" title="3 内存编码结构相关"></a>3 内存编码结构相关</h1><h1 id="4-数据类型相关"><a href="#4-数据类型相关" class="headerlink" title="4 数据类型相关"></a>4 数据类型相关</h1><h1 id="5-单机数据库相关"><a href="#5-单机数据库相关" class="headerlink" title="5 单机数据库相关"></a>5 单机数据库相关</h1><h1 id="6-客户端和服务器端相关"><a href="#6-客户端和服务器端相关" class="headerlink" title="6 客户端和服务器端相关"></a>6 客户端和服务器端相关</h1><h1 id="7-多机数据库相关"><a href="#7-多机数据库相关" class="headerlink" title="7 多机数据库相关"></a>7 多机数据库相关</h1><h1 id="8-测试类文件"><a href="#8-测试类文件" class="headerlink" title="8 测试类文件"></a>8 测试类文件</h1><h3 id="testhelp-h"><a href="#testhelp-h" class="headerlink" title="testhelp.h"></a>testhelp.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a really minimal testing framework for C.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * test_cond("Check if 1 == 1", 1==1)</span></span><br><span class="line"><span class="comment"> * test_cond("Check if 5 &gt; 10", 5 &gt; 10)</span></span><br><span class="line"><span class="comment"> * test_report()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TESTHELP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TESTHELP_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试失败次数</span></span><br><span class="line"><span class="keyword">int</span> __failed_tests = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//测试总次数</span></span><br><span class="line"><span class="keyword">int</span> __test_num = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_cond(descr,_c) do &#123; \</span></span><br><span class="line">    <span class="comment">//测试次数加一，先输出描述信息</span></span><br><span class="line">    __test_num++; <span class="built_in">printf</span>(<span class="string">"%d - %s: "</span>, __test_num, descr); \</span><br><span class="line">    <span class="comment">//执行_c表示的表达式，输出成功或失败提示</span></span><br><span class="line">    <span class="keyword">if</span>(_c) <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>); <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">"FAILED\n"</span>); __failed_tests++;&#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试报告</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_report() do &#123; \</span></span><br><span class="line">    <span class="comment">//输出测试总次数，成功次数和失败次数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d tests, %d passed, %d failed\n"</span>, __test_num, \</span><br><span class="line">                    __test_num-__failed_tests, __failed_tests); \</span><br><span class="line">    <span class="comment">//如果有失败的样例就报warning</span></span><br><span class="line">    <span class="keyword">if</span> (__failed_tests) &#123; \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"=== WARNING === We have failed tests here...\n"</span>); \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<h1 id="9-工具类文件"><a href="#9-工具类文件" class="headerlink" title="9 工具类文件"></a>9 工具类文件</h1><h1 id="10-封装类文件"><a href="#10-封装类文件" class="headerlink" title="10 封装类文件"></a>10 封装类文件</h1></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:wkx1996@foxmail.com">w.k.x.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://shivakasu.github.io/2020/06/20/redis0/">http://shivakasu.github.io/2020/06/20/redis0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://shivakasu.github.io">SHIVAKASU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis    </a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库    </a></div><div class="post_share"><div class="social-share" data-image="http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png" data-sites="facebook,twitter,wechat,weibo,qq,qzone,douban,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="http://file.shivakasu.cn/4a84dcfb31806db98b2a/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="http://file.shivakasu.cn/982f781ef31cbc46968b/alipay.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/06/14/haskell0/"><img class="next_cover lazyload" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Haskell Programming From First Principles notes (更新中)</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'qIfwEiuSjlc5vyminB1rx2qX-gzGzoHsz',
  appKey:'erfVXuW3AybzbWGqxSGxnBRp',
  placeholder:'来都来了，说点儿什么吧~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By w.k.x.</div><div class="framework-info"><span>driven by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>京ICP备19001969号-1</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>