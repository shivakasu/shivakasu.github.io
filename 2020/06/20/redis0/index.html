<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redis源码阅读(更新中) | SHIVAKASU</title><meta name="description" content="1 概述 redis版本：2.2.15 看的很老的版本，因为代码少 v^^7 阅读顺序参考自博文 https:&#x2F;&#x2F;blog.csdn.net&#x2F;terence1212&#x2F;article&#x2F;details&#x2F;53541908  2 数据结构相关2.1 内存分配config.h#ifndef __CONFIG_H#define __CONFIG_H#ifdef __APPLE__#include &lt;Av"><meta name="keywords" content="redis,数据库"><meta name="author" content="w.k.x.,wkx1996@foxmail.com"><meta name="copyright" content="w.k.x."><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://file.shivakasu.cn/eb8581b76ec032ab0db8/favicon.ico"><link rel="canonical" href="https://shivakasu.cn/2020/06/20/redis0/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="redis源码阅读(更新中)"><meta property="og:url" content="https://shivakasu.cn/2020/06/20/redis0/"><meta property="og:site_name" content="SHIVAKASU"><meta property="og:description" content="1 概述 redis版本：2.2.15 看的很老的版本，因为代码少 v^^7 阅读顺序参考自博文 https:&#x2F;&#x2F;blog.csdn.net&#x2F;terence1212&#x2F;article&#x2F;details&#x2F;53541908  2 数据结构相关2.1 内存分配config.h#ifndef __CONFIG_H#define __CONFIG_H#ifdef __APPLE__#include &lt;Av"><meta property="og:image" content="http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png"><meta property="article:published_time" content="2020-06-20T10:41:20.000Z"><meta property="article:modified_time" content="2020-07-04T15:34:20.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="tinyhttpd 源码阅读" href="https://shivakasu.cn/2020/06/28/webserver0/"><link rel="next" title="Haskell Programming From First Principles notes (更新中)" href="https://shivakasu.cn/2020/06/14/haskell0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: w.k.x.","link":"链接: ","source":"来源: SHIVAKASU","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: ,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="SHIVAKASU" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://file.shivakasu.cn/cb7049104af4685e7289/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-text">1 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-数据结构相关"><span class="toc-text">2 数据结构相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-内存分配"><span class="toc-text">2.1 内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#config-h"><span class="toc-text">config.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zmalloc-c"><span class="toc-text">zmalloc.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-动态字符串"><span class="toc-text">2.2 动态字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sds-h"><span class="toc-text">sds.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sds-c"><span class="toc-text">sds.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-双端链表"><span class="toc-text">2.3 双端链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#adlist-h"><span class="toc-text">adlist.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adlist-c"><span class="toc-text">adlist.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-字典"><span class="toc-text">2.4 字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dict-h"><span class="toc-text">dict.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dict-c"><span class="toc-text">dict.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-跳跃表"><span class="toc-text">2.5 跳跃表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-h-跳跃表相关部分）"><span class="toc-text">redis.h(跳跃表相关部分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t-zset-c-跳跃表相关部分"><span class="toc-text">t_zset.c(跳跃表相关部分)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-内存编码结构相关"><span class="toc-text">3 内存编码结构相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-整数集合数据结构"><span class="toc-text">3.1 整数集合数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#intset-h"><span class="toc-text">intset.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intset-c"><span class="toc-text">intset.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-压缩列表"><span class="toc-text">3.2 压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist-h"><span class="toc-text">ziplist.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist-c"><span class="toc-text">ziplist.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-压缩字典"><span class="toc-text">3.3 压缩字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zipmap-c"><span class="toc-text">zipmap.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-数据类型相关"><span class="toc-text">4 数据类型相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-对象系统"><span class="toc-text">4.1 对象系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-h-对象系统相关部分"><span class="toc-text">redis.h(对象系统相关部分)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object-c"><span class="toc-text">object.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-字符串"><span class="toc-text">4.2 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#t-string-c"><span class="toc-text">t_string.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-列表"><span class="toc-text">4.3 列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-h-列表相关"><span class="toc-text">redis.h(列表相关)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t-list-c"><span class="toc-text">t_list.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-哈希"><span class="toc-text">4.4 哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#t-hash-c"><span class="toc-text">t_hash.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-单机数据库相关"><span class="toc-text">5 单机数据库相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-客户端和服务器端相关"><span class="toc-text">6 客户端和服务器端相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-多机数据库相关"><span class="toc-text">7 多机数据库相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-测试类文件"><span class="toc-text">8 测试类文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#testhelp-h"><span class="toc-text">testhelp.h</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-工具类文件"><span class="toc-text">9 工具类文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-封装类文件"><span class="toc-text">10 封装类文件</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SHIVAKASU</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">redis源码阅读(更新中)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-20 18:41:20"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-20</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-04 23:34:20"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-04</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/">日常专业学习</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">50.9k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 235 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/2020/06/20/redis0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/20/redis0/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul>
<li>redis版本：2.2.15</li>
<li>看的很老的版本，因为代码少 v^^7</li>
<li>阅读顺序参考自博文 <a href="https://blog.csdn.net/terence1212/article/details/53541908" target="_blank" rel="noopener">https://blog.csdn.net/terence1212/article/details/53541908</a></li>
</ul>
<h1 id="2-数据结构相关"><a href="#2-数据结构相关" class="headerlink" title="2 数据结构相关"></a>2 数据结构相关</h1><h2 id="2-1-内存分配"><a href="#2-1-内存分配" class="headerlink" title="2.1 内存分配"></a>2.1 内存分配</h2><h3 id="config-h"><a href="#config-h" class="headerlink" title="config.h"></a>config.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;AvailabilityMacros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use tcmalloc's malloc_size() when available.</span></span><br><span class="line"><span class="comment"> * When tcmalloc is used, native OSX malloc_size() may never be used because</span></span><br><span class="line"><span class="comment"> * this expects a different allocation scheme. Therefore, *exclusively* use</span></span><br><span class="line"><span class="comment"> * either tcmalloc or OSX's malloc_size()! */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果系统中存在Google的TC_MALLOC库，redis_malloc_size函数就当做tc_malloc_size函数使用</span></span><br><span class="line"><span class="comment">//tc_malloc比原始的malloc性能好</span></span><br><span class="line"><span class="comment">//redis_malloc_size的功能是获得参数p所指向的内存块的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TC_VERSION_MAJOR &gt;= 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6</span></span><br><span class="line"><span class="comment">//HAVE_MALLOC_SIZE用来标记是否定义了redis_malloc_size函数</span></span><br><span class="line"><span class="comment">//可是为什么不直接检查redis_malloc_size是否存在，还要额外定义一个标记呢？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_malloc_size(p) tc_malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//或者，如果系统是Mac系统，那么redis_malloc_size函数就当做原始的malloc_size函数使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_malloc_size(p) malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define redis_fstat to fstat or fstat64() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) &amp;&amp; !defined(MAC_OS_X_VERSION_10_6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_fstat fstat64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_stat stat64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_fstat fstat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_stat stat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for proc filesystem */</span></span><br><span class="line"><span class="comment">//如果是linux系统，当前文件系统就是procfs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_PROCFS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for task_info() */</span></span><br><span class="line"><span class="comment">//如果是unix系统，就可以使用task_info，macos是基于unix的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_TASKINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for backtrace() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__linux__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_BACKTRACE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for polling API */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(__APPLE__) &amp;&amp; defined(MAC_OS_X_VERSION_10_6)) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__NetBSD__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_KQUEUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define aof_fsync to fdatasync() in Linux and fsync() for all the rest */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fdatasync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fsync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="zmalloc-c"><a href="#zmalloc-c" class="headerlink" title="zmalloc.c"></a>zmalloc.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zmalloc - total amount of allocated memory aware version of malloc()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//redis是基于内存的数据库，所以内存管理很重要。</span></span><br><span class="line"><span class="comment">//redis把C语言的内存分配函数封装成zmalloc、zfree等z开头的函数，来屏蔽各底层平台的差异。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果定义了HAVE_MALLOC_SIZE，即定义了redis_malloc_size函数，PREFIX_SIZE就是0</span></span><br><span class="line"><span class="comment">//PREFIX_SIZE用于在分配到的的空间头部存储原本申请空间的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//如果没有定义HAVE_MALLOC_SIZE，且当前系统是Solaris，PREFIX_SIZE就是long long类型的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//否则，PREFIX_SIZE就是size_t的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Explicitly override malloc/free etc when using tcmalloc. */</span></span><br><span class="line"><span class="comment">//如果使用了tcmalloc库，就用tcmalloc库函数替换原始的malloc库函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) tc_malloc(size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) tc_calloc(count,size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) tc_realloc(ptr,size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) tc_free(ptr)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//update_zmalloc_stat_alloc用于在分配内存的时候更新已分配大小</span></span><br><span class="line"><span class="comment">//__n是实际分配到的空间大小，__size是程序原本请求的空间大小</span></span><br><span class="line"><span class="comment">//__size应该是改了代码以后忘记删掉的参数</span></span><br><span class="line"><span class="comment">//使用do-while(0)封装成代码块，防止宏定义展开的时候出问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n,__size) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="comment">//64位系统中，sizeof(long)通常是8</span></span><br><span class="line">    <span class="comment">//malloc分配的内存是8字节对齐的，如果请求分配的内存不是8的倍数，那么malloc就会多分配一点来凑成8的倍数</span></span><br><span class="line">    <span class="comment">//如果_n值不是内存分配单元(sizeof(long))的整数倍，说明当前分配的内存大小有碎片，为了与malloc的实际结果匹配，需要补齐到8的整数倍</span></span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</span><br><span class="line">        <span class="comment">//如果要考虑线程安全，先加锁再修改used_memory</span></span><br><span class="line">        pthread_mutex_lock(&amp;used_memory_mutex);  \</span><br><span class="line">        used_memory += _n; \</span><br><span class="line">        pthread_mutex_unlock(&amp;used_memory_mutex); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        <span class="comment">//不考虑线程安全时，直接修改used_memory</span></span><br><span class="line">        used_memory += _n; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//update_zmalloc_stat_free用于释放已经分配的空间</span></span><br><span class="line"><span class="comment">//__n是待释放的空间大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</span><br><span class="line">        pthread_mutex_lock(&amp;used_memory_mutex);  \</span><br><span class="line">        used_memory -= _n; \</span><br><span class="line">        pthread_mutex_unlock(&amp;used_memory_mutex); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        used_memory -= _n; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配得到的内存大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//是否要考虑线程安全，默认不考虑</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//保证线程安全的锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//oom的错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把错误信息输出到stderr流文件中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    <span class="comment">//刷新缓冲，把stderr中的数据发给错误输出设备</span></span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="comment">//终止当前进程，但不清理任何对象</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 是分配的内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际多申请了PREFIX_SIZE大小的空间</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line">    <span class="comment">// 如果分配失败，调用zmalloc_oom函数打印oom的错误信息，然后退出进程</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">//如果已经定义了redis_malloc_size函数，直接计算ptr的实际大小，然后更新used_memory</span></span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(ptr),size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//否则，先在分配到的空间的第一个字长处保存住原本请求的空间大小size</span></span><br><span class="line">    <span class="comment">//然后只能默认size+PREFIX_SIZE是已分配的大小(大概没有malloc_size算出来的靠谱)，更新used_memory</span></span><br><span class="line">    <span class="comment">//多申请的PREFIX_SIZE空间就是用来存储size的，所以当定义了redis_malloc_size函数时PREFIX_SIZE就是0，因为已经不需要存储size了</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对calloc的封装，更新了used_memory</span></span><br><span class="line"><span class="comment">//调用calloc时，第一个参数固定为1，所以每次只会分配一个size+PREFIX_SIZE大小的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(ptr),size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对realloc的封装，重新分配内存，重置并更新了used_memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = redis_malloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom(size);</span><br><span class="line"></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(newptr),size);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom(size);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(size,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对free的封装，重置了used_memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(redis_malloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对strdup的封装，复制一个字符串到新的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前的used_memory</span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) pthread_mutex_lock(&amp;used_memory_mutex);</span><br><span class="line">    um = used_memory;</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) pthread_mutex_unlock(&amp;used_memory_mutex);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在vm.c中被调用，当系统支持多线程时，要保证线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_enable_thread_safeness</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zmalloc_thread_safe = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the RSS information in an OS-specific way.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: the function zmalloc_get_rss() is not designed to be fast</span></span><br><span class="line"><span class="comment"> * and may not be called in the busy loops where Redis tries to release</span></span><br><span class="line"><span class="comment"> * memory expiring or swapping out objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For this kind of "fast RSS reporting" usages use instead the</span></span><br><span class="line"><span class="comment"> * function RedisEstimateRSS() that is a much faster (and less precise)</span></span><br><span class="line"><span class="comment"> * version of the funciton. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//zmalloc_get_rss用于获取当前进程实际所驻留在内存中的空间大小</span></span><br><span class="line"><span class="comment">//rss全称是Resident Set Size，即驻留集。因为程序申请的内存空间不会全部常驻于内存，系统会把其中暂时不用的部分从内存中置换到swap区，所以rss表示的就是不包括swap区的实际驻留在内存中的空间大小</span></span><br><span class="line"><span class="comment">//在linux系统中，可以通过读取/proc/pid/stat文件获取，该文件的第24个字段是rss的信息，pid为当前进程的进程号。读取到的不是byte数，而是内存页数。通过系统调用sysconf(_SC_PAGESIZE)可以获得当前系统的内存页大小。</span></span><br><span class="line"><span class="comment">//Unix系统可以直接通过task_info直接获取rss，比linux系统简单的多。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是linux的procfs文件系统，就读取/proc/pid/stat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PROCFS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">//获取内存页大小</span></span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">size_t</span> rss;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//snprintf的作用是把stat文件的绝对路径复制到filename</span></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">"/proc/%d/stat"</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为什么只读4096个字符呢？</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    <span class="comment">//第24个字段是rss的信息，所以找到第23个空格，后面就是rss</span></span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串转换成10进制的数</span></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    rss *= page;</span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是unix系统，就使用task_info获取rss</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAVE_TASKINFO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">task_t</span> task = MACH_PORT_NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_basic_info</span> <span class="title">t_info</span>;</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> t_info_count = TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task_for_pid(current_task(), getpid(), &amp;task) != KERN_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    task_info(task, TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>)&amp;t_info, &amp;t_info_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t_info.resident_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">/* If we can't get the RSS in an OS-specific way for this system just</span></span><br><span class="line"><span class="comment">     * return the memory usage we estimated in zmalloc()..</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Fragmentation will appear to be always 1 (no fragmentation)</span></span><br><span class="line"><span class="comment">     * of course... */</span></span><br><span class="line">    <span class="comment">//获取不到rss，说明当前系统就不用考虑碎片</span></span><br><span class="line">    <span class="keyword">return</span> zmalloc_used_memory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fragmentation = RSS / allocated-bytes */</span></span><br><span class="line"><span class="comment">//获得进程的RSS后，可以计算目前的内存碎片率，直接用rss除以used_memory。rss包含进程的所有内存使用，包括代码，共享库，堆栈等。但是由于通常情况下redis在内存中数据的量要远远大于这些数据所占用的内存，因此这个简单的计算还是比较准确的。</span></span><br><span class="line"><span class="comment">//之所以会产生碎片，是因为malloc并不是严格按照参数的值来分配内存。比如程序只请求一个byte的内存，malloc通常会基于内存对齐等方面的考虑而分配4个byte。malloc进行小内存分配是很浪费的，浪费的空间因为用不上就不会在rss中</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)zmalloc_get_rss()/zmalloc_used_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-动态字符串"><a href="#2-2-动态字符串" class="headerlink" title="2.2 动态字符串"></a>2.2 动态字符串</h2><h3 id="sds-h"><a href="#sds-h" class="headerlink" title="sds.h"></a>sds.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDSLib, A C dynamic strings library</span></span><br><span class="line"><span class="comment">//比起 C 字符串， SDS 具有以下优点：常数复杂度获取字符串长度，杜绝缓冲区溢出，减少修改字符串长度时所需的内存重分配次数，二进制安全，兼容部分 C 字符串函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SDS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SDS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//记录buf数组中已使用字节的数量，有效字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="comment">//C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存，所以sizeof(struct sdshdr)==8。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果用的gcc编译器，需要提醒编译器检查可变参数的类型或者个数是否正确</span></span></span><br><span class="line"><span class="function">    __<span class="title">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="sds-c"><a href="#sds-c" class="headerlink" title="sds.c"></a>sds.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDSLib, A C dynamic strings library</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_ABORT_ON_OOM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sds.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//oom错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sdsOomAbort</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"SDS: Out Of Memory (SDS_ABORT_ON_OOM defined)\n"</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据初始化的字符串init和给定的字符串长度initlen，创建新的sdshdr</span></span><br><span class="line"><span class="comment">//const void *init表示可以修改指针本身的指向，但不能修改指针指向的内容</span></span><br><span class="line"><span class="comment">//void * const init指的才是不能修改指针本身</span></span><br><span class="line"><span class="comment">//返回值类型sds定义成了char指针的别名</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//buf数组不被计算在sizeof里，所以initlen要单独加上，再多分配一个字节给'\0'</span></span><br><span class="line">    sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//已经明确define过SDS_ABORT_ON_OOM了还做判断，莫名其妙</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//内存分配失败就报oom的error</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据initlen把init复制到sh的buf数组中</span></span><br><span class="line">    <span class="keyword">if</span> (initlen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (init) <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,initlen);</span><br><span class="line">    &#125;</span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">//返回的是buf数组而不是结构体</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成只包含'\0'的空的sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定字符串init并调用sdsnewlen，来创建sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回sdshdr结构体中len字段的值</span></span><br><span class="line"><span class="keyword">size_t</span> sdslen(<span class="keyword">const</span> sds s) &#123;</span><br><span class="line">    <span class="comment">//参数s是sdshdr结构体末尾的buf数组的指针，需要重建sdshdr结构体才能得到len字段的值</span></span><br><span class="line">    <span class="comment">//给结构体分配的内存空间是连续的，因此只需要将s指针回退一段距离就是原始结构体的头地址，回退的长度是len和free两个字段的大小，也就是sizeof(struct sdshdr)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定buf数组创建新的sdshdr，相当于复制原始的sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放sdshdr对象的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//s指针回退得到指向sdshdr对象头部的指针，调用zfree释放空间</span></span><br><span class="line">    zfree(s-<span class="keyword">sizeof</span>(struct sdshdr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回sdshdr结构体中free字段的值</span></span><br><span class="line"><span class="keyword">size_t</span> sdsavail(sds s) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据buf数组的内容调整len和free的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到结构体对象的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="comment">//计算真实长度</span></span><br><span class="line">    <span class="keyword">int</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">//根据真实长度调整free和len</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> += (sh-&gt;len-reallen);</span><br><span class="line">    sh-&gt;len = reallen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使buf数组有足够的额外空间容纳addlen个字节的数据</span></span><br><span class="line"><span class="comment">//静态函数，只能本文件内调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若剩余空间已经足够，不做修改直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//实际分配的数组大小是申请的两倍，减少可能的重分配次数</span></span><br><span class="line">    newlen = (len+addlen)*<span class="number">2</span>;</span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//空间不足报oom的error</span></span><br><span class="line">    <span class="comment">//空间不足为什么不试试只申请len+addlen的空间呢？</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//len是不变的，扩容只是增加free</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grow the sds to have the specified length. Bytes that were not part of</span></span><br><span class="line"><span class="comment"> * the original length of the sds will be set to zero. */</span></span><br><span class="line"><span class="comment">//将buf数组扩容到指定长度，指定len字段的值，并用0填充新空间</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen, curlen = sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若目标长度比当前长度小，就不用了扩容了</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//实际增加的长度是(curlen+len-curlen)*2==len*2</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure added region doesn't contain garbage */</span></span><br><span class="line">    sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//增加了2个len长度，实际只对一个len长度填充0</span></span><br><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span><br><span class="line">    totlen = sh-&gt;len+sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//指定len字段的值</span></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">//这个free值有什么意义？</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-sh-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长度为len的字符串t追加到sdshdr的有效字符串末尾</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先对buf数组扩容</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="comment">//返回NULL表示空间不足</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//从有效字符串的末尾开始，将长度为len的字符串t复制到指针指向的位置</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="comment">//有效字符串长度增加len</span></span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    <span class="comment">//剩余空间减少len</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求个字符串长度而已，多此一举</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用长度为len的字符串t从头覆盖buf数组</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;</span><br><span class="line">        <span class="comment">//若buf数组长度比要存的字符串短，先扩容，但是扩容的长度不是与buf数组总长度的差，而是与有效字符串长度的差</span></span><br><span class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从buf数组头部开始覆盖</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span><br><span class="line">    <span class="comment">//标记新有效字符串的末尾</span></span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">//后面存的是什么都无所谓了，反正都算free</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样的多此一举</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把ap里的所有参数格式化后拼接到buf数组s的后面</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    va_list cpy;</span><br><span class="line">    <span class="keyword">char</span> *buf, *t;</span><br><span class="line">    <span class="comment">//缓冲区初始长度设为16</span></span><br><span class="line">    <span class="keyword">size_t</span> buflen = <span class="number">16</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        buf = zmalloc(buflen);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//缓冲区的倒数第二位设为结束符</span></span><br><span class="line">        <span class="comment">//为什么不是最后一位？</span></span><br><span class="line">        buf[buflen<span class="number">-2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">//把ap指针复制到cpy，之后回到sdscatprintf函数里ap指针还要free掉，所以这里不能直接用</span></span><br><span class="line">        va_copy(cpy,ap);</span><br><span class="line">        <span class="comment">//把可变参数表格式化并输出到缓冲区</span></span><br><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span><br><span class="line">        <span class="comment">//如果缓冲区的结束符被覆盖了，说明缓冲区长度不够，直接free掉，加大长度重新zmalloc</span></span><br><span class="line">        <span class="keyword">if</span> (buf[buflen<span class="number">-2</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            zfree(buf);</span><br><span class="line">            buflen *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把缓冲区数据追加到s末尾</span></span><br><span class="line">    t = sdscat(s, buf);</span><br><span class="line">    zfree(buf);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据fmt格式化参数列表，结果追加到s末尾并返回。使用了可变参数，所以要在&lt;sds.h&gt;中提示编译器检查可变参数</span></span><br><span class="line"><span class="comment">//s只是作为一个容器而已，原本的内容不会被修改</span></span><br><span class="line"><span class="comment">//va_开头的是&lt;stdarg.h&gt;中定义的结构和函数</span></span><br><span class="line"><span class="comment">//va_list是用于存放参数列表的结构，实际上是char*的别名，通过移动指针取参数</span></span><br><span class="line"><span class="comment">//va_start函数根据fmt指针来初始化参数列表ap，其实就是让ap指向可变参数表里面的第一个参数。因为fmt是紧挨着可变参数表的前一个参数，所以就让ap指向fmt后面的第一个参数</span></span><br><span class="line"><span class="comment">//va_end函数负责清理参数列表，因为ap是字符指针，所以最后需要释放</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("Sum is: ");</span></span><br><span class="line"><span class="comment"> * s = sdscatprintf(s,"%d+%d = %d",a,b,a+b)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    t = sdscatvprintf(s,fmt,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从s数组左右两端分别移除所有在cset字符串中出现过的字符，也就是保证s两端的两个字符不在cset中</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s,"Aa. :");  =&gt; "Hello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头标记和尾标记设为s的两端</span></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//两端分别逐位判断字符是否在cset中，一旦匹配失败就退出</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//用sp到ep的子串从头覆盖buf数组，因为是子串所以不用判断溢出</span></span><br><span class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</span><br><span class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用s中start到end的子串覆盖原始的s</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("Hello World");</span></span><br><span class="line"><span class="comment"> * sdsrange(s,1,-1); =&gt; "ello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> newlen, len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//先把负下标换成正数</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start = len+start;</span><br><span class="line">        <span class="comment">//负过头了就归0</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        end = len+end;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子串的长度</span></span><br><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newlen != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//若start超出buf的有效字符串长度，则子串不存在，长度设为0</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            newlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若end越界超出buf的有效字符串长度，则退回到有效字符串末尾</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            end = len<span class="number">-1</span>;</span><br><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用子串覆盖buf数组</span></span><br><span class="line">    <span class="keyword">if</span> (start &amp;&amp; newlen) memmove(sh-&gt;buf, sh-&gt;buf+start, newlen);</span><br><span class="line">    <span class="comment">//结束符为什么不是'\0'</span></span><br><span class="line">    sh-&gt;buf[newlen] = <span class="number">0</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-newlen);</span><br><span class="line">    sh-&gt;len = newlen;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组转小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">tolower</span>(s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组转大写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">toupper</span>(s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(sds s1, sds s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l1, l2, minlen;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">    l1 = sdslen(s1);</span><br><span class="line">    l2 = sdslen(s2);</span><br><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span><br><span class="line">    cmp = <span class="built_in">memcmp</span>(s1,s2,minlen);</span><br><span class="line">    <span class="comment">//相等应该直接返回0，为什么多此一举非要算出个0？</span></span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> l1-l2;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split 's' with separator in 'sep'. An array</span></span><br><span class="line"><span class="comment"> * of sds strings is returned. *count will be set</span></span><br><span class="line"><span class="comment"> * by reference to the number of tokens returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On out of memory, zero length string, zero length</span></span><br><span class="line"><span class="comment"> * separator, NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that 'sep' is able to split a string using</span></span><br><span class="line"><span class="comment"> * a multi-character separator. For example</span></span><br><span class="line"><span class="comment"> * sdssplit("foo_-_bar","_-_"); will return two</span></span><br><span class="line"><span class="comment"> * elements "foo" and "bar".</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This version of the function is binary-safe but</span></span><br><span class="line"><span class="comment"> * requires length arguments. sdssplit() is just the</span></span><br><span class="line"><span class="comment"> * same function but for zero-terminated strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用分隔符(字符串)sep分割字符串s，返回一个sds数组，同时count存放分割后子串数量，因为是指针所以能修改数值</span></span><br><span class="line"><span class="comment">//len是s的长度，seplen是sep的长度</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>, slots = <span class="number">5</span>, start = <span class="number">0</span>, j;</span><br><span class="line">    <span class="comment">//slots是预设的子串数量，因为要申请空间所以要先预设，不够再扩容</span></span><br><span class="line">    <span class="comment">//sds本身是char*，所以tokens实际上是指针数组的指针</span></span><br><span class="line">    sds *tokens = zmalloc(<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//空间不足就返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span> || tokens == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//s为空，则返回空的tokens，count设为0</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (len-(seplen<span class="number">-1</span>)); j++) &#123;</span><br><span class="line">        <span class="comment">/* make sure there is room for the next element and the final one */</span></span><br><span class="line">        <span class="comment">//tokens数组要有至少存放两个sds的空位，不够就扩容成两倍</span></span><br><span class="line">        <span class="comment">//因为后面在循环体内部要存入一个sds，又因为循环下标截止到len-(seplen-1)，循环结束后还会存入最后一个sds，所以要预留两个空位</span></span><br><span class="line">        <span class="keyword">if</span> (slots &lt; elements+<span class="number">2</span>) &#123;</span><br><span class="line">            sds *newtokens;</span><br><span class="line"></span><br><span class="line">            slots *= <span class="number">2</span>;</span><br><span class="line">            newtokens = zrealloc(tokens,<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line">            <span class="comment">//若空间不足扩容失败，报错并释放tokens指针</span></span><br><span class="line">            <span class="keyword">if</span> (newtokens == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            tokens = newtokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* search the separator */</span></span><br><span class="line">        <span class="comment">//sep只有一个字符时直接比较，有多个字符时用memcmp比较</span></span><br><span class="line">        <span class="keyword">if</span> ((seplen == <span class="number">1</span> &amp;&amp; *(s+j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s+j,sep,seplen) == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//构造新的sds，空间不足就退出</span></span><br><span class="line">            tokens[elements] = sdsnewlen(s+start,j-start);</span><br><span class="line">            <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下标加一</span></span><br><span class="line">            elements++;</span><br><span class="line">            start = j+seplen;</span><br><span class="line">            j = j+seplen<span class="number">-1</span>; <span class="comment">/* skip the separator */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add the final element. We are sure there is room in the tokens array. */</span></span><br><span class="line">    <span class="comment">//存入最后一个子串</span></span><br><span class="line">    tokens[elements] = sdsnewlen(s+start,len-start);</span><br><span class="line">    <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    elements++;</span><br><span class="line">    *count = elements;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line"><span class="comment">//tokens是指针数组的指针，所以tokens指针和其内部的指针元素要分别释放</span></span><br><span class="line">cleanup:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) sdsfree(tokens[i]);</span><br><span class="line">        zfree(tokens);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和cleanup基本重复了，如果sdssplitlen里直接用count计数而不用额外的elements计数，就能合并了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tokens) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">        sdsfree(tokens[count]);</span><br><span class="line">    zfree(tokens);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长整型数据转成字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//buf和p的作用重复了，没必要</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>], *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">    v = (value &lt; <span class="number">0</span>) ? -value : value;</span><br><span class="line">    <span class="comment">//其实long long int最长就20位，没必要留这么多位置</span></span><br><span class="line">    <span class="comment">//从后往前赋值，最后p就指向了字符串头部</span></span><br><span class="line">    p = buf+<span class="number">31</span>; <span class="comment">/* point to the last character */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *p-- = <span class="string">'0'</span>+(v%<span class="number">10</span>);</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) *p-- = <span class="string">'-'</span>;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="comment">//指定p和p的长度创建sds</span></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(p,<span class="number">32</span>-(p-buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长度为len的字符串p以带引号的格式追加到s的末尾，也就是添加引用字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s末尾添加'"'，作为引用字符串的开头</span></span><br><span class="line">    s = sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">        <span class="comment">//把non-printable characters转换成printable characters</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">            s = sdscatprintf(s,<span class="string">"\\%c"</span>,*p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>: s = sdscatlen(s,<span class="string">"\\n"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>: s = sdscatlen(s,<span class="string">"\\r"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>: s = sdscatlen(s,<span class="string">"\\t"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\a'</span>: s = sdscatlen(s,<span class="string">"\\a"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\b'</span>: s = sdscatlen(s,<span class="string">"\\b"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//isprint判断是否为printable character</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isprint</span>(*p))</span><br><span class="line">                s = sdscatprintf(s,<span class="string">"%c"</span>,*p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//不可打印的用两位十六进制字符串表示</span></span><br><span class="line">                s = sdscatprintf(s,<span class="string">"\\x%02x"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后添加'"'，作为引用字符串的结束</span></span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Helper function for sdssplitargs() that returns non zero if 'c'</span></span><br><span class="line"><span class="comment"> * is a valid hex digit. */</span></span><br><span class="line"><span class="comment">//判断一个给定字符是否是十六进制数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_hex_digit</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) ||</span><br><span class="line">           (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Helper function for sdssplitargs() that converts an hex digit into an</span></span><br><span class="line"><span class="comment"> * integer from 0 to 15 */</span></span><br><span class="line"><span class="comment">//把单个十六进制字符转换为相应的十进制数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex_digit_to_int</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'1'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>: <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'4'</span>: <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'5'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'6'</span>: <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'7'</span>: <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'8'</span>: <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'9'</span>: <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>: <span class="keyword">case</span> <span class="string">'B'</span>: <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>: <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'d'</span>: <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'E'</span>: <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'f'</span>: <span class="keyword">case</span> <span class="string">'F'</span>: <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split a line into arguments, where every argument can be in the</span></span><br><span class="line"><span class="comment"> * following programming-language REPL-alike form:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * foo bar "newline are supported\n" and "\xff\x00otherstuff"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The number of arguments is stored into *argc, and an array</span></span><br><span class="line"><span class="comment"> * of sds is returned. The caller should sdsfree() all the returned</span></span><br><span class="line"><span class="comment"> * strings and finally zfree() the array itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that sdscatrepr() is able to convert back a string into</span></span><br><span class="line"><span class="comment"> * a quoted string in the same format sdssplitargs() is able to parse.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//命令行解析，argc存放解析后的参数个数</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = line;</span><br><span class="line">    <span class="keyword">char</span> *current = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> **<span class="built_in">vector</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* skip blanks */</span></span><br><span class="line">        <span class="keyword">while</span>(*p &amp;&amp; <span class="built_in">isspace</span>(*p)) p++;</span><br><span class="line">        <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">            <span class="comment">/* get a token */</span></span><br><span class="line">            <span class="keyword">int</span> inq=<span class="number">0</span>; <span class="comment">/* set to 1 if we are in "quotes" */</span></span><br><span class="line">            <span class="keyword">int</span> done=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面已经把current重置成NULL了，这个判断多此一举</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) current = sdsempty();</span><br><span class="line">            <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">                <span class="comment">//双引号内的解析</span></span><br><span class="line">                <span class="comment">//在双引号内部不关心分隔符，读到右双引号才算读完一个参数</span></span><br><span class="line">                <span class="keyword">if</span> (inq) &#123;</span><br><span class="line">                    <span class="comment">//读到一个以'\x'开头的表示两位十六进制整数的字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="string">'x'</span> &amp;&amp;</span><br><span class="line">                                             is_hex_digit(*(p+<span class="number">2</span>)) &amp;&amp;</span><br><span class="line">                                             is_hex_digit(*(p+<span class="number">3</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</span><br><span class="line">                        <span class="comment">//转换成十进制格式的字符串</span></span><br><span class="line">                        byte = (hex_digit_to_int(*(p+<span class="number">2</span>))*<span class="number">16</span>)+</span><br><span class="line">                                hex_digit_to_int(*(p+<span class="number">3</span>));</span><br><span class="line">                        <span class="comment">//追加到current尾部</span></span><br><span class="line">                        current = sdscatlen(current,(<span class="keyword">char</span>*)&amp;byte,<span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//跳过这个十六进制的数，接着读下个字符</span></span><br><span class="line">                        p += <span class="number">3</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="comment">//处理'\'开头的特殊字符</span></span><br><span class="line">                        <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">                        p++;</span><br><span class="line">                        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'n'</span>: c = <span class="string">'\n'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'r'</span>: c = <span class="string">'\r'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'t'</span>: c = <span class="string">'\t'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'b'</span>: c = <span class="string">'\b'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'a'</span>: c = <span class="string">'\a'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: c = *p; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//特殊字符也追加到current尾部，因为都在一个双引号的引用内</span></span><br><span class="line">                        current = sdscatlen(current,&amp;c,<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'"'</span>) &#123;</span><br><span class="line">                        <span class="comment">/* closing quote must be followed by a space */</span></span><br><span class="line">                        <span class="comment">//读到右双引号表示读取完毕，跳出循环，但是与下个参数的分隔符必须是空格，否则报错</span></span><br><span class="line">                        <span class="keyword">if</span> (*(p+<span class="number">1</span>) &amp;&amp; !<span class="built_in">isspace</span>(*(p+<span class="number">1</span>))) <span class="keyword">goto</span> err;</span><br><span class="line">                        done=<span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!*p) &#123;</span><br><span class="line">                        <span class="comment">/* unterminated quotes */</span></span><br><span class="line">                        <span class="comment">//没读到右双引号就读完了，说明命令行参数写错了，报error</span></span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//剩下的情况就是一般字符，直接追加到current尾部</span></span><br><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//双引号外的解析</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">                    <span class="comment">//读到分割符，done=1表示当前参数解析完毕</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\0'</span>:</span><br><span class="line">                        done=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//读到双引号</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                        inq=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">//如果是一般字符，就追加到current尾部，跳出循环开始读下个字符</span></span><br><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没有break就接着读下个字符</span></span><br><span class="line">                <span class="keyword">if</span> (*p) p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* add the token to the vector */</span></span><br><span class="line">            <span class="comment">//事先不知道能解析出多少个参数，只能读到一个就扩容一个空位</span></span><br><span class="line">            <span class="built_in">vector</span> = zrealloc(<span class="built_in">vector</span>,((*argc)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">            <span class="comment">//读出的参数先是保存在current中，再存入vector中</span></span><br><span class="line">            <span class="built_in">vector</span>[*argc] = current;</span><br><span class="line">            (*argc)++;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//返回解析出的参数列表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="comment">//和上面的tokens一样，指针数组的指针要内外分别释放</span></span><br><span class="line">    <span class="keyword">while</span>((*argc)--)</span><br><span class="line">        sdsfree(<span class="built_in">vector</span>[*argc]);</span><br><span class="line">    zfree(<span class="built_in">vector</span>);</span><br><span class="line">    <span class="keyword">if</span> (current) sdsfree(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-双端链表"><a href="#2-3-双端链表" class="headerlink" title="2.3 双端链表"></a>2.3 双端链表</h2><h3 id="adlist-h"><a href="#adlist-h" class="headerlink" title="adlist.h"></a>adlist.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adlist.h - A generic doubly linked list implementation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ADLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ADLIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//指向后一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//value是void类型，表示链表可以保存各种不同类型的值，相当于多态</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于访问链表的迭代器，双向链表自然支持双向迭代</span></span><br><span class="line"><span class="comment">//迭代器并不保存链表，只是标记链表的一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    <span class="comment">//下个待访问的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="comment">//迭代访问的方向，AL_START_HEAD表示向前，AL_START_TAIL表示向后，在后面的宏定义里</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向头结点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//指向尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//提供了三个函数指针, 供用户传入自定义函数</span></span><br><span class="line">    <span class="comment">//dup用于复制节点所保存的值，free用于释放节点所保存的值(因为节点值是void指针)，match用于匹配节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//链表长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="comment">//把指针的操作封装成了宏的类型，方便了程序员的使用</span></span><br><span class="line"><span class="comment">//l表示list指针，n表示listNode指针，m表示函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="comment">//迭代链表的方向</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __ADLIST_H__ */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="adlist-c"><a href="#adlist-c" class="headerlink" title="adlist.c"></a>adlist.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adlist.c - A generic doubly linked list implementation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"adlist.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new list. The created list can be freed with</span></span><br><span class="line"><span class="comment"> * AlFreeList(), but private value of every node need to be freed</span></span><br><span class="line"><span class="comment"> * by the user before to call AlFreeList().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned. Otherwise the pointer to the new list. */</span></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="comment">//空参数实际上表示函数需要不确定个数的参数，比如main()，而void参数才是明确告诉编译器函数不需要参数</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line">    <span class="comment">//空间不足就退出</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//返回链表指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free the whole list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can't fail. */</span></span><br><span class="line"><span class="comment">//释放链表</span></span><br><span class="line"><span class="comment">//先释放listNode的value指针，再释放listNode指针，释放完所有节点后再释放list指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new node to the list, to head, contaning the specified 'value'</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the 'list' pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="comment">//给定一个值value和链表list，根据value构造新节点添加到list的表头</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line">    <span class="comment">//申请空节点</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//给节点赋值</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="comment">//设置链表的头尾指针和新节点的前后指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新链表长度</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new node to the list, to tail, contaning the specified 'value'</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the 'list' pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="comment">//给定一个值value和链表list，根据value构造新节点添加到list的尾部</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个包含给定值value的新节点添加到给定节点old_node的之前或者之后</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="comment">//after==0表示新节点添加到old_node前面，否则就是添加到后面</span></span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让新节点的前后节点指向该新节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove the specified node from the specified list.</span></span><br><span class="line"><span class="comment"> * It's up to the caller to free the private value of the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can't fail. */</span></span><br><span class="line"><span class="comment">//从链表中删除给定节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a list iterator 'iter'. After the initialization every</span></span><br><span class="line"><span class="comment"> * call to listNext() will return the next element of the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can't fail. */</span></span><br><span class="line"><span class="comment">//指定迭代方向，获取链表的迭代器</span></span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">    <span class="comment">//正向迭代从头结点开始</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//反向迭代从尾结点开始</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release the iterator memory */</span></span><br><span class="line"><span class="comment">//释放迭代器，就是给zfree指定了参数类型，多此一举</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an iterator in the list private iterator structure */</span></span><br><span class="line"><span class="comment">//重置迭代器li，起点设为链表头结点，方向设为自前向后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置迭代器li，起点设为链表尾结点，方向设为自后向前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the next element of an iterator.</span></span><br><span class="line"><span class="comment"> * It's valid to remove the currently returned element using</span></span><br><span class="line"><span class="comment"> * listDelNode(), but not to remove other elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns a pointer to the next element of the list,</span></span><br><span class="line"><span class="comment"> * or NULL if there are no more elements, so the classical usage patter</span></span><br><span class="line"><span class="comment"> * is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * iter = listGetIterator(list,&lt;direction&gt;);</span></span><br><span class="line"><span class="comment"> * while ((node = listNext(iter)) != NULL) &#123;</span></span><br><span class="line"><span class="comment"> *     doSomethingWith(listNodeValue(node));</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">//返回迭代器指向的下一个节点，然后根据迭代方向更新迭代器指向的节点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Duplicate the whole list. On out of memory NULL is returned.</span></span><br><span class="line"><span class="comment"> * On success a copy of the original list is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The 'Dup' method set with listSetDupMethod() function is used</span></span><br><span class="line"><span class="comment"> * to copy the node value. Otherwise the same pointer value of</span></span><br><span class="line"><span class="comment"> * the original node is used as value of the copied node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The original list both on success or error is never modified. */</span></span><br><span class="line"><span class="comment">//复制整个链表orig，返回新副本链表的指针</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//先复制orig的三个方法</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    <span class="comment">//获取orig的迭代器，逐个节点进行复制</span></span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//复制出错，清理迭代器和copy并退出</span></span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="comment">//根据value构造新节点添加到copy末尾</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器用完就释放</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search the list for a node matching a given key.</span></span><br><span class="line"><span class="comment"> * The match is performed using the 'match' method</span></span><br><span class="line"><span class="comment"> * set with listSetMatchMethod(). If no 'match' method</span></span><br><span class="line"><span class="comment"> * is set, the 'value' pointer of every node is directly</span></span><br><span class="line"><span class="comment"> * compared with the 'key' pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success the first matching node pointer is returned</span></span><br><span class="line"><span class="comment"> * (search starts from head). If no matching node exists</span></span><br><span class="line"><span class="comment"> * NULL is returned. */</span></span><br><span class="line"><span class="comment">//获取链表中节点值等于给定key的节点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line">    <span class="comment">//利用迭代器遍历</span></span><br><span class="line">    iter = listGetIterator(<span class="built_in">list</span>, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the element at the specified zero-based index</span></span><br><span class="line"><span class="comment"> * where 0 is the head, 1 is the element next to head</span></span><br><span class="line"><span class="comment"> * and so on. Negative integers are used in order to count</span></span><br><span class="line"><span class="comment"> * from the tail, -1 is the last element, -2 the penultimante</span></span><br><span class="line"><span class="comment"> * and so on. If the index is out of range NULL is returned. */</span></span><br><span class="line"><span class="comment">//返回链表在给定索引上的节点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line">    <span class="comment">//支持负索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//负索引是从尾节点倒着数</span></span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//正索引是从头结点正着数</span></span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-字典"><a href="#2-4-字典" class="headerlink" title="2.4 字典"></a>2.4 字典</h2><h3 id="dict-h"><a href="#dict-h" class="headerlink" title="dict.h"></a>dict.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hash Tables Implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DICT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DICT_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的状态码，DICT_OK表示对字典的操作成功，DICT_ERR表示操作失败</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_OK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_ERR 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unused arguments generate annoying warnings... */</span></span><br><span class="line"><span class="comment">//没用到</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_NOTUSED(V) ((void) V)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字典表项，一个key-value对</span></span><br><span class="line"><span class="comment">//因为采用拉链法处理哈希碰撞，所以需要一个指针所在链表的下一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">void</span> *val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典需要的一组函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="comment">//字典使用的哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组，数组中的每个元素都是一个指向某个dictEntry的指针</span></span><br><span class="line">    <span class="comment">//也就是拉链法需要的链表的链表，第一层链表(桶链表)的每个元素是第二层链表的头节点，第二层的链表(节点链表)存储哈希值相同的dictEntry元素</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//table的大小，也就是桶的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值。sizemask=size-1，给定dictEntry节点的key的哈希值计算出来后，与sizemask进行按位与操作，决定该节点应该被放在桶链表的哪个桶里</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//哈希表已有dictEntry节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">//为字典设置的针对不同数据类型的特定函数簇</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据，保存了需要传给type中特定函数的可选参数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//一个字典使用了两个哈希表，用户使用的是0号哈希表，1号哈希表用于对0号哈希表进行rehash</span></span><br><span class="line">    <span class="comment">//rehash的目的是提高哈希表的查找效率。因为要映射哈希值的缘故，桶链表的长度在创建以后就不能改了，随着节点的增多，哈希表的负载因子会越来越大(负载因子=总节点数/桶链表长度)，表现为桶不够用了，使得节点链表过长，查询操作会在节点链表上浪费时间。所以rehash就是新建一个更长的桶链表，把节点疏散开。反之，如果节点数过少，rehash的过程就是新建一个更短的桶链表，不让节点分布太疏散。rehash完成后，就用1号哈希表替换0号哈希表，所以1号哈希表只是辅助rehash的，用户无需访问。</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash标示，为-1表示不在rehash，不为0表示正在rehash的桶序号</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">//当前正在运行的安全迭代器数量</span></span><br><span class="line">    <span class="comment">//存在安全迭代器就不会进行rehash，也就不会有节点被偷偷迁移到1号哈希表，保证了迭代的准确性</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iteartor, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="comment">//字典的迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    <span class="comment">//被迭代的字典</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="comment">//table是当前正在迭代的哈希表序号，取值为0或1</span></span><br><span class="line">    <span class="comment">//index是迭代器当前所指向的桶索引位置</span></span><br><span class="line">    <span class="comment">//safe标识此迭代器是否安全。safe=1表示安全，迭代时可以对节点增删改查，否则就是不安全的，只能迭代哈希表而不能修改</span></span><br><span class="line">    <span class="keyword">int</span> table, index, safe;</span><br><span class="line">    <span class="comment">//entry是当前迭代到的节点的指针</span></span><br><span class="line">    <span class="comment">//nextEntry是当前迭代节点的下一个节点。因为在迭代时entry指针可能会被修改，所以要单独保存下个节点的地址，防止丢失链接</span></span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">&#125; dictIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the initial size of every hash table */</span></span><br><span class="line"><span class="comment">//哈希表的初始长度，即桶的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HT_INITIAL_SIZE     4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------- Macros ------------------------------------*/</span></span><br><span class="line"><span class="comment">//宏定义函数，d表示字典dict，entry表示节点dictEntry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点的val指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeEntryVal(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;val)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置节点的val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetHashVal(d, entry, _val_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span><br><span class="line">        <span class="comment">//如果定义了复制值的函数，就调用该函数完成</span></span><br><span class="line">        entry-&gt;val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;val = (_val_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点的key指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeEntryKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置节点的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetHashKey(d, entry, _key_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span><br><span class="line">        entry-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;key = (_key_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictCompareHashKeys(d, key1, key2) \</span></span><br><span class="line">    (((d)-&gt;type-&gt;keyCompare) ? \</span><br><span class="line">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span><br><span class="line">        (key1) == (key2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算key的哈希值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取节点的key和val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetEntryKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetEntryVal(he) ((he)-&gt;val)</span></span><br><span class="line"><span class="comment">//计算字典中两个哈希表的总大小(桶的数量)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)</span></span><br><span class="line"><span class="comment">//计算字典中两个哈希表的总节点数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="comment">//是否正在进行rehash</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictIsRehashing(ht) ((ht)-&gt;rehashidx != -1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hash table types */</span></span><br><span class="line"><span class="comment">//作者的样例代码用到的，实际没啥用</span></span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStringCopyKey;</span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStrings;</span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStringCopyKeyValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __DICT_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="dict-c"><a href="#dict-c" class="headerlink" title="dict.c"></a>dict.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hash Tables Implementation.*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmacros.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dict.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Using dictEnableResize() / dictDisableResize() we make possible to</span></span><br><span class="line"><span class="comment"> * enable/disable resizing of the hash table as needed. This is very important</span></span><br><span class="line"><span class="comment"> * for Redis, as we use copy-on-write and don't want to move too much memory</span></span><br><span class="line"><span class="comment"> * around when there is a child performing saving operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that even when dict_can_resize is set to 0, not all resizes are</span></span><br><span class="line"><span class="comment"> * prevented: an hash table is still allowed to grow if the ratio between</span></span><br><span class="line"><span class="comment"> * the number of elements and the buckets &gt; dict_force_resize_ratio. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dict_can_resize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dict_force_resize_ratio = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------- private prototypes ---------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *ht);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictInit(dict *ht, dictType *type, <span class="keyword">void</span> *privDataPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------- hash functions -------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thomas Wang's 32 bit Mix Function */</span></span><br><span class="line"><span class="comment">//针对整型的哈希函数，把整型key转换成对应的哈希值，作为哈希表的键值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictIntHashFunction</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">10</span>);</span><br><span class="line">    key +=  (key &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">6</span>);</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">11</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Identity hash function for integer keys */</span></span><br><span class="line"><span class="comment">//不使用哈希函数，直接把整型作为哈希表的key</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictIdentityHashFunction</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generic hash function (a popular one from Bernstein).</span></span><br><span class="line"><span class="comment"> * I tested a few and this was the best. */</span></span><br><span class="line"><span class="comment">//djb哈希算法，一种通用的哈希函数，计算字符串buf的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//hash seed</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">        <span class="comment">//字符串的ascii值与hash seed做运算</span></span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + (*buf++); <span class="comment">/* hash * 33 + c */</span></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* And a case insensitive version */</span></span><br><span class="line"><span class="comment">//大小写无关的djb哈希算法</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + (<span class="built_in">tolower</span>(*buf++)); <span class="comment">/* hash * 33 + c */</span></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------------------------- API implementation ------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset an hashtable already initialized with ht_init().</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This function should only called by ht_destroy(). */</span></span><br><span class="line"><span class="comment">//初始化或重置哈希表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    ht-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">    ht-&gt;size = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;sizemask = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new hash table */</span></span><br><span class="line"><span class="comment">//创建新的空字典</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *privDataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</span><br><span class="line">    <span class="comment">//申请到空间后做初始化</span></span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    <span class="comment">//返回字典指针</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the hash table */</span></span><br><span class="line"><span class="comment">//字典的初始化函数</span></span><br><span class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</span><br><span class="line">        <span class="keyword">void</span> *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重置字典的两个哈希表</span></span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//初始化赋值</span></span><br><span class="line">    d-&gt;type = type;</span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//返回成功的状态码</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USER/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="comment">//调整字典d中哈希表的size，保证每个节点占一个单独的桶，但长度可能有冗余，因为哈希表长度必须是DICT_HT_INITIAL_SIZE乘以2的幂次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line">    <span class="comment">//如果不支持resize，或者字典正在rehash，返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">//桶的数量定为0号哈希表的总节点数，但不能少于初始化的DICT_HT_INITIAL_SIZE</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="comment">//调用dictExpand对哈希表扩容</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand or create the hashtable */</span></span><br><span class="line"><span class="comment">//哈希表扩容函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht n; <span class="comment">/* the new hashtable */</span></span><br><span class="line">    <span class="comment">//计算实际的扩容长度，结果是DICT_HT_INITIAL_SIZE乘以2的幂次</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hashtable */</span></span><br><span class="line">    <span class="comment">//若字典正在rehash，需要等待rehash完成再扩容</span></span><br><span class="line">    <span class="comment">//若节点数大于扩容的长度，说明出了问题，具体什么问题？</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hashtable and initialize all pointers to NULL */</span></span><br><span class="line">    <span class="comment">//初始化扩容的哈希表</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it's not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前字典的0号哈希表是空，就把新哈希表赋给0号，可以直接使用</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    <span class="comment">//如果当前字典有正在使用的0号哈希表，就把新哈希表先赋给1号，之后rehash的时候再赋给0号</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * thank one key as we use chaining) from the old to the new hash table. */</span></span><br><span class="line"><span class="comment">//字典的rehash函数，采用分n步渐进式的rehash，因为当前的字典可能非常庞大，如果一次性把0号表的节点全部迁移到1号表，可能会占用大量时间和资源，影响系统性能，所以redis实际上是把rehash操作平摊到 dictAddRaw 、dictGetRandomKey 、dictFind 、dictGenericDelete 这些函数里，每当这些函数被执行的时候, 就会顺便执行_dictRehashStep函数，_dictRehashStep再调用dictRehash来迁移部分节点。此外还有dictRehashMilliseconds函数，支持在给定的时间段内集中进行rehash。</span></span><br><span class="line"><span class="comment">//参数n表示本次要迁移的桶的数量</span></span><br><span class="line"><span class="comment">//返回1说明rehash还没完，继续下一步，返回0就表示rehash已经完成</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询字典的rehashidx标志，如果表示已经rehash完毕，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环迁移n个桶中的节点</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="comment">//辅助指针，用于迭代当前桶中的节点链表</span></span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">        <span class="comment">//0号表节点数为0说明已经全部迁移完成，此时用1号表替换0号表，然后重置1号表，修改rehashidx标志，返回0表示rehash完毕</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">            zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">            d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        <span class="comment">//当前的桶迁移完毕后开始迁移下一个桶</span></span><br><span class="line">        <span class="comment">//这里桶的索引不会越界，因为越界说明0号表已经全部清空了，这在前面已经判断过了</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</span><br><span class="line">        <span class="comment">//把当前桶中节点链表的头节点赋给de</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="comment">//把当前桶中的所有节点迁移到1号表</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">//用字典的type函数簇里的哈希函数计算当前节点key的哈希值，与1号表的掩码按位与，得到在1号表中的桶索引</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            <span class="comment">//节点总是被插入到1号表的节点链表的表头</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            <span class="comment">//更新两个表的节点数</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为迁移过程是用辅助指针做的，所以最后还要把0号表当前桶中的链表指针设为NULL，表示桶已经清空</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否rehash完毕要在函数头部检查，此时无脑返回1即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的毫秒时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">timeInMilliseconds</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">long</span> <span class="keyword">long</span>)tv.tv_sec)*<span class="number">1000</span>)+(tv.tv_usec/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</span></span><br><span class="line"><span class="comment">//在给定的毫秒时间段内集中进行rehash</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次迁移100个桶</span></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//时间到了就中止rehash</span></span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回桶索引</span></span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function performs just a step of rehashing, and only if there are</span></span><br><span class="line"><span class="comment"> * no safe iterators bound to our hash table. When we have iterators in the</span></span><br><span class="line"><span class="comment"> * middle of a rehashing we can't mess with the two hash tables otherwise</span></span><br><span class="line"><span class="comment"> * some element can be missed or duplicated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called by common lookup or update operations in the</span></span><br><span class="line"><span class="comment"> * dictionary so that the hash table automatically migrates from H1 to H2</span></span><br><span class="line"><span class="comment"> * while it is actively used. */</span></span><br><span class="line"><span class="comment">//如果当前字典没有迭代器，执行一步rehash，迁移一个桶的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="comment">//向字典插入dictEntry节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="comment">//根据节点的key计算应该放入的桶序号。哈希碰撞指的是索引冲突</span></span><br><span class="line">    <span class="comment">//当key已经在字典中，插入失败，返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocates the memory and stores key */</span></span><br><span class="line">    <span class="comment">//如果正在rehash，就往1号表里插，否则直接往0号表插</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">//插入到节点链表的头部</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    <span class="comment">//把key和val赋给新节点</span></span><br><span class="line">    dictSetHashKey(d, entry, key);</span><br><span class="line">    dictSetHashVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add an element, discarding the old if the key already exists.</span></span><br><span class="line"><span class="comment"> * Return 1 if the key was added from scratch, 0 if there was already an</span></span><br><span class="line"><span class="comment"> * element with such key and dictReplace() just performed a value update</span></span><br><span class="line"><span class="comment"> * operation. */</span></span><br><span class="line"><span class="comment">//向字典插入dictEntry节点，若key已经存在就更新val</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry, auxentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to add the element. If the key</span></span><br><span class="line"><span class="comment">     * does not exists dictAdd will suceed. */</span></span><br><span class="line">    <span class="comment">//能插就插</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* It already exists, get the entry */</span></span><br><span class="line">    <span class="comment">//插入失败说明key已经存在，获取对应的节点</span></span><br><span class="line">    entry = dictFind(d, key);</span><br><span class="line">    <span class="comment">/* Free the old value and set the new one */</span></span><br><span class="line">    <span class="comment">/* Set the new value and free the old one. Note that it is important</span></span><br><span class="line"><span class="comment">     * to do that in this order, as the value may just be exactly the same</span></span><br><span class="line"><span class="comment">     * as the previous one. In this context, think to reference counting,</span></span><br><span class="line"><span class="comment">     * you want to increment (set), and then decrement (free), and not the</span></span><br><span class="line"><span class="comment">     * reverse. */</span></span><br><span class="line">    <span class="comment">//更新节点的val，释放旧的val指针</span></span><br><span class="line">    auxentry = *entry;</span><br><span class="line">    dictSetHashVal(d, entry, val);</span><br><span class="line">    dictFreeEntryVal(d, &amp;auxentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search and remove an element */</span></span><br><span class="line"><span class="comment">//删除字典中给定key的结点，可控制是否调用释放方法</span></span><br><span class="line"><span class="comment">//节点指针一定会被释放，nofree参数用于指定是否要释放节点中key和val的指针</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line">    <span class="comment">//如果字典的0号表是NULL，返回错误码。空的表size一般不是0，没初始化的表才是NULL</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR; <span class="comment">/* d-&gt;ht[0].table is NULL */</span></span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//用字典的type函数簇里的哈希函数计算节点key的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">//不知道节点在哪个表，所以都查一遍</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">//key的哈希值与表的掩码按位与，得到桶索引</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">//得到节点链表的头节点</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="comment">//保存前一个节点，删除节点后用于重连</span></span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="comment">//比较两个key，如果type函数簇中有自定义的比较函数，调用之</span></span><br><span class="line">            <span class="keyword">if</span> (dictCompareHashKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="comment">//断开目标节点的链接</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeEntryKey(d, he);</span><br><span class="line">                    dictFreeEntryVal(d, he);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//释放节点指针</span></span><br><span class="line">                zfree(he);</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> DICT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历完0号表，如果当前没有在rehash，就不用再查1号表了，因为肯定是空的</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点，同时释放节点的key和val指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点，但不释放节点的key和val指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy an entire dictionary */</span></span><br><span class="line"><span class="comment">//清空字典中指定的哈希表</span></span><br><span class="line"><span class="keyword">int</span> _dictClear(dict *d, dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free all the elements */</span></span><br><span class="line">    <span class="comment">//遍历指定表ht的桶</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        dictEntry *he, *nextHe;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((he = ht-&gt;table[i]) == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//逐个节点进行free</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            nextHe = he-&gt;next;</span><br><span class="line">            dictFreeEntryKey(d, he);</span><br><span class="line">            dictFreeEntryVal(d, he);</span><br><span class="line">            zfree(he);</span><br><span class="line">            ht-&gt;used--;</span><br><span class="line">            he = nextHe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Free the table and the allocated cache structure */</span></span><br><span class="line">    <span class="comment">//所有桶都清空后，释放哈希表的指针</span></span><br><span class="line">    zfree(ht-&gt;table);</span><br><span class="line">    <span class="comment">/* Re-initialize the table */</span></span><br><span class="line">    <span class="comment">//把ht重置成NULL</span></span><br><span class="line">    _dictReset(ht);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">/* never fails */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clear &amp; Release the hash table */</span></span><br><span class="line"><span class="comment">//清空整个字典，也就是先分别清空两个哈希表，再释放字典指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    zfree(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字典中指定key的节点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    <span class="comment">//0号表是NULL，说明整个字典都是空的</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* We don't have a table at all */</span></span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//计算key的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">//遍历两个哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">//计算桶索引</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">//获取节点链表的表头</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="comment">//遍历节点链表，找到就返回</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareHashKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前没有在rehash，不用再查1号表</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定key节点的val指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dictFetchValue</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    he = dictFind(d,key);</span><br><span class="line">    <span class="keyword">return</span> he ? dictGetEntryVal(he) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器，默认迭代0号表(迭代完会自动切换到1号表)，不安全，只设置字典而不设置节点指针</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line"></span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取安全迭代器</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器获取下一个节点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没设置节点指针，先获取迭代的表</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;safe &amp;&amp; iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//条件里有safe，所以字典的iterators属性其实是记录安全迭代器的数量</span></span><br><span class="line">                iter-&gt;d-&gt;iterators++;</span><br><span class="line">            <span class="comment">//桶索引归零</span></span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">//如果恰好遍历完当前的表，桶索引会越界</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">signed</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="comment">//如果遍历完的是0号表且正在rehash，说明1号表也有节点，把迭代的表切换到1号表</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//如果遍历完的是1号表，或者没有在rehash，说明整个字典的全部节点都遍历完了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置当前迭代的节点</span></span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//entry不为NULL，表示应该返回nextEntry</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the 'next' here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            <span class="comment">//用户怎么处理得到的entry节点都无所谓，反正已经事先设置了nextEntry节点，迭代器不会丢失指针</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//字典的iterators增加后，迭代器的index一定不是-1，所以(iter-&gt;index == -1 &amp;&amp; iter-&gt;table == 0)说明没有调用过dictNext，字典的iterators也就没有增加过，所以不需要减一</span></span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;safe &amp;&amp; !(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>))</span><br><span class="line">        iter-&gt;d-&gt;iterators--;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a random entry from the hash table. Useful to</span></span><br><span class="line"><span class="comment"> * implement randomized algorithms */</span></span><br><span class="line"><span class="comment">//获取字典中一个随机的节点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictGetRandomKey</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he, *orighe;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">int</span> listlen, listele;</span><br><span class="line">    <span class="comment">//如果两个哈希表的总节点数是0，就没有可返回的节点</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//如果正在rehash，随机的范围就是两个表的桶，通过判断桶里的表头指针是不是NULL，可以保证随机到的桶不是空的</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() % (d-&gt;ht[<span class="number">0</span>].size+d-&gt;ht[<span class="number">1</span>].size);</span><br><span class="line">            he = (h &gt;= d-&gt;ht[<span class="number">0</span>].size) ? d-&gt;ht[<span class="number">1</span>].table[h - d-&gt;ht[<span class="number">0</span>].size] :</span><br><span class="line">                                      d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果没有在rehash，随机的范围只有0号表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() &amp; d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">            he = d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we found a non empty bucket, but it is a linked</span></span><br><span class="line"><span class="comment">     * list and we need to get a random element from the list.</span></span><br><span class="line"><span class="comment">     * The only sane way to do so is counting the elements and</span></span><br><span class="line"><span class="comment">     * select a random index. */</span></span><br><span class="line">    listlen = <span class="number">0</span>;</span><br><span class="line">    orighe = he;</span><br><span class="line">    <span class="comment">//计算桶里的节点数</span></span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">        listlen++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机选一个节点</span></span><br><span class="line">    listele = random() % listlen;</span><br><span class="line">    he = orighe;</span><br><span class="line">    <span class="keyword">while</span>(listele--) he = he-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------- private functions ------------------------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="comment">//推断是否需要扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="comment">//如果正在扩容，返回0，表示不需要</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the intial size. */</span></span><br><span class="line">    <span class="comment">//如果0号表长度是0，先扩展到长度下限DICT_HT_INITIAL_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the "safe" threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="comment">//如果字典支持resize，每当负载因子大于等于1，就触发扩容</span></span><br><span class="line">    <span class="comment">//如果不支持resize，只有负载因子超过预设的dict_force_resize_ratio时，才触发强制扩容</span></span><br><span class="line">    <span class="comment">//扩容后的长度是总节点数的两倍</span></span><br><span class="line">    <span class="comment">//先扩容才能rehash</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里为什么还要判断d-&gt;ht[0].size &gt; d-&gt;ht[0].used？</span></span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, ((d-&gt;ht[<span class="number">0</span>].size &gt; d-&gt;ht[<span class="number">0</span>].used) ?</span><br><span class="line">                                    d-&gt;ht[<span class="number">0</span>].size : d-&gt;ht[<span class="number">0</span>].used)*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="comment">//计算哈希表实际的扩容长度</span></span><br><span class="line"><span class="comment">//实际长度必须是DICT_HT_INITIAL_SIZE值乘以2的幂次，结果不小于给定的size，但不能大于long int的上限</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the index of a free slot that can be populated with</span></span><br><span class="line"><span class="comment"> * an hash entry for the given 'key'.</span></span><br><span class="line"><span class="comment"> * If the key already exists, -1 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if we are in the process of rehashing the hash table, the</span></span><br><span class="line"><span class="comment"> * index is always returned in the context of the second (new) hash table. */</span></span><br><span class="line"><span class="comment">//计算给定的key在哈希表中的索引</span></span><br><span class="line"><span class="comment">//字典的key是唯一的，但索引是可以冲突的。哈希碰撞不是key重复，而是不同的key被放在了同一个桶里</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hashtable if needed */</span></span><br><span class="line">    <span class="comment">//先判断要不要扩容，返回错误码说明需要扩容但是扩容失败</span></span><br><span class="line">    <span class="comment">//但是为什么选在这个时候扩容？</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* Compute the key hash value */</span></span><br><span class="line">    <span class="comment">//计算key的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">//依次计算在两个表中的桶索引，如果正在rehash，返回的就是1号表中的索引，否则返回0号表中的索引</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareHashKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空整个字典，清空和销毁不一样，只释放哈希表指针，不释放字典指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调试函数，输出哈希表的相关信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_STATS_VECTLEN 50</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictPrintStatsHt(dictht *ht) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i, slots = <span class="number">0</span>, chainlen, maxchainlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> totchainlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> clvector[DICT_STATS_VECTLEN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;used == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No stats available for empty dictionaries\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DICT_STATS_VECTLEN; i++) clvector[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size; i++) &#123;</span><br><span class="line">        dictEntry *he;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ht-&gt;table[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            clvector[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slots++;</span><br><span class="line">        <span class="comment">/* For each hash entry on this slot... */</span></span><br><span class="line">        chainlen = <span class="number">0</span>;</span><br><span class="line">        he = ht-&gt;table[i];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            chainlen++;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        clvector[(chainlen &lt; DICT_STATS_VECTLEN) ? chainlen : (DICT_STATS_VECTLEN<span class="number">-1</span>)]++;</span><br><span class="line">        <span class="keyword">if</span> (chainlen &gt; maxchainlen) maxchainlen = chainlen;</span><br><span class="line">        totchainlen += chainlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hash table stats:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" table size: %ld\n"</span>, ht-&gt;size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" number of elements: %ld\n"</span>, ht-&gt;used);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" different slots: %ld\n"</span>, slots);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" max chain length: %ld\n"</span>, maxchainlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" avg chain length (counted): %.02f\n"</span>, (<span class="keyword">float</span>)totchainlen/slots);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" avg chain length (computed): %.02f\n"</span>, (<span class="keyword">float</span>)ht-&gt;used/slots);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" Chain length distribution:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DICT_STATS_VECTLEN<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clvector[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   %s%ld: %ld (%.02f%%)\n"</span>,(i == DICT_STATS_VECTLEN<span class="number">-1</span>)?<span class="string">"&gt;= "</span>:<span class="string">""</span>, i, clvector[i], ((<span class="keyword">float</span>)clvector[i]/ht-&gt;size)*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调试函数，输出字典的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictPrintStats</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    _dictPrintStatsHt(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-- Rehashing into ht[1]:\n"</span>);</span><br><span class="line">        _dictPrintStatsHt(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制是否允许resize</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following are just example hash table types implementations.</span></span><br><span class="line"><span class="comment"> * Not useful for Redis so they are commented out.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//作者的样例代码</span></span><br><span class="line"><span class="comment">/* ----------------------- StringCopy Hash Table Type ------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> _dictStringCopyHTHashFunction(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenHashFunction(key, <span class="built_in">strlen</span>(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_dictStringDup(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="keyword">char</span> *copy = zmalloc(len+<span class="number">1</span>);</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(copy, key, len);</span><br><span class="line">    copy[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictStringCopyHTKeyCompare(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *key2)</span><br><span class="line">&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(key1, key2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictStringDestructor(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    zfree(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictType dictTypeHeapStringCopyKey = &#123;</span><br><span class="line">    _dictStringCopyHTHashFunction, <span class="comment">/* hash function */</span></span><br><span class="line">    _dictStringDup,                <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* val dup */</span></span><br><span class="line">    _dictStringCopyHTKeyCompare,   <span class="comment">/* key compare */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                           <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is like StringCopy but does not auto-duplicate the key.</span></span><br><span class="line"><span class="comment"> * It's used for intepreter's shared strings. */</span></span><br><span class="line">dictType dictTypeHeapStrings = &#123;</span><br><span class="line">    _dictStringCopyHTHashFunction, <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* val dup */</span></span><br><span class="line">    _dictStringCopyHTKeyCompare,   <span class="comment">/* key compare */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                           <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is like StringCopy but also automatically handle dynamic</span></span><br><span class="line"><span class="comment"> * allocated C strings as values. */</span></span><br><span class="line">dictType dictTypeHeapStringCopyKeyValue = &#123;</span><br><span class="line">    _dictStringCopyHTHashFunction, <span class="comment">/* hash function */</span></span><br><span class="line">    _dictStringDup,                <span class="comment">/* key dup */</span></span><br><span class="line">    _dictStringDup,                <span class="comment">/* val dup */</span></span><br><span class="line">    _dictStringCopyHTKeyCompare,   <span class="comment">/* key compare */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-跳跃表"><a href="#2-5-跳跃表" class="headerlink" title="2.5 跳跃表"></a>2.5 跳跃表</h2><h3 id="redis-h-跳跃表相关部分）"><a href="#redis-h-跳跃表相关部分）" class="headerlink" title="redis.h(跳跃表相关部分）"></a>redis.h(跳跃表相关部分）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳跃表就是给有序list添加多级索引，能够以更大的步长遍历list，提高查找效率，属于空间换时间。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32 <span class="comment">/* Should be enough for 2^32 elements */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//跳跃表的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//节点真正存储的数据，类型是redis定义的对象，也是在redis.h中定义的</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">//分值。在跳跃表中，节点按各自所保存的分值从小到大排列</span></span><br><span class="line">    <span class="comment">//跳跃表中各个节点保存的对象必须是唯一的，但多个节点的分值可以是相同的，分值相同的节点将按照对象在字典序中的大小来进行排序</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//后退指针，用于从表尾向表头遍历</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//节点所在层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">//前进指针，用于从表头向表尾遍历</span></span><br><span class="line">        <span class="comment">//一个节点有多个不同跨度的前进指针，但只有一个后退指针，所以只有正向遍历是跳跃的，反向遍历只能退到前一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度(步长)，记录了前进指针所指向的节点到当前节点的距离。因为是有跨度的遍历，所以遍历到某个节点后，将沿途所有经过的节点的跨度相加，就是该节点在跳跃表中的次序(rank)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳跃表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量,表头节点不计算在内，因为头结点只存储层次不存储数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数,表头节点的层数不计算在内</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sorted sets data type */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span></span>;</span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="t-zset-c-跳跃表相关部分"><a href="#t-zset-c-跳跃表相关部分" class="headerlink" title="t_zset.c(跳跃表相关部分)"></a>t_zset.c(跳跃表相关部分)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建跳跃表的节点。设置存储对象和分值，level参数只用于申请空间，level数组并没有初始化</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;obj = obj;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建跳跃表</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">//初始化最高层数是1，不考虑头结点</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//初始节点数0</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//头结点的层数设成上限，分值是0(最小)，存储的对象是NULL。每层初始化前进指针和跨度</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点，这里不用考虑表的链接，因为只有两种情况会释放节点，一个是要释放整个表，链接自然就不用管了，另一个是先删除节点再释放节点，删除节点的函数中已经调整好链接了，这里就不用管了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFreeNode</span><span class="params">(zskiplistNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//节点存储的对象的引用计数减一，在object.c中定义的</span></span><br><span class="line">    decrRefCount(node-&gt;obj);</span><br><span class="line">    <span class="comment">//释放节点指针</span></span><br><span class="line">    zfree(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放跳跃表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next;</span><br><span class="line">    <span class="comment">//先释放头结点</span></span><br><span class="line">    zfree(zsl-&gt;header);</span><br><span class="line">    <span class="comment">//沿着第0层遍历节点并释放，因为第0层的跨度是1，就等于按顺序遍历全部节点</span></span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslFreeNode(node);</span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后释放表的指针</span></span><br><span class="line">    zfree(zsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个介于1和ZSKIPLIST_MAXLEVEL之间的随机值，作为节点的层数</span></span><br><span class="line"><span class="comment">//根据幂次定律(power law)，越大的层数产生的几率就越小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//random返回一个long int范围内的随机整数，random()&amp;0xFFFF的结果就是一个0到65535的随机整数</span></span><br><span class="line">    <span class="comment">//ZSKIPLIST_P=0.25，每次level只有1/4的概率加一，所以结果就是越大的数越难得到</span></span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定分值和存储对象，创建新节点并插入跳跃表，返回该节点指针</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//update数组存放寻找新节点位置的过程中经过的节点</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">//rank数组存放寻找新节点位置的过程中经过的节点的跨度累加和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line">    <span class="comment">//从头节点正向遍历</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//从高层到低层遍历，相当于先查高层索引再查低层索引，步子迈得越来越小，最后定位到新节点应该存放的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        <span class="comment">//遍历过程中记录的跨度是累加和，不是单个节点的跨度</span></span><br><span class="line">        <span class="comment">//因为i是从大到小，所以最终的跨度和是存在rank[0]里，所以这里是先把上一层的rank值继承下来</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//因为跳跃表从小到大排序，所以要找到当前层第一个分值大于新节点，或者分值相同但字典序大于新节点的节点，此时退出循环，x就是本层中新节点的左侧邻居节点。但新节点插入的位置必须精确到真正相邻的两个节点之间，而高层里相邻的节点跨度可能大于1，并不是真正相邻，所以要进入下一层继续精确新节点的左邻居，直到新节点的左右邻居跨度是1，新节点只能插入这个唯一的间隙中，才算真正确定了插入位置。</span></span><br><span class="line">        <span class="comment">//只有在没找到本层的左邻居时，rank值才会增加，所以rank[i]并不包括update[i]的跨度，所以rank[i]代表的是找到左邻居的过程中在本层遍历的总距离。又因为在当前层一定是从上一层左邻居的位置开始向右遍历，所以最后累加得到的rank[0]就是从头节点到新节点真正左邻居的距离。</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="comment">//继承下来的rank值加上当前节点的rank值</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录新节点在第i层的左邻居</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the key is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, and the re-insertion of score and redis object should never</span></span><br><span class="line"><span class="comment">     * happpen since the caller of zslInsert() should test in the hash table</span></span><br><span class="line"><span class="comment">     * if the element is already inside or not. */</span></span><br><span class="line">    <span class="comment">//新节点的最高层数是随机的</span></span><br><span class="line">    <span class="comment">//为什么不把索引设成固定间隔的？随机的会不会性能不太好？</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">//如果新节点的最高层比整个表的最高层(不包括头节点)低，那么新节点最高层以上的层次就不用关心了</span></span><br><span class="line">    <span class="comment">//反之，如果新节点最高层创了新高，就需要多做一些修改</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//因为是前所未有的新高层，所以左邻居只能是头节点</span></span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            <span class="comment">//头节点的跨度为什么是节点数？不应该是rank[0]吗？</span></span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新跳跃表的最高层数</span></span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新节点</span></span><br><span class="line">    x = zslCreateNode(level,score,obj);</span><br><span class="line">    <span class="comment">//与每一层的左右邻居做链接</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">//插入以后，原本是新节点左邻居的右邻居就成了新节点的右邻居，用前进指针链接</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">//新节点x就成了他左邻居的右邻居，用前进指针链接</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        <span class="comment">//update[i]-&gt;level[i].span是第i层中左邻居到右邻居的跨度，rank[0]-rank[i]是第i层左邻居到第0层左邻居的距离，所以二者相减得到的是第0层左邻居到第i层右邻居的跨度。新节点插入后，新节点到第i层右邻居的跨度就等于原本第0层左邻居到第i层右邻居的跨度。</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        <span class="comment">//左邻居的跨度要改成左邻居到新节点的距离</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="comment">//新节点最高层以上的层次找到的也都是左邻居，所以新节点插入后它们的跨度都加一</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后退指针指向左邻居，后退指针只和第0层有关，所以不用循环</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//如果新节点有右邻居，就把右邻居的后退指针指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果没有右邻居，自然就成了尾结点</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    <span class="comment">//跳跃表节点数加一</span></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></span><br><span class="line"><span class="comment">//删除节点x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//遍历update每一层的节点，一定是x左边的节点，但不一定是左邻居，因为x的最高层数可能低于i</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="comment">//如果是左邻居，就要继承x的跨度，前进指针指向x的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">//如果不是左邻居，只是跨度减一</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果x有右邻居，就把右邻居的后退指针指向x的左邻居</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    <span class="comment">//如果没有右邻居，x就是尾结点，重新设置尾结点就行了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果删掉的节点是最高的，就需要重新设置跳跃表的最高层数</span></span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">    <span class="comment">//节点数减一</span></span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete an element with matching score/object from the skiplist. */</span></span><br><span class="line"><span class="comment">//删除跳跃表中包含给定对象和分值的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//和插入节点的逻辑一样，根据分值从高层到底层找左邻居，记录左邻居是为了删除节点后调整指针链接</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="comment">//找到分值相同的节点之后，再找存储的对象是obj的节点</span></span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</span><br><span class="line">        <span class="comment">//先删除再释放节点</span></span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec. */</span></span><br><span class="line"><span class="comment">//分值范围</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//最小值和最大值</span></span><br><span class="line">    <span class="keyword">double</span> min, max;</span><br><span class="line">    <span class="comment">//最小值和最大值是否包含在本范围里，表示区间开闭</span></span><br><span class="line">    <span class="comment">//ex是exclusive的意思，所以0表示包含(闭区间)，1表示不包含(开区间)</span></span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zrangespec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete all the elements with score between min and max from the skiplist.</span></span><br><span class="line"><span class="comment"> * Min and mx are inclusive, so a score &gt;= min || score &lt;= max is deleted.</span></span><br><span class="line"><span class="comment"> * Note that this function takes the reference to the hash table view of the</span></span><br><span class="line"><span class="comment"> * sorted set, in order to remove the elements from the hash table too. */</span></span><br><span class="line"><span class="comment">//给定一个分值范围，删除跳跃表中所有在这个范围之内的节点，同时也在字典中删除该节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslDeleteRangeByScore</span><span class="params">(zskiplist *zsl, zrangespec range, dict *dict)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//找到分值范围的左邻居</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (range.minex ?</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt;= range.min :</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt; range.min))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Current node is the last with score &lt; or &lt;= min. */</span></span><br><span class="line">    <span class="comment">//在第0层非跳跃地遍历节点</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete nodes while in range. */</span></span><br><span class="line">    <span class="comment">//在跳跃表和字典中删除节点，最后释放该节点</span></span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; (range.maxex ? x-&gt;score &lt; range.max : x-&gt;score &lt;= range.max)) &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回删除的节点数</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete all the elements with rank between start and end from the skiplist.</span></span><br><span class="line"><span class="comment"> * Start and end are inclusive. Note that start and end need to be 1-based */</span></span><br><span class="line"><span class="comment">//给定一个排序范围，删除跳跃表中所有在这个范围之内的节点</span></span><br><span class="line"><span class="comment">//大体逻辑同zslDeleteRangeByScore，最后也是返回删除的节点数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslDeleteRangeByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">int</span> start, <span class="keyword">unsigned</span> <span class="keyword">int</span> end, dict *dict)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>, removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt; start) &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traversed++;</span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; traversed &lt;= end) &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        traversed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the first node having a score equal or greater than the specified one.</span></span><br><span class="line"><span class="comment"> * Returns NULL if there is no match. */</span></span><br><span class="line"><span class="comment">//获取第一个分值不小于给定分值的节点</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslFirstWithScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//直接从高层到低层找，不用记录左邻居了。最后找到第0层，得到的就是真正的左邻居</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; x-&gt;level[i].forward-&gt;score &lt; score)</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    <span class="comment">//返回左邻居的下个节点</span></span><br><span class="line">    <span class="keyword">return</span> x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the rank for an element by both score and key.</span></span><br><span class="line"><span class="comment"> * Returns 0 when the element cannot be found, rank otherwise.</span></span><br><span class="line"><span class="comment"> * Note that the rank is 1-based due to the span of zsl-&gt;header to the</span></span><br><span class="line"><span class="comment"> * first element. */</span></span><br><span class="line"><span class="comment">//返回包含给定对象和分值的节点在跳跃表中的排序</span></span><br><span class="line"><span class="comment">//和zslInsert中一样，从高层到低层遍历，通过累加途径节点的跨度来得到节点在表中的rank值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//和</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></span><br><span class="line"><span class="comment">//返回跳跃表在给定排序上的节点</span></span><br><span class="line"><span class="comment">//从高层到底层遍历，记录节点的rank值，每当下个节点的rank值高于给定的rank，就跳到下一层继续遍历，因为到了下一层右邻居会更左</span></span><br><span class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Populate the rangespec according to the objects min and max. */</span></span><br><span class="line"><span class="comment">//把spec的左右边界设成min和max</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zslParseRange</span><span class="params">(robj *min, robj *max, zrangespec *spec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line">    <span class="comment">//初始默认是闭区间</span></span><br><span class="line">    spec-&gt;minex = spec-&gt;maxex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the min-max interval. If one of the values is prefixed</span></span><br><span class="line"><span class="comment">     * by the "(" character, it's considered "open". For instance</span></span><br><span class="line"><span class="comment">     * ZRANGEBYSCORE zset (1.5 (2.5 will match min &lt; x &lt; max</span></span><br><span class="line"><span class="comment">     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min &lt;= x &lt;= max */</span></span><br><span class="line">    <span class="comment">//对象的ptr指针指向底层的数据结构</span></span><br><span class="line">    <span class="comment">//如果对象的数据结构是整型，直接赋给spec，也是默认闭区间</span></span><br><span class="line">    <span class="keyword">if</span> (min-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        spec-&gt;min = (<span class="keyword">long</span>)min-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是整型，对象就是用字符串表示的数</span></span><br><span class="line">        <span class="comment">//字符串以'('开头表示开区间</span></span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">char</span>*)min-&gt;ptr)[<span class="number">0</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="comment">//strtod将ptr指向的字符串转换成浮点数，如果发生错误就让eptr指针指向出错的字符</span></span><br><span class="line">            spec-&gt;min = strtod((<span class="keyword">char</span>*)min-&gt;ptr+<span class="number">1</span>,&amp;eptr);</span><br><span class="line">            <span class="comment">//如果转换出错了，返回错误码</span></span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;min)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            <span class="comment">//开区间的exclusive是1</span></span><br><span class="line">            spec-&gt;minex = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            spec-&gt;min = strtod((<span class="keyword">char</span>*)min-&gt;ptr,&amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;min)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右边界设置同上</span></span><br><span class="line">    <span class="keyword">if</span> (max-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        spec-&gt;max = (<span class="keyword">long</span>)max-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">char</span>*)max-&gt;ptr)[<span class="number">0</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">            spec-&gt;max = strtod((<span class="keyword">char</span>*)max-&gt;ptr+<span class="number">1</span>,&amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;max)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            spec-&gt;maxex = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            spec-&gt;max = strtod((<span class="keyword">char</span>*)max-&gt;ptr,&amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;max)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置成功，返回成功码</span></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-内存编码结构相关"><a href="#3-内存编码结构相关" class="headerlink" title="3 内存编码结构相关"></a>3 内存编码结构相关</h1><h2 id="3-1-整数集合数据结构"><a href="#3-1-整数集合数据结构" class="headerlink" title="3.1 整数集合数据结构"></a>3.1 整数集合数据结构</h2><h3 id="intset-h"><a href="#intset-h" class="headerlink" title="intset.h"></a>intset.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __INTSET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INTSET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式，包括int16_t、int32_t和int64_t</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合中元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//存储元素的有序数组，要实现的集合是无序的，但底层的数组是有序的</span></span><br><span class="line">    <span class="comment">//虽然contents属性声明为int8_t类型的数组，但实际上contents数组的真正类型取决于encoding属性的值</span></span><br><span class="line">    <span class="comment">//由于contents所有元素的类型要一致，因此contents的类型是由其中最大的数决定的</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __INTSET_H</span></span></span><br></pre></td></tr></table></figure>
<h3 id="intset-c"><a href="#intset-c" class="headerlink" title="intset.c"></a>intset.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"intset.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="comment">//int的编码方式</span></span><br><span class="line"><span class="comment">//int16_t，2bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="comment">//int32_t，4bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="comment">//int64_t，8bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the required encoding for the provided value. */</span></span><br><span class="line"><span class="comment">//根据给定数的大小，返回满足需求又最省空间的int类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at pos, given an encoding. */</span></span><br><span class="line"><span class="comment">//得到enc编码方式下的第pos个位置的值</span></span><br><span class="line"><span class="comment">//因为呈现给用户的intset是无序的，所以能访问底层数组contents的函数必须是声明为static的内部函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGetEncoded(intset *is, <span class="keyword">int</span> pos, <span class="keyword">uint8_t</span> enc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enc == INTSET_ENC_INT64)</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (enc == INTSET_ENC_INT32)</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="comment">//得到is中第pos个位置的值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGet(intset *is, <span class="keyword">int</span> pos) &#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGetEncoded(is,pos,is-&gt;encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="comment">//把集合is第pos个位置的值设为value</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT64)</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT32)</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an empty intset. */</span></span><br><span class="line"><span class="comment">//创建空的整数集合</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    <span class="comment">//默认使用int16_t，只支持升级，不支持降级</span></span><br><span class="line">    is-&gt;encoding = INTSET_ENC_INT16;</span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the intset */</span></span><br><span class="line"><span class="comment">//因为结构体的内存空间是连续的，所以添加新元素之前要先扩容，删除元素之后要收缩。len是新的元素总数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//is-&gt;encoding就是表示一个整数需要的bit数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*is-&gt;encoding;</span><br><span class="line">    <span class="comment">//需要的空间是结构体大小加所有元素需要的大小</span></span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search for the position of "value". Return 1 when the value was found and</span></span><br><span class="line"><span class="comment"> * sets "pos" to the position of the value within the intset. Return 0 when</span></span><br><span class="line"><span class="comment"> * the value is not present in the intset and sets "pos" to the position</span></span><br><span class="line"><span class="comment"> * where "value" can be inserted. */</span></span><br><span class="line"><span class="comment">//在集合的有序数组中查询给定的value，如果找到，把索引赋给pos，如果找不到，把value能插入的位置赋给pos</span></span><br><span class="line"><span class="comment">//返回1表示找到了，返回0表示没找到</span></span><br><span class="line"><span class="comment">//采用二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = is-&gt;length<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="comment">//集合是空的，直接返回0，pos=0表示value可以直接插在数组头部</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="comment">//因为数组是有序的，所以先和数组收尾比较，如果value小于左边界或大于右边界，就说明不在数组中，pos设置为数组的头或尾</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,is-&gt;length<span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = is-&gt;length;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找，cur记录的是数组中mid索引的值</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = (min+max)/<span class="number">2</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出上面循环的一种情况是value==cur，pos设为cur的索引mid</span></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//另一种情况是max&lt;min，此时value的插入位置就是新的min(想一想就知道)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="comment">//升级is的编码(int类型)，并插入新的value</span></span><br><span class="line"><span class="comment">//因为调用该函数的条件是value超过了is支持的表示范围，所以编码要先升级，而且value一定是插在数组头或尾</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = is-&gt;encoding;</span><br><span class="line">    <span class="comment">//选择刚好适合新元素value的int类型</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">int</span> length = is-&gt;length;</span><br><span class="line">    <span class="comment">//负数插在数组头，正数插在数组尾</span></span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    <span class="comment">//修改is的encoding，再为新元素扩容</span></span><br><span class="line">    is-&gt;encoding = newenc;</span><br><span class="line">    is = intsetResize(is,is-&gt;length+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don't overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the "prepend" variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="comment">//在扩容以后的数组中</span></span><br><span class="line">    <span class="comment">//如果value是负数，就从后到前把每个元素插到它后面的位置，最后空出数组头来存放value</span></span><br><span class="line">    <span class="comment">//如果value是正数，就从后到前把每个元素插到它当前的位置，相当于啥也没干，最后空出数组尾来存放value</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="comment">//负数插在数组头，正数插在数组尾</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,is-&gt;length,value);</span><br><span class="line">    <span class="comment">//元素数量加一</span></span><br><span class="line">    is-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把集合中从from位置开始的所有元素移动到从to位置开始</span></span><br><span class="line"><span class="comment">//memmove比memcpy更安全。如果目标区域和源区域有重叠的话，memmove能够保证被覆盖之前将重叠区域的字节拷贝到目标区域中</span></span><br><span class="line"><span class="comment">//使用memmove要设定移动的长度，所以要分别考虑三种不同长度的int类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="comment">//bytes是from之后的总元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = is-&gt;length-from;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        <span class="comment">//元素数量乘以单个元素占用的空间就是要移动的内存长度</span></span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="keyword">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="keyword">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line"><span class="comment">//向集合is中插入value</span></span><br><span class="line"><span class="comment">//success只是个flag，大概只有测试的时候用得到</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询适合value的int类型</span></span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="comment">//初始默认插入成功</span></span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="comment">//适合value的int长度比is支持的要长，就要先扩容再添加，而且超出规格说明value本来也不在is中</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; is-&gt;encoding) &#123;</span><br><span class="line">        <span class="comment">/* This always succeeds, so we don't need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate "pos" with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="comment">//如果value已经在is中了，集合元素不能重复，success设为0表示插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先给新元素扩容</span></span><br><span class="line">        is = intsetResize(is,is-&gt;length+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//之前调用intsetSearch时，已经把应该插入的位置赋给了pos</span></span><br><span class="line">        <span class="comment">//插入前要把pos之后的全部元素后移一位</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; is-&gt;length) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在pos处插入新元素</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete integer from intset */</span></span><br><span class="line"><span class="comment">//从is中移除元素value</span></span><br><span class="line"><span class="comment">//和intsetAdd的基本逻辑相同</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valenc &lt;= is-&gt;encoding &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">        <span class="comment">/* We know we can delete */</span></span><br><span class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Overwrite value with tail and update length */</span></span><br><span class="line">        <span class="comment">//删除pos位置的元素，就是把pos+1之后的元素都前移一位</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; (is-&gt;length<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</span><br><span class="line">        <span class="comment">//数组长度收缩一位</span></span><br><span class="line">        is = intsetResize(is,is-&gt;length<span class="number">-1</span>);</span><br><span class="line">        is-&gt;length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine whether a value belongs to this set */</span></span><br><span class="line"><span class="comment">//查询value是否在集合is中</span></span><br><span class="line"><span class="comment">//intsetSearch函数里是直接查，但是实际情况中要先判断value是否超出了集合支持的int类型的表示范围</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetFind(intset *is, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= is-&gt;encoding &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return random member */</span></span><br><span class="line"><span class="comment">//随机返回集合中一个元素</span></span><br><span class="line"><span class="keyword">int64_t</span> intsetRandom(intset *is) &#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGet(is,rand()%is-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sets the value to the value at the given position. When this position is</span></span><br><span class="line"><span class="comment"> * out of range the function returns 0, when in range it returns 1. */</span></span><br><span class="line"><span class="comment">//获取pos位置上的元素</span></span><br><span class="line"><span class="comment">//仅仅是在_intsetGet之前判断了pos索引是否越界，没必要单独写成一个函数</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetGet(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; is-&gt;length) &#123;</span><br><span class="line">        *value = _intsetGet(is,pos);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return intset length */</span></span><br><span class="line"><span class="comment">//返回集合的元素总数</span></span><br><span class="line"><span class="keyword">uint32_t</span> intsetLen(intset *is) &#123;</span><br><span class="line">    <span class="keyword">return</span> is-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-压缩列表"><a href="#3-2-压缩列表" class="headerlink" title="3.2 压缩列表"></a>3.2 压缩列表</h2><h3 id="ziplist-h"><a href="#ziplist-h" class="headerlink" title="ziplist.h"></a>ziplist.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标记ziplist的头部和尾部，在插入新元素时会用到</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL 1</span></span><br></pre></td></tr></table></figure>
<h3 id="ziplist-c"><a href="#ziplist-c" class="headerlink" title="ziplist.c"></a>ziplist.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ziplist是为了节约内存而设计的特殊的双端队列，Ziplist能存储strings和integer值，整型值被存储为实际的整型值而不是字符串。Ziplist在头部和尾部的操作时间O(1)，但是由于ziplist的操作都需要重新分配内存，所以实际的复杂度和ziplist使用的内存大小有关。</span></span><br><span class="line"><span class="comment"> * ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZIPLIST OVERALL LAYOUT:</span></span><br><span class="line"><span class="comment"> * The general layout of the ziplist is as follows:</span></span><br><span class="line"><span class="comment"> * &lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;&lt;entry&gt;&lt;zlend&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zlbytes，uint32_t，4字节，记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用</span></span><br><span class="line"><span class="comment"> * zltail，uint32_t，4字节，记录压缩列表最后一个entry距离压缩列表的起始地址有多少字节，通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</span></span><br><span class="line"><span class="comment"> * zllen，uint16_t，2字节，记录了压缩列表包含的节点数量，当这个属性的值小于 UINT16_MAX(65535)时，这个属性的值就是压缩列表包含节点的数量，当这个值等于UINT16_MAX 时，节点的真实数量需要遍历整个压缩列表才能计算得出。</span></span><br><span class="line"><span class="comment"> * zlend，uint8_t，1字节，特殊值 0xFF(十进制255)，用于标记压缩列表的末端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZIPLIST ENTRIES:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 每个压缩列表节点都由 previous_entry_length 、encoding 、content 三个部分组成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 节点的 previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度，previous_entry_length的长度可以是1字节或者5字节。如果前一节点的长度小于254字节，那么previous_entry_length长度就是1字节，因为1字节可以表示0~253(0xFD)范围内的值。如果前一节点的长度大于等于254字节，那么previous_entry_length的长度就是5字节，其中第一个字节会被设置为 0xFE(254)，而之后的四个字节则用于保存前一节点的长度。这是由于0xFF已经是ziplist的结束标字节了，所以entry的flag字节最大只能是0xFE，所以表示的数就以254为界限分成上述两种情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度。如果是1字节、2字节或者5字节长，且值的最高位对应着分别为00、01或10，表示节点的content保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录。如果是1字节长，且值的最高位以11，表示节点的content保存着整数值，整数值的类型由编码除去最高两位之后的其他位记录，整数的长度无需记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * |00pppppp| - 1 byte</span></span><br><span class="line"><span class="comment"> *      String value with length less than or equal to 63 bytes (6 bits).</span></span><br><span class="line"><span class="comment"> * |01pppppp|qqqqqqqq| - 2 bytes</span></span><br><span class="line"><span class="comment"> *      String value with length less than or equal to 16383 bytes (14 bits).</span></span><br><span class="line"><span class="comment"> * |10______|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes</span></span><br><span class="line"><span class="comment"> *      String value with length greater than or equal to 16384 bytes.</span></span><br><span class="line"><span class="comment"> * |1100____| - 1 byte</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int16_t (2 bytes).</span></span><br><span class="line"><span class="comment"> * |1101____| - 1 byte</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int32_t (4 bytes).</span></span><br><span class="line"><span class="comment"> * |1110____| - 1 byte</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int64_t (8 bytes).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 节点的 content 属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的 encoding 属性决定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ziplist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把long long类型的value转换成字符串，字符串存储在s中，len是s的最大长度</span></span><br><span class="line"><span class="comment">//返回值是s的实际长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ll2string</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0xFF，也就是zlend的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_END 255</span></span><br><span class="line"><span class="comment">//previous_entry_length两种情况的分界</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_BIGLEN 254</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Different encoding/length possibilities */</span></span><br><span class="line"><span class="comment">//entry可使用的编码</span></span><br><span class="line"><span class="comment">//1字节，00开头，后6位表示字节数组的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)</span></span><br><span class="line"><span class="comment">//2字节，01开头，后14位表示字节数组的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="comment">//5字节，10000000开头，后32位表示字节数组的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)</span></span><br><span class="line"><span class="comment">//整数的编码是1字节，前两位都是11，后六位表示int类型</span></span><br><span class="line"><span class="comment">//11000000，int16_t，后面的content是16位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)</span></span><br><span class="line"><span class="comment">//11010000，int32_t，后面的content是32位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)</span></span><br><span class="line"><span class="comment">//11100000，int64_t，后面的content是64位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro's to determine type */</span></span><br><span class="line"><span class="comment">//判断节点存的是不是字符串，特征是编码的第一字节小于0xc0(11000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_IS_STR(enc) (((enc) &amp; 0xc0) &lt; 0xc0)</span></span><br><span class="line"><span class="comment">//判断节点存的是不是整数，!ZIP_IS_STR(enc)说明是11开头，(enc) &amp; 0x30) &lt; 0x30说明不是1111开头，因为支持的三种整数编码没有1111开头的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_IS_INT(enc) (!ZIP_IS_STR(enc) &amp;&amp; ((enc) &amp; 0x30) &lt; 0x30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Utility macros */</span></span><br><span class="line"><span class="comment">//zl就是ziplist，本质其实就是一个字符串</span></span><br><span class="line"><span class="comment">//返回zlbytes字段的指针，在zl的1~4字节，(uint32_t*)表示取zl前4个字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="comment">//返回zltail字段的指针，在zl的5~8字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="comment">//返回zllen字段的指针，在zl的9~10字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"><span class="comment">//返回zl的header的长度，就是zlbytes、zltail、zllen三个字段的总长</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="comment">//返回第一个节点的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span></span><br><span class="line"><span class="comment">//返回最后一个节点的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+ZIPLIST_TAIL_OFFSET(zl))</span></span><br><span class="line"><span class="comment">//返回zlend字段的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+ZIPLIST_BYTES(zl)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We know a positive increment can only be 1 because entries can only be</span></span><br><span class="line"><span class="comment"> * pushed one at a time. */</span></span><br><span class="line"><span class="comment">//增加ziplist的节点数，就是修改zllen字段的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_INCR_LENGTH(zl,incr) &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> (ZIPLIST_LENGTH(zl) &lt; UINT16_MAX) ZIPLIST_LENGTH(zl)+=incr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ziplist的节点</span></span><br><span class="line"><span class="comment">//entry是ziplist字符串的一个子串</span></span><br><span class="line"><span class="comment">//zlentry结构体用于描述entry的各个属性的一种结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="comment">//prevrawlen是前一个entry子串content字段的长度(字节数)</span></span><br><span class="line">    <span class="comment">//prevrawlensize是当前entry中表示prevrawlen所需的字节数</span></span><br><span class="line">    <span class="comment">//这两个属性对应entry的previous_entry_length字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize, prevrawlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len是当前entry子串content字段的长度(字节数)</span></span><br><span class="line">    <span class="comment">//lensize是表示len所需的字节数</span></span><br><span class="line">    <span class="comment">//这两个属性对应entry的、encoding字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize, len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前entry子串中header的字节数，headersize=prevrawlensize+lensize</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;</span><br><span class="line">    <span class="comment">//当前节点值所使用的编码类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;</span><br><span class="line">    <span class="comment">//指向当前节点表示的entry子串的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">&#125; zlentry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the encoding pointer to by 'p'. */</span></span><br><span class="line"><span class="comment">//返回p指向的entry的编码类型</span></span><br><span class="line"><span class="comment">//该函数用于计算zlentry结构体中的encoding属性，因为encoding属性的char类型，是1个字节，所以函数返回的也应该是char类型。entry的编码类型确实只需要一个字节就能表示六种编码：ZIP_STR_06B是0x00，ZIP_STR_14B是0x40，ZIP_STR_32B是0x80，ZIP_INT_16B是0xc0，ZIP_INT_32B是0xd0，ZIP_INT_64B是0xe0</span></span><br><span class="line"><span class="comment">//因为编码类型要从encoding字段中解析，所以p不应该指向entry的头部，而是要向后偏移prevrawlensize个字节，指向entry的encoding字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipEntryEncoding</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* String encoding: 2 MSBs */</span></span><br><span class="line">    <span class="comment">//如果是字符串类型，b就是0x00、0x40或0x80</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b = p[<span class="number">0</span>] &amp; <span class="number">0xc0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0xc0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="comment">//如果是整数类型，p[0] &amp; 0xf0的结果就是0xc0、0xd0或0xe0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Integer encoding: 4 MSBs */</span></span><br><span class="line">        <span class="keyword">return</span> p[<span class="number">0</span>] &amp; <span class="number">0xf0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是字符串也不是整数，强制让assert为false，向stderr报错</span></span><br><span class="line">    assert(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return bytes needed to store integer encoded by 'encoding' */</span></span><br><span class="line"><span class="comment">//用于返回整数节点的len属性，也就是content字段存储的整数的字节数，三种int分别是2字节、4字节和8字节</span></span><br><span class="line"><span class="comment">//一个字符串的长度是不固定的，但是一个整数的长度是固定的，所以不需要计算，根据int类型就能知道整数占多少字节</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipIntSize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_16B: <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_32B: <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_64B: <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入的编码不支持，向stderr报错</span></span><br><span class="line">    assert(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the encoded length pointed by 'p'. If a pointer to 'lensize' is</span></span><br><span class="line"><span class="comment"> * provided, it is set to the number of bytes required to encode the length. */</span></span><br><span class="line"><span class="comment">//用于解析entry的encoding字段，得到zlentry结构体的len和lensize属性</span></span><br><span class="line"><span class="comment">//p指向entry子串的encoding字段，len是content字段的字节数，lensize是表示len需要的字节数，</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipDecodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> *lensize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取p的编码类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = zipEntryEncoding(p);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(encoding) &#123;</span><br><span class="line">        <span class="comment">//00开头的1字节编码</span></span><br><span class="line">        <span class="keyword">case</span> ZIP_STR_06B:</span><br><span class="line">            <span class="comment">//后6位是字符串长度，0x3f表示把p[0]的最高两位置0，len就是后6位表示的整数值</span></span><br><span class="line">            len = p[<span class="number">0</span>] &amp; <span class="number">0x3f</span>;</span><br><span class="line">            <span class="comment">//6bit的整数需要1个字节表示</span></span><br><span class="line">            <span class="keyword">if</span> (lensize) *lensize = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//01开头的2字节编码</span></span><br><span class="line">        <span class="keyword">case</span> ZIP_STR_14B:</span><br><span class="line">            <span class="comment">//后14位是字符串长度，0x3f表示把p[0]的最高两位置0，len就是后14位表示的整数值</span></span><br><span class="line">            len = ((p[<span class="number">0</span>] &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">8</span>) | p[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//14bit的整数需要2个字节表示</span></span><br><span class="line">            <span class="keyword">if</span> (lensize) *lensize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//10000000开头的5字节编码</span></span><br><span class="line">        <span class="keyword">case</span> ZIP_STR_32B:</span><br><span class="line">            <span class="comment">//后32位是字符串长度，用不到第一个字节，所以就不用考虑高位置0，len就是后4个字节表示的整数值</span></span><br><span class="line">            len = (p[<span class="number">1</span>] &lt;&lt; <span class="number">24</span>) | (p[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (p[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | p[<span class="number">4</span>];</span><br><span class="line">            <span class="comment">//4个字节的无符号整数，为什么需要5个字节表示呢？</span></span><br><span class="line">            <span class="keyword">if</span> (lensize) *lensize = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//都不是就报错</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            assert(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果是整数类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//整数的长度只能是2字节、4字节或8字节</span></span><br><span class="line">        len = zipIntSize(encoding);</span><br><span class="line">        <span class="comment">//2、4和8只需要1个字节表示</span></span><br><span class="line">        <span class="keyword">if</span> (lensize) *lensize = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode the length 'l' writing it in 'p'. If p is NULL it just returns</span></span><br><span class="line"><span class="comment"> * the amount of bytes required to encode such a length. */</span></span><br><span class="line"><span class="comment">//rawlen是某个entry的content字段的长度(字节数)，返回的是表示rawlen需要的字节数</span></span><br><span class="line"><span class="comment">//p指针指向entry的encoding字段，如果p!=NULL，就把算出来的encoding字段写到p地址上</span></span><br><span class="line"><span class="comment">//传进来的encoding是zlentry的属性，只有1个字节，要算出的是entry字符串中的encoding字段，可能是1字节、2字节或5字节</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding, <span class="keyword">unsigned</span> <span class="keyword">int</span> rawlen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//len是表示rawlen需要的字节数，默认是1</span></span><br><span class="line">    <span class="comment">//buf存的是encoding字段的值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> len = <span class="number">1</span>, buf[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//如果是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="comment">/* Although encoding is given it may not be set for strings,</span></span><br><span class="line"><span class="comment">         * so we determine it here using the raw length. */</span></span><br><span class="line">        <span class="comment">//如果rawlen不大于6bit整数的上限</span></span><br><span class="line">        <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3f</span>) &#123;</span><br><span class="line">            <span class="comment">//需要1个字节表示</span></span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            <span class="comment">//ZIP_STR_06B后6位是0，相当于给rawlen加上00的前缀，变成encoding字段的值</span></span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_06B | rawlen;</span><br><span class="line">        <span class="comment">//如果rawlen不大于14bit整数的上限</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3fff</span>) &#123;</span><br><span class="line">            <span class="comment">//需要2个字节表示</span></span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            <span class="comment">//ZIP_STR_14B后14位是0，相当于先对rawlen最高两位置0，再给rawlen加上01的前缀，变成encoding字段的值</span></span><br><span class="line">            <span class="comment">//为什么要置0呢？不大于0x3fff已经能确定最高两位是00了呀？</span></span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_14B | ((rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x3f</span>);</span><br><span class="line">            buf[<span class="number">1</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="comment">//否则就是需要5个字节表示</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            <span class="comment">//buf就是ZIP_STR_32B前缀加上rawlen的后4个字节</span></span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_32B;</span><br><span class="line">            buf[<span class="number">1</span>] = (rawlen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = (rawlen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = (rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">4</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果是整数编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Implies integer encoding, so length is always 1. */</span></span><br><span class="line">        <span class="comment">//默认的一个字节就足够</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="comment">//对于整数，zlentry的encoding属性和entry的encoding字段是相同的，因为只表示int类型不表示长度</span></span><br><span class="line">        <span class="comment">//而对于字符串，即使都是一个字节，两个encoding的值也不相同，因为zlentry的encoding属性后6位是0，而entry的encoding字段后6位表示字符串长度</span></span><br><span class="line">        buf[<span class="number">0</span>] = encoding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store this length at p */</span></span><br><span class="line">    <span class="comment">//把buf的前len个字节写到p地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,buf,len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the length of the previous element stored at "p". */</span></span><br><span class="line"><span class="comment">//返回前一个entry的content长度</span></span><br><span class="line"><span class="comment">//与上面的p不同，这里的p指向entry头部</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipPrevDecodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> *lensize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = *p;</span><br><span class="line">    <span class="comment">//第一个字节小于254，说明前一个entry的content小于254个字节</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">        <span class="comment">//需要1个字节就能表示</span></span><br><span class="line">        <span class="keyword">if</span> (lensize) *lensize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//第一个字节等于254，说明前一个entry的content大于等于254</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//需要多1个字节，因为第一个字节默认是0xfe的标志</span></span><br><span class="line">        <span class="keyword">if</span> (lensize) *lensize = <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        <span class="comment">//跳过第一个字节，读取长度值并赋给len</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;len,p+<span class="number">1</span>,<span class="keyword">sizeof</span>(len));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode the length of the previous entry and write it to "p". Return the</span></span><br><span class="line"><span class="comment"> * number of bytes needed to encode this length if "p" is NULL. */</span></span><br><span class="line"><span class="comment">//返回表示len需要的字节数</span></span><br><span class="line"><span class="comment">//和zipPrevDecodeLength逻辑正好相反</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipPrevEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (len &lt; ZIP_BIGLEN) ? <span class="number">1</span> : <span class="keyword">sizeof</span>(len)+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">            <span class="comment">//跳过第一个字节，把长度值从第二个字节开始写入previous_entry_length字段</span></span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode the length of the previous entry and write it to "p". This only</span></span><br><span class="line"><span class="comment"> * uses the larger encoding (required in __ziplistCascadeUpdate). */</span></span><br><span class="line"><span class="comment">//强制将上一个entry的content长度以0xfe开头5字节形式写入当前entry的previous_entry_length字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipPrevEncodeLengthForceLarge</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">    <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the difference in number of bytes needed to store the new length</span></span><br><span class="line"><span class="comment"> * "len" on the entry pointed to by "p". */</span></span><br><span class="line"><span class="comment">//计算表示len需要的字节数与上个entry的previous_entry_length字段的字节数之差</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zipPrevLenByteDiff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize;</span><br><span class="line">    <span class="comment">//prevlensize记录上个entry的previous_entry_length字段的字节数</span></span><br><span class="line">    zipPrevDecodeLength(p,&amp;prevlensize);</span><br><span class="line">    <span class="keyword">return</span> zipPrevEncodeLength(<span class="literal">NULL</span>,len)-prevlensize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if string pointed to by 'entry' can be encoded as an integer.</span></span><br><span class="line"><span class="comment"> * Stores the integer value in 'v' and its encoding in 'encoding'. */</span></span><br><span class="line"><span class="comment">//判断entrylen个字节的字符串类型的content能否转换为数值，如果可以返回1，否则返回0，并将拿到的数字赋值给*v, 将encoding字段赋值给 *encoding</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zipTryEncoding</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *entry, <span class="keyword">unsigned</span> <span class="keyword">int</span> entrylen, <span class="keyword">long</span> <span class="keyword">long</span> *v, <span class="keyword">unsigned</span> <span class="keyword">char</span> *encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最高支持32字节的有符号整数</span></span><br><span class="line">    <span class="keyword">if</span> (entrylen &gt;= <span class="number">32</span> || entrylen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//'-'开头表示是负数</span></span><br><span class="line">    <span class="keyword">if</span> (entry[<span class="number">0</span>] == <span class="string">'-'</span> || (entry[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; entry[<span class="number">0</span>] &lt;= <span class="string">'9'</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> slen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Perform a back-and-forth conversion to make sure that</span></span><br><span class="line"><span class="comment">         * the string turned into an integer is not losing any info. */</span></span><br><span class="line">        <span class="comment">//把字符串全部复制到buf数组</span></span><br><span class="line">        <span class="built_in">memcpy</span>(buf,entry,entrylen);</span><br><span class="line">        <span class="comment">//字符串的结束标记</span></span><br><span class="line">        buf[entrylen] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">//把buf转换成10进制的long long int类型整数，eptr返回可转换的子串的下一个字符</span></span><br><span class="line">        value = strtoll(buf,&amp;eptr,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//可转换的子串下一个字符不是结束符，说明从eptr位置开始不能转换成整数，退出函数</span></span><br><span class="line">        <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把value再转换成最长32字节的字符串</span></span><br><span class="line">        slen = ll2string(buf,<span class="number">32</span>,value);</span><br><span class="line">        <span class="comment">//转成数值再转回来，如果长度不相等，或者buf和entry不相等，说明出了问题</span></span><br><span class="line">        <span class="comment">//为什么会出问题？</span></span><br><span class="line">        <span class="keyword">if</span> (entrylen != (<span class="keyword">unsigned</span>)slen || <span class="built_in">memcmp</span>(buf,entry,slen)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Great, the string can be encoded. Check what's the smallest</span></span><br><span class="line"><span class="comment">         * of our encoding types that can hold this value. */</span></span><br><span class="line">        <span class="comment">//根据value选择合适的编码</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_16B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_32B;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *encoding = ZIP_INT_64B;</span><br><span class="line">        &#125;</span><br><span class="line">        *v = value;</span><br><span class="line">        <span class="comment">//成功就返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store integer 'value' at 'p', encoded as 'encoding' */</span></span><br><span class="line"><span class="comment">//指定编码类型，在p地址写入整数value，p指向entry的content字段</span></span><br><span class="line"><span class="comment">//参数的value是8字节的，根据encoding判断前多少个字节是有效的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipSaveInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int64_t</span> value, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        i16 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i16,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        i32 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i32,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        i64 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i64,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read integer encoded as 'encoding' from 'p' */</span></span><br><span class="line"><span class="comment">//指定编码类型，从p地址取出存储的整数，p指向entry的content字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int64_t <span class="title">zipLoadInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i16,p,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">        ret = i16;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i32,p,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">        ret = i32;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i64,p,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">        ret = i64;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a struct with all information about an entry. */</span></span><br><span class="line"><span class="comment">//解析指针p指向的entry字符串，生成zlentry结构</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> zlentry <span class="title">zipEntry</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    zlentry e;</span><br><span class="line">    <span class="comment">//p指向entry头部，解析previous_entry_length字段</span></span><br><span class="line">    <span class="comment">//得到上个entry的content字段的字节数prevrawlen，以及表示prevrawlen所需的字节数prevrawlensize</span></span><br><span class="line">    e.prevrawlen = zipPrevDecodeLength(p,&amp;e.prevrawlensize);</span><br><span class="line">    <span class="comment">//p指向entry的encoding字段，解析encoding字段</span></span><br><span class="line">    <span class="comment">//得到当前entry的content字段的字节数prevrawlen，以及表示len所需的字节数lensize</span></span><br><span class="line">    e.len = zipDecodeLength(p+e.prevrawlensize,&amp;e.lensize);</span><br><span class="line">    <span class="comment">//计算headersize，也就是header部分(content之前)的字节数</span></span><br><span class="line">    e.headersize = e.prevrawlensize+e.lensize;</span><br><span class="line">    <span class="comment">//获取当前节点的编码类型</span></span><br><span class="line">    e.encoding = zipEntryEncoding(p+e.prevrawlensize);</span><br><span class="line">    <span class="comment">//指针指向entry头部</span></span><br><span class="line">    e.p = p;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the total number of bytes used by the entry at "p". */</span></span><br><span class="line"><span class="comment">//返回p指向的entry的总字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipRawEntryLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析成zlentry结构</span></span><br><span class="line">    zlentry e = zipEntry(p);</span><br><span class="line">    <span class="comment">//总字节数就是header字节数加content字节数</span></span><br><span class="line">    <span class="keyword">return</span> e.headersize + e.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="comment">//创建空的ziplist</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ziplist的header固定10个字节，再加上末尾的zlend是1个字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    <span class="comment">//zlbytes字段记录整个ziplist的总字节数，也就是bytes</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = bytes;</span><br><span class="line">    <span class="comment">//zltail字段记录表尾节点到表头的距离，因为新列表还没有节点，所以尾节点默认在header后面</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = ZIPLIST_HEADER_SIZE;</span><br><span class="line">    <span class="comment">//zllen字段记录entry的个数</span></span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最后一个字节是0xff</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the ziplist. */</span></span><br><span class="line"><span class="comment">//重新设置ziplist的大小，参数len是整个ziplist的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    zl = zrealloc(zl,len);</span><br><span class="line">    ZIPLIST_BYTES(zl) = len;</span><br><span class="line">    zl[len<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When an entry is inserted, we need to set the prevlen field of the next</span></span><br><span class="line"><span class="comment"> * entry to equal the length of the inserted entry. It can occur that this</span></span><br><span class="line"><span class="comment"> * length cannot be encoded in 1 byte and the next entry needs to be grow</span></span><br><span class="line"><span class="comment"> * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,</span></span><br><span class="line"><span class="comment"> * because this only happens when an entry is already being inserted (which</span></span><br><span class="line"><span class="comment"> * causes a realloc and memmove). However, encoding the prevlen may require</span></span><br><span class="line"><span class="comment"> * that this entry is grown as well. This effect may cascade throughout</span></span><br><span class="line"><span class="comment"> * the ziplist when there are consecutive entries with a size close to</span></span><br><span class="line"><span class="comment"> * ZIP_BIGLEN, so we need to check that the prevlen can be encoded in every</span></span><br><span class="line"><span class="comment"> * consecutive entry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this effect can also happen in reverse, where the bytes required</span></span><br><span class="line"><span class="comment"> * to encode the prevlen field can shrink. This effect is deliberately ignored,</span></span><br><span class="line"><span class="comment"> * because it can cause a "flapping" effect where a chain prevlen fields is</span></span><br><span class="line"><span class="comment"> * first grown and then shrunk again after consecutive inserts. Rather, the</span></span><br><span class="line"><span class="comment"> * field is allowed to stay larger than necessary, because a large prevlen</span></span><br><span class="line"><span class="comment"> * field implies the ziplist is holding large entries anyway.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pointer "p" points to the first entry that does NOT need to be</span></span><br><span class="line"><span class="comment"> * updated, i.e. consecutive fields MAY need an update. */</span></span><br><span class="line"><span class="comment">//连锁更新函数</span></span><br><span class="line"><span class="comment">//当在ziplist中插入新entry后，如果前一个entry长度大于254个字节，而新entry的previous_entry_length字段只有一个字节，就需要对新entry扩容，同时如果新entry长度大于254个字节，而后一个entry的previous_entry_length字段只有一个字节，就需要对后一个entry扩容。所以在插入新entry后，可能会对包括新entry在内的之后连续的几个entry进行扩容，这个过程叫做连锁更新。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p) &#123;</span><br><span class="line">    <span class="comment">//curlen是当前ziplist的总字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> curlen = ZIPLIST_BYTES(zl), rawlen, rawlensize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, noffset, extra;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line">    <span class="comment">//从p指针指向的entry开始检查，每次遍历到p指向的entry时，实际要修改的是下个entry的字段</span></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">//生成当前entry的zlentry结构</span></span><br><span class="line">        cur = zipEntry(p);</span><br><span class="line">        <span class="comment">//rawlen是当前entry的总字节数</span></span><br><span class="line">        rawlen = cur.headersize + cur.len;</span><br><span class="line">        <span class="comment">//rawlensize是表示rawlen需要的字节数</span></span><br><span class="line">        rawlensize = zipPrevEncodeLength(<span class="literal">NULL</span>,rawlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort if there is no next entry. */</span></span><br><span class="line">        <span class="comment">//后面没有entry了，所以就没有待修改的entry了，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//生成下个entry的zlentry结构</span></span><br><span class="line">        next = zipEntry(p+rawlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort when "prevlen" has not changed. */</span></span><br><span class="line">        <span class="comment">//如果下个entry的prevrawlen属性等于当前entry的字节数，说明后面所有entry的previous_entry_length都不用改了，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果下个entry的previous_entry_length的字节数不足以表示当前entry的长度，就要对ziplist扩容</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</span><br><span class="line">            <span class="comment">/* The "prevlen" field of "next" needs more bytes to hold</span></span><br><span class="line"><span class="comment">             * the raw length of "cur". */</span></span><br><span class="line">            <span class="comment">//offset是ziplist中当前entry之前的字节数，也就是当前entry头部到ziplist头部的字节数</span></span><br><span class="line">            offset = p-zl;</span><br><span class="line">            <span class="comment">//需要增加的字节数量</span></span><br><span class="line">            extra = rawlensize-next.prevrawlensize;</span><br><span class="line">            <span class="comment">//把ziplist的字节数设为当前字节数加extra</span></span><br><span class="line">            zl = ziplistResize(zl,curlen+extra);</span><br><span class="line">            <span class="comment">//ziplist扩容后，当前entry之前的部分没有变化，所以新的ziplist中offset的位置仍然是当前entry</span></span><br><span class="line">            p = zl+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Current pointer and offset for next element. */</span></span><br><span class="line">            <span class="comment">//下个entry的地址</span></span><br><span class="line">            np = p+rawlen;</span><br><span class="line">            <span class="comment">//下个entry到ziplist头部的字节数</span></span><br><span class="line">            noffset = np-zl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update tail offset when next element is not the tail element. */</span></span><br><span class="line">            <span class="comment">//zltail是最后一个entry到ziplist头部的字节数，如果下个entry不是最后一个，扩容多出来的几个字节应该算在zltail里</span></span><br><span class="line">            <span class="keyword">if</span> ((zl+ZIPLIST_TAIL_OFFSET(zl)) != np)</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) += extra;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move the tail to the back. */</span></span><br><span class="line">            <span class="comment">//增加下个entry的previous_entry_length字段的长度，就是把ziplist中从下个entry的encoding开始的后面的部分全部后移extra个字节。换言之，把旧的encoding字段开始的后半段移动到新的encoding字段开始的地址上。</span></span><br><span class="line">            <span class="comment">//np+rawlensize就是下个entry的encoding字段在新ziplist的起始位置，np+next.prevrawlensize就是下个entry的encoding字段在旧ziplist的起始位置，移动的后半段的字节数是curlen-noffset-next.prevrawlensize-1</span></span><br><span class="line">            memmove(np+rawlensize,</span><br><span class="line">                np+next.prevrawlensize,</span><br><span class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//把新的previous_entry_length字段写入下个entry的头部</span></span><br><span class="line">            zipPrevEncodeLength(np,rawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Advance the cursor */</span></span><br><span class="line">            <span class="comment">//继续检查下个entry</span></span><br><span class="line">            p += rawlen;</span><br><span class="line">            <span class="comment">//更新ziplist总字节数</span></span><br><span class="line">            curlen += extra;</span><br><span class="line">        <span class="comment">//如果下个entry的previous_entry_length的字节数足够表示当前entry的长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前entry的长度只需要1字节表示，但是下个entry的previous_entry_length有5字节，说明容量多了。但此时不缩减ziplist的长度，而是把rawlensize以5字节的记录方式写入下个entry的previous_entry_length</span></span><br><span class="line">            <span class="comment">//所以连锁更新的时候ziplist只扩容不收缩，为啥呢？</span></span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></span><br><span class="line"><span class="comment">                 * So, set "rawlen" in the available bytes. */</span></span><br><span class="line">                zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);</span><br><span class="line">            <span class="comment">//如果恰好都是1字节，就直接把rawlen写入下个entry的previous_entry_length</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zipPrevEncodeLength(p+rawlen,rawlen);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Stop here, as the raw length of "next" has not changed. */</span></span><br><span class="line">            <span class="comment">//在这种情况下，下个entry只需要修改字段值，而不需要扩容，所以连锁更新到此为止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete "num" entries, starting at "p". Returns pointer to the ziplist. */</span></span><br><span class="line"><span class="comment">//在zl中，从p指向的entry开始，删除num个entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistDelete(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, totlen, deleted = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> offset, nextdiff = <span class="number">0</span>;</span><br><span class="line">    zlentry first, tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原始的p指针保存在first中</span></span><br><span class="line">    first = zipEntry(p);</span><br><span class="line">    <span class="comment">//p指针移动到所有要删除的entry的末尾</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; p[<span class="number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</span><br><span class="line">        p += zipRawEntryLength(p);</span><br><span class="line">        deleted++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要删除的总字节数就是现在的p地址和原始的p地址的位置差</span></span><br><span class="line">    totlen = p-first.p;</span><br><span class="line">    <span class="keyword">if</span> (totlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//p没有到ziplist末尾，说明没有删除最后一个entry</span></span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">/* Tricky: storing the prevlen in this entry might reduce or</span></span><br><span class="line"><span class="comment">             * increase the number of bytes needed, compared to the current</span></span><br><span class="line"><span class="comment">             * prevlen. Note that we can always store this length because</span></span><br><span class="line"><span class="comment">             * it was previously stored by an entry that is being deleted. */</span></span><br><span class="line">            <span class="comment">//原始的p地址和现在的p地址之间被删掉了，所以要重新连接的是原来的p指向的entry的上个entry，和现在的p指向的entry。所以要更新的就是现在的p指向的entry的previous_entry_length字段，也就是让现在的p指向的entry的previous_entry_length字段存储first.prevrawlen表示的数值</span></span><br><span class="line">            <span class="comment">//如果当前entry的previous_entry_length字段不足以表示first.prevrawlen的值，nextdiff存储的就是额外需要的字节数</span></span><br><span class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</span><br><span class="line">            <span class="comment">//不需要扩容，额外的字节从p前面找，反正前面的entry是准备删掉的，直接覆盖写入就好，到时候少删掉nextdiff个字节就ok了</span></span><br><span class="line">            zipPrevEncodeLength(p-nextdiff,first.prevrawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update offset for tail */</span></span><br><span class="line">            <span class="comment">//zltail要减去删除掉的字节数</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) -= totlen;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">             * "nextdiff" in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">             * size of prevlen doesn't have an effect on the *tail* offset. */</span></span><br><span class="line">            tail = zipEntry(p);</span><br><span class="line">            <span class="comment">//长度对不上，是因为上面多删了nextdiff个字节，所以在这里要加回来</span></span><br><span class="line">            <span class="keyword">if</span> (p[tail.headersize+tail.len] != ZIP_END)</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) += nextdiff;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move tail to the front of the ziplist */</span></span><br><span class="line">            <span class="comment">//把p-nextdiff开始的内容复制到first.p开始的地址，就相当于把中间的部分删除了</span></span><br><span class="line">            memmove(first.p,p-nextdiff,ZIPLIST_BYTES(zl)-(p-zl)<span class="number">-1</span>+nextdiff);</span><br><span class="line">        <span class="comment">//p就是ziplist末尾，说明原始的p地址后面所有的entry都删掉了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The entire tail was deleted. No need to move memory. */</span></span><br><span class="line">            <span class="comment">//zltail是最后一个entry到ziplist头部的字节数，first.p-zl是最初的p指向的entry到ziplist头部的字节数，但因为这个entry也被删掉了，所以还要移动到上个entry的头部，也就是回退first.prevrawlen个字节</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) = (first.p-zl)-first.prevrawlen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Resize and update length */</span></span><br><span class="line">        <span class="comment">//记录第一个删除的节点的头地址</span></span><br><span class="line">        offset = first.p-zl;</span><br><span class="line">        <span class="comment">//减少ziplist的总字节数</span></span><br><span class="line">        zl = ziplistResize(zl, ZIPLIST_BYTES(zl)-totlen+nextdiff);</span><br><span class="line">        <span class="comment">//修改zllen字段的值，zllen表示ziplist中entry的数量，所以减去deleted</span></span><br><span class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</span><br><span class="line">        <span class="comment">//调整完ziplist的长度后，定位第一个删除的节点的头地址</span></span><br><span class="line">        p = zl+offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">         * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">        <span class="comment">//nextdiff不等于0，说明p指向的entry的previous_entry_length字段被延长了，也就是这个entry的总长度变了，所以需要从这个entry开始连锁更新，但是是从下个entry的previous_entry_length字段开始更新，p指向的entry不变</span></span><br><span class="line">        <span class="keyword">if</span> (nextdiff != <span class="number">0</span>)</span><br><span class="line">            zl = __ziplistCascadeUpdate(zl,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert item at "p". */</span></span><br><span class="line"><span class="comment">//在zl的位置p插入一个新entry，s是被插入的entry，slen是s的content字段的字节数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="comment">//curlen是当前ziplist的总字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> curlen = ZIPLIST_BYTES(zl), reqlen, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    zlentry entry, tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></span><br><span class="line">    <span class="comment">//p是插入entry的位置，所以当前p指向的entry就是新entry的后一个entry，所以p指向的entry的previous_entry_length字段应该存在新entry里</span></span><br><span class="line">    <span class="comment">//如果p没有指向ZIP_END，说明新entry的后面还有entry，也就是p指向的entry</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">//获取p指向的entry的prevrawlen属性</span></span><br><span class="line">        entry = zipEntry(p);</span><br><span class="line">        prevlen = entry.prevrawlen;</span><br><span class="line">    <span class="comment">//如果p指向ZIP_END，说明新entry的后面没有entry了，所以新entry的prevrawlen属性就不能从后面的entry头部找，而是直接解析前一个entry，也就是zltail指向的entry</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if the entry can be encoded */</span></span><br><span class="line">    <span class="comment">//在ziplist中，整型值被存储为实际的整型值而不是字符串。所以插入新entry时要检查content字段是否可以当做整数存储，如果可以转成整数，就不用存成字符串了，这样可以节省空间</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* 'encoding' is set to the appropriate integer encoding */</span></span><br><span class="line">        <span class="comment">//如果能转成整数，reqlen就是该整数类型需要的字节数</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 'encoding' is untouched, however zipEncodeLength will use the</span></span><br><span class="line"><span class="comment">         * string length to figure out how to encode it. */</span></span><br><span class="line">        <span class="comment">//否则，reqlen就是新entry的content字段的字节数</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We need space for both the length of the previous entry and</span></span><br><span class="line"><span class="comment">     * the length of the payload. */</span></span><br><span class="line">    <span class="comment">//reqlen再加上新entry的previous_entry_length字段所需的字节数</span></span><br><span class="line">    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">//reqlen再加上表示新entry需要的字节数，也就是新entry的encoding字段的字节数</span></span><br><span class="line">    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line">    <span class="comment">//三个字段都算上了，现在的reqlen就是新entry的总字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the insert position is not equal to the tail, we need to</span></span><br><span class="line"><span class="comment">     * make sure that the next entry can hold this entry's length in</span></span><br><span class="line"><span class="comment">     * its prevlen field. */</span></span><br><span class="line">    <span class="comment">//如果新entry后面还有entry，需要考虑后面entry的previous_entry_length字段是否足够表示新entry的长度</span></span><br><span class="line">    <span class="comment">//nextdiff就是后面的entry的previous_entry_length字段需要延长的字节数</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    <span class="comment">//因为是在p地址后面插入，所以要保存p地址到ziplist头部的距离</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    <span class="comment">//给ziplist扩容，增加的长度是新entry所需的字节数加上后面entry需要延长的字节数</span></span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    <span class="comment">//在新的ziplist中重定位p的位置</span></span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class="line">        <span class="comment">//p-nextdiff是后面的entry的头地址，把这之后的所有内容后移reqlen个字节，给新entry腾出位置</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Encode this entry's raw length in the next entry. */</span></span><br><span class="line">        <span class="comment">//更新后面entry的previous_entry_length，来表示新entry的总字节数reqlen</span></span><br><span class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update offset for tail */</span></span><br><span class="line">        <span class="comment">//zltail的值要增加</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) += reqlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">         * "nextdiff" in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">         * size of prevlen doesn't have an effect on the *tail* offset. */</span></span><br><span class="line">        tail = zipEntry(p+reqlen);</span><br><span class="line">        <span class="comment">//如果后面的entry头部被延长了，就需要给zltail补回nextdiff</span></span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END)</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) += nextdiff;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This element will be the new tail. */</span></span><br><span class="line">        <span class="comment">//如果新entry就是最后一个entry，zltail就是新entry头地址到ziplist头地址的距离</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = p-zl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">    <span class="comment">//如果后面的entry被延长了，需要连锁更新</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the entry */</span></span><br><span class="line">    <span class="comment">//填写新entry各个字段的值</span></span><br><span class="line">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">    p += zipEncodeLength(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//zllen表示entry总数，插入新entry后要加一</span></span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向zl中插入s，插入位置可以选择是头部或尾部</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns an offset to use for iterating with ziplistNext. When the given</span></span><br><span class="line"><span class="comment"> * index is negative, the list is traversed back to front. When the list</span></span><br><span class="line"><span class="comment"> * doesn't contain an element at the provided index, NULL is returned. */</span></span><br><span class="line"><span class="comment">//返回zl中第index个entry的头地址</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistIndex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="comment">//支持负索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//负索引是从最后一个entry向前数</span></span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            entry = zipEntry(p);</span><br><span class="line">            <span class="comment">//每跳过一个entry，指针p就减去这个entry的长度，相当于退到前一个entry</span></span><br><span class="line">            <span class="keyword">while</span> (entry.prevrawlen &gt; <span class="number">0</span> &amp;&amp; index--) &#123;</span><br><span class="line">                p -= entry.prevrawlen;</span><br><span class="line">                entry = zipEntry(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从第一个entry开始，每跳过一个entry，指针p就加上这个entry的长度，最后p指向的就是第index个entry</span></span><br><span class="line">        p = ZIPLIST_ENTRY_HEAD(zl);</span><br><span class="line">        <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END &amp;&amp; index--) &#123;</span><br><span class="line">            p += zipRawEntryLength(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果索引越界，就返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END || index &gt; <span class="number">0</span>) ? <span class="literal">NULL</span> : p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return pointer to next entry in ziplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zl is the pointer to the ziplist</span></span><br><span class="line"><span class="comment"> * p is the pointer to the current element</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The element after 'p' is returned, otherwise NULL if we are at the end. */</span></span><br><span class="line"><span class="comment">//返回p指向的entry的下一个entry的头地址</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>) zl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* "p" could be equal to ZIP_END, caused by ziplistDelete,</span></span><br><span class="line"><span class="comment">     * and we should return NULL. Otherwise, we should return NULL</span></span><br><span class="line"><span class="comment">     * when the *next* element is ZIP_END (there is no next entry). */</span></span><br><span class="line">    <span class="comment">//如果p是ZIP_END，后面就没有entry了</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//其实就是把p后移，后移长度是p指向的entry的长度</span></span><br><span class="line">        p = p+zipRawEntryLength(p);</span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END) ? <span class="literal">NULL</span> : p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return pointer to previous entry in ziplist. */</span></span><br><span class="line"><span class="comment">//返回p指向的entry的前一个entry的头地址</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterating backwards from ZIP_END should return the tail. When "p" is</span></span><br><span class="line"><span class="comment">     * equal to the first element of the list, we're already at the head,</span></span><br><span class="line"><span class="comment">     * and should return NULL. */</span></span><br><span class="line">    <span class="comment">//如果p是ZIP_END，上一个entry就是最后一个entry</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="comment">//如果最后一个entry也是ZIP_END，说明zl是空的</span></span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END) ? <span class="literal">NULL</span> : p;</span><br><span class="line">    <span class="comment">//如果p指向的就是第一个entry，前面就没有entry了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == ZIPLIST_ENTRY_HEAD(zl)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则就是把p前移，前移长度是p指向的entry的长度</span></span><br><span class="line">        <span class="comment">//这时就体现出previous_entry_length字段的作用了，之所以要记录前一个entry的长度，就是为了从后向前遍历</span></span><br><span class="line">        entry = zipEntry(p);</span><br><span class="line">        assert(entry.prevrawlen &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> p-entry.prevrawlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get entry pointer to by 'p' and store in either 'e' or 'v' depending</span></span><br><span class="line"><span class="comment"> * on the encoding of the entry. 'e' is always set to NULL to be able</span></span><br><span class="line"><span class="comment"> * to find out whether the string pointer or the integer value was set.</span></span><br><span class="line"><span class="comment"> * Return 0 if 'p' points to the end of the zipmap, 1 otherwise. */</span></span><br><span class="line"><span class="comment">//读取p指向的entry的content字段，如果是字符串就赋给sstr，同时字符串长度赋给slen，如果是整数就赋给sval</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **sstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> *slen, <span class="keyword">long</span> <span class="keyword">long</span> *sval)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="comment">//如果p指向的不是entry，就返回0，表示读取失败</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p[<span class="number">0</span>] == ZIP_END) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sstr) *sstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    entry = zipEntry(p);</span><br><span class="line">    <span class="comment">//如果content的类型的字符串</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">        <span class="comment">//判断一下，防止传进来的sstr指针本身就是NULL</span></span><br><span class="line">        <span class="keyword">if</span> (sstr) &#123;</span><br><span class="line">            *slen = entry.len;</span><br><span class="line">            *sstr = p+entry.headersize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sval) &#123;</span><br><span class="line">            *sval = zipLoadInteger(p+entry.headersize,entry.encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert an entry at "p". */</span></span><br><span class="line"><span class="comment">//毫无意义的函数，和__ziplistInsert参数一样，只是对__ziplistInsert的调用</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a single entry from the ziplist, pointed to by *p.</span></span><br><span class="line"><span class="comment"> * Also update *p in place, to be able to iterate over the</span></span><br><span class="line"><span class="comment"> * ziplist, while deleting entries. */</span></span><br><span class="line"><span class="comment">//在zl中删除p指向的entry，再把下个entry的地址赋给p</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset = *p-zl;</span><br><span class="line">    zl = __ziplistDelete(zl,*p,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store pointer to current element in p, because ziplistDelete will</span></span><br><span class="line"><span class="comment">     * do a realloc which might result in a different "zl"-pointer.</span></span><br><span class="line"><span class="comment">     * When the delete direction is back to front, we might delete the last</span></span><br><span class="line"><span class="comment">     * entry and end up with "p" pointing to ZIP_END, so check this. */</span></span><br><span class="line">    *p = zl+offset;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a range of entries from the ziplist. */</span></span><br><span class="line"><span class="comment">//从第index个entry开始，删除num个entry</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDeleteRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(zl,index);</span><br><span class="line">    <span class="comment">//把p==NULL的判断放在__ziplistDelete里，就不必写成两个函数了</span></span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">NULL</span>) ? zl : __ziplistDelete(zl,p,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare entry pointer to by 'p' with 'entry'. Return 1 if equal. */</span></span><br><span class="line"><span class="comment">//把p指向的entry的content字段，和长度为slen的字符串sstr作比较，相同返回1，不相同返回0</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistCompare</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *sstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sencoding;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> zval, sval;</span><br><span class="line">    <span class="comment">//如果p指向的不是entry，就退出</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    entry = zipEntry(p);</span><br><span class="line">    <span class="comment">//如果content的内容是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">        <span class="comment">/* Raw compare */</span></span><br><span class="line">        <span class="comment">//用memcmp比较字符串</span></span><br><span class="line">        <span class="keyword">if</span> (entry.len == slen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">memcmp</span>(p+entry.headersize,sstr,slen) == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果content的内容是整数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Try to compare encoded values */</span></span><br><span class="line">        <span class="comment">//先把字符串表示的整数转换成int类型</span></span><br><span class="line">        <span class="keyword">if</span> (zipTryEncoding(sstr,slen,&amp;sval,&amp;sencoding)) &#123;</span><br><span class="line">            <span class="comment">//encoding相不相等其实无所谓吧，encoding不相等的话值肯定不会相等的，存疑？</span></span><br><span class="line">            <span class="keyword">if</span> (entry.encoding == sencoding) &#123;</span><br><span class="line">                zval = zipLoadInteger(p+entry.headersize,entry.encoding);</span><br><span class="line">                <span class="keyword">return</span> zval == sval;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return length of ziplist. */</span></span><br><span class="line"><span class="comment">//返回zllen字段的值，也就是ziplist中存储的entry的数量</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//因为zllen的类型是uint16_t，所以如果zllen小于UINT16_MAX，说明表示的值是有效的</span></span><br><span class="line">    <span class="keyword">if</span> (ZIPLIST_LENGTH(zl) &lt; UINT16_MAX) &#123;</span><br><span class="line">        len = ZIPLIST_LENGTH(zl);</span><br><span class="line">    <span class="comment">//如果zllen等于UINT16_MAX，说明溢出了，需要遍历ziplist数entry的个数，数量存在len变量里</span></span><br><span class="line">    <span class="comment">//len是uint32_t，所以ziplist支持的最大entry数量是uint32_t的上界</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//p定位在第一个entry的头地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zl+ZIPLIST_HEADER_SIZE;</span><br><span class="line">        <span class="keyword">while</span> (*p != ZIP_END) &#123;</span><br><span class="line">            p += zipRawEntryLength(p);</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Re-store length if small enough */</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; UINT16_MAX) ZIPLIST_LENGTH(zl) = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return size in bytes of ziplist. */</span></span><br><span class="line"><span class="comment">//返回zlbytes字段的值，也就是ziplist的总字节数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistSize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ZIPLIST_BYTES(zl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印ziplist的结构，debug用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ziplistRepr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    zlentry entry;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"&#123;total bytes %d&#125; "</span></span><br><span class="line">        <span class="string">"&#123;length %u&#125;\n"</span></span><br><span class="line">        <span class="string">"&#123;tail offset %u&#125;\n"</span>,</span><br><span class="line">        ZIPLIST_BYTES(zl),</span><br><span class="line">        ZIPLIST_LENGTH(zl),</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl));</span><br><span class="line">    p = ZIPLIST_ENTRY_HEAD(zl);</span><br><span class="line">    <span class="keyword">while</span>(*p != ZIP_END) &#123;</span><br><span class="line">        entry = zipEntry(p);</span><br><span class="line">        <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">"&#123;"</span></span><br><span class="line">                <span class="string">"addr 0x%08lx, "</span></span><br><span class="line">                <span class="string">"index %2d, "</span></span><br><span class="line">                <span class="string">"offset %5ld, "</span></span><br><span class="line">                <span class="string">"rl: %5u, "</span></span><br><span class="line">                <span class="string">"hs %2u, "</span></span><br><span class="line">                <span class="string">"pl: %5u, "</span></span><br><span class="line">                <span class="string">"pls: %2u, "</span></span><br><span class="line">                <span class="string">"payload %5u"</span></span><br><span class="line">            <span class="string">"&#125; "</span>,</span><br><span class="line">            (<span class="keyword">long</span> <span class="keyword">unsigned</span>)p,</span><br><span class="line">            index,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (p-zl),</span><br><span class="line">            entry.headersize+entry.len,</span><br><span class="line">            entry.headersize,</span><br><span class="line">            entry.prevrawlen,</span><br><span class="line">            entry.prevrawlensize,</span><br><span class="line">            entry.len);</span><br><span class="line">        p += entry.headersize;</span><br><span class="line">        <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fwrite(p,<span class="number">40</span>,<span class="number">1</span>,<span class="built_in">stdout</span>) == <span class="number">0</span>) perror(<span class="string">"fwrite"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"..."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.len &amp;&amp;</span><br><span class="line">                    fwrite(p,entry.len,<span class="number">1</span>,<span class="built_in">stdout</span>) == <span class="number">0</span>) perror(<span class="string">"fwrite"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>) zipLoadInteger(p,entry.encoding));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        p += entry.len;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#123;end&#125;\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-压缩字典"><a href="#3-3-压缩字典" class="headerlink" title="3.3 压缩字典"></a>3.3 压缩字典</h2><h3 id="zipmap-c"><a href="#zipmap-c" class="headerlink" title="zipmap.c"></a>zipmap.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; String Map data structure optimized for size.</span></span><br><span class="line"><span class="comment">//和ziplist类似，zipmap是为节省内存而设计的一种存储String-&gt;String数据的字符串形式的字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory layout of a zipmap, for the map "foo" =&gt; "bar", "hello" =&gt; "world":</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;zmlen&gt;&lt;len&gt;"foo"&lt;len&gt;&lt;free&gt;"bar"&lt;len&gt;"hello"&lt;len&gt;&lt;free&gt;"world"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zmlen字段存储的是zipmap中的key-value对的数量，只有1字节，当zipmap长度超过254时，zmlen的值就失效了，需要遍历zipmap来得到真实的key-value数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个len字段存储的是它后面的数据的字节数，数据可能是key也可能是value，len字段长度是1字节或5字节。当第一个字节值小于254时，表示len字段只有1个字节，该字节的值就是数据的长度。当第一个字节值等于254时，表示len字段有5个字节，后面4个字节的值才是数据的长度。当第一个字节值等于255时，表示到了zipmap的末尾。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 因为每个字符串前面都有len字段，所以执行查询操作时，不需要逐字节比较，直接取len长度的字符串用memcmp比较一次即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * free字段存储的是可用的空闲字节数，如果把某个value字符串替换成更短的字符串，后面就会留出多余的字节。空闲字节数只需要1个字节表示，如果空出来的字节数过多，zipmap会被realloc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The most compact representation of the above two elements hash is actually:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * "\x02\x03foo\x03\x00bar\x05hello\x05\x00world\xff"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//254是len字段的分界值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_BIGLEN 254</span></span><br><span class="line"><span class="comment">//255是zipmap尾部的标记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_END 255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following defines the max value for the &lt;free&gt; field described in the</span></span><br><span class="line"><span class="comment"> * comments above, that is, the max number of trailing bytes in a value. */</span></span><br><span class="line"><span class="comment">//zipmap允许的最大free字节数3(4是不可取的上限)，所以free字段只需要1个字节表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_VALUE_MAX_FREE 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following macro returns the number of bytes needed to encode the length</span></span><br><span class="line"><span class="comment"> * for the integer value _l, that is, 1 byte for lengths &lt; ZIPMAP_BIGLEN and</span></span><br><span class="line"><span class="comment"> * 5 bytes for all the other lengths. */</span></span><br><span class="line"><span class="comment">//返回表示长度_l的len字段所需的字节数，如果小于254就只需要1个字节，否则需要5个字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_LEN_BYTES(_l) (((_l) &lt; ZIPMAP_BIGLEN) ? 1 : sizeof(unsigned int)+1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new empty zipmap. */</span></span><br><span class="line"><span class="comment">//创建空的zipmap</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zm = zmalloc(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//没存储key-value时，只有zmlen字段和表示结尾的len字段，zmlen=0表示存储了0个key-value对，len=255是zipmap末尾的标记</span></span><br><span class="line">    zm[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">/* Length */</span></span><br><span class="line">    zm[<span class="number">1</span>] = ZIPMAP_END;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the encoded length pointed by 'p' */</span></span><br><span class="line"><span class="comment">//获取len字段表示的数值，p指向的是某个len字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapDecodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//len是int类型，所以默认取1个字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = *p;</span><br><span class="line">    <span class="comment">//第一个字节的值小于254，说明len字段只有1个字节</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; ZIPMAP_BIGLEN) <span class="keyword">return</span> len;</span><br><span class="line">    <span class="comment">//否则len的值就是p后面的4个字节表示的值</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;len,p+<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode the length 'l' writing it in 'p'. If p is NULL it just returns</span></span><br><span class="line"><span class="comment"> * the amount of bytes required to encode such a length. */</span></span><br><span class="line"><span class="comment">//返回表示长度len需要的字节数，并把len的数值写入p指向的len字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果p没有指向len字段，就只获取需要的字节数，不必把len写入p</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ZIPMAP_LEN_BYTES(len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//以ZIPMAP_BIGLEN为分界判断需要1个字节还是5个字节</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIPMAP_BIGLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[<span class="number">0</span>] = ZIPMAP_BIGLEN;</span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search for a matching key, returning a pointer to the entry inside the</span></span><br><span class="line"><span class="comment"> * zipmap. Returns NULL if the key is not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If NULL is returned, and totlen is not NULL, it is set to the entire</span></span><br><span class="line"><span class="comment"> * size of the zimap, so that the calling function will be able to</span></span><br><span class="line"><span class="comment"> * reallocate the original zipmap to make room for more entries. */</span></span><br><span class="line"><span class="comment">//在zm中查找长度为klen的key并返回，同时把zm的总字节数存入参数totlen中</span></span><br><span class="line"><span class="comment">//因为这两种操作都需要进行遍历，所以索性写在一个函数里</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapLookupRaw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">int</span> *totlen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//跳过zmlen字段，p指向第一个len字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zm+<span class="number">1</span>, *k = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l,llen;</span><br><span class="line">    <span class="comment">//p指向的字节的值不是ZIPMAP_END，说明后面还有key-value对</span></span><br><span class="line">    <span class="keyword">while</span>(*p != ZIPMAP_END) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Match or skip the key */</span></span><br><span class="line">        <span class="comment">//l是下个key的字节数，llen是len字段的字节数</span></span><br><span class="line">        l = zipmapDecodeLength(p);</span><br><span class="line">        llen = zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">        <span class="comment">//如果参数的key和zipmap中的key相等</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">NULL</span> &amp;&amp; l == klen &amp;&amp; !<span class="built_in">memcmp</span>(p+llen,key,l)) &#123;</span><br><span class="line">            <span class="comment">/* Only return when the user doesn't care</span></span><br><span class="line"><span class="comment">             * for the total length of the zipmap. */</span></span><br><span class="line">            <span class="comment">//totlen != NULL说明需要返回zm的总字节数，即使找到了给定的key也要遍历完整个zipmap</span></span><br><span class="line">            <span class="keyword">if</span> (totlen != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                k = p;</span><br><span class="line">            <span class="comment">//totlen == NULL说明不需要返回zm的总字节数，找到了给定的key就结束</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跳过了&lt;len&gt;&lt;key&gt;两个字段，开始解析&lt;len&gt;&lt;free&gt;&lt;value&gt;三个字段</span></span><br><span class="line">        <span class="comment">//一个key-value对包含&lt;len&gt;&lt;key&gt;&lt;len&gt;&lt;free&gt;&lt;value&gt;这5个字段</span></span><br><span class="line">        p += llen+l;</span><br><span class="line">        <span class="comment">/* Skip the value as well */</span></span><br><span class="line">        <span class="comment">//因为查找的目标是key，所以value不用比较</span></span><br><span class="line">        <span class="comment">//p指针移动的长度包含四部分，len字段，free字段，value字段，以及free字段标示的value尾部的空余字节</span></span><br><span class="line">        l = zipmapDecodeLength(p);</span><br><span class="line">        p += zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">        <span class="built_in">free</span> = p[<span class="number">0</span>];</span><br><span class="line">        p += l+<span class="number">1</span>+<span class="built_in">free</span>; <span class="comment">/* +1 to skip the free byte */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历到ZIPMAP_END后，把zm的总字节数存入totlen</span></span><br><span class="line">    <span class="keyword">if</span> (totlen != <span class="literal">NULL</span>) *totlen = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(p-zm)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定key的长度和value的长度，返回存储该key-value对需要的总字节数</span></span><br><span class="line"><span class="comment">//也就是&lt;len&gt;&lt;key&gt;&lt;len&gt;&lt;free&gt;&lt;value&gt;的总字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zipmapRequiredLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line">    <span class="comment">//两个len字段和free字段默认都是1个字节</span></span><br><span class="line">    l = klen+vlen+<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//如果长度超过253个字节，len字段需要5个字节</span></span><br><span class="line">    <span class="keyword">if</span> (klen &gt;= ZIPMAP_BIGLEN) l += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (vlen &gt;= ZIPMAP_BIGLEN) l += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the total amount used by a key (encoded length + payload) */</span></span><br><span class="line"><span class="comment">//p指向len字段，返回&lt;len&gt;&lt;key&gt;两个字段的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapRawKeyLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//l是key的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l = zipmapDecodeLength(p);</span><br><span class="line">    <span class="comment">//zipmapEncodeLength得到的是记录l需要的len字段的字节数</span></span><br><span class="line">    <span class="keyword">return</span> zipmapEncodeLength(<span class="literal">NULL</span>,l) + l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the total amount used by a value</span></span><br><span class="line"><span class="comment"> * (encoded length + single byte free count + payload) */</span></span><br><span class="line"><span class="comment">//p指向len字段，返回&lt;len&gt;&lt;free&gt;&lt;value&gt;三个字段的字节数，但value尾部的空余字节不被计入</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapRawValueLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l = zipmapDecodeLength(p);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> used;</span><br><span class="line">    <span class="comment">//used得到的是value字段的有效长度，而不是全部长度，因为排除了尾部的空余字节</span></span><br><span class="line">    used = zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">    used += p[used] + <span class="number">1</span> + l;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If 'p' points to a key, this function returns the total amount of</span></span><br><span class="line"><span class="comment"> * bytes used to store this entry (entry = key + associated value + trailing</span></span><br><span class="line"><span class="comment"> * free space if any). */</span></span><br><span class="line"><span class="comment">//p指向len字段，返回一个key-value对，也就是&lt;len&gt;&lt;key&gt;&lt;len&gt;&lt;free&gt;&lt;value&gt;5个字段的字节数</span></span><br><span class="line"><span class="comment">//仿照ziplist，这样一个key-value对也叫做一个entry</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapRawEntryLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l = zipmapRawKeyLength(p);</span><br><span class="line">    <span class="keyword">return</span> l + zipmapRawValueLength(p+l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新调整zipmap的大小，参数len是zipmap的总字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    zm = zrealloc(zm, len);</span><br><span class="line">    zm[len<span class="number">-1</span>] = ZIPMAP_END;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set key to value, creating the key if it does not already exist.</span></span><br><span class="line"><span class="comment"> * If 'update' is not NULL, *update is set to 1 if the key was</span></span><br><span class="line"><span class="comment"> * already preset, otherwise to 0. */</span></span><br><span class="line"><span class="comment">//把长度为klen的vlen的key-value对插入到zm中。如果key已经存在，就变成更新对应的value，同时把参数update设为1</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapSet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">int</span> *update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> zmlen, offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> freelen, reqlen = zipmapRequiredLength(klen,vlen);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> empty, vempty;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">   </span><br><span class="line">    freelen = reqlen;</span><br><span class="line">    <span class="keyword">if</span> (update) *update = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//在zm中查找key，同时把zm的总字节数存在变量zmlen中</span></span><br><span class="line">    p = zipmapLookupRaw(zm,key,klen,&amp;zmlen);</span><br><span class="line">    <span class="comment">//如果key不存在，就是插入新的key-value</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Key not found: enlarge */</span></span><br><span class="line">        <span class="comment">//先给zm扩容，增加的reqlen是存储key-value需要的字节数</span></span><br><span class="line">        zm = zipmapResize(zm, zmlen+reqlen);</span><br><span class="line">        <span class="comment">//默认在尾部插入，所以把p指向到倒数第二个字节，因为最后一个字节是0xff的结束符</span></span><br><span class="line">        p = zm+zmlen<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//新zipmap的总字节数</span></span><br><span class="line">        zmlen = zmlen+reqlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increase zipmap length (this is an insert) */</span></span><br><span class="line">        <span class="comment">//如果zmlen字段没有溢出，就加一表示zm的真实长度</span></span><br><span class="line">        <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>]++;</span><br><span class="line">    <span class="comment">//如果key已经存在，就是更新value</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Key found. Is there enough space for the new value? */</span></span><br><span class="line">        <span class="comment">/* Compute the total length: */</span></span><br><span class="line">        <span class="keyword">if</span> (update) *update = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//得到当前key所在的整个entry的字节数</span></span><br><span class="line">        freelen = zipmapRawEntryLength(p);</span><br><span class="line">        <span class="comment">//如果目标entry的长度不够，就要先扩容</span></span><br><span class="line">        <span class="keyword">if</span> (freelen &lt; reqlen) &#123;</span><br><span class="line">            <span class="comment">/* Store the offset of this key within the current zipmap, so</span></span><br><span class="line"><span class="comment">             * it can be resized. Then, move the tail backwards so this</span></span><br><span class="line"><span class="comment">             * pair fits at the current position. */</span></span><br><span class="line">            offset = p-zm;</span><br><span class="line">            <span class="comment">//增加的长度是reqlen-freelen，也就是新entry比旧entry多的字节数</span></span><br><span class="line">            <span class="comment">//因为&lt;len&gt;&lt;key&gt;&lt;free&gt;三个字段长度都不变，所以增加的长度是&lt;len&gt;&lt;value&gt;两个字段的</span></span><br><span class="line">            zm = zipmapResize(zm, zmlen-freelen+reqlen);</span><br><span class="line">            <span class="comment">//在新的zm中定位到当前entry</span></span><br><span class="line">            p = zm+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The +1 in the number of bytes to be moved is caused by the</span></span><br><span class="line"><span class="comment">             * end-of-zipmap byte. Note: the *original* zmlen is used. */</span></span><br><span class="line">            <span class="comment">//更新的value不一定在zm尾部，所以要把后面的内容后移，防止数据覆盖</span></span><br><span class="line">            <span class="comment">//p+freelen是旧zm中下个entry的地址，p+reqlen是新zm中下个entry应该在的地址</span></span><br><span class="line">            memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+<span class="number">1</span>));</span><br><span class="line">            <span class="comment">//计算新zm的总字节数</span></span><br><span class="line">            zmlen = zmlen-freelen+reqlen;</span><br><span class="line">            freelen = reqlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We now have a suitable block where the key/value entry can</span></span><br><span class="line"><span class="comment">     * be written. If there is too much free space, move the tail</span></span><br><span class="line"><span class="comment">     * of the zipmap a few bytes to the front and shrink the zipmap,</span></span><br><span class="line"><span class="comment">     * as we want zipmaps to be very space efficient. */</span></span><br><span class="line">    <span class="comment">//需要扩容的情况一定是扩容到刚刚好，所以value尾部不会有空余字节。</span></span><br><span class="line">    <span class="comment">//只有在更新value且新value长度比旧value小的情况下，才会有空余字节</span></span><br><span class="line">    empty = freelen-reqlen;</span><br><span class="line">    <span class="comment">//空余字节大于等于ZIPMAP_VALUE_MAX_FREE，就需要收缩zm</span></span><br><span class="line">    <span class="keyword">if</span> (empty &gt;= ZIPMAP_VALUE_MAX_FREE) &#123;</span><br><span class="line">        <span class="comment">/* First, move the tail &lt;empty&gt; bytes to the front, then resize</span></span><br><span class="line"><span class="comment">         * the zipmap to be &lt;empty&gt; bytes smaller. */</span></span><br><span class="line">        offset = p-zm;</span><br><span class="line">        memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+<span class="number">1</span>));</span><br><span class="line">        zmlen -= empty;</span><br><span class="line">        zm = zipmapResize(zm, zmlen);</span><br><span class="line">        p = zm+offset;</span><br><span class="line">        vempty = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则就留着空余字节，把字节数记在free字段</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vempty = empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just write the key + value and we are done. */</span></span><br><span class="line">    <span class="comment">/* Key: */</span></span><br><span class="line">    <span class="comment">//写入第一个len字段，p移动到key字段</span></span><br><span class="line">    p += zipmapEncodeLength(p,klen);</span><br><span class="line">    <span class="comment">//写入key字段</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,key,klen);</span><br><span class="line">    <span class="comment">//p移动到第二个len字段</span></span><br><span class="line">    p += klen;</span><br><span class="line">    <span class="comment">/* Value: */</span></span><br><span class="line">    <span class="comment">//写入第二个len字段，p移动到free字段</span></span><br><span class="line">    p += zipmapEncodeLength(p,vlen);</span><br><span class="line">    <span class="comment">//写入free字段，p移动到value字段</span></span><br><span class="line">    *p++ = vempty;</span><br><span class="line">    <span class="comment">//写入value</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,val,vlen);</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove the specified key. If 'deleted' is not NULL the pointed integer is</span></span><br><span class="line"><span class="comment"> * set to 0 if the key was not found, to 1 if it was found and deleted. */</span></span><br><span class="line"><span class="comment">//删除给定key的key-value对</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapDel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">int</span> *deleted)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> zmlen, freelen;</span><br><span class="line">    <span class="comment">//查找key，并得到zm总字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zipmapLookupRaw(zm,key,klen,&amp;zmlen);</span><br><span class="line">    <span class="comment">//找到key了</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="comment">//得到entry的字节数</span></span><br><span class="line">        freelen = zipmapRawEntryLength(p);</span><br><span class="line">        <span class="comment">//把目标entry后面的内容复制到entry头部，相当于覆盖了待删除的entry</span></span><br><span class="line">        memmove(p, p+freelen, zmlen-((p-zm)+freelen+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//收缩zm的长度</span></span><br><span class="line">        zm = zipmapResize(zm, zmlen-freelen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Decrease zipmap length */</span></span><br><span class="line">        <span class="comment">//如果zmlen字段的值有效就维护起来</span></span><br><span class="line">        <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>]--;</span><br><span class="line">        <span class="comment">//标记为删除成功</span></span><br><span class="line">        <span class="keyword">if</span> (deleted) *deleted = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//没找到key直接标记为删除失败</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deleted) *deleted = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call it before to iterate trought elements via zipmapNext() */</span></span><br><span class="line"><span class="comment">//用于开始迭代zipmap时，跳过zmlen字段，功能太简单，没必要单独写成函数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapRewind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zm+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is used to iterate through all the zipmap elements.</span></span><br><span class="line"><span class="comment"> * In the first call the first argument is the pointer to the zipmap + 1.</span></span><br><span class="line"><span class="comment"> * In the next calls what zipmapNext returns is used as first argument.</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * unsigned char *i = zipmapRewind(my_zipmap);</span></span><br><span class="line"><span class="comment"> * while((i = zipmapNext(i,&amp;key,&amp;klen,&amp;value,&amp;vlen)) != NULL) &#123;</span></span><br><span class="line"><span class="comment"> *     printf("%d bytes key at $p\n", klen, key);</span></span><br><span class="line"><span class="comment"> *     printf("%d bytes value at $p\n", vlen, value);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//一步的遍历，只遍历zm指针指向的entry，然后zm指向下一个entry，遍历得到的entry信息保存在参数里的四个指针里</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> **key, <span class="keyword">unsigned</span> <span class="keyword">int</span> *klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> **value, <span class="keyword">unsigned</span> <span class="keyword">int</span> *vlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (zm[<span class="number">0</span>] == ZIPMAP_END) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        *key = zm;</span><br><span class="line">        *klen = zipmapDecodeLength(zm);</span><br><span class="line">        *key += ZIPMAP_LEN_BYTES(*klen);</span><br><span class="line">    &#125;</span><br><span class="line">    zm += zipmapRawKeyLength(zm);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        *value = zm+<span class="number">1</span>;</span><br><span class="line">        *vlen = zipmapDecodeLength(zm);</span><br><span class="line">        *value += ZIPMAP_LEN_BYTES(*vlen);</span><br><span class="line">    &#125;</span><br><span class="line">    zm += zipmapRawValueLength(zm);</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search a key and retrieve the pointer and len of the associated value.</span></span><br><span class="line"><span class="comment"> * If the key is found the function returns 1, otherwise 0. */</span></span><br><span class="line"><span class="comment">//给定长度为klen的key，查询对应的value值并存入参数的value指针，同时把value的长度存入参数的vlen指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipmapGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> **value, <span class="keyword">unsigned</span> <span class="keyword">int</span> *vlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = zipmapLookupRaw(zm,key,klen,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    p += zipmapRawKeyLength(p);</span><br><span class="line">    *vlen = zipmapDecodeLength(p);</span><br><span class="line">    *value = p + ZIPMAP_LEN_BYTES(*vlen) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return 1 if the key exists, otherwise 0 is returned. */</span></span><br><span class="line"><span class="comment">//查询长度为klen的key是否在zm中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipmapExists</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zipmapLookupRaw(zm,key,klen,<span class="literal">NULL</span>) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the number of entries inside a zipmap */</span></span><br><span class="line"><span class="comment">//遍历zipmap，返回entry的数量</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果zmlen字段的值有效，直接返回这个值，无需遍历</span></span><br><span class="line">    <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) &#123;</span><br><span class="line">        len = zm[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//如果zmlen字段溢出了，就需要遍历整个zipmap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zipmapRewind(zm);</span><br><span class="line">        <span class="keyword">while</span>((p = zipmapNext(p,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) != <span class="literal">NULL</span>) len++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Re-store length if small enough */</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>] = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印zipmap的结构，debug用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zipmapRepr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#123;status %u&#125;"</span>,*p++);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIPMAP_END) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;end&#125;"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> e;</span><br><span class="line"></span><br><span class="line">            l = zipmapDecodeLength(p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;key %u&#125;"</span>,l);</span><br><span class="line">            p += zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">            <span class="keyword">if</span> (l != <span class="number">0</span> &amp;&amp; fwrite(p,l,<span class="number">1</span>,<span class="built_in">stdout</span>) == <span class="number">0</span>) perror(<span class="string">"fwrite"</span>);</span><br><span class="line">            p += l;</span><br><span class="line"></span><br><span class="line">            l = zipmapDecodeLength(p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;value %u&#125;"</span>,l);</span><br><span class="line">            p += zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">            e = *p++;</span><br><span class="line">            <span class="keyword">if</span> (l != <span class="number">0</span> &amp;&amp; fwrite(p,l,<span class="number">1</span>,<span class="built_in">stdout</span>) == <span class="number">0</span>) perror(<span class="string">"fwrite"</span>);</span><br><span class="line">            p += l+e;</span><br><span class="line">            <span class="keyword">if</span> (e) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"["</span>);</span><br><span class="line">                <span class="keyword">while</span>(e--) <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-数据类型相关"><a href="#4-数据类型相关" class="headerlink" title="4 数据类型相关"></a>4 数据类型相关</h1><h2 id="4-1-对象系统"><a href="#4-1-对象系统" class="headerlink" title="4.1 对象系统"></a>4.1 对象系统</h2><h3 id="redis-h-对象系统相关部分"><a href="#redis-h-对象系统相关部分" class="headerlink" title="redis.h(对象系统相关部分)"></a>redis.h(对象系统相关部分)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Error codes */</span></span><br><span class="line"><span class="comment">//状态码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_OK                0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ERR               -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Virtual memory object-&gt;where field. */</span></span><br><span class="line"><span class="comment">//对象存储的位置</span></span><br><span class="line"><span class="comment">//内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VM_MEMORY 0       <span class="comment">/* The object is on memory */</span></span></span><br><span class="line"><span class="comment">//磁盘</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VM_SWAPPED 1      <span class="comment">/* The object is on disk */</span></span></span><br><span class="line"><span class="comment">//正在从内存换出到磁盘</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VM_SWAPPING 2     <span class="comment">/* Redis is swapping this object on disk */</span></span></span><br><span class="line"><span class="comment">//正在从磁盘换入内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VM_LOADING 3      <span class="comment">/* Redis is loading this object from disk */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="comment">//对象类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VMPOINTER 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The 'encoding' field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="comment">//对象编码，其实就是所使用的底层数据结构</span></span><br><span class="line"><span class="comment">//简单动态字符串sds</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="comment">//压缩字典</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="comment">//双端链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="comment">//压缩列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="comment">//整数集合</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="comment">//跳跃表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="comment">//逻辑时钟的最大位数，类似现实中的表盘，划分了最大的刻度。计算出的实际LRU时间要对最大刻度LRU_CLOCK_MAX取模</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;21)-1) /* Max value of obj-&gt;lru */</span></span></span><br><span class="line"><span class="comment">//LRU算法的精度，即一个LRU的单位是多长</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_CLOCK_RESOLUTION 10 <span class="comment">/* LRU clock resolution in seconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顶层对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">//对象类型，有6种对象，所以需要4bits表示</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//存储位置，有4种取值，所以需要2bits表示</span></span><br><span class="line">    <span class="keyword">unsigned</span> storage:<span class="number">2</span>;     <span class="comment">/* REDIS_VM_MEMORY or REDIS_VM_SWAPPING */</span></span><br><span class="line">    <span class="comment">//编码，有8中取值，需要4bits表示</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;        <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="comment">//引用计数，用于垃圾回收</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">//指向底层数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">/* VM fields are only allocated if VM is active, otherwise the</span></span><br><span class="line"><span class="comment">     * object allocation function will just allocate</span></span><br><span class="line"><span class="comment">     * sizeof(redisObjct) minus sizeof(redisObjectVM), so using</span></span><br><span class="line"><span class="comment">     * Redis without VM active will not have any overhead. */</span></span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The VM pointer structure - identifies an object in the swap file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This object is stored in place of the value</span></span><br><span class="line"><span class="comment"> * object in the main key-&gt;value hash table representing a database.</span></span><br><span class="line"><span class="comment"> * Note that the first fields (type, storage) are the same as the redisObject</span></span><br><span class="line"><span class="comment"> * structure so that vmPointer strucuters can be accessed even when casted</span></span><br><span class="line"><span class="comment"> * as redisObject structures.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is useful as we don't know if a value object is or not on disk, but we</span></span><br><span class="line"><span class="comment"> * are always able to read obj-&gt;storage to check this. For vmPointer</span></span><br><span class="line"><span class="comment"> * structures "type" is set to REDIS_VMPOINTER (even if without this field</span></span><br><span class="line"><span class="comment"> * is still possible to check the kind of object from the value of 'storage').*/</span></span><br><span class="line"><span class="comment">//标记对象在磁盘交换区的存储位置</span></span><br><span class="line"><span class="comment">//当value存储在内存中时，Redis使用一个RedisObject与之关联；而当value存储在磁盘中时，Redis使用一个VMPointer与之关联。要知道value存储在磁盘中还是内存中，只需判断storage字段。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vmPointer</span> &#123;</span></span><br><span class="line">    <span class="comment">//type和storage两个字段与robj一样</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> storage:<span class="number">2</span>; <span class="comment">/* REDIS_VM_SWAPPED or REDIS_VM_LOADING */</span></span><br><span class="line">    <span class="keyword">unsigned</span> notused:<span class="number">26</span>;</span><br><span class="line">    <span class="comment">//交换出去的对象类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vtype; <span class="comment">/* type of the object stored in the swap file */</span></span><br><span class="line">    <span class="comment">//记录对象在交换区中从哪页开始</span></span><br><span class="line">    <span class="keyword">off_t</span> page;         <span class="comment">/* the page at witch the object is stored on disk */</span></span><br><span class="line">    <span class="comment">//记录对象共包含几页</span></span><br><span class="line">    <span class="keyword">off_t</span> usedpages;    <span class="comment">/* number of pages used on disk */</span></span><br><span class="line">&#125; vmpointer;</span><br></pre></td></tr></table></figure>
<h3 id="object-c"><a href="#object-c" class="headerlink" title="object.c"></a>object.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给定对象类型和底层数据结构的指针，创建新的robj</span></span><br><span class="line"><span class="comment">//默认是基于sds的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    <span class="comment">//先默认ptr是简单动态字符串</span></span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    <span class="comment">//生成对象后引用计数设为1</span></span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution).</span></span><br><span class="line"><span class="comment">     * We do this regardless of the fact VM is active as LRU is also</span></span><br><span class="line"><span class="comment">     * used for the maxmemory directive when Redis is used as cache.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that this code may run in the context of an I/O thread</span></span><br><span class="line"><span class="comment">     * and accessing server.lruclock in theory is an error</span></span><br><span class="line"><span class="comment">     * (no locks). But in practice this is safe, and even if we read</span></span><br><span class="line"><span class="comment">     * garbage Redis will not fail. */</span></span><br><span class="line">    <span class="comment">//设置对象的最后访问时间</span></span><br><span class="line">    <span class="comment">//server.lruclock来源于redis.h定义的redisServer结构体中</span></span><br><span class="line">    o-&gt;lru = server.lruclock;</span><br><span class="line">    <span class="comment">/* The following is only needed if VM is active, but since the conditional</span></span><br><span class="line"><span class="comment">     * is probably more costly than initializing the field it's better to</span></span><br><span class="line"><span class="comment">     * have every field properly initialized anyway. */</span></span><br><span class="line">    <span class="comment">//默认存储在内存中</span></span><br><span class="line">    o-&gt;storage = REDIS_VM_MEMORY;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于简单动态字符串的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createObject(REDIS_STRING,sdsnewlen(ptr,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于整数值的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">//Redis内部采用了shared integer的方式来省去分配内存的开销,即在系统启动时先分配一个从1~REDIS_SHARED_INTEGERS那么多个数值对象放在一个池子中。如果要创建的对象的整数值在这个共享池里，就不用创建新的对象，而是直接返回共享池里的对象，并增加该对象的引用计数</span></span><br><span class="line">    <span class="comment">//只共享了整数类型的对象，大概是因为只有整数的相等能在O(1)时间内验证，共享复杂的对象会影响cpu性能</span></span><br><span class="line">    <span class="comment">//要求当前线程是服务端的主线程，why？</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS &amp;&amp;</span><br><span class="line">        pthread_equal(pthread_self(),server.mainthread)) &#123;</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        o = shared.integers[value];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//支持的最大整数值是long int的上限</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</span><br><span class="line">            o = createObject(REDIS_STRING, <span class="literal">NULL</span>);</span><br><span class="line">            o-&gt;encoding = REDIS_ENCODING_INT;</span><br><span class="line">            o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</span><br><span class="line">        <span class="comment">//如果超过了上限，就不能创建基于整数值的字符串对象，而是要把整数值转成sds，创建基于sds的字符串对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = createObject(REDIS_STRING,sdsfromlonglong(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串对象的深拷贝，原对象与副本对象的ptr指针指向的不是同一个sds，因为在调用createStringObject时用sdsnewlen函数基于原对象的sds生成了一个新的sds对象</span></span><br><span class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    redisAssert(o-&gt;encoding == REDIS_ENCODING_RAW);</span><br><span class="line">    <span class="keyword">return</span> createStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于双端链表(adlist)的列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建底层的adlist</span></span><br><span class="line">    <span class="built_in">list</span> *l = listCreate();</span><br><span class="line">    <span class="comment">//指定类型是列表，创建robj</span></span><br><span class="line">    robj *o = createObject(REDIS_LIST,l);</span><br><span class="line">    <span class="comment">//把adlist的free函数设为引用计数减一的函数</span></span><br><span class="line">    listSetFreeMethod(l,decrRefCount);</span><br><span class="line">    <span class="comment">//底层数据结构设为adlist</span></span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于压缩列表(ziplist)的列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(REDIS_LIST,zl);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于字典(dict)的集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict *d = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    robj *o = createObject(REDIS_SET,d);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于整数集合(intset)的集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = intsetNew();</span><br><span class="line">    robj *o = createObject(REDIS_SET,is);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于压缩字典(zipmap)的哈希对象(后来的版本中取消了zipmap，使用ziplist实现哈希对象)</span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* All the Hashes start as zipmaps. Will be automatically converted</span></span><br><span class="line"><span class="comment">     * into hash tables if there are enough elements or big elements</span></span><br><span class="line"><span class="comment">     * inside. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zm = zipmapNew();</span><br><span class="line">    robj *o = createObject(REDIS_HASH,zm);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_ZIPMAP;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于跳跃表(skiplist)和字典(dict)的有序集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(REDIS_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放字符串对象</span></span><br><span class="line"><span class="comment">//为什么只释放sds类型的对象？难道是因为long int占的空间少所以没必要释放？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        sdsfree(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放列表对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line">    <span class="comment">//adlist是列表指针套着节点指针的复杂结构，所以需要单独设计的free函数，用zfree只能释放列表指针，不能释放里面的节点指针</span></span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_LINKEDLIST:</span><br><span class="line">        listRelease((<span class="built_in">list</span>*) o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//ziplist就是个字符串，所以不需要为它单独定义一个free函数，直接用zfree</span></span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST:</span><br><span class="line">        zfree(o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_HT:</span><br><span class="line">        dictRelease((dict*) o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//intset只有一个结构体指针，所以也可以用zfree释放</span></span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_INTSET:</span><br><span class="line">        zfree(o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        redisPanic(<span class="string">"Unknown set encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放有序集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    zset *zs = o-&gt;ptr;</span><br><span class="line">    <span class="comment">//zset包含一个adlist和一个dict，所以要先分别调用各自的free函数，最后再释放最外层的zset指针</span></span><br><span class="line">    dictRelease(zs-&gt;dict);</span><br><span class="line">    zslFree(zs-&gt;zsl);</span><br><span class="line">    zfree(zs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放哈希对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_HT:</span><br><span class="line">        dictRelease((dict*) o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//zipmap只是个字符串</span></span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPMAP:</span><br><span class="line">        zfree(o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        redisPanic(<span class="string">"Unknown hash encoding type"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的引用计数加一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    o-&gt;refcount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的引用计数加一，如果会减到0意味着要释放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(<span class="keyword">void</span> *obj)</span> </span>&#123;</span><br><span class="line">    robj *o = obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Object is a swapped out value, or in the process of being loaded. */</span></span><br><span class="line">    <span class="comment">//如果对象存在磁盘上</span></span><br><span class="line">    <span class="keyword">if</span> (server.vm_enabled &amp;&amp;</span><br><span class="line">        (o-&gt;storage == REDIS_VM_SWAPPED || o-&gt;storage == REDIS_VM_LOADING))</span><br><span class="line">    &#123;</span><br><span class="line">        vmpointer *vp = obj;</span><br><span class="line">        <span class="comment">//如果对象正在被加载到内存，先中止当前作业，因为当前作业可能会篡改对象，或者删除对象会使当前作业产生错误</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;storage == REDIS_VM_LOADING) vmCancelThreadedIOJob(o);</span><br><span class="line">        <span class="comment">//被交换到磁盘上的对象引用只能是1，所以引用计数减一就是删除对象</span></span><br><span class="line">        <span class="comment">//释放对象占用的所有页</span></span><br><span class="line">        vmMarkPagesFree(vp-&gt;page,vp-&gt;usedpages);</span><br><span class="line">        server.vm_stats_swapped_objects--;</span><br><span class="line">        <span class="comment">//最后释放对象的指针</span></span><br><span class="line">        zfree(vp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象已经没有引用了，还要求减引用就说明出bug了</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line">    <span class="comment">/* Object is in memory, or in the process of being swapped out.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the object is being swapped out, abort the operation on</span></span><br><span class="line"><span class="comment">     * decrRefCount even if the refcount does not drop to 0: the object</span></span><br><span class="line"><span class="comment">     * is referenced at least two times, as value of the key AND as</span></span><br><span class="line"><span class="comment">     * job-&gt;val in the iojob. So if we don't invalidate the iojob, when it is</span></span><br><span class="line"><span class="comment">     * done but the relevant key was removed in the meantime, the</span></span><br><span class="line"><span class="comment">     * complete jobs handler will not find the key about the job and the</span></span><br><span class="line"><span class="comment">     * assert will fail. */</span></span><br><span class="line">    <span class="comment">//如果对象存在内存里，但正在把对象交换到磁盘上，也需要先中止作业</span></span><br><span class="line">    <span class="keyword">if</span> (server.vm_enabled &amp;&amp; o-&gt;storage == REDIS_VM_SWAPPING)</span><br><span class="line">        vmCancelThreadedIOJob(o);</span><br><span class="line">    <span class="comment">//如果当前引用数是1，再减就会到0，所以直接删除对象，执行对象的free函数</span></span><br><span class="line">    <span class="keyword">if</span> (--(o-&gt;refcount) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> REDIS_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: redisPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;ptr = <span class="literal">NULL</span>; <span class="comment">/* defensive programming. We'll see NULL in traces. */</span></span><br><span class="line">        <span class="comment">//最后释放robj的指针</span></span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端对客户端提交的对象进行类型检查</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkType</span><span class="params">(redisClient *c, robj *o, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != type) &#123;</span><br><span class="line">        <span class="comment">//如果类型错误，把错误信息返回给客户端</span></span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to encode a string object in order to save space */</span></span><br><span class="line"><span class="comment">//尝试编码字符串对象以节省空间，其实就是尝试用整数值替换sds字符串</span></span><br><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果对象存储的已经是整数的表示了，就不需要修改</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != REDIS_ENCODING_RAW)</span><br><span class="line">        <span class="keyword">return</span> o; <span class="comment">/* Already encoded */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It's not safe to encode shared objects: shared objects can be shared</span></span><br><span class="line"><span class="comment">     * everywhere in the "object space" of Redis. Encoded objects can only</span></span><br><span class="line"><span class="comment">     * appear as "values" (and not, for instance, as keys) */</span></span><br><span class="line">    <span class="comment">//如果当前对象有多个引用，在此修改对象是不安全的，直接退出</span></span><br><span class="line">     <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Currently we try to encode only strings */</span></span><br><span class="line">    <span class="comment">//只能编码字符串对象</span></span><br><span class="line">    redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we can represent this string as a long integer */</span></span><br><span class="line">    <span class="comment">//如果当前对象存储的sds字符串不能转成整数，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (isStringRepresentableAsLong(s,&amp;value) == REDIS_ERR) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ok, this object can be encoded...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Can I use a shared object? Only if the object is inside a given</span></span><br><span class="line"><span class="comment">     * range and if this is the main thread, since when VM is enabled we</span></span><br><span class="line"><span class="comment">     * have the constraint that I/O thread should only handle non-shared</span></span><br><span class="line"><span class="comment">     * objects, in order to avoid race conditions (we don't have per-object</span></span><br><span class="line"><span class="comment">     * locking).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we also avoid using shared integers when maxmemory is used</span></span><br><span class="line"><span class="comment">     * because very object needs to have a private LRU field for the LRU</span></span><br><span class="line"><span class="comment">     * algorithm to work well. */</span></span><br><span class="line">    <span class="comment">//如果能用共享池里的对象，就删除当前对象，返回共享池里的对象</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory == <span class="number">0</span> &amp;&amp; value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS &amp;&amp;</span><br><span class="line">        pthread_equal(pthread_self(),server.mainthread)) &#123;</span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">    <span class="comment">//如果没用共享池里的对象，就修改当前对象的ptr，释放sds数据，把ptr指向相应的整型数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//把数据类型变成int</span></span><br><span class="line">        o-&gt;encoding = REDIS_ENCODING_INT;</span><br><span class="line">        sdsfree(o-&gt;ptr);</span><br><span class="line">        o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get a decoded version of an encoded object (returned as a new object).</span></span><br><span class="line"><span class="comment"> * If the object is already raw-encoded just increment the ref count. */</span></span><br><span class="line"><span class="comment">//和tryObjectEncoding相反，是把基于整数的字符串对象转换成基于sds的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    robj *dec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果已经是基于sds的字符串对象，引用加一并返回</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        incrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type == REDIS_STRING &amp;&amp; o-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        ll2string(buf,<span class="number">32</span>,(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">        dec = createStringObject(buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare two string objects via strcmp() or alike.</span></span><br><span class="line"><span class="comment"> * Note that the objects may be integer-encoded. In such a case we</span></span><br><span class="line"><span class="comment"> * use ll2string() to get a string representation of the numbers on the stack</span></span><br><span class="line"><span class="comment"> * and compare the strings, it's much faster than calling getDecodedObject().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Important note: if objects are not integer encoded, but binary-safe strings,</span></span><br><span class="line"><span class="comment"> * sdscmp() from sds.c will apply memcmp() so this function ca be considered</span></span><br><span class="line"><span class="comment"> * binary safe. */</span></span><br><span class="line"><span class="comment">//比较两个字符串对象保存的数据是否相同，最后比较的是两个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareStringObjects</span><span class="params">(robj *a, robj *b)</span> </span>&#123;</span><br><span class="line">    redisAssert(a-&gt;type == REDIS_STRING &amp;&amp; b-&gt;type == REDIS_STRING);</span><br><span class="line">    <span class="comment">//只能比较最长128个字节的字符串</span></span><br><span class="line">    <span class="keyword">char</span> bufa[<span class="number">128</span>], bufb[<span class="number">128</span>], *astr, *bstr;</span><br><span class="line">    <span class="keyword">int</span> bothsds = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果两个指针指向的是一个对象，就说明是相等的，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果是基于整数的字符串对象，要先转成sds字符串，最后再比较两个对象的sds字符串</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        ll2string(bufa,<span class="keyword">sizeof</span>(bufa),(<span class="keyword">long</span>) a-&gt;ptr);</span><br><span class="line">        astr = bufa;</span><br><span class="line">        bothsds = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        astr = a-&gt;ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        ll2string(bufb,<span class="keyword">sizeof</span>(bufb),(<span class="keyword">long</span>) b-&gt;ptr);</span><br><span class="line">        bstr = bufb;</span><br><span class="line">        bothsds = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bstr = b-&gt;ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果都是原生的sds字符串，就用sdscmp比较，如果二者之中有整数转成的字符串，就用strcmp比较</span></span><br><span class="line">    <span class="comment">//其实根本没区别，因为二者要么是ll2string产生的字符串，要么是sdshdr结构体中的buf字符串，都是字符串，直接用strcmp就可以</span></span><br><span class="line">    <span class="keyword">return</span> bothsds ? sdscmp(astr,bstr) : <span class="built_in">strcmp</span>(astr,bstr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Equal string objects return 1 if the two objects are the same from the</span></span><br><span class="line"><span class="comment"> * point of view of a string comparison, otherwise 0 is returned. Note that</span></span><br><span class="line"><span class="comment"> * this function is faster then checking for (compareStringObject(a,b) == 0)</span></span><br><span class="line"><span class="comment"> * because it can perform some more optimization. */</span></span><br><span class="line"><span class="comment">//比较两个字符串对象保存的数据是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">equalStringObjects</span><span class="params">(robj *a, robj *b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果都存储的整数，直接比较整数</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;encoding != REDIS_ENCODING_RAW &amp;&amp; b-&gt;encoding != REDIS_ENCODING_RAW)&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;ptr == b-&gt;ptr;</span><br><span class="line">    <span class="comment">//如果不全是整数，就都转成字符串比较</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compareStringObjects(a,b) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符串对象存储的数据的长度</span></span><br><span class="line"><span class="keyword">size_t</span> stringObjectLen(robj *o) &#123;</span><br><span class="line">    redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">    <span class="comment">//对于sds直接调用sds的len函数</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        <span class="keyword">return</span> sdslen(o-&gt;ptr);</span><br><span class="line">    <span class="comment">//对于整数值，返回其转成的字符串的长度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">return</span> ll2string(buf,<span class="number">32</span>,(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串对象中获取double类型的数值，虽然字符串对象能以数值形式保存的只有整数，但浮点数可以以sds的形式存在对象中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObject</span><span class="params">(robj *o, <span class="keyword">double</span> *target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">        <span class="comment">//如果是sds就转成浮点数</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            <span class="comment">//strtod把ptr指向的字符串转成浮点数，eptr指向的是遇到的第一个无法转成数值的字符</span></span><br><span class="line">            value = strtod(o-&gt;ptr, &amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(value)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        <span class="comment">//如果对象存的是整数，就把整数赋给浮点数变量</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">            value = (<span class="keyword">long</span>)o-&gt;ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisPanic(<span class="string">"Unknown string encoding"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端从对象中获取double类型的数值，返回给客户端</span></span><br><span class="line"><span class="comment">//返回的值写入target指针，msg保存的是获取失败的情况下默认返回给客户端的错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    <span class="keyword">if</span> (getDoubleFromObject(o, &amp;value) != REDIS_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyError(c,(<span class="keyword">char</span>*)msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"value is not a double"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串对象中获取long long类型的数值，和getDoubleFromObject的逻辑相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            <span class="comment">//strtoll把ptr指向的字符串转成10进制的long long类型的值，eptr指向的是遇到的第一个无法转成数值的字符</span></span><br><span class="line">            value = strtoll(o-&gt;ptr, &amp;eptr, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span>) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            <span class="comment">//errno 是记录系统的最后一次错误代码，ERANGE是&lt;errno.h&gt;里的宏定义，表示有某个变量溢出了</span></span><br><span class="line">            <span class="comment">//为什么getDoubleFromObject里不用判断越界呢？</span></span><br><span class="line">            <span class="keyword">if</span> (errno == ERANGE &amp;&amp; (value == LLONG_MIN || value == LLONG_MAX))</span><br><span class="line">                <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">            value = (<span class="keyword">long</span>)o-&gt;ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisPanic(<span class="string">"Unknown string encoding"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target) *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端从对象中获取long long类型的数值，返回给客户端</span></span><br><span class="line"><span class="comment">//和getDoubleFromObjectOrReply逻辑相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObject(o, &amp;value) != REDIS_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyError(c,(<span class="keyword">char</span>*)msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"value is not an integer or out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端从对象中获取long类型的数值，返回给客户端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="comment">//为什么不用专门写一个getLongFromObject函数呢？</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, o, &amp;value, msg) != REDIS_OK) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; LONG_MIN || value &gt; LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyError(c,(<span class="keyword">char</span>*)msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"value is out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把long long类型的值赋给long类型变量不会有危险吗？</span></span><br><span class="line">    *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取编码类型的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strEncoding</span><span class="params">(<span class="keyword">int</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_RAW: <span class="keyword">return</span> <span class="string">"raw"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_INT: <span class="keyword">return</span> <span class="string">"int"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_HT: <span class="keyword">return</span> <span class="string">"hashtable"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPMAP: <span class="keyword">return</span> <span class="string">"zipmap"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_LINKEDLIST: <span class="keyword">return</span> <span class="string">"linkedlist"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST: <span class="keyword">return</span> <span class="string">"ziplist"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_INTSET: <span class="keyword">return</span> <span class="string">"intset"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_SKIPLIST: <span class="keyword">return</span> <span class="string">"skiplist"</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">"unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given an object returns the min number of seconds the object was never</span></span><br><span class="line"><span class="comment"> * requested, using an approximated LRU algorithm. */</span></span><br><span class="line"><span class="comment">//计算给定对象的闲置时长，使用近似LRU算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.lruclock &gt;= o-&gt;lru) &#123;</span><br><span class="line">        <span class="keyword">return</span> (server.lruclock - o-&gt;lru) * REDIS_LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当server.lruclock的值超出REDIS_LRU_CLOCK_MAX时，会从头开始计算，导致其小于对象的lru，所以算的时候要加上REDIS_LRU_CLOCK_MAX</span></span><br><span class="line">        <span class="comment">//为什么认为server.lruclock只会多转一周呢？会不会加上REDIS_LRU_CLOCK_MAX还是小于o-&gt;lru？</span></span><br><span class="line">        <span class="keyword">return</span> ((REDIS_LRU_CLOCK_MAX - o-&gt;lru) + server.lruclock) *</span><br><span class="line">                    REDIS_LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is an helper function for the DEBUG command. We need to lookup keys</span></span><br><span class="line"><span class="comment"> * without any modification of LRU or other parameters. */</span></span><br><span class="line"><span class="comment">//给定key查找字典中对应的val</span></span><br><span class="line"><span class="function">robj *<span class="title">objectCommandLookup</span><span class="params">(redisClient *c, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((de = dictFind(c-&gt;db-&gt;dict,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (robj*) dictGetEntryVal(de);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定key查找字典中对应的val，如果获取失败就返回reply给客户端</span></span><br><span class="line"><span class="function">robj *<span class="title">objectCommandLookupOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span> </span>&#123;</span><br><span class="line">    robj *o = objectCommandLookup(c,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!o) addReply(c, reply);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object command allows to inspect the internals of an Redis Object.</span></span><br><span class="line"><span class="comment"> * Usage: OBJECT &lt;verb&gt; ... arguments ... */</span></span><br><span class="line"><span class="comment">//解析并执行客户端的object命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OBJECT REFCOUNT &lt;key&gt; ，返回字典中给定key对应的value被引用的次数</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"refcount"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        addReplyLongLong(c,o-&gt;refcount);</span><br><span class="line">    <span class="comment">//OBJECT ENCODING &lt;key&gt; ，返回给定key对应的value的编码类型的字符串表示</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"encoding"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        addReplyBulkCString(c,strEncoding(o-&gt;encoding));</span><br><span class="line">    <span class="comment">//OBJECT IDLETIME &lt;key&gt; ，返回给定key对应的value自储存以来的空闲时间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"idletime"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        addReplyLongLong(c,estimateObjectIdleTime(o));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"Syntax error. Try OBJECT (refcount|encoding|idletime)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h2><h3 id="t-string-c"><a href="#t-string-c" class="headerlink" title="t_string.c"></a>t_string.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * String Commands</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串长度不能超过512MB</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkStringLength</span><span class="params">(redisClient *c, <span class="keyword">long</span> <span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"string exceeds maximum allowed size (512MB)"</span>);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的SET命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> nx, robj *key, robj *val, robj *expire)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="comment">//harmness warning？</span></span><br><span class="line">    <span class="keyword">long</span> seconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid an harmness warning */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        <span class="comment">//从字符串对象中解析出long类型的值，存储在seconds变量中</span></span><br><span class="line">        <span class="keyword">if</span> (getLongFromObjectOrReply(c, expire, &amp;seconds, <span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//设置的过期时间必须大于0</span></span><br><span class="line">        <span class="keyword">if</span> (seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"invalid expire time in SETEX"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在db中查询key，同时检查是否过期，过期则删除key</span></span><br><span class="line">    lookupKeyWrite(c-&gt;db,key); <span class="comment">/* Force expire of old key if needed */</span></span><br><span class="line">    <span class="comment">//向db中插入键值对</span></span><br><span class="line">    retval = dbAdd(c-&gt;db,key,val);</span><br><span class="line">    <span class="comment">//插入失败，说明key已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (retval == REDIS_ERR) &#123;</span><br><span class="line">        <span class="comment">//如果不是SETNX命令，就用新的键值对替换旧的</span></span><br><span class="line">        <span class="keyword">if</span> (!nx) &#123;</span><br><span class="line">            dbReplace(c-&gt;db,key,val);</span><br><span class="line">            incrRefCount(val);</span><br><span class="line">        <span class="comment">//如果是SETNX命令，放弃插入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入失败，向客户端返回0(共享池中的对象)</span></span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//插入成功，value的引用加一</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        incrRefCount(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有正在watch这个key客户端，打开他们的REDIS_DIRTY_CAS标识</span></span><br><span class="line">    touchWatchedKey(c-&gt;db,key);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">//清除旧的过期时间的记录</span></span><br><span class="line">    <span class="comment">//key的过期时间保存在过期字典里，由过期时间对象指向key对象，过期字典存储的redisDb对象里</span></span><br><span class="line">    <span class="comment">//SET命令会清除过期时间，默认把对象持久化，所以SETEX和SET混用时要注意</span></span><br><span class="line">    removeExpire(c-&gt;db,key);</span><br><span class="line">    <span class="comment">//设置key的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) setExpire(c-&gt;db,key,time(<span class="literal">NULL</span>)+seconds);</span><br><span class="line">    <span class="comment">//插入成功，向客户端返回成功码</span></span><br><span class="line">    addReply(c, nx ? shared.cone : shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现set命令</span></span><br><span class="line"><span class="comment">//SET KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先尝试把value字符串转换成数值以节省空间</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    setGenericCommand(c,<span class="number">0</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Setnx(SET if Not eXists)命令</span></span><br><span class="line"><span class="comment">//SETNX KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnxCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    setGenericCommand(c,<span class="number">1</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Setex命令，为指定的key设置值及其过期时间</span></span><br><span class="line"><span class="comment">//SETEX KEY_NAME TIMEOUT VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setexCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    setGenericCommand(c,<span class="number">0</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的GET命令</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGenericCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">//在db中查询key并向客户端返回结果，shared.nullbulk是共享池里表示-1的对象，如果没找到就向客户端返回-1</span></span><br><span class="line">    <span class="comment">//没找到就返回REDIS_OK退出</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    <span class="comment">//如果找到了key但其对应的value不是字符串对象，就向客户端报错</span></span><br><span class="line">    <span class="comment">//虽然在set时会尝试把底层数据改成整型，但基于整型的字符串对象的类型还是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != REDIS_STRING) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    <span class="comment">//否则就是查找成功，把查到的value返回给客户端</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,o);</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现get命令</span></span><br><span class="line"><span class="comment">//GET KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    getGenericCommand(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现getset命令</span></span><br><span class="line"><span class="comment">//GETSET KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsetCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先get旧的value，返回给客户端</span></span><br><span class="line">    <span class="keyword">if</span> (getGenericCommand(c) == REDIS_ERR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//在db中用新的value替换旧的value</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    incrRefCount(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//遍历所有正在watch这个key客户端，打开他们的REDIS_DIRTY_CAS标识</span></span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">//getset命令也执行了set，所以要清除过期时间的记录</span></span><br><span class="line">    removeExpire(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查setbit和getbit命令中的offset参数是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBitOffsetFromArgument</span><span class="params">(redisClient *c, robj *o, <span class="keyword">size_t</span> *offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> loffset;</span><br><span class="line">    <span class="keyword">char</span> *err = <span class="string">"bit offset is not an integer or out of range"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先把offset转成long long类型的数值</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;loffset,err) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Limit offset to 512MB in bytes */</span></span><br><span class="line">    <span class="comment">//判断offset是否越界，因为offset单位是bit，字符串size单位是byte，所以offset要先右移三位</span></span><br><span class="line">    <span class="keyword">if</span> ((loffset &lt; <span class="number">0</span>) || ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)loffset &gt;&gt; <span class="number">3</span>) &gt;= (<span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyError(c,err);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有问题，就把offset数值赋给参数</span></span><br><span class="line">    *offset = (<span class="keyword">size_t</span>)loffset;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现setbit命令</span></span><br><span class="line"><span class="comment">//Setbit KEY_NAME OFFSET VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbitCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">char</span> *err = <span class="string">"bit is not an integer or out of range"</span>;</span><br><span class="line">    <span class="keyword">size_t</span> bitoffset;</span><br><span class="line">    <span class="keyword">int</span> byte, bit;</span><br><span class="line">    <span class="keyword">int</span> byteval, bitval;</span><br><span class="line">    <span class="keyword">long</span> on;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先检查offset是否越界，并把表示的数值存储在bitoffset中</span></span><br><span class="line">    <span class="keyword">if</span> (getBitOffsetFromArgument(c,c-&gt;argv[<span class="number">2</span>],&amp;bitoffset) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//读取命令中的value对象，解析出整数值，存在on中</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;on,err) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bits can only be set or cleared... */</span></span><br><span class="line">    <span class="comment">//因为是给一个bit赋值，所以value只能是0或1</span></span><br><span class="line">    <span class="keyword">if</span> (on &amp; ~<span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在db中查询key，同时检查是否过期，过期则删除key</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//如果key不存在，就创建基于sds的空字符串对象写入db</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        o = createObject(REDIS_STRING,sdsempty());</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create a copy when the object is shared or encoded. */</span></span><br><span class="line">        <span class="comment">//如果value不是原生的sds字符串，就要先转成sds。因为基于int的字符串只是节省内存的一种存储捷径，但修改某个bit时所针对的是原始sds字符串的某个bit</span></span><br><span class="line">        <span class="comment">//为什么要判断o-&gt;refcount？</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            robj *decoded = getDecodedObject(o);</span><br><span class="line">            o = createStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr));</span><br><span class="line">            <span class="comment">//调用getDecodedObject时，可能返回转过类型且引用加一的对象，也可能返回新创建引用数为1的新对象，这两种情况下都需要引用减一，来删除本次操作增加的引用，新对象的值既然已经存到对象o里了，所以引用减到0直接删除该对象。</span></span><br><span class="line">            decrRefCount(decoded);</span><br><span class="line">            dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Grow sds value to the right length if necessary */</span></span><br><span class="line">    <span class="comment">//计算offset对应的字节长度，如果比value字符串还长，就要先将value延长并补0</span></span><br><span class="line">    byte = bitoffset &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    o-&gt;ptr = sdsgrowzero(o-&gt;ptr,byte+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get current values */</span></span><br><span class="line">    <span class="comment">//先取字节值，再从字节值里取目标位的值</span></span><br><span class="line">    byteval = ((<span class="keyword">char</span>*)o-&gt;ptr)[byte];</span><br><span class="line">    bit = <span class="number">7</span> - (bitoffset &amp; <span class="number">0x7</span>);</span><br><span class="line">    bitval = byteval &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update byte with new bit value and return original value */</span></span><br><span class="line">    <span class="comment">//在byte里更新bit的值，再把byte写入字符串中</span></span><br><span class="line">    byteval &amp;= ~(<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    byteval |= ((on &amp; <span class="number">0x1</span>) &lt;&lt; bit);</span><br><span class="line">    ((<span class="keyword">char</span>*)o-&gt;ptr)[byte] = byteval;</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c, bitval ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现getbit命令</span></span><br><span class="line"><span class="comment">//GETBIT KEY_NAME OFFSET</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getbitCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">char</span> llbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">size_t</span> bitoffset;</span><br><span class="line">    <span class="keyword">size_t</span> byte, bit;</span><br><span class="line">    <span class="keyword">size_t</span> bitval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断offset合法性，并转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (getBitOffsetFromArgument(c,c-&gt;argv[<span class="number">2</span>],&amp;bitoffset) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出key对应的value字符串</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算目标的字节和其中具体的位</span></span><br><span class="line">    byte = bitoffset &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    bit = <span class="number">7</span> - (bitoffset &amp; <span class="number">0x7</span>);</span><br><span class="line">    <span class="comment">//如果value不是原生sds，要先转成字符串，再从字符串里取目标位的值</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        <span class="keyword">if</span> (byte &lt; (<span class="keyword">size_t</span>)ll2string(llbuf,<span class="keyword">sizeof</span>(llbuf),(<span class="keyword">long</span>)o-&gt;ptr))</span><br><span class="line">            bitval = llbuf[byte] &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (byte &lt; sdslen(o-&gt;ptr))</span><br><span class="line">            bitval = ((<span class="keyword">char</span>*)o-&gt;ptr)[byte] &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addReply(c, bitval ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现setrange命令</span></span><br><span class="line"><span class="comment">//SETRANGE KEY_NAME OFFSET VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setrangeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> offset;</span><br><span class="line">    sds value = c-&gt;argv[<span class="number">3</span>]-&gt;ptr;</span><br><span class="line">    <span class="comment">//把offset转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;offset,<span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"offset is out of range"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从db中取出key对应的value</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//如果key不存在，就变成了插入新的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Return 0 when setting nothing on a non-existing string */</span></span><br><span class="line">        <span class="comment">//但是如果要set的value是空字符串，就不继续插入，直接退出，因为set空的值就等于啥也没干</span></span><br><span class="line">        <span class="keyword">if</span> (sdslen(value) == <span class="number">0</span>) &#123;</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return when the resulting string exceeds allowed size */</span></span><br><span class="line">        <span class="comment">//执行set之后的字符串长度不能超过512MB，offset是修改起始点前面的长度，sdslen(value)是修改起始点后面的长度</span></span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,offset+sdslen(value)) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//创建新的字符串对象并插入db</span></span><br><span class="line">        o = createObject(REDIS_STRING,sdsempty());</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    <span class="comment">//如果key存在，就是修改对应的字符串</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> olen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Key exists, check type */</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,REDIS_STRING))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return existing string length when setting nothing */</span></span><br><span class="line">        <span class="comment">//要写入的value不能是空字符串</span></span><br><span class="line">        olen = stringObjectLen(o);</span><br><span class="line">        <span class="keyword">if</span> (sdslen(value) == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyLongLong(c,olen);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return when the resulting string exceeds allowed size */</span></span><br><span class="line">        <span class="comment">//修改后的字符串不能超过512MB</span></span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,offset+sdslen(value)) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create a copy when the object is shared or encoded. */</span></span><br><span class="line">        <span class="comment">//把非sds的对象转成基于sds的字符串后，再进行赋值</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            robj *decoded = getDecodedObject(o);</span><br><span class="line">            o = createStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr));</span><br><span class="line">            decrRefCount(decoded);</span><br><span class="line">            dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前面已经判断过sdslen(value)，这里是不是没必要？</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        o-&gt;ptr = sdsgrowzero(o-&gt;ptr,offset+sdslen(value));</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)o-&gt;ptr+offset,value,sdslen(value));</span><br><span class="line">        touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回给客户端的是被修改后的字符串长度</span></span><br><span class="line">    addReplyLongLong(c,sdslen(o-&gt;ptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现getrange命令</span></span><br><span class="line"><span class="comment">//GETRANGE KEY_NAME start end</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrangeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> start, end;</span><br><span class="line">    <span class="keyword">char</span> *str, llbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">strlen</span>;</span><br><span class="line">    <span class="comment">//把start和end转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;start,<span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;end,<span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果key不存在，或value不是字符串，就退出</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptybulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取value字符串的长度</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        str = llbuf;</span><br><span class="line">        <span class="built_in">strlen</span> = ll2string(llbuf,<span class="keyword">sizeof</span>(llbuf),(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = o-&gt;ptr;</span><br><span class="line">        <span class="built_in">strlen</span> = sdslen(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Convert negative indexes */</span></span><br><span class="line">    <span class="comment">//支持负索引，取值时先把负索引换算成正索引，还要把越界的索引拉回到边界</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="built_in">strlen</span>+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="built_in">strlen</span>+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span>)end &gt;= <span class="built_in">strlen</span>) end = <span class="built_in">strlen</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Precondition: end &gt;= 0 &amp;&amp; end &lt; strlen, so the only condition where</span></span><br><span class="line"><span class="comment">     * nothing can be returned is: start &gt; end. */</span></span><br><span class="line">    <span class="comment">//如果起点在终点之后，返回空的字符串</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        addReply(c,shared.emptybulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//取出字符串后返回给客户端</span></span><br><span class="line">        <span class="comment">//取的方法是把ptr指针指到start位置，取出长度为end-start+1的字符串</span></span><br><span class="line">        addReplyBulkCBuffer(c,(<span class="keyword">char</span>*)str+start,end-start+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现mget命令</span></span><br><span class="line"><span class="comment">//MGET KEY1 KEY2 .. KEYN</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mgetCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">//因为要向客户端返回多个值，所以先算出输出时显示的序号</span></span><br><span class="line">    addReplyMultiBulkLen(c,c-&gt;argc<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//查询所有的key并逐个返回，key不存在或value类型不是字符串的返回shared.nullbulk</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type != REDIS_STRING) &#123;</span><br><span class="line">                addReply(c,shared.nullbulk);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulk(c,o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的MSET和MSETNX命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> nx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, busykeys = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//argc从0开始计数，所以argc的值就是所有key和value的数量，所以必须是偶数</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"wrong number of arguments for MSET"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Handle the NX flag. The MSETNX semantic is to return zero and don't</span></span><br><span class="line"><span class="comment">     * set nothing at all if at least one already key exists. */</span></span><br><span class="line">    <span class="comment">//对于msetnx命令，只有当所有给定key都不存在时，才能进行set</span></span><br><span class="line">    <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lookupKeyWrite(c-&gt;db,c-&gt;argv[j]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                busykeys++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//busykeys是已存在的key的数量，放弃set，失败返回0</span></span><br><span class="line">    <span class="keyword">if</span> (busykeys) &#123;</span><br><span class="line">        addReply(c, shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set所有的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j += <span class="number">2</span>) &#123;</span><br><span class="line">        c-&gt;argv[j+<span class="number">1</span>] = tryObjectEncoding(c-&gt;argv[j+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//已经确定key不存在了，可以直接用dbAdd</span></span><br><span class="line">        dbReplace(c-&gt;db,c-&gt;argv[j],c-&gt;argv[j+<span class="number">1</span>]);</span><br><span class="line">        incrRefCount(c-&gt;argv[j+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//执行set类命令后要清除过期时间记录</span></span><br><span class="line">        removeExpire(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        touchWatchedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (c-&gt;argc<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    addReply(c, nx ? shared.cone : shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现mset命令</span></span><br><span class="line"><span class="comment">//MSET key1 value1 key2 value2 .. keyN valueN </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    msetGenericCommand(c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现msetnx命令</span></span><br><span class="line"><span class="comment">//MSETNX key1 value1 key2 value2 .. keyN valueN </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetnxCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    msetGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的INCR和DECR类命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrDecrCommand</span><span class="params">(redisClient *c, <span class="keyword">long</span> <span class="keyword">long</span> incr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value, oldvalue;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">//获取value字符串</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//先确定value是字符串对象，再确定是否是数值或能否转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;value,<span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    oldvalue = value;</span><br><span class="line">    <span class="comment">//自增还是自减只需要设置incr参数</span></span><br><span class="line">    value += incr;</span><br><span class="line">    <span class="comment">//如果自增以后反而变小，或者自减以后反而变大，说明执行加减操作后value溢出了</span></span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span> &amp;&amp; value &gt; oldvalue) || (incr &gt; <span class="number">0</span> &amp;&amp; value &lt; oldvalue)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"increment or decrement would overflow"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新的基于整型的字符串对象，替换旧的value对象</span></span><br><span class="line">    o = createStringObjectFromLongLong(value);</span><br><span class="line">    dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">//客户端的输出是冒号-新value值-回车换行</span></span><br><span class="line">    addReply(c,shared.colon);</span><br><span class="line">    addReply(c,o);</span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现incr命令</span></span><br><span class="line"><span class="comment">//INCR KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现decr命令</span></span><br><span class="line"><span class="comment">//DECR KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现incrby命令</span></span><br><span class="line"><span class="comment">//INCRBY KEY_NAME INCR_AMOUNT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> incr;</span><br><span class="line">    <span class="comment">//把命令里的INCR_AMOUNT转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;incr, <span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    incrDecrCommand(c,incr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现decrby命令</span></span><br><span class="line"><span class="comment">//DECRBY KEY_NAME DECREMENT_AMOUNT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrbyCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> incr;</span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;incr, <span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    incrDecrCommand(c,-incr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现append命令</span></span><br><span class="line"><span class="comment">//APPEND KEY_NAME NEW_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> totlen;</span><br><span class="line">    robj *o, *append;</span><br><span class="line"></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//如果key不存在，就相当于set命令</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Create the key */</span></span><br><span class="line">        c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        incrRefCount(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        totlen = stringObjectLen(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Key exists, check type */</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,REDIS_STRING))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* "append" is an argument, so always an sds */</span></span><br><span class="line">        append = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</span><br><span class="line">        <span class="comment">//判断追加后的字符串长度是否超过512MB</span></span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,totlen) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the object is shared or encoded, we have to make a copy */</span></span><br><span class="line">        <span class="comment">//只能追加到sds字符串后面，所以先转数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            robj *decoded = getDecodedObject(o);</span><br><span class="line">            o = createStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr));</span><br><span class="line">            decrRefCount(decoded);</span><br><span class="line">            dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Append the value */</span></span><br><span class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</span><br><span class="line">        totlen = sdslen(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">//返回给客户端的是追加后的字符串长度</span></span><br><span class="line">    addReplyLongLong(c,totlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现strlen命令</span></span><br><span class="line"><span class="comment">//STRLEN KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strlenCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    addReplyLongLong(c,stringObjectLen(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-列表"><a href="#4-3-列表" class="headerlink" title="4.3 列表"></a>4.3 列表</h2><h3 id="redis-h-列表相关"><a href="#redis-h-列表相关" class="headerlink" title="redis.h(列表相关)"></a>redis.h(列表相关)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Structure to hold list iteration abstraction. */</span></span><br><span class="line"><span class="comment">//列表的迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//列表对象</span></span><br><span class="line">    robj *subject;</span><br><span class="line">    <span class="comment">//列表编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;</span><br><span class="line">    <span class="comment">//迭代方向</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> direction; <span class="comment">/* Iteration direction */</span></span><br><span class="line">    <span class="comment">//下个ziplist节点的头地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;</span><br><span class="line">    <span class="comment">//下个linkedlist节点的地址</span></span><br><span class="line">    listNode *ln;</span><br><span class="line">&#125; listTypeIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure for an entry while iterating over a list. */</span></span><br><span class="line"><span class="comment">//迭代过程中存储迭代器当前节点的信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;  <span class="comment">/* Entry in ziplist */</span></span><br><span class="line">    listNode *ln;       <span class="comment">/* Entry in linked list */</span></span><br><span class="line">&#125; listTypeEntry;</span><br></pre></td></tr></table></figure>
<h3 id="t-list-c"><a href="#t-list-c" class="headerlink" title="t_list.c"></a>t_list.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * List API</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the argument length to see if it requires us to convert the ziplist</span></span><br><span class="line"><span class="comment"> * to a real list. Only check raw-encoded objects because integer encoded</span></span><br><span class="line"><span class="comment"> * objects are never too long. */</span></span><br><span class="line"><span class="comment">//在向列表插入元素前调用，如果当前列表subject是基于ziplist的，且要插入的value字符串的长度超过了系统设定的ziplist单个entry的最大长度，就要把当前列表转换成基于linkedlist的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeTryConversion</span><span class="params">(robj *subject, robj *value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不是基于ziplist的列表不需要考虑转换</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding != REDIS_ENCODING_ZIPLIST) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (value-&gt;encoding == REDIS_ENCODING_RAW &amp;&amp;</span><br><span class="line">        sdslen(value-&gt;ptr) &gt; server.list_max_ziplist_value)</span><br><span class="line">            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向列表中插入元素，subject是列表对象，value是要插入的字符串对象，where是插入位置(0是表头，1是表尾)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypePush</span><span class="params">(robj *subject, robj *value, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先检查当前列表需不需要转成基于linkedlist的</span></span><br><span class="line">    listTypeTryConversion(subject,value);</span><br><span class="line">    <span class="comment">//如果当前列表基于ziplist，且存储的entry数量超过了系统设定的ziplist可容纳的最大entry数，也要把当前列表转成基于linkedlist的</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST &amp;&amp;</span><br><span class="line">        ziplistLen(subject-&gt;ptr) &gt;= server.list_max_ziplist_entries)</span><br><span class="line">            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);</span><br><span class="line">    <span class="comment">//如果是基于ziplist的列表，调用ziplistPush插入</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (where == REDIS_HEAD) ? ZIPLIST_HEAD : ZIPLIST_TAIL;</span><br><span class="line">        <span class="comment">//如果value是基于整型的字符串，要先转成基于sds的</span></span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line">        subject-&gt;ptr = ziplistPush(subject-&gt;ptr,value-&gt;ptr,sdslen(value-&gt;ptr),pos);</span><br><span class="line">        <span class="comment">//value已经存进列表了，本次对value的引用可以撤销了</span></span><br><span class="line">        decrRefCount(value);</span><br><span class="line">    <span class="comment">//如果是基于linkedlist的列表，调用listAddNodeHead和listAddNodeTail插入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (where == REDIS_HEAD) &#123;</span><br><span class="line">            listAddNodeHead(subject-&gt;ptr,value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listAddNodeTail(subject-&gt;ptr,value);</span><br><span class="line">        &#125;</span><br><span class="line">        incrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出列表元素，where是弹出位置(0是表头，1是表尾)</span></span><br><span class="line"><span class="function">robj *<span class="title">listTypePop</span><span class="params">(robj *subject, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">        <span class="keyword">int</span> pos = (where == REDIS_HEAD) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        p = ziplistIndex(subject-&gt;ptr,pos);</span><br><span class="line">        <span class="comment">//从ziplist中取出要弹出的元素，如果是字符串就存在vstr里，如果是整数就存在vlong里</span></span><br><span class="line">        <span class="keyword">if</span> (ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                <span class="comment">//返回值要求是robj对象，所以要基于弹出的元素新建robj</span></span><br><span class="line">                value = createStringObject((<span class="keyword">char</span>*)vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = createStringObjectFromLongLong(vlong);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* We only need to delete an element when it exists */</span></span><br><span class="line">            <span class="comment">//pop实际是两步，先生成并返回副本，然后删除原本</span></span><br><span class="line">            subject-&gt;ptr = ziplistDelete(subject-&gt;ptr,&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="built_in">list</span> *<span class="built_in">list</span> = subject-&gt;ptr;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        <span class="keyword">if</span> (where == REDIS_HEAD) &#123;</span><br><span class="line">            ln = listFirst(<span class="built_in">list</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ln = listLast(<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ln != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            value = listNodeValue(ln);</span><br><span class="line">            incrRefCount(value);</span><br><span class="line">            listDelNode(<span class="built_in">list</span>,ln);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回列表长度</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">listTypeLength</span><span class="params">(robj *subject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">return</span> ziplistLen(subject-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="keyword">return</span> listLength((<span class="built_in">list</span>*)subject-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize an iterator at the specified index. */</span></span><br><span class="line"><span class="comment">//创建列表的迭代器，index是指定的起始点，direction是迭代方向</span></span><br><span class="line"><span class="function">listTypeIterator *<span class="title">listTypeInitIterator</span><span class="params">(robj *subject, <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">char</span> direction)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li = zmalloc(<span class="keyword">sizeof</span>(listTypeIterator));</span><br><span class="line">    li-&gt;subject = subject;</span><br><span class="line">    li-&gt;encoding = subject-&gt;encoding;</span><br><span class="line">    li-&gt;direction = direction;</span><br><span class="line">    <span class="comment">//zi和ln分别存储ziplist和linkedlist的节点地址</span></span><br><span class="line">    <span class="comment">//对于ziplist，节点地址就是entry子串的头地址，对于linkedlist，节点地址就是指向某个listNode的指针</span></span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        li-&gt;zi = ziplistIndex(subject-&gt;ptr,index);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        li-&gt;ln = listIndex(subject-&gt;ptr,index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clean up the iterator. */</span></span><br><span class="line"><span class="comment">//释放迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeReleaseIterator</span><span class="params">(listTypeIterator *li)</span> </span>&#123;</span><br><span class="line">    zfree(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stores pointer to current the entry in the provided entry structure</span></span><br><span class="line"><span class="comment"> * and advances the position of the iterator. Returns 1 when the current</span></span><br><span class="line"><span class="comment"> * entry is in fact an entry, 0 otherwise. */</span></span><br><span class="line"><span class="comment">//把迭代器li的当前节点取出，存储在entry中，再让li指向下个节点</span></span><br><span class="line"><span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listTypeNext</span><span class="params">(listTypeIterator *li, listTypeEntry *entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Protect from converting when iterating */</span></span><br><span class="line">    <span class="comment">//如果迭代器最初保存的列表编码与当前的列表编码不同，说明列表被convert过，退出程序保平安</span></span><br><span class="line">    redisAssert(li-&gt;subject-&gt;encoding == li-&gt;encoding);</span><br><span class="line">    <span class="comment">//先把迭代器中的节点信息zi或ln转移到entry中，再更新迭代器中的zi或ln</span></span><br><span class="line">    entry-&gt;li = li;</span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        entry-&gt;zi = li-&gt;zi;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;zi != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (li-&gt;direction == REDIS_TAIL)</span><br><span class="line">                li-&gt;zi = ziplistNext(li-&gt;subject-&gt;ptr,li-&gt;zi);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                li-&gt;zi = ziplistPrev(li-&gt;subject-&gt;ptr,li-&gt;zi);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        entry-&gt;ln = li-&gt;ln;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;ln != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (li-&gt;direction == REDIS_TAIL)</span><br><span class="line">                li-&gt;ln = li-&gt;ln-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                li-&gt;ln = li-&gt;ln-&gt;prev;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return entry or NULL at the current position of the iterator. */</span></span><br><span class="line"><span class="comment">//返回entry中存储的节点对象</span></span><br><span class="line"><span class="function">robj *<span class="title">listTypeGet</span><span class="params">(listTypeEntry *entry)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li = entry-&gt;li;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">        redisAssert(entry-&gt;zi != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//对于ziplist是要新建robj</span></span><br><span class="line">        <span class="keyword">if</span> (ziplistGet(entry-&gt;zi,&amp;vstr,&amp;vlen,&amp;vlong)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                value = createStringObject((<span class="keyword">char</span>*)vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = createStringObjectFromLongLong(vlong);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        redisAssert(entry-&gt;ln != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//对于linkedlist就直接返回节点指针，引用加一</span></span><br><span class="line">        value = listNodeValue(entry-&gt;ln);</span><br><span class="line">        incrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将新元素value插入到entry所表示的节点之前或之后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeInsert</span><span class="params">(listTypeEntry *entry, robj *value, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *subject = entry-&gt;li-&gt;subject;</span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line">        <span class="keyword">if</span> (where == REDIS_TAIL) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点后面的节点</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *next = ziplistNext(subject-&gt;ptr,entry-&gt;zi);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果后面没有节点了，说明value应该插在表尾，直接调用ziplistPush，否则调用ziplistInsert</span></span><br><span class="line">            <span class="comment">//subject-&gt;ptr是ziplist字符串，value-&gt;ptr是要插入的字符串</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                subject-&gt;ptr = ziplistPush(subject-&gt;ptr,value-&gt;ptr,sdslen(value-&gt;ptr),REDIS_TAIL);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                subject-&gt;ptr = ziplistInsert(subject-&gt;ptr,next,value-&gt;ptr,sdslen(value-&gt;ptr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subject-&gt;ptr = ziplistInsert(subject-&gt;ptr,entry-&gt;zi,value-&gt;ptr,sdslen(value-&gt;ptr));</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (where == REDIS_TAIL) &#123;</span><br><span class="line">            listInsertNode(subject-&gt;ptr,entry-&gt;ln,value,AL_START_TAIL);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listInsertNode(subject-&gt;ptr,entry-&gt;ln,value,AL_START_HEAD);</span><br><span class="line">        &#125;</span><br><span class="line">        incrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare the given object with the entry at the current position. */</span></span><br><span class="line"><span class="comment">//对比entry中存储的节点对象和给定的对象o</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listTypeEqual</span><span class="params">(listTypeEntry *entry, robj *o)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li = entry-&gt;li;</span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="comment">//ziplistCompare只能比较字符串</span></span><br><span class="line">        <span class="comment">//如果o是基于整型的字符串，为什么不能转一下再比较？下面的equalStringObjects就考虑了ll2string</span></span><br><span class="line">        redisAssert(o-&gt;encoding == REDIS_ENCODING_RAW);</span><br><span class="line">        <span class="keyword">return</span> ziplistCompare(entry-&gt;zi,o-&gt;ptr,sdslen(o-&gt;ptr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="keyword">return</span> equalStringObjects(o,listNodeValue(entry-&gt;ln));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete the element pointed to. */</span></span><br><span class="line"><span class="comment">//删除entry中记录的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeDelete</span><span class="params">(listTypeEntry *entry)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li = entry-&gt;li;</span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = entry-&gt;zi;</span><br><span class="line">        <span class="comment">//删除p指向的entry，再把下个entry的地址重新赋给p</span></span><br><span class="line">        li-&gt;subject-&gt;ptr = ziplistDelete(li-&gt;subject-&gt;ptr,&amp;p);</span><br><span class="line">        <span class="comment">//li指向的本来就是下个节点，但是删除了当前节点后，下个节点的地址就变了，所以要重新让迭代器指向下个节点</span></span><br><span class="line">        <span class="comment">//所以结果就是entry指向的节点被删了，li指向的节点不变，但是节点地址变了</span></span><br><span class="line">        <span class="keyword">if</span> (li-&gt;direction == REDIS_TAIL)</span><br><span class="line">            li-&gt;zi = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            li-&gt;zi = ziplistPrev(li-&gt;subject-&gt;ptr,p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *next;</span><br><span class="line">        <span class="keyword">if</span> (li-&gt;direction == REDIS_TAIL)</span><br><span class="line">            next = entry-&gt;ln-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next = entry-&gt;ln-&gt;prev;</span><br><span class="line">        listDelNode(li-&gt;subject-&gt;ptr,entry-&gt;ln);</span><br><span class="line">        li-&gt;ln = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把基于ziplist的列表转成基于linkedlist的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeConvert</span><span class="params">(robj *subject, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    redisAssert(subject-&gt;type == REDIS_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="built_in">list</span> *l = listCreate();</span><br><span class="line">        listSetFreeMethod(l,decrRefCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* listTypeGet returns a robj with incremented refcount */</span></span><br><span class="line">        <span class="comment">//创建一个原列表迭代器</span></span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">        <span class="comment">//迭代每个节点并add到新列表</span></span><br><span class="line">        <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) listAddNodeTail(l,listTypeGet(&amp;entry));</span><br><span class="line">        listTypeReleaseIterator(li);</span><br><span class="line"></span><br><span class="line">        subject-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</span><br><span class="line">        <span class="comment">//free掉原来的ziplist</span></span><br><span class="line">        zfree(subject-&gt;ptr);</span><br><span class="line">        subject-&gt;ptr = l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unsupported list conversion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * List Commands</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//处理客户端发来的lpush和rpush请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在db中根据key获取列表对象</span></span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//这里为什么要把value转成整型呢？后面调用listTypePush时明明又会把value转回字符串</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//列表不存在</span></span><br><span class="line">    <span class="keyword">if</span> (lobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果有正在等待blocking pop的客户端，就把要push的新元素直接返回给那个等待pop的客户端，就不用继续push了</span></span><br><span class="line">        <span class="keyword">if</span> (handleClientsWaitingListPush(c,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>])) &#123;</span><br><span class="line">            addReply(c,shared.cone);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有等待pop的客户端，就新建列表，把新元素push进去</span></span><br><span class="line">        lobj = createZiplistObject();</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果key对应的value不是列表对象，向客户端报错</span></span><br><span class="line">        <span class="keyword">if</span> (lobj-&gt;type != REDIS_LIST) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handleClientsWaitingListPush(c,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>])) &#123;</span><br><span class="line">            touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            addReply(c,shared.cone);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行push操作</span></span><br><span class="line">    listTypePush(lobj,c-&gt;argv[<span class="number">2</span>],where);、</span><br><span class="line">    <span class="comment">//返回给客户端的是push后列表的长度</span></span><br><span class="line">    addReplyLongLong(c,listTypeLength(lobj));</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lpush命令，2.4版本以前的lpush只接受单个value参数</span></span><br><span class="line"><span class="comment">//LPUSH KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    pushGenericCommand(c,REDIS_HEAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现rpush命令，2.4版本以前的rpush只接受单个value参数</span></span><br><span class="line"><span class="comment">//RPUSH KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    pushGenericCommand(c,REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的lpushx、rpushx和linsert请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushxGenericCommand</span><span class="params">(redisClient *c, robj *refval, robj *val, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *subject;</span><br><span class="line">    listTypeIterator *iter;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    <span class="keyword">int</span> inserted = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果目标列表不存在或不是列表对象，放弃push操作</span></span><br><span class="line">    <span class="keyword">if</span> ((subject = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,subject,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//refval不为NULL说明是linsert命令，要把val插入到refval之前或之后</span></span><br><span class="line">    <span class="keyword">if</span> (refval != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Note: we expect refval to be string-encoded because it is *not* the</span></span><br><span class="line"><span class="comment">         * last argument of the multi-bulk LINSERT. */</span></span><br><span class="line">        redisAssert(refval-&gt;encoding == REDIS_ENCODING_RAW);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We're not sure if this value can be inserted yet, but we cannot</span></span><br><span class="line"><span class="comment">         * convert the list inside the iterator. We don't want to loop over</span></span><br><span class="line"><span class="comment">         * the list twice (once to see if the value can be inserted and once</span></span><br><span class="line"><span class="comment">         * to do the actual insert), so we assume this value can be inserted</span></span><br><span class="line"><span class="comment">         * and convert the ziplist to a regular list if necessary. */</span></span><br><span class="line">        <span class="comment">//先检查当前列表需不需要转成基于linkedlist的</span></span><br><span class="line">        listTypeTryConversion(subject,val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Seek refval from head to tail */</span></span><br><span class="line">        <span class="comment">//创建迭代器，在列表中定位refval，然后插入val</span></span><br><span class="line">        iter = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">        <span class="keyword">while</span> (listTypeNext(iter,&amp;entry)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (listTypeEqual(&amp;entry,refval)) &#123;</span><br><span class="line">                listTypeInsert(&amp;entry,val,where);</span><br><span class="line">                inserted = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listTypeReleaseIterator(iter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">            <span class="comment">/* Check if the length exceeds the ziplist length threshold. */</span></span><br><span class="line">            <span class="comment">//如果当前是ziplist，还要检查插入后是否超过了允许容纳的最大entry数量</span></span><br><span class="line">            <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST &amp;&amp;</span><br><span class="line">                ziplistLen(subject-&gt;ptr) &gt; server.list_max_ziplist_entries)</span><br><span class="line">                    listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);</span><br><span class="line">            touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Notify client of a failed insert */</span></span><br><span class="line">            <span class="comment">//插入失败，给客户端返回-1</span></span><br><span class="line">            addReply(c,shared.cnegone);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果refval是NULL，正常执行push操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        listTypePush(subject,val,where);</span><br><span class="line">        touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回给客户端的是执行push后列表的长度</span></span><br><span class="line">    addReplyLongLong(c,listTypeLength(subject));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lpushx命令</span></span><br><span class="line"><span class="comment">//LPUSHX KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushxCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    pushxGenericCommand(c,<span class="literal">NULL</span>,c-&gt;argv[<span class="number">2</span>],REDIS_HEAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现rpushx命令</span></span><br><span class="line"><span class="comment">//RPUSHX KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushxCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    pushxGenericCommand(c,<span class="literal">NULL</span>,c-&gt;argv[<span class="number">2</span>],REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现linsert命令</span></span><br><span class="line"><span class="comment">//LINSERT key BEFORE|AFTER pivot value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linsertCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">4</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">"after"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        pushxGenericCommand(c,c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">4</span>],REDIS_TAIL);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">"before"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        pushxGenericCommand(c,c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">4</span>],REDIS_HEAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现llen命令</span></span><br><span class="line"><span class="comment">//LLEN KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    addReplyLongLong(c,listTypeLength(o));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lindex命令</span></span><br><span class="line"><span class="comment">//LINDEX KEY_NAME INDEX_POSITION</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lindexCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">        <span class="comment">//获取第index个entry的头地址</span></span><br><span class="line">        p = ziplistIndex(o-&gt;ptr,index);</span><br><span class="line">        <span class="keyword">if</span> (ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                value = createStringObject((<span class="keyword">char</span>*)vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = createStringObjectFromLongLong(vlong);</span><br><span class="line">            &#125;</span><br><span class="line">            addReplyBulk(c,value);</span><br><span class="line">            decrRefCount(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *ln = listIndex(o-&gt;ptr,index);</span><br><span class="line">        <span class="keyword">if</span> (ln != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            value = listNodeValue(ln);</span><br><span class="line">            addReplyBulk(c,value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lset命令</span></span><br><span class="line"><span class="comment">//LSET KEY_NAME INDEX VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsetCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nokeyerr);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    robj *value = (c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">    listTypeTryConversion(o,value);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, *zl = o-&gt;ptr;</span><br><span class="line">        p = ziplistIndex(zl,index);</span><br><span class="line">        <span class="comment">//找不到第index个entry，就报索引越界的错</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c,shared.outofrangeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//set新value的逻辑是，先删掉旧的，再插入新的</span></span><br><span class="line">            o-&gt;ptr = ziplistDelete(o-&gt;ptr,&amp;p);</span><br><span class="line">            value = getDecodedObject(value);</span><br><span class="line">            o-&gt;ptr = ziplistInsert(o-&gt;ptr,p,value-&gt;ptr,sdslen(value-&gt;ptr));</span><br><span class="line">            decrRefCount(value);</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">            touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *ln = listIndex(o-&gt;ptr,index);</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c,shared.outofrangeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ziplist的entry没有引用，所以能直接删，但是linkedlist的listNode有引用，所以在重置listNode指针之前要把指向的value引用减一</span></span><br><span class="line">            <span class="comment">//ziplist的插入是把字符串hardcode到ziplist中，不是对value的引用，但是linkedlist的插入是把listNode的指针指向value，是对value的引用</span></span><br><span class="line">            decrRefCount((robj*)listNodeValue(ln));</span><br><span class="line">            listNodeValue(ln) = value;</span><br><span class="line">            incrRefCount(value);</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">            touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的lpop和rpop请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//返回弹出的元素</span></span><br><span class="line">    robj *value = listTypePop(o,where);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReply(c,shared.nullbulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,value);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">        <span class="comment">//如果弹出后列表为空，就顺便从db中删除列表</span></span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lpop命令</span></span><br><span class="line"><span class="comment">//Lpop KEY_NAME </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpopCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,REDIS_HEAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现rpop命令</span></span><br><span class="line"><span class="comment">//Rpop KEY_NAME </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpopCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lrange命令</span></span><br><span class="line"><span class="comment">//LRANGE KEY_NAME START END</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrangeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">int</span> start = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> end = atoi(c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> llen;</span><br><span class="line">    <span class="keyword">int</span> rangelen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymultibulk)) == <span class="literal">NULL</span></span><br><span class="line">         || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取列表的长度</span></span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert negative indexes */</span></span><br><span class="line">    <span class="comment">//把负索引转成正索引</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="comment">//调整边界</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        addReply(c,shared.emptymultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整边界</span></span><br><span class="line">    <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">    rangelen = (end-start)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the result in form of a multi-bulk reply */</span></span><br><span class="line">    addReplyMultiBulkLen(c,rangelen);</span><br><span class="line">    <span class="comment">//先调用ziplistIndex把指针p放在起点，再循环调用ziplistGet取出元素</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(o-&gt;ptr,start);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123;</span><br><span class="line">            ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong);</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkLongLong(c,vlong);</span><br><span class="line">            &#125;</span><br><span class="line">            p = ziplistNext(o-&gt;ptr,p);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//对于linkedlist，直接通过节点的next就能遍历</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we are nearest to the end of the list, reach the element</span></span><br><span class="line"><span class="comment">         * starting from tail and going backward, as it is faster. */</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; llen/<span class="number">2</span>) start -= llen;</span><br><span class="line">        ln = listIndex(o-&gt;ptr,start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123;</span><br><span class="line">            addReplyBulk(c,ln-&gt;value);</span><br><span class="line">            ln = ln-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"List encoding is not LINKEDLIST nor ZIPLIST!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现ltrim命令</span></span><br><span class="line"><span class="comment">//LTRIM KEY_NAME START STOP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltrimCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">int</span> start = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> end = atoi(c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> llen;</span><br><span class="line">    <span class="comment">//ltrim是从列表头部裁减掉的节点数，rtrim是从列表尾部裁减掉的节点数</span></span><br><span class="line">    <span class="keyword">int</span> j, ltrim, rtrim;</span><br><span class="line">    <span class="built_in">list</span> *<span class="built_in">list</span>;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.ok)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert negative indexes */</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        <span class="comment">/* Out of range start or start &gt; end result in empty list */</span></span><br><span class="line">        ltrim = llen;</span><br><span class="line">        rtrim = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//因为列表索引是从0开始的，索引为start的节点其实是第start+1个节点，所以左侧要删除的节点数是就start</span></span><br><span class="line">        ltrim = start;</span><br><span class="line">        <span class="comment">//llen-end是end右侧且包括end索引的节点数，因为end索引处的节点要保留，所以最后减一</span></span><br><span class="line">        rtrim = llen-end<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove list elements to perform the trim */</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="comment">//从列表头部开始删除ltrim个节点，左侧裁剪完成</span></span><br><span class="line">        o-&gt;ptr = ziplistDeleteRange(o-&gt;ptr,<span class="number">0</span>,ltrim);</span><br><span class="line">        <span class="comment">//从列表尾部删除时用负索引定位倒数第rtrim个节点，往后删除共rtrim个节点，右侧裁剪完成</span></span><br><span class="line">        o-&gt;ptr = ziplistDeleteRange(o-&gt;ptr,-rtrim,rtrim);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="built_in">list</span> = o-&gt;ptr;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ltrim; j++) &#123;</span><br><span class="line">            ln = listFirst(<span class="built_in">list</span>);</span><br><span class="line">            listDelNode(<span class="built_in">list</span>,ln);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; rtrim; j++) &#123;</span><br><span class="line">            ln = listLast(<span class="built_in">list</span>);</span><br><span class="line">            listDelNode(<span class="built_in">list</span>,ln);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果裁剪后列表为空，就顺便从db中删除列表</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lrem命令</span></span><br><span class="line"><span class="comment">//LREM KEY_NAME COUNT VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lremCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *subject, *obj;</span><br><span class="line">    obj = c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//toremove是要移除的节点数，也就是命令里count参数的绝对值</span></span><br><span class="line">    <span class="keyword">int</span> toremove = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    <span class="comment">//removed是已经移除的节点数</span></span><br><span class="line">    <span class="keyword">int</span> removed = <span class="number">0</span>;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line"></span><br><span class="line">    subject = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (subject == <span class="literal">NULL</span> || checkType(c,subject,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure obj is raw when we're dealing with a ziplist */</span></span><br><span class="line">    <span class="comment">//在ziplist中只能做字符串比较，所以要先把value转成sds字符串</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST)</span><br><span class="line">        obj = getDecodedObject(obj);</span><br><span class="line"></span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    <span class="comment">//toremove&lt;0表示从后往前遍历列表，设置好迭代器的方向后，把toremove转成正数</span></span><br><span class="line">    <span class="keyword">if</span> (toremove &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        toremove = -toremove;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">-1</span>,REDIS_HEAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代节点并删除直到 removed == toremove</span></span><br><span class="line">    <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listTypeEqual(&amp;entry,obj)) &#123;</span><br><span class="line">            listTypeDelete(&amp;entry);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            removed++;</span><br><span class="line">            <span class="keyword">if</span> (toremove &amp;&amp; removed == toremove) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listTypeReleaseIterator(li);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up raw encoded object */</span></span><br><span class="line">    <span class="comment">//之前调用getDecodedObject增加了对sds字符串的引用，这里引用要减一</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST)</span><br><span class="line">        decrRefCount(obj);</span><br><span class="line">    <span class="comment">//如果删除节点后列表为空，就顺便从db中删除列表</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(subject) == <span class="number">0</span>) dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//返回给客户端的是实际删除的节点数</span></span><br><span class="line">    addReplyLongLong(c,removed);</span><br><span class="line">    <span class="keyword">if</span> (removed) touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the semantic of this command:</span></span><br><span class="line"><span class="comment"> *  RPOPLPUSH srclist dstlist:</span></span><br><span class="line"><span class="comment"> *    IF LLEN(srclist) &gt; 0</span></span><br><span class="line"><span class="comment"> *      element = RPOP srclist</span></span><br><span class="line"><span class="comment"> *      LPUSH dstlist element</span></span><br><span class="line"><span class="comment"> *      RETURN element</span></span><br><span class="line"><span class="comment"> *    ELSE</span></span><br><span class="line"><span class="comment"> *      RETURN nil</span></span><br><span class="line"><span class="comment"> *    END</span></span><br><span class="line"><span class="comment"> *  END</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The idea is to be able to get an element from a list in a reliable way</span></span><br><span class="line"><span class="comment"> * since the element is not just returned but pushed against another list</span></span><br><span class="line"><span class="comment"> * as well. This command was originally proposed by Ezra Zygmuntowicz.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//处理客户端发来的rpoplpush命令，负责执行push的部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpoplpushHandlePush</span><span class="params">(redisClient *origclient, redisClient *c, robj *dstkey, robj *dstobj, robj *value)</span> </span>&#123;</span><br><span class="line">    robj *aux;</span><br><span class="line">    <span class="comment">//如果有正在阻塞的客户端，就把value发送给该客户端执行push操作</span></span><br><span class="line">    <span class="keyword">if</span> (!handleClientsWaitingListPush(origclient,dstkey,value)) &#123;</span><br><span class="line">        <span class="comment">/* Create the list if the key does not exist */</span></span><br><span class="line">        <span class="comment">//如果要push的列表不存在，就先创建新列表</span></span><br><span class="line">        <span class="keyword">if</span> (!dstobj) &#123;</span><br><span class="line">            dstobj = createZiplistObject();</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstobj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            touchWatchedKey(c-&gt;db,dstkey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把value添加到列表头部</span></span><br><span class="line">        listTypePush(dstobj,value,REDIS_HEAD);</span><br><span class="line">        <span class="comment">/* If we are pushing as a result of LPUSH against a key</span></span><br><span class="line"><span class="comment">         * watched by BRPOPLPUSH, we need to rewrite the command vector</span></span><br><span class="line"><span class="comment">         * as an LPUSH.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If this is called directly by RPOPLPUSH (either directly</span></span><br><span class="line"><span class="comment">         * or via a BRPOPLPUSH where the popped list exists)</span></span><br><span class="line"><span class="comment">         * we should replicate the RPOPLPUSH command itself. */</span></span><br><span class="line">        <span class="comment">//修改客户端命令，写入AOF文件，没看懂？？？</span></span><br><span class="line">        <span class="keyword">if</span> (c != origclient) &#123;</span><br><span class="line">            aux = createStringObject(<span class="string">"LPUSH"</span>,<span class="number">5</span>);</span><br><span class="line">            rewriteClientCommandVector(origclient,<span class="number">3</span>,aux,dstkey,value);</span><br><span class="line">            decrRefCount(aux);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Make sure to always use RPOPLPUSH in the replication / AOF,</span></span><br><span class="line"><span class="comment">             * even if the original command was BRPOPLPUSH. */</span></span><br><span class="line">            aux = createStringObject(<span class="string">"RPOPLPUSH"</span>,<span class="number">9</span>);</span><br><span class="line">            rewriteClientCommandVector(origclient,<span class="number">3</span>,aux,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">            decrRefCount(aux);</span><br><span class="line">        &#125;</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Always send the pushed value to the client. */</span></span><br><span class="line">    addReplyBulk(c,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现rpoplpush命令</span></span><br><span class="line"><span class="comment">//RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpoplpushCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *sobj, *value;</span><br><span class="line">    <span class="comment">//获取执行pop的列表</span></span><br><span class="line">    <span class="keyword">if</span> ((sobj = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,sobj,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//因为要执行pop，所以列表不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(sobj) == <span class="number">0</span>) &#123;</span><br><span class="line">        addReply(c,shared.nullbulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取执行push的列表</span></span><br><span class="line">        robj *dobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        robj *touchedkey = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dobj &amp;&amp; checkType(c,dobj,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//执行pop得到value</span></span><br><span class="line">        value = listTypePop(sobj,REDIS_TAIL);</span><br><span class="line">        <span class="comment">/* We saved touched key, and protect it, since rpoplpushHandlePush</span></span><br><span class="line"><span class="comment">         * may change the client command argument vector. */</span></span><br><span class="line">        incrRefCount(touchedkey);</span><br><span class="line">        <span class="comment">//把value添加到执行push的列表中，当执行rpoplpush命令时，pop和push操作都是在同一个client下完成，所以两个client参数相同</span></span><br><span class="line">        rpoplpushHandlePush(c,c,c-&gt;argv[<span class="number">2</span>],dobj,value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* listTypePop returns an object with its refcount incremented */</span></span><br><span class="line">        <span class="comment">//push完毕，value就没用了，引用减一</span></span><br><span class="line">        decrRefCount(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Delete the source list when it is empty */</span></span><br><span class="line">        <span class="comment">//对于执行pop的列表，如果pop以后列表为空，就删除该列表</span></span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(sobj) == <span class="number">0</span>) dbDelete(c-&gt;db,touchedkey);</span><br><span class="line">        touchWatchedKey(c-&gt;db,touchedkey);</span><br><span class="line">        decrRefCount(touchedkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Blocking POP operations</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Currently Redis blocking operations support is limited to list POP ops,</span></span><br><span class="line"><span class="comment"> * so the current implementation is not fully generic, but it is also not</span></span><br><span class="line"><span class="comment"> * completely specific so it will not require a rewrite to support new</span></span><br><span class="line"><span class="comment"> * kind of blocking operations in the future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Still it's important to note that list blocking operations can be already</span></span><br><span class="line"><span class="comment"> * used as a notification mechanism in order to implement other blocking</span></span><br><span class="line"><span class="comment"> * operations at application level, so there must be a very strong evidence</span></span><br><span class="line"><span class="comment"> * of usefulness and generality before new blocking operations are implemented.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is how the current blocking POP works, we use BLPOP as example:</span></span><br><span class="line"><span class="comment"> * - If the user calls BLPOP and the key exists and contains a non empty list</span></span><br><span class="line"><span class="comment"> *   then LPOP is called instead. So BLPOP is semantically the same as LPOP</span></span><br><span class="line"><span class="comment"> *   if there is not to block.</span></span><br><span class="line"><span class="comment"> * - If instead BLPOP is called and the key does not exists or the list is</span></span><br><span class="line"><span class="comment"> *   empty we need to block. In order to do so we remove the notification for</span></span><br><span class="line"><span class="comment"> *   new data to read in the client socket (so that we'll not serve new</span></span><br><span class="line"><span class="comment"> *   requests if the blocking request is not served). Also we put the client</span></span><br><span class="line"><span class="comment"> *   in a dictionary (db-&gt;blocking_keys) mapping keys to a list of clients</span></span><br><span class="line"><span class="comment"> *   blocking for this keys.</span></span><br><span class="line"><span class="comment"> * - If a PUSH operation against a key with blocked clients waiting is</span></span><br><span class="line"><span class="comment"> *   performed, we serve the first in the list: basically instead to push</span></span><br><span class="line"><span class="comment"> *   the new element inside the list we return it to the (first / oldest)</span></span><br><span class="line"><span class="comment"> *   blocking client, unblock the client, and remove it form the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above comment and the source code should be enough in order to understand</span></span><br><span class="line"><span class="comment"> * the implementation and modify / fix it later.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set a client in blocking mode for the specified key, with the specified</span></span><br><span class="line"><span class="comment"> * timeout */</span></span><br><span class="line"><span class="comment">//因为只支持blocking pop的命令，所以阻塞客户端就是等待指定key对应的列表有可以pop的元素</span></span><br><span class="line"><span class="comment">//keys是存储所有等待pop的列表的数组，numkeys是keys数组的长度，timeout是超时时间，target是被push的列表的key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockForKeys</span><span class="params">(redisClient *c, robj **keys, <span class="keyword">int</span> numkeys, <span class="keyword">time_t</span> timeout, robj *target)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *l;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">//bpop是client的属性，记录阻塞信息</span></span><br><span class="line">    c-&gt;bpop.keys = zmalloc(<span class="keyword">sizeof</span>(robj*)*numkeys);</span><br><span class="line">    c-&gt;bpop.count = numkeys;</span><br><span class="line">    c-&gt;bpop.timeout = timeout;</span><br><span class="line">    c-&gt;bpop.target = target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        incrRefCount(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">        <span class="comment">/* Add the key in the client structure, to map clients -&gt; keys */</span></span><br><span class="line">        <span class="comment">//把所有等待pop的列表添加到c-&gt;bpop，标记阻塞的客户端正在监听哪些列表</span></span><br><span class="line">        c-&gt;bpop.keys[j] = keys[j];</span><br><span class="line">        incrRefCount(keys[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* And in the other "side", to map keys -&gt; clients */</span></span><br><span class="line">        <span class="comment">//c-&gt;db-&gt;blocking_keys字典存储正在监听某个列表的所有客户端，key是列表的键，value就是存储客户端的列表</span></span><br><span class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);</span><br><span class="line">        <span class="comment">//当前列表没有被其他客户端监听</span></span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* For every key we take a list of clients blocked for it */</span></span><br><span class="line">            <span class="comment">//新建客户端列表，存入blocking_keys字典</span></span><br><span class="line">            l = listCreate();</span><br><span class="line">            retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);</span><br><span class="line">            incrRefCount(keys[j]);</span><br><span class="line">            redisAssert(retval == DICT_OK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就是直接往客户端列表里add</span></span><br><span class="line">            l = dictGetEntryVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        listAddNodeTail(l,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Mark the client as a blocked client */</span></span><br><span class="line">    <span class="comment">//修改客户端的阻塞标记</span></span><br><span class="line">    c-&gt;flags |= REDIS_BLOCKED;</span><br><span class="line">    server.bpop_blocked_clients++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unblock a client that's waiting in a blocking operation such as BLPOP */</span></span><br><span class="line"><span class="comment">//解除客户端的阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unblockClientWaitingData</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *l;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    redisAssert(c-&gt;bpop.keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* The client may wait for multiple keys, so unblock it for every key. */</span></span><br><span class="line">    <span class="comment">//遍历当前客户端监视的所有列表，修改blocking_keys</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;bpop.count; j++) &#123;</span><br><span class="line">        <span class="comment">/* Remove this client from the list of clients waiting for this key. */</span></span><br><span class="line">        <span class="comment">//把客户端从blocking_keys中清除</span></span><br><span class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,c-&gt;bpop.keys[j]);</span><br><span class="line">        redisAssert(de != <span class="literal">NULL</span>);</span><br><span class="line">        l = dictGetEntryVal(de);</span><br><span class="line">        listDelNode(l,listSearchKey(l,c));</span><br><span class="line">        <span class="comment">/* If the list is empty we need to remove it to avoid wasting memory */</span></span><br><span class="line">        <span class="comment">//删除以后如果列表为空，就顺便把列表也删除</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(l) == <span class="number">0</span>)</span><br><span class="line">            dictDelete(c-&gt;db-&gt;blocking_keys,c-&gt;bpop.keys[j]);</span><br><span class="line">        decrRefCount(c-&gt;bpop.keys[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup the client structure */</span></span><br><span class="line">    <span class="comment">//解除客户端的阻塞就要把c-&gt;bpop.keys里的列表的key全部删除</span></span><br><span class="line">    zfree(c-&gt;bpop.keys);</span><br><span class="line">    c-&gt;bpop.keys = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//调用本函数前，c-&gt;bpop.target已经被handler复制下来了，所以现在就可以清除记录了</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;bpop.target) decrRefCount(c-&gt;bpop.target);</span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//修改阻塞标记和非阻塞标记</span></span><br><span class="line">    c-&gt;flags &amp;= ~REDIS_BLOCKED;</span><br><span class="line">    c-&gt;flags |= REDIS_UNBLOCKED;</span><br><span class="line">    server.bpop_blocked_clients--;</span><br><span class="line">    listAddNodeTail(server.unblocked_clients,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This should be called from any function PUSHing into lists.</span></span><br><span class="line"><span class="comment"> * 'c' is the "pushing client", 'key' is the key it is pushing data against,</span></span><br><span class="line"><span class="comment"> * 'ele' is the element pushed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the function returns 0 there was no client waiting for a list push</span></span><br><span class="line"><span class="comment"> * against this key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the function returns 1 there was a client waiting for a list push</span></span><br><span class="line"><span class="comment"> * against this key, the element was passed to this client thus it's not</span></span><br><span class="line"><span class="comment"> * needed to actually add it to the list and the caller should return asap. */</span></span><br><span class="line"><span class="comment">//每当有新元素被push到列表中时，都要先检查当前是否有正在等待的blocking pop命令</span></span><br><span class="line"><span class="comment">//c是执行push命令的client，key是执行pop的列表的key，ele是被push的新元素</span></span><br><span class="line"><span class="comment">//返回0表示没有正在等待的blocking pop，回到原函数中要继续执行push。返回1表示有正在等待的blocking pop，直接把ele返回给执行pop的client，ele就不需要再push到列表中了</span></span><br><span class="line"><span class="comment">//过程比较乱，涉及到一个pop和两个push。列表A被等待blocking pop的客户端监听，当新元素被push到A中，这个push实际不执行，直接当做pop的结果返回，如果是rpoplpush命令，后面还有一个push操作，pop出的元素会被push到列表B中，这个push是一定会执行的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWaitingListPush</span><span class="params">(redisClient *c, robj *key, robj *ele)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">de</span>;</span></span><br><span class="line">    redisClient *receiver;</span><br><span class="line">    <span class="keyword">int</span> numclients;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    robj *dstkey, *dstobj;</span><br><span class="line">    <span class="comment">//c-&gt;db-&gt;blocking_keys中没有记录，说明当前列表没有被任何客户端所等待</span></span><br><span class="line">    de = dictFind(c-&gt;db-&gt;blocking_keys,key);</span><br><span class="line">    <span class="keyword">if</span> (de == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取当前列表关联的所有阻塞客户端</span></span><br><span class="line">    clients = dictGetEntryVal(de);</span><br><span class="line">    numclients = listLength(clients);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to handle the push as long as there are clients waiting for a push.</span></span><br><span class="line"><span class="comment">     * Note that "numclients" is used because the list of clients waiting for a</span></span><br><span class="line"><span class="comment">     * push on "key" is deleted by unblockClient() when empty.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This loop will have more than 1 iteration when there is a BRPOPLPUSH</span></span><br><span class="line"><span class="comment">     * that cannot push the target list because it does not contain a list. If</span></span><br><span class="line"><span class="comment">     * this happens, it simply tries the next client waiting for a push. */</span></span><br><span class="line">    <span class="keyword">while</span> (numclients--) &#123;</span><br><span class="line">        ln = listFirst(clients);</span><br><span class="line">        redisAssert(ln != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//receiver是等待执行pop的客户端</span></span><br><span class="line">        receiver = ln-&gt;value;</span><br><span class="line">        <span class="comment">//如果pop出的元素要立即被push到另一个列表中，dstkey是被执行push的列表的key</span></span><br><span class="line">        dstkey = receiver-&gt;bpop.target;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Protect receiver-&gt;bpop.target, that will be freed by</span></span><br><span class="line"><span class="comment">         * the next unblockClientWaitingData() call. */</span></span><br><span class="line">        <span class="keyword">if</span> (dstkey) incrRefCount(dstkey);</span><br><span class="line">        <span class="comment">/* This should remove the first element of the "clients" list. */</span></span><br><span class="line">        <span class="comment">//执行push前先解除客户端的阻塞</span></span><br><span class="line">        unblockClientWaitingData(receiver);</span><br><span class="line">        <span class="comment">//如果没指定push的列表，说明当前的命令就是单纯的blocking pop，因为此前pop已经执行，函数直接在此退出</span></span><br><span class="line">        <span class="keyword">if</span> (dstkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* BRPOP/BLPOP */</span></span><br><span class="line">            addReplyMultiBulkLen(receiver,<span class="number">2</span>);</span><br><span class="line">            addReplyBulk(receiver,key);</span><br><span class="line">            addReplyBulk(receiver,ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Serve just the first client as in B[RL]POP semantics */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* BRPOPLPUSH, note that receiver-&gt;db is always equal to c-&gt;db. */</span></span><br><span class="line">            dstobj = lookupKeyWrite(receiver-&gt;db,dstkey);</span><br><span class="line">            <span class="keyword">if</span> (!(dstobj &amp;&amp; checkType(receiver,dstobj,REDIS_LIST))) &#123;</span><br><span class="line">                rpoplpushHandlePush(c,receiver,dstkey,dstobj,ele);</span><br><span class="line">                decrRefCount(dstkey);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            decrRefCount(dstkey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析出对象object的过期时间，结果保存在timeout中，其实只是调用getLongFromObjectOrReply</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTimeoutFromObjectOrReply</span><span class="params">(redisClient *c, robj *object, <span class="keyword">time_t</span> *timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,object,&amp;tval,</span><br><span class="line">        <span class="string">"timeout is not an integer or out of range"</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"timeout is negative"</span>);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tval &gt; <span class="number">0</span>) tval += time(<span class="literal">NULL</span>);</span><br><span class="line">    *timeout = tval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Blocking RPOP/LPOP */</span></span><br><span class="line"><span class="comment">//处理客户端发来的blpop和brpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockingPopGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">time_t</span> timeout;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[c-&gt;argc<span class="number">-1</span>],&amp;timeout) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序遍历命令参数里的所有列表，找到第一个非空列表后，执行pop并返回</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">//获取列表</span></span><br><span class="line">        o = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//不是列表对象就退出</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type != REDIS_LIST) &#123;</span><br><span class="line">                addReply(c,shared.wrongtypeerr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果列表不为空就可以执行pop</span></span><br><span class="line">                <span class="keyword">if</span> (listTypeLength(o) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* If the list contains elements fall back to the usual</span></span><br><span class="line"><span class="comment">                     * non-blocking POP operation */</span></span><br><span class="line">                    struct redisCommand *orig_cmd;</span><br><span class="line">                    robj *argv[<span class="number">2</span>], **orig_argv;</span><br><span class="line">                    <span class="keyword">int</span> orig_argc;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* We need to alter the command arguments before to call</span></span><br><span class="line"><span class="comment">                     * popGenericCommand() as the command takes a single key. */</span></span><br><span class="line">                    <span class="comment">//因为要切换到执行pop命令的popGenericCommand函数，所以需要调整一下命令参数</span></span><br><span class="line">                    orig_argv = c-&gt;argv;</span><br><span class="line">                    orig_argc = c-&gt;argc;</span><br><span class="line">                    orig_cmd = c-&gt;cmd;</span><br><span class="line">                    argv[<span class="number">1</span>] = c-&gt;argv[j];</span><br><span class="line">                    c-&gt;argv = argv;</span><br><span class="line">                    c-&gt;argc = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Also the return value is different, we need to output</span></span><br><span class="line"><span class="comment">                     * the multi bulk reply header and the key name. The</span></span><br><span class="line"><span class="comment">                     * "real" command will add the last element (the value)</span></span><br><span class="line"><span class="comment">                     * for us. If this souds like an hack to you it's just</span></span><br><span class="line"><span class="comment">                     * because it is... */</span></span><br><span class="line">                    addReplyMultiBulkLen(c,<span class="number">2</span>);</span><br><span class="line">                    addReplyBulk(c,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                    popGenericCommand(c,where);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Fix the client structure with the original stuff */</span></span><br><span class="line">                    c-&gt;argv = orig_argv;</span><br><span class="line">                    c-&gt;argc = orig_argc;</span><br><span class="line">                    c-&gt;cmd = orig_cmd;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are inside a MULTI/EXEC and the list is empty the only thing</span></span><br><span class="line"><span class="comment">     * we can do is treating it as a timeout (even with timeout 0). */</span></span><br><span class="line">    <span class="comment">//没看懂？？？</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</span><br><span class="line">        addReply(c,shared.nullmultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the list is empty or the key does not exists we must block */</span></span><br><span class="line">    <span class="comment">//如果执行到这里，说明命令里的所有列表都是空的，pop执行失败，需要把当前客户端设置为阻塞并且关联上命令里的所有列表</span></span><br><span class="line">    blockForKeys(c, c-&gt;argv + <span class="number">1</span>, c-&gt;argc - <span class="number">2</span>, timeout, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现blpop命令</span></span><br><span class="line"><span class="comment">//BLPOP LIST1 LIST2 .. LISTN TIMEOUT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blpopCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    blockingPopGenericCommand(c,REDIS_HEAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现brpop命令</span></span><br><span class="line"><span class="comment">//BLPOP LIST1 LIST2 .. LISTN TIMEOUT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpopCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    blockingPopGenericCommand(c,REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现brpoplpush命令</span></span><br><span class="line"><span class="comment">//BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT </span></span><br><span class="line"><span class="comment">//rpoplpush里如果列表为空就退出，brpoplpush里如果列表为空就阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpoplpushCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;timeout) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    robj *key = lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//如果要执行pop的列表为空，就调用blockForKeys</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Blocking against an empty list in a multi state</span></span><br><span class="line"><span class="comment">             * returns immediately. */</span></span><br><span class="line">            addReply(c, shared.nullbulk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The list is empty and the client blocks. */</span></span><br><span class="line">            blockForKeys(c, c-&gt;argv + <span class="number">1</span>, <span class="number">1</span>, timeout, c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果要执行pop的列表不为空，就调用rpoplpushCommand</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key-&gt;type != REDIS_LIST) &#123;</span><br><span class="line">            addReply(c, shared.wrongtypeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The list exists and has elements, so</span></span><br><span class="line"><span class="comment">             * the regular rpoplpushCommand is executed. */</span></span><br><span class="line">            redisAssert(listTypeLength(key) &gt; <span class="number">0</span>);</span><br><span class="line">            rpoplpushCommand(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-哈希"><a href="#4-4-哈希" class="headerlink" title="4.4 哈希"></a>4.4 哈希</h2><h3 id="t-hash-c"><a href="#t-hash-c" class="headerlink" title="t_hash.c"></a>t_hash.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="5-单机数据库相关"><a href="#5-单机数据库相关" class="headerlink" title="5 单机数据库相关"></a>5 单机数据库相关</h1><h1 id="6-客户端和服务器端相关"><a href="#6-客户端和服务器端相关" class="headerlink" title="6 客户端和服务器端相关"></a>6 客户端和服务器端相关</h1><h1 id="7-多机数据库相关"><a href="#7-多机数据库相关" class="headerlink" title="7 多机数据库相关"></a>7 多机数据库相关</h1><h1 id="8-测试类文件"><a href="#8-测试类文件" class="headerlink" title="8 测试类文件"></a>8 测试类文件</h1><h3 id="testhelp-h"><a href="#testhelp-h" class="headerlink" title="testhelp.h"></a>testhelp.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a really minimal testing framework for C.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * test_cond("Check if 1 == 1", 1==1)</span></span><br><span class="line"><span class="comment"> * test_cond("Check if 5 &gt; 10", 5 &gt; 10)</span></span><br><span class="line"><span class="comment"> * test_report()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TESTHELP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TESTHELP_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试失败次数</span></span><br><span class="line"><span class="keyword">int</span> __failed_tests = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//测试总次数</span></span><br><span class="line"><span class="keyword">int</span> __test_num = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_cond(descr,_c) do &#123; \</span></span><br><span class="line">    <span class="comment">//测试次数加一，先输出描述信息</span></span><br><span class="line">    __test_num++; <span class="built_in">printf</span>(<span class="string">"%d - %s: "</span>, __test_num, descr); \</span><br><span class="line">    <span class="comment">//执行_c表示的表达式，输出成功或失败提示</span></span><br><span class="line">    <span class="keyword">if</span>(_c) <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>); <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">"FAILED\n"</span>); __failed_tests++;&#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试报告</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_report() do &#123; \</span></span><br><span class="line">    <span class="comment">//输出测试总次数，成功次数和失败次数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d tests, %d passed, %d failed\n"</span>, __test_num, \</span><br><span class="line">                    __test_num-__failed_tests, __failed_tests); \</span><br><span class="line">    <span class="comment">//如果有失败的样例就报warning</span></span><br><span class="line">    <span class="keyword">if</span> (__failed_tests) &#123; \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"=== WARNING === We have failed tests here...\n"</span>); \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="9-工具类文件"><a href="#9-工具类文件" class="headerlink" title="9 工具类文件"></a>9 工具类文件</h1><h1 id="10-封装类文件"><a href="#10-封装类文件" class="headerlink" title="10 封装类文件"></a>10 封装类文件</h1></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:wkx1996@foxmail.com">w.k.x.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shivakasu.cn/2020/06/20/redis0/">https://shivakasu.cn/2020/06/20/redis0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shivakasu.cn" target="_blank">SHIVAKASU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="http://file.shivakasu.cn/11b6eb34f8286c1cd02c/phi0.jpg" data-sites="facebook,twitter,wechat,weibo,qq,qzone,douban,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://file.shivakasu.cn/4a84dcfb31806db98b2a/wechat.png" alt="微信" onclick="window.open('https://file.shivakasu.cn/4a84dcfb31806db98b2a/wechat.png')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://file.shivakasu.cn/982f781ef31cbc46968b/alipay.jpg" alt="支付宝" onclick="window.open('https://file.shivakasu.cn/982f781ef31cbc46968b/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/28/webserver0/"><img class="prev-cover" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">tinyhttpd 源码阅读</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/14/haskell0/"><img class="next-cover" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Haskell Programming From First Principles notes (更新中)</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'qIfwEiuSjlc5vyminB1rx2qX-gzGzoHsz',
  appKey: 'erfVXuW3AybzbWGqxSGxnBRp',
  placeholder: '来都来了，说点儿什么吧~',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: true,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By w.k.x.</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>京ICP备19001969号-1</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
  pangu.autoSpacingPage()
})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>