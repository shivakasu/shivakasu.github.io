<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>redis源码阅读(更新中) | SHIVAKASU</title><meta name="description" content="redis源码阅读(更新中)"><meta name="keywords" content="redis,数据库"><meta name="author" content="w.k.x.,wkx1996@foxmail.com"><meta name="copyright" content="w.k.x."><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="http://file.shivakasu.cn/eb8581b76ec032ab0db8/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="redis源码阅读(更新中)"><meta name="twitter:description" content="redis源码阅读(更新中)"><meta name="twitter:image" content="http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png"><meta property="og:type" content="article"><meta property="og:title" content="redis源码阅读(更新中)"><meta property="og:url" content="http://shivakasu.github.io/2020/06/20/redis0/"><meta property="og:site_name" content="SHIVAKASU"><meta property="og:description" content="redis源码阅读(更新中)"><meta property="og:image" content="http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://shivakasu.github.io/2020/06/20/redis0/"><link rel="next" title="Haskell Programming From First Principles notes (更新中)" href="http://shivakasu.github.io/2020/06/14/haskell0/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QBXC0PXLIT","apiKey":"517431eabeeedb8d3792391b21e8cf20","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="SHIVAKASU" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">SHIVAKASU</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="http://file.shivakasu.cn/cb7049104af4685e7289/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1-概述"><span class="toc_mobile_items-text">1 概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2-数据结构相关"><span class="toc_mobile_items-text">2 数据结构相关</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-1-内存分配"><span class="toc_mobile_items-text">2.1 内存分配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#config-h"><span class="toc_mobile_items-text">config.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#zmalloc-h"><span class="toc_mobile_items-text">zmalloc.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#zmalloc-c"><span class="toc_mobile_items-text">zmalloc.c</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-2-动态字符串"><span class="toc_mobile_items-text">2.2 动态字符串</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sds-h"><span class="toc_mobile_items-text">sds.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sds-c"><span class="toc_mobile_items-text">sds.c</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-3-双端链表"><span class="toc_mobile_items-text">2.3 双端链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#adlist-h"><span class="toc_mobile_items-text">adlist.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#adlist-c"><span class="toc_mobile_items-text">adlist.c</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-4-字典"><span class="toc_mobile_items-text">2.4 字典</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#dict-h"><span class="toc_mobile_items-text">dict.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#dict-c"><span class="toc_mobile_items-text">dict.c</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-5-跳跃表"><span class="toc_mobile_items-text">2.5 跳跃表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#redis-h-跳跃表相关部分）"><span class="toc_mobile_items-text">redis.h(跳跃表相关部分）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#t-zset-c-跳跃表相关部分"><span class="toc_mobile_items-text">t_zset.c(跳跃表相关部分)</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#3-内存编码结构相关"><span class="toc_mobile_items-text">3 内存编码结构相关</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-1-整数集合数据结构"><span class="toc_mobile_items-text">3.1 整数集合数据结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#intset-h"><span class="toc_mobile_items-text">intset.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#intset-c"><span class="toc_mobile_items-text">intset.c</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-2-压缩列表"><span class="toc_mobile_items-text">3.2 压缩列表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ziplist-h"><span class="toc_mobile_items-text">ziplist.h</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ziplist-c"><span class="toc_mobile_items-text">ziplist.c</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#4-数据类型相关"><span class="toc_mobile_items-text">4 数据类型相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#5-单机数据库相关"><span class="toc_mobile_items-text">5 单机数据库相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#6-客户端和服务器端相关"><span class="toc_mobile_items-text">6 客户端和服务器端相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#7-多机数据库相关"><span class="toc_mobile_items-text">7 多机数据库相关</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#8-测试类文件"><span class="toc_mobile_items-text">8 测试类文件</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#testhelp-h"><span class="toc_mobile_items-text">testhelp.h</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#9-工具类文件"><span class="toc_mobile_items-text">9 工具类文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#10-封装类文件"><span class="toc_mobile_items-text">10 封装类文件</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-text">1 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-数据结构相关"><span class="toc-text">2 数据结构相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-内存分配"><span class="toc-text">2.1 内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#config-h"><span class="toc-text">config.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zmalloc-h"><span class="toc-text">zmalloc.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zmalloc-c"><span class="toc-text">zmalloc.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-动态字符串"><span class="toc-text">2.2 动态字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sds-h"><span class="toc-text">sds.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sds-c"><span class="toc-text">sds.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-双端链表"><span class="toc-text">2.3 双端链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#adlist-h"><span class="toc-text">adlist.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adlist-c"><span class="toc-text">adlist.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-字典"><span class="toc-text">2.4 字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dict-h"><span class="toc-text">dict.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dict-c"><span class="toc-text">dict.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-跳跃表"><span class="toc-text">2.5 跳跃表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-h-跳跃表相关部分）"><span class="toc-text">redis.h(跳跃表相关部分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#t-zset-c-跳跃表相关部分"><span class="toc-text">t_zset.c(跳跃表相关部分)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-内存编码结构相关"><span class="toc-text">3 内存编码结构相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-整数集合数据结构"><span class="toc-text">3.1 整数集合数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#intset-h"><span class="toc-text">intset.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intset-c"><span class="toc-text">intset.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-压缩列表"><span class="toc-text">3.2 压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist-h"><span class="toc-text">ziplist.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist-c"><span class="toc-text">ziplist.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-数据类型相关"><span class="toc-text">4 数据类型相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-单机数据库相关"><span class="toc-text">5 单机数据库相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-客户端和服务器端相关"><span class="toc-text">6 客户端和服务器端相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-多机数据库相关"><span class="toc-text">7 多机数据库相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-测试类文件"><span class="toc-text">8 测试类文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#testhelp-h"><span class="toc-text">testhelp.h</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-工具类文件"><span class="toc-text">9 工具类文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-封装类文件"><span class="toc-text">10 封装类文件</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png)"><div id="post-info"><div id="post-title"><div class="posttitle">redis源码阅读(更新中)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-06-20<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-06-24</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/">日常专业学习</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">23.1k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 106 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2020/06/20/redis0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/20/redis0/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul>
<li>redis版本：2.2.15</li>
<li>看的很老的版本，因为代码少 v^^7</li>
<li>阅读顺序参考自博文 <a href="https://blog.csdn.net/terence1212/article/details/53541908" target="_blank" rel="noopener">https://blog.csdn.net/terence1212/article/details/53541908</a></li>
</ul>
<h1 id="2-数据结构相关"><a href="#2-数据结构相关" class="headerlink" title="2 数据结构相关"></a>2 数据结构相关</h1><h2 id="2-1-内存分配"><a href="#2-1-内存分配" class="headerlink" title="2.1 内存分配"></a>2.1 内存分配</h2><h3 id="config-h"><a href="#config-h" class="headerlink" title="config.h"></a>config.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;AvailabilityMacros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use tcmalloc's malloc_size() when available.</span></span><br><span class="line"><span class="comment"> * When tcmalloc is used, native OSX malloc_size() may never be used because</span></span><br><span class="line"><span class="comment"> * this expects a different allocation scheme. Therefore, *exclusively* use</span></span><br><span class="line"><span class="comment"> * either tcmalloc or OSX's malloc_size()! */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果系统中存在Google的TC_MALLOC库，redis_malloc_size函数就当做tc_malloc_size函数使用</span></span><br><span class="line"><span class="comment">//tc_malloc比原始的malloc性能好</span></span><br><span class="line"><span class="comment">//redis_malloc_size的功能是获得参数p所指向的内存块的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TC_VERSION_MAJOR &gt;= 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6</span></span><br><span class="line"><span class="comment">//HAVE_MALLOC_SIZE用来标记是否定义了redis_malloc_size函数</span></span><br><span class="line"><span class="comment">//可是为什么不直接检查redis_malloc_size是否存在，还要额外定义一个标记呢？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_malloc_size(p) tc_malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//或者，如果系统是Mac系统，那么redis_malloc_size函数就当做原始的malloc_size函数使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_malloc_size(p) malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define redis_fstat to fstat or fstat64() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) &amp;&amp; !defined(MAC_OS_X_VERSION_10_6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_fstat fstat64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_stat stat64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_fstat fstat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_stat stat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for proc filesystem */</span></span><br><span class="line"><span class="comment">//如果是linux系统，当前文件系统就是procfs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_PROCFS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for task_info() */</span></span><br><span class="line"><span class="comment">//如果是unix系统，就可以使用task_info，macos是基于unix的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_TASKINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for backtrace() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__linux__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_BACKTRACE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for polling API */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(__APPLE__) &amp;&amp; defined(MAC_OS_X_VERSION_10_6)) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__NetBSD__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_KQUEUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define aof_fsync to fdatasync() in Linux and fsync() for all the rest */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fdatasync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fsync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="zmalloc-h"><a href="#zmalloc-h" class="headerlink" title="zmalloc.h"></a>zmalloc.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ZMALLOC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ZMALLOC_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_enable_thread_safeness</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ZMALLOC_H */</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="zmalloc-c"><a href="#zmalloc-c" class="headerlink" title="zmalloc.c"></a>zmalloc.c</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zmalloc - total amount of allocated memory aware version of malloc()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//redis是基于内存的数据库，所以内存管理很重要。</span></span><br><span class="line"><span class="comment">//redis把C语言的内存分配函数封装成zmalloc、zfree等z开头的函数，来屏蔽各底层平台的差异。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果定义了HAVE_MALLOC_SIZE，即定义了redis_malloc_size函数，PREFIX_SIZE就是0</span></span><br><span class="line"><span class="comment">//PREFIX_SIZE用于在分配到的的空间头部存储原本申请空间的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//如果没有定义HAVE_MALLOC_SIZE，且当前系统是Solaris，PREFIX_SIZE就是long long类型的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//否则，PREFIX_SIZE就是size_t的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Explicitly override malloc/free etc when using tcmalloc. */</span></span><br><span class="line"><span class="comment">//如果使用了tcmalloc库，就用tcmalloc库函数替换原始的malloc库函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) tc_malloc(size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) tc_calloc(count,size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) tc_realloc(ptr,size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) tc_free(ptr)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//update_zmalloc_stat_alloc用于在分配内存的时候更新已分配大小</span></span><br><span class="line"><span class="comment">//__n是实际分配到的空间大小，__size是程序原本请求的空间大小</span></span><br><span class="line"><span class="comment">//__size应该是改了代码以后忘记删掉的参数</span></span><br><span class="line"><span class="comment">//使用do-while(0)封装成代码块，防止宏定义展开的时候出问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n,__size) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="comment">//64位系统中，sizeof(long)通常是8</span></span><br><span class="line">    <span class="comment">//malloc分配的内存是8字节对齐的，如果请求分配的内存不是8的倍数，那么malloc就会多分配一点来凑成8的倍数</span></span><br><span class="line">    <span class="comment">//如果_n值不是内存分配单元(sizeof(long))的整数倍，说明当前分配的内存大小有碎片，为了与malloc的实际结果匹配，需要补齐到8的整数倍</span></span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</span><br><span class="line">        <span class="comment">//如果要考虑线程安全，先加锁再修改used_memory</span></span><br><span class="line">        pthread_mutex_lock(&amp;used_memory_mutex);  \</span><br><span class="line">        used_memory += _n; \</span><br><span class="line">        pthread_mutex_unlock(&amp;used_memory_mutex); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        <span class="comment">//不考虑线程安全时，直接修改used_memory</span></span><br><span class="line">        used_memory += _n; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//update_zmalloc_stat_free用于释放已经分配的空间</span></span><br><span class="line"><span class="comment">//__n是待释放的空间大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</span><br><span class="line">        pthread_mutex_lock(&amp;used_memory_mutex);  \</span><br><span class="line">        used_memory -= _n; \</span><br><span class="line">        pthread_mutex_unlock(&amp;used_memory_mutex); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        used_memory -= _n; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配得到的内存大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//是否要考虑线程安全，默认不考虑</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//保证线程安全的锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//oom的错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把错误信息输出到stderr流文件中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    <span class="comment">//刷新缓冲，把stderr中的数据发给错误输出设备</span></span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="comment">//终止当前进程，但不清理任何对象</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 是分配的内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际多申请了PREFIX_SIZE大小的空间</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line">    <span class="comment">// 如果分配失败，调用zmalloc_oom函数打印oom的错误信息，然后退出进程</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">//如果已经定义了redis_malloc_size函数，直接计算ptr的实际大小，然后更新used_memory</span></span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(ptr),size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//否则，先在分配到的空间的第一个字长处保存住原本请求的空间大小size</span></span><br><span class="line">    <span class="comment">//然后只能默认size+PREFIX_SIZE是已分配的大小(大概没有malloc_size算出来的靠谱)，更新used_memory</span></span><br><span class="line">    <span class="comment">//多申请的PREFIX_SIZE空间就是用来存储size的，所以当定义了redis_malloc_size函数时PREFIX_SIZE就是0，因为已经不需要存储size了</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对calloc的封装，更新了used_memory</span></span><br><span class="line"><span class="comment">//调用calloc时，第一个参数固定为1，所以每次只会分配一个size+PREFIX_SIZE大小的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(ptr),size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对realloc的封装，重新分配内存，重置并更新了used_memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = redis_malloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom(size);</span><br><span class="line"></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(newptr),size);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom(size);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(size,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对free的封装，重置了used_memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(redis_malloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对strdup的封装，复制一个字符串到新的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前的used_memory</span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) pthread_mutex_lock(&amp;used_memory_mutex);</span><br><span class="line">    um = used_memory;</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) pthread_mutex_unlock(&amp;used_memory_mutex);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在vm.c中被调用，当系统支持多线程时，要保证线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_enable_thread_safeness</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zmalloc_thread_safe = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the RSS information in an OS-specific way.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: the function zmalloc_get_rss() is not designed to be fast</span></span><br><span class="line"><span class="comment"> * and may not be called in the busy loops where Redis tries to release</span></span><br><span class="line"><span class="comment"> * memory expiring or swapping out objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For this kind of "fast RSS reporting" usages use instead the</span></span><br><span class="line"><span class="comment"> * function RedisEstimateRSS() that is a much faster (and less precise)</span></span><br><span class="line"><span class="comment"> * version of the funciton. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//zmalloc_get_rss用于获取当前进程实际所驻留在内存中的空间大小</span></span><br><span class="line"><span class="comment">//rss全称是Resident Set Size，即驻留集。因为程序申请的内存空间不会全部常驻于内存，系统会把其中暂时不用的部分从内存中置换到swap区，所以rss表示的就是不包括swap区的实际驻留在内存中的空间大小</span></span><br><span class="line"><span class="comment">//在linux系统中，可以通过读取/proc/pid/stat文件获取，该文件的第24个字段是rss的信息，pid为当前进程的进程号。读取到的不是byte数，而是内存页数。通过系统调用sysconf(_SC_PAGESIZE)可以获得当前系统的内存页大小。</span></span><br><span class="line"><span class="comment">//Unix系统可以直接通过task_info直接获取rss，比linux系统简单的多。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是linux的procfs文件系统，就读取/proc/pid/stat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PROCFS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">//获取内存页大小</span></span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">size_t</span> rss;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//snprintf的作用是把stat文件的绝对路径复制到filename</span></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">"/proc/%d/stat"</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为什么只读4096个字符呢？</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    <span class="comment">//第24个字段是rss的信息，所以找到第23个空格，后面就是rss</span></span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串转换成10进制的数</span></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    rss *= page;</span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是unix系统，就使用task_info获取rss</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAVE_TASKINFO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">task_t</span> task = MACH_PORT_NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_basic_info</span> <span class="title">t_info</span>;</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> t_info_count = TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task_for_pid(current_task(), getpid(), &amp;task) != KERN_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    task_info(task, TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>)&amp;t_info, &amp;t_info_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t_info.resident_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">/* If we can't get the RSS in an OS-specific way for this system just</span></span><br><span class="line"><span class="comment">     * return the memory usage we estimated in zmalloc()..</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Fragmentation will appear to be always 1 (no fragmentation)</span></span><br><span class="line"><span class="comment">     * of course... */</span></span><br><span class="line">    <span class="comment">//获取不到rss，说明当前系统就不用考虑碎片</span></span><br><span class="line">    <span class="keyword">return</span> zmalloc_used_memory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fragmentation = RSS / allocated-bytes */</span></span><br><span class="line"><span class="comment">//获得进程的RSS后，可以计算目前的内存碎片率，直接用rss除以used_memory。rss包含进程的所有内存使用，包括代码，共享库，堆栈等。但是由于通常情况下redis在内存中数据的量要远远大于这些数据所占用的内存，因此这个简单的计算还是比较准确的。</span></span><br><span class="line"><span class="comment">//之所以会产生碎片，是因为malloc并不是严格按照参数的值来分配内存。比如程序只请求一个byte的内存，malloc通常会基于内存对齐等方面的考虑而分配4个byte。malloc进行小内存分配是很浪费的，浪费的空间因为用不上就不会在rss中</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)zmalloc_get_rss()/zmalloc_used_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-2-动态字符串"><a href="#2-2-动态字符串" class="headerlink" title="2.2 动态字符串"></a>2.2 动态字符串</h2><h3 id="sds-h"><a href="#sds-h" class="headerlink" title="sds.h"></a>sds.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDSLib, A C dynamic strings library</span></span><br><span class="line"><span class="comment">//比起 C 字符串， SDS 具有以下优点：常数复杂度获取字符串长度，杜绝缓冲区溢出，减少修改字符串长度时所需的内存重分配次数，二进制安全，兼容部分 C 字符串函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SDS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SDS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//记录buf数组中已使用字节的数量，有效字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="comment">//C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存，所以sizeof(struct sdshdr)==8。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> sdslen(<span class="keyword">const</span> sds s);</span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> sdsavail(sds s);</span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果用的gcc编译器，需要提醒编译器检查可变参数的类型或者个数是否正确</span></span></span><br><span class="line"><span class="function">    __<span class="title">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(sds s1, sds s2)</span></span>;</span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="sds-c"><a href="#sds-c" class="headerlink" title="sds.c"></a>sds.c</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDSLib, A C dynamic strings library</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_ABORT_ON_OOM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sds.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//oom错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sdsOomAbort</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"SDS: Out Of Memory (SDS_ABORT_ON_OOM defined)\n"</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据初始化的字符串init和给定的字符串长度initlen，创建新的sdshdr</span></span><br><span class="line"><span class="comment">//const void *init表示可以修改指针本身的指向，但不能修改指针指向的内容</span></span><br><span class="line"><span class="comment">//void * const init指的才是不能修改指针本身</span></span><br><span class="line"><span class="comment">//返回值类型sds定义成了char指针的别名</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//buf数组不被计算在sizeof里，所以initlen要单独加上，再多分配一个字节给'\0'</span></span><br><span class="line">    sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//已经明确define过SDS_ABORT_ON_OOM了还做判断，莫名其妙</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//内存分配失败就报oom的error</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据initlen把init复制到sh的buf数组中</span></span><br><span class="line">    <span class="keyword">if</span> (initlen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (init) <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,initlen);</span><br><span class="line">    &#125;</span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">//返回的是buf数组而不是结构体</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成只包含'\0'的空的sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定字符串init并调用sdsnewlen，来创建sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回sdshdr结构体中len字段的值</span></span><br><span class="line"><span class="keyword">size_t</span> sdslen(<span class="keyword">const</span> sds s) &#123;</span><br><span class="line">    <span class="comment">//参数s是sdshdr结构体末尾的buf数组的指针，需要重建sdshdr结构体才能得到len字段的值</span></span><br><span class="line">    <span class="comment">//给结构体分配的内存空间是连续的，因此只需要将s指针回退一段距离就是原始结构体的头地址，回退的长度是len和free两个字段的大小，也就是sizeof(struct sdshdr)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定buf数组创建新的sdshdr，相当于复制原始的sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放sdshdr对象的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//s指针回退得到指向sdshdr对象头部的指针，调用zfree释放空间</span></span><br><span class="line">    zfree(s-<span class="keyword">sizeof</span>(struct sdshdr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回sdshdr结构体中free字段的值</span></span><br><span class="line"><span class="keyword">size_t</span> sdsavail(sds s) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据buf数组的内容调整len和free的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到结构体对象的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="comment">//计算真实长度</span></span><br><span class="line">    <span class="keyword">int</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">//根据真实长度调整free和len</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> += (sh-&gt;len-reallen);</span><br><span class="line">    sh-&gt;len = reallen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使buf数组有足够的额外空间容纳addlen个字节的数据</span></span><br><span class="line"><span class="comment">//静态函数，只能本文件内调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若剩余空间已经足够，不做修改直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//实际分配的数组大小是申请的两倍，减少可能的重分配次数</span></span><br><span class="line">    newlen = (len+addlen)*<span class="number">2</span>;</span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//空间不足报oom的error</span></span><br><span class="line">    <span class="comment">//空间不足为什么不试试只申请len+addlen的空间呢？</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//len是不变的，扩容只是增加free</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grow the sds to have the specified length. Bytes that were not part of</span></span><br><span class="line"><span class="comment"> * the original length of the sds will be set to zero. */</span></span><br><span class="line"><span class="comment">//将buf数组扩容到指定长度，指定len字段的值，并用0填充新空间</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen, curlen = sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若目标长度比当前长度小，就不用了扩容了</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//实际增加的长度是(curlen+len-curlen)*2==len*2</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure added region doesn't contain garbage */</span></span><br><span class="line">    sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//增加了2个len长度，实际只对一个len长度填充0</span></span><br><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span><br><span class="line">    totlen = sh-&gt;len+sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//指定len字段的值</span></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">//这个free值有什么意义？</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-sh-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长度为len的字符串t追加到sdshdr的有效字符串末尾</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先对buf数组扩容</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="comment">//返回NULL表示空间不足</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//从有效字符串的末尾开始，将长度为len的字符串t复制到指针指向的位置</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="comment">//有效字符串长度增加len</span></span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    <span class="comment">//剩余空间减少len</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求个字符串长度而已，多此一举</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用长度为len的字符串t从头覆盖buf数组</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;</span><br><span class="line">        <span class="comment">//若buf数组长度比要存的字符串短，先扩容，但是扩容的长度不是与buf数组总长度的差，而是与有效字符串长度的差</span></span><br><span class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从buf数组头部开始覆盖</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span><br><span class="line">    <span class="comment">//标记新有效字符串的末尾</span></span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">//后面存的是什么都无所谓了，反正都算free</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样的多此一举</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把ap里的所有参数格式化后拼接到buf数组s的后面</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    va_list cpy;</span><br><span class="line">    <span class="keyword">char</span> *buf, *t;</span><br><span class="line">    <span class="comment">//缓冲区初始长度设为16</span></span><br><span class="line">    <span class="keyword">size_t</span> buflen = <span class="number">16</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        buf = zmalloc(buflen);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//缓冲区的倒数第二位设为结束符</span></span><br><span class="line">        <span class="comment">//为什么不是最后一位？</span></span><br><span class="line">        buf[buflen<span class="number">-2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">//把ap指针复制到cpy，之后回到sdscatprintf函数里ap指针还要free掉，所以这里不能直接用</span></span><br><span class="line">        va_copy(cpy,ap);</span><br><span class="line">        <span class="comment">//把可变参数表格式化并输出到缓冲区</span></span><br><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span><br><span class="line">        <span class="comment">//如果缓冲区的结束符被覆盖了，说明缓冲区长度不够，直接free掉，加大长度重新zmalloc</span></span><br><span class="line">        <span class="keyword">if</span> (buf[buflen<span class="number">-2</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            zfree(buf);</span><br><span class="line">            buflen *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把缓冲区数据追加到s末尾</span></span><br><span class="line">    t = sdscat(s, buf);</span><br><span class="line">    zfree(buf);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据fmt格式化参数列表，结果追加到s末尾并返回。使用了可变参数，所以要在&lt;sds.h&gt;中提示编译器检查可变参数</span></span><br><span class="line"><span class="comment">//s只是作为一个容器而已，原本的内容不会被修改</span></span><br><span class="line"><span class="comment">//va_开头的是&lt;stdarg.h&gt;中定义的结构和函数</span></span><br><span class="line"><span class="comment">//va_list是用于存放参数列表的结构，实际上是char*的别名，通过移动指针取参数</span></span><br><span class="line"><span class="comment">//va_start函数根据fmt指针来初始化参数列表ap，其实就是让ap指向可变参数表里面的第一个参数。因为fmt是紧挨着可变参数表的前一个参数，所以就让ap指向fmt后面的第一个参数</span></span><br><span class="line"><span class="comment">//va_end函数负责清理参数列表，因为ap是字符指针，所以最后需要释放</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("Sum is: ");</span></span><br><span class="line"><span class="comment"> * s = sdscatprintf(s,"%d+%d = %d",a,b,a+b)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    t = sdscatvprintf(s,fmt,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从s数组左右两端分别移除所有在cset字符串中出现过的字符，也就是保证s两端的两个字符不在cset中</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s,"Aa. :");  =&gt; "Hello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头标记和尾标记设为s的两端</span></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//两端分别逐位判断字符是否在cset中，一旦匹配失败就退出</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//用sp到ep的子串从头覆盖buf数组，因为是子串所以不用判断溢出</span></span><br><span class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</span><br><span class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用s中start到end的子串覆盖原始的s</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("Hello World");</span></span><br><span class="line"><span class="comment"> * sdsrange(s,1,-1); =&gt; "ello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> newlen, len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//先把负下标换成正数</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start = len+start;</span><br><span class="line">        <span class="comment">//负过头了就归0</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        end = len+end;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子串的长度</span></span><br><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newlen != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//若start超出buf的有效字符串长度，则子串不存在，长度设为0</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            newlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若end越界超出buf的有效字符串长度，则退回到有效字符串末尾</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            end = len<span class="number">-1</span>;</span><br><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用子串覆盖buf数组</span></span><br><span class="line">    <span class="keyword">if</span> (start &amp;&amp; newlen) memmove(sh-&gt;buf, sh-&gt;buf+start, newlen);</span><br><span class="line">    <span class="comment">//结束符为什么不是'\0'</span></span><br><span class="line">    sh-&gt;buf[newlen] = <span class="number">0</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-newlen);</span><br><span class="line">    sh-&gt;len = newlen;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组转小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">tolower</span>(s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组转大写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">toupper</span>(s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(sds s1, sds s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l1, l2, minlen;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">    l1 = sdslen(s1);</span><br><span class="line">    l2 = sdslen(s2);</span><br><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span><br><span class="line">    cmp = <span class="built_in">memcmp</span>(s1,s2,minlen);</span><br><span class="line">    <span class="comment">//相等应该直接返回0，为什么多此一举非要算出个0？</span></span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> l1-l2;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split 's' with separator in 'sep'. An array</span></span><br><span class="line"><span class="comment"> * of sds strings is returned. *count will be set</span></span><br><span class="line"><span class="comment"> * by reference to the number of tokens returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On out of memory, zero length string, zero length</span></span><br><span class="line"><span class="comment"> * separator, NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that 'sep' is able to split a string using</span></span><br><span class="line"><span class="comment"> * a multi-character separator. For example</span></span><br><span class="line"><span class="comment"> * sdssplit("foo_-_bar","_-_"); will return two</span></span><br><span class="line"><span class="comment"> * elements "foo" and "bar".</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This version of the function is binary-safe but</span></span><br><span class="line"><span class="comment"> * requires length arguments. sdssplit() is just the</span></span><br><span class="line"><span class="comment"> * same function but for zero-terminated strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用分隔符(字符串)sep分割字符串s，返回一个sds数组，同时count存放分割后子串数量，因为是指针所以能修改数值</span></span><br><span class="line"><span class="comment">//len是s的长度，seplen是sep的长度</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>, slots = <span class="number">5</span>, start = <span class="number">0</span>, j;</span><br><span class="line">    <span class="comment">//slots是预设的子串数量，因为要申请空间所以要先预设，不够再扩容</span></span><br><span class="line">    <span class="comment">//sds本身是char*，所以tokens实际上是指针数组的指针</span></span><br><span class="line">    sds *tokens = zmalloc(<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//空间不足就返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span> || tokens == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//s为空，则返回空的tokens，count设为0</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (len-(seplen<span class="number">-1</span>)); j++) &#123;</span><br><span class="line">        <span class="comment">/* make sure there is room for the next element and the final one */</span></span><br><span class="line">        <span class="comment">//tokens数组要有至少存放两个sds的空位，不够就扩容成两倍</span></span><br><span class="line">        <span class="comment">//因为后面在循环体内部要存入一个sds，又因为循环下标截止到len-(seplen-1)，循环结束后还会存入最后一个sds，所以要预留两个空位</span></span><br><span class="line">        <span class="keyword">if</span> (slots &lt; elements+<span class="number">2</span>) &#123;</span><br><span class="line">            sds *newtokens;</span><br><span class="line"></span><br><span class="line">            slots *= <span class="number">2</span>;</span><br><span class="line">            newtokens = zrealloc(tokens,<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line">            <span class="comment">//若空间不足扩容失败，报错并释放tokens指针</span></span><br><span class="line">            <span class="keyword">if</span> (newtokens == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            tokens = newtokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* search the separator */</span></span><br><span class="line">        <span class="comment">//sep只有一个字符时直接比较，有多个字符时用memcmp比较</span></span><br><span class="line">        <span class="keyword">if</span> ((seplen == <span class="number">1</span> &amp;&amp; *(s+j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s+j,sep,seplen) == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//构造新的sds，空间不足就退出</span></span><br><span class="line">            tokens[elements] = sdsnewlen(s+start,j-start);</span><br><span class="line">            <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下标加一</span></span><br><span class="line">            elements++;</span><br><span class="line">            start = j+seplen;</span><br><span class="line">            j = j+seplen<span class="number">-1</span>; <span class="comment">/* skip the separator */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add the final element. We are sure there is room in the tokens array. */</span></span><br><span class="line">    <span class="comment">//存入最后一个子串</span></span><br><span class="line">    tokens[elements] = sdsnewlen(s+start,len-start);</span><br><span class="line">    <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    elements++;</span><br><span class="line">    *count = elements;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line"><span class="comment">//tokens是指针数组的指针，所以tokens指针和其内部的指针元素要分别释放</span></span><br><span class="line">cleanup:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) sdsfree(tokens[i]);</span><br><span class="line">        zfree(tokens);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和cleanup基本重复了，如果sdssplitlen里直接用count计数而不用额外的elements计数，就能合并了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tokens) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">        sdsfree(tokens[count]);</span><br><span class="line">    zfree(tokens);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长整型数据转成字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//buf和p的作用重复了，没必要</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>], *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">    v = (value &lt; <span class="number">0</span>) ? -value : value;</span><br><span class="line">    <span class="comment">//其实long long int最长就20位，没必要留这么多位置</span></span><br><span class="line">    <span class="comment">//从后往前赋值，最后p就指向了字符串头部</span></span><br><span class="line">    p = buf+<span class="number">31</span>; <span class="comment">/* point to the last character */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *p-- = <span class="string">'0'</span>+(v%<span class="number">10</span>);</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) *p-- = <span class="string">'-'</span>;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="comment">//指定p和p的长度创建sds</span></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(p,<span class="number">32</span>-(p-buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长度为len的字符串p以带引号的格式追加到s的末尾，也就是添加引用字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s末尾添加'"'，作为引用字符串的开头</span></span><br><span class="line">    s = sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">        <span class="comment">//把non-printable characters转换成printable characters</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">            s = sdscatprintf(s,<span class="string">"\\%c"</span>,*p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>: s = sdscatlen(s,<span class="string">"\\n"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>: s = sdscatlen(s,<span class="string">"\\r"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>: s = sdscatlen(s,<span class="string">"\\t"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\a'</span>: s = sdscatlen(s,<span class="string">"\\a"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\b'</span>: s = sdscatlen(s,<span class="string">"\\b"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//isprint判断是否为printable character</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isprint</span>(*p))</span><br><span class="line">                s = sdscatprintf(s,<span class="string">"%c"</span>,*p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//不可打印的用两位十六进制字符串表示</span></span><br><span class="line">                s = sdscatprintf(s,<span class="string">"\\x%02x"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后添加'"'，作为引用字符串的结束</span></span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Helper function for sdssplitargs() that returns non zero if 'c'</span></span><br><span class="line"><span class="comment"> * is a valid hex digit. */</span></span><br><span class="line"><span class="comment">//判断一个给定字符是否是十六进制数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_hex_digit</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) ||</span><br><span class="line">           (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Helper function for sdssplitargs() that converts an hex digit into an</span></span><br><span class="line"><span class="comment"> * integer from 0 to 15 */</span></span><br><span class="line"><span class="comment">//把单个十六进制字符转换为相应的十进制数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex_digit_to_int</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'1'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>: <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'4'</span>: <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'5'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'6'</span>: <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'7'</span>: <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'8'</span>: <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'9'</span>: <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>: <span class="keyword">case</span> <span class="string">'B'</span>: <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>: <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'d'</span>: <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'E'</span>: <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'f'</span>: <span class="keyword">case</span> <span class="string">'F'</span>: <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split a line into arguments, where every argument can be in the</span></span><br><span class="line"><span class="comment"> * following programming-language REPL-alike form:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * foo bar "newline are supported\n" and "\xff\x00otherstuff"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The number of arguments is stored into *argc, and an array</span></span><br><span class="line"><span class="comment"> * of sds is returned. The caller should sdsfree() all the returned</span></span><br><span class="line"><span class="comment"> * strings and finally zfree() the array itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that sdscatrepr() is able to convert back a string into</span></span><br><span class="line"><span class="comment"> * a quoted string in the same format sdssplitargs() is able to parse.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//命令行解析，argc存放解析后的参数个数</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = line;</span><br><span class="line">    <span class="keyword">char</span> *current = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> **<span class="built_in">vector</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* skip blanks */</span></span><br><span class="line">        <span class="keyword">while</span>(*p &amp;&amp; <span class="built_in">isspace</span>(*p)) p++;</span><br><span class="line">        <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">            <span class="comment">/* get a token */</span></span><br><span class="line">            <span class="keyword">int</span> inq=<span class="number">0</span>; <span class="comment">/* set to 1 if we are in "quotes" */</span></span><br><span class="line">            <span class="keyword">int</span> done=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面已经把current重置成NULL了，这个判断多此一举</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) current = sdsempty();</span><br><span class="line">            <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">                <span class="comment">//双引号内的解析</span></span><br><span class="line">                <span class="comment">//在双引号内部不关心分隔符，读到右双引号才算读完一个参数</span></span><br><span class="line">                <span class="keyword">if</span> (inq) &#123;</span><br><span class="line">                    <span class="comment">//读到一个以'\x'开头的表示两位十六进制整数的字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="string">'x'</span> &amp;&amp;</span><br><span class="line">                                             is_hex_digit(*(p+<span class="number">2</span>)) &amp;&amp;</span><br><span class="line">                                             is_hex_digit(*(p+<span class="number">3</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</span><br><span class="line">                        <span class="comment">//转换成十进制格式的字符串</span></span><br><span class="line">                        byte = (hex_digit_to_int(*(p+<span class="number">2</span>))*<span class="number">16</span>)+</span><br><span class="line">                                hex_digit_to_int(*(p+<span class="number">3</span>));</span><br><span class="line">                        <span class="comment">//追加到current尾部</span></span><br><span class="line">                        current = sdscatlen(current,(<span class="keyword">char</span>*)&amp;byte,<span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//跳过这个十六进制的数，接着读下个字符</span></span><br><span class="line">                        p += <span class="number">3</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="comment">//处理'\'开头的特殊字符</span></span><br><span class="line">                        <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">                        p++;</span><br><span class="line">                        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'n'</span>: c = <span class="string">'\n'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'r'</span>: c = <span class="string">'\r'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'t'</span>: c = <span class="string">'\t'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'b'</span>: c = <span class="string">'\b'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'a'</span>: c = <span class="string">'\a'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: c = *p; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//特殊字符也追加到current尾部，因为都在一个双引号的引用内</span></span><br><span class="line">                        current = sdscatlen(current,&amp;c,<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'"'</span>) &#123;</span><br><span class="line">                        <span class="comment">/* closing quote must be followed by a space */</span></span><br><span class="line">                        <span class="comment">//读到右双引号表示读取完毕，跳出循环，但是与下个参数的分隔符必须是空格，否则报错</span></span><br><span class="line">                        <span class="keyword">if</span> (*(p+<span class="number">1</span>) &amp;&amp; !<span class="built_in">isspace</span>(*(p+<span class="number">1</span>))) <span class="keyword">goto</span> err;</span><br><span class="line">                        done=<span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!*p) &#123;</span><br><span class="line">                        <span class="comment">/* unterminated quotes */</span></span><br><span class="line">                        <span class="comment">//没读到右双引号就读完了，说明命令行参数写错了，报error</span></span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//剩下的情况就是一般字符，直接追加到current尾部</span></span><br><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//双引号外的解析</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">                    <span class="comment">//读到分割符，done=1表示当前参数解析完毕</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\0'</span>:</span><br><span class="line">                        done=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//读到双引号</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                        inq=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">//如果是一般字符，就追加到current尾部，跳出循环开始读下个字符</span></span><br><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没有break就接着读下个字符</span></span><br><span class="line">                <span class="keyword">if</span> (*p) p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* add the token to the vector */</span></span><br><span class="line">            <span class="comment">//事先不知道能解析出多少个参数，只能读到一个就扩容一个空位</span></span><br><span class="line">            <span class="built_in">vector</span> = zrealloc(<span class="built_in">vector</span>,((*argc)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">            <span class="comment">//读出的参数先是保存在current中，再存入vector中</span></span><br><span class="line">            <span class="built_in">vector</span>[*argc] = current;</span><br><span class="line">            (*argc)++;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//返回解析出的参数列表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="comment">//和上面的tokens一样，指针数组的指针要内外分别释放</span></span><br><span class="line">    <span class="keyword">while</span>((*argc)--)</span><br><span class="line">        sdsfree(<span class="built_in">vector</span>[*argc]);</span><br><span class="line">    zfree(<span class="built_in">vector</span>);</span><br><span class="line">    <span class="keyword">if</span> (current) sdsfree(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面是测试代码，略</span></span><br></pre></td></tr></table></figure></div>
<h2 id="2-3-双端链表"><a href="#2-3-双端链表" class="headerlink" title="2.3 双端链表"></a>2.3 双端链表</h2><h3 id="adlist-h"><a href="#adlist-h" class="headerlink" title="adlist.h"></a>adlist.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adlist.h - A generic doubly linked list implementation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ADLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ADLIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//指向后一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//value是void类型，表示链表可以保存各种不同类型的值，相当于多态</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于访问链表的迭代器，双向链表自然支持双向迭代</span></span><br><span class="line"><span class="comment">//迭代器并不保存链表，只是标记链表的一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    <span class="comment">//下个待访问的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="comment">//迭代访问的方向，AL_START_HEAD表示向前，AL_START_TAIL表示向后，在后面的宏定义里</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向头结点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//指向尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//提供了三个函数指针, 供用户传入自定义函数</span></span><br><span class="line">    <span class="comment">//dup用于复制节点所保存的值，free用于释放节点所保存的值(因为节点值是void指针)，match用于匹配节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//链表长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="comment">//把指针的操作封装成了宏的类型，方便了程序员的使用</span></span><br><span class="line"><span class="comment">//l表示list指针，n表示listNode指针，m表示函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Prototypes */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span>;</span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="comment">//迭代链表的方向</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __ADLIST_H__ */</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="adlist-c"><a href="#adlist-c" class="headerlink" title="adlist.c"></a>adlist.c</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adlist.c - A generic doubly linked list implementation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"adlist.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new list. The created list can be freed with</span></span><br><span class="line"><span class="comment"> * AlFreeList(), but private value of every node need to be freed</span></span><br><span class="line"><span class="comment"> * by the user before to call AlFreeList().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned. Otherwise the pointer to the new list. */</span></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="comment">//空参数实际上表示函数需要不确定个数的参数，比如main()，而void参数才是明确告诉编译器函数不需要参数</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line">    <span class="comment">//空间不足就退出</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//返回链表指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free the whole list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can't fail. */</span></span><br><span class="line"><span class="comment">//释放链表</span></span><br><span class="line"><span class="comment">//先释放listNode的value指针，再释放listNode指针，释放完所有节点后再释放list指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new node to the list, to head, contaning the specified 'value'</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the 'list' pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="comment">//给定一个值value和链表list，根据value构造新节点添加到list的表头</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line">    <span class="comment">//申请空节点</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//给节点赋值</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="comment">//设置链表的头尾指针和新节点的前后指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新链表长度</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new node to the list, to tail, contaning the specified 'value'</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the 'list' pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="comment">//给定一个值value和链表list，根据value构造新节点添加到list的尾部</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个包含给定值value的新节点添加到给定节点old_node的之前或者之后</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="comment">//after==0表示新节点添加到old_node前面，否则就是添加到后面</span></span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让新节点的前后节点指向该新节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove the specified node from the specified list.</span></span><br><span class="line"><span class="comment"> * It's up to the caller to free the private value of the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can't fail. */</span></span><br><span class="line"><span class="comment">//从链表中删除给定节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a list iterator 'iter'. After the initialization every</span></span><br><span class="line"><span class="comment"> * call to listNext() will return the next element of the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can't fail. */</span></span><br><span class="line"><span class="comment">//指定迭代方向，获取链表的迭代器</span></span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">    <span class="comment">//正向迭代从头结点开始</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//反向迭代从尾结点开始</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release the iterator memory */</span></span><br><span class="line"><span class="comment">//释放迭代器，就是给zfree指定了参数类型，多此一举</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an iterator in the list private iterator structure */</span></span><br><span class="line"><span class="comment">//重置迭代器li，起点设为链表头结点，方向设为自前向后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置迭代器li，起点设为链表尾结点，方向设为自后向前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the next element of an iterator.</span></span><br><span class="line"><span class="comment"> * It's valid to remove the currently returned element using</span></span><br><span class="line"><span class="comment"> * listDelNode(), but not to remove other elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns a pointer to the next element of the list,</span></span><br><span class="line"><span class="comment"> * or NULL if there are no more elements, so the classical usage patter</span></span><br><span class="line"><span class="comment"> * is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * iter = listGetIterator(list,&lt;direction&gt;);</span></span><br><span class="line"><span class="comment"> * while ((node = listNext(iter)) != NULL) &#123;</span></span><br><span class="line"><span class="comment"> *     doSomethingWith(listNodeValue(node));</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">//返回迭代器指向的下一个节点，然后根据迭代方向更新迭代器指向的节点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Duplicate the whole list. On out of memory NULL is returned.</span></span><br><span class="line"><span class="comment"> * On success a copy of the original list is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The 'Dup' method set with listSetDupMethod() function is used</span></span><br><span class="line"><span class="comment"> * to copy the node value. Otherwise the same pointer value of</span></span><br><span class="line"><span class="comment"> * the original node is used as value of the copied node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The original list both on success or error is never modified. */</span></span><br><span class="line"><span class="comment">//复制整个链表orig，返回新副本链表的指针</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//先复制orig的三个方法</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    <span class="comment">//获取orig的迭代器，逐个节点进行复制</span></span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//复制出错，清理迭代器和copy并退出</span></span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="comment">//根据value构造新节点添加到copy末尾</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器用完就释放</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search the list for a node matching a given key.</span></span><br><span class="line"><span class="comment"> * The match is performed using the 'match' method</span></span><br><span class="line"><span class="comment"> * set with listSetMatchMethod(). If no 'match' method</span></span><br><span class="line"><span class="comment"> * is set, the 'value' pointer of every node is directly</span></span><br><span class="line"><span class="comment"> * compared with the 'key' pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success the first matching node pointer is returned</span></span><br><span class="line"><span class="comment"> * (search starts from head). If no matching node exists</span></span><br><span class="line"><span class="comment"> * NULL is returned. */</span></span><br><span class="line"><span class="comment">//获取链表中节点值等于给定key的节点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line">    <span class="comment">//利用迭代器遍历</span></span><br><span class="line">    iter = listGetIterator(<span class="built_in">list</span>, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the element at the specified zero-based index</span></span><br><span class="line"><span class="comment"> * where 0 is the head, 1 is the element next to head</span></span><br><span class="line"><span class="comment"> * and so on. Negative integers are used in order to count</span></span><br><span class="line"><span class="comment"> * from the tail, -1 is the last element, -2 the penultimante</span></span><br><span class="line"><span class="comment"> * and so on. If the index is out of range NULL is returned. */</span></span><br><span class="line"><span class="comment">//返回链表在给定索引上的节点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line">    <span class="comment">//支持负索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//负索引是从尾节点倒着数</span></span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//正索引是从头结点正着数</span></span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-4-字典"><a href="#2-4-字典" class="headerlink" title="2.4 字典"></a>2.4 字典</h2><h3 id="dict-h"><a href="#dict-h" class="headerlink" title="dict.h"></a>dict.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hash Tables Implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DICT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DICT_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的状态码，DICT_OK表示对字典的操作成功，DICT_ERR表示操作失败</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_OK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_ERR 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unused arguments generate annoying warnings... */</span></span><br><span class="line"><span class="comment">//没用到</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_NOTUSED(V) ((void) V)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字典表项，一个key-value对</span></span><br><span class="line"><span class="comment">//因为采用拉链法处理哈希碰撞，所以需要一个指针所在链表的下一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">void</span> *val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典需要的一组函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="comment">//字典使用的哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组，数组中的每个元素都是一个指向某个dictEntry的指针</span></span><br><span class="line">    <span class="comment">//也就是拉链法需要的链表的链表，第一层链表(桶链表)的每个元素是第二层链表的头节点，第二层的链表(节点链表)存储哈希值相同的dictEntry元素</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//table的大小，也就是桶的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值。sizemask=size-1，给定dictEntry节点的key的哈希值计算出来后，与sizemask进行按位与操作，决定该节点应该被放在桶链表的哪个桶里</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//哈希表已有dictEntry节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">//为字典设置的针对不同数据类型的特定函数簇</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据，保存了需要传给type中特定函数的可选参数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//一个字典使用了两个哈希表，用户使用的是0号哈希表，1号哈希表用于对0号哈希表进行rehash</span></span><br><span class="line">    <span class="comment">//rehash的目的是提高哈希表的查找效率。因为要映射哈希值的缘故，桶链表的长度在创建以后就不能改了，随着节点的增多，哈希表的负载因子会越来越大(负载因子=总节点数/桶链表长度)，表现为桶不够用了，使得节点链表过长，查询操作会在节点链表上浪费时间。所以rehash就是新建一个更长的桶链表，把节点疏散开。反之，如果节点数过少，rehash的过程就是新建一个更短的桶链表，不让节点分布太疏散。rehash完成后，就用1号哈希表替换0号哈希表，所以1号哈希表只是辅助rehash的，用户无需访问。</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash标示，为-1表示不在rehash，不为0表示正在rehash的桶序号</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">//当前正在运行的安全迭代器数量</span></span><br><span class="line">    <span class="comment">//存在安全迭代器就不会进行rehash，也就不会有节点被偷偷迁移到1号哈希表，保证了迭代的准确性</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iteartor, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="comment">//字典的迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    <span class="comment">//被迭代的字典</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="comment">//table是当前正在迭代的哈希表序号，取值为0或1</span></span><br><span class="line">    <span class="comment">//index是迭代器当前所指向的桶索引位置</span></span><br><span class="line">    <span class="comment">//safe标识此迭代器是否安全。safe=1表示安全，迭代时可以对节点增删改查，否则就是不安全的，只能迭代哈希表而不能修改</span></span><br><span class="line">    <span class="keyword">int</span> table, index, safe;</span><br><span class="line">    <span class="comment">//entry是当前迭代到的节点的指针</span></span><br><span class="line">    <span class="comment">//nextEntry是当前迭代节点的下一个节点。因为在迭代时entry指针可能会被修改，所以要单独保存下个节点的地址，防止丢失链接</span></span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">&#125; dictIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the initial size of every hash table */</span></span><br><span class="line"><span class="comment">//哈希表的初始长度，即桶的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HT_INITIAL_SIZE     4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------- Macros ------------------------------------*/</span></span><br><span class="line"><span class="comment">//宏定义函数，d表示字典dict，entry表示节点dictEntry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点的val指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeEntryVal(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;val)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置节点的val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetHashVal(d, entry, _val_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span><br><span class="line">        <span class="comment">//如果定义了复制值的函数，就调用该函数完成</span></span><br><span class="line">        entry-&gt;val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;val = (_val_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点的key指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeEntryKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置节点的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetHashKey(d, entry, _key_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span><br><span class="line">        entry-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;key = (_key_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictCompareHashKeys(d, key1, key2) \</span></span><br><span class="line">    (((d)-&gt;type-&gt;keyCompare) ? \</span><br><span class="line">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span><br><span class="line">        (key1) == (key2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算key的哈希值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取节点的key和val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetEntryKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetEntryVal(he) ((he)-&gt;val)</span></span><br><span class="line"><span class="comment">//计算字典中两个哈希表的总大小(桶的数量)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)</span></span><br><span class="line"><span class="comment">//计算字典中两个哈希表的总节点数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="comment">//是否正在进行rehash</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictIsRehashing(ht) ((ht)-&gt;rehashidx != -1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* API */</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type, <span class="keyword">void</span> *privDataPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function">dictEntry * <span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dictFetchValue</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span>;</span><br><span class="line"><span class="function">dictEntry *<span class="title">dictGetRandomKey</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictPrintStats</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span><span class="params">(dict *d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hash table types */</span></span><br><span class="line"><span class="comment">//作者的样例代码用到的，实际没啥用</span></span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStringCopyKey;</span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStrings;</span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStringCopyKeyValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __DICT_H */</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="dict-c"><a href="#dict-c" class="headerlink" title="dict.c"></a>dict.c</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hash Tables Implementation.*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmacros.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dict.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Using dictEnableResize() / dictDisableResize() we make possible to</span></span><br><span class="line"><span class="comment"> * enable/disable resizing of the hash table as needed. This is very important</span></span><br><span class="line"><span class="comment"> * for Redis, as we use copy-on-write and don't want to move too much memory</span></span><br><span class="line"><span class="comment"> * around when there is a child performing saving operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that even when dict_can_resize is set to 0, not all resizes are</span></span><br><span class="line"><span class="comment"> * prevented: an hash table is still allowed to grow if the ratio between</span></span><br><span class="line"><span class="comment"> * the number of elements and the buckets &gt; dict_force_resize_ratio. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dict_can_resize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dict_force_resize_ratio = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------- private prototypes ---------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *ht);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictInit(dict *ht, dictType *type, <span class="keyword">void</span> *privDataPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------- hash functions -------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thomas Wang's 32 bit Mix Function */</span></span><br><span class="line"><span class="comment">//针对整型的哈希函数，把整型key转换成对应的哈希值，作为哈希表的键值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictIntHashFunction</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">10</span>);</span><br><span class="line">    key +=  (key &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">6</span>);</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">11</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Identity hash function for integer keys */</span></span><br><span class="line"><span class="comment">//不使用哈希函数，直接把整型作为哈希表的key</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictIdentityHashFunction</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generic hash function (a popular one from Bernstein).</span></span><br><span class="line"><span class="comment"> * I tested a few and this was the best. */</span></span><br><span class="line"><span class="comment">//djb哈希算法，一种通用的哈希函数，计算字符串buf的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//hash seed</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">        <span class="comment">//字符串的ascii值与hash seed做运算</span></span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + (*buf++); <span class="comment">/* hash * 33 + c */</span></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* And a case insensitive version */</span></span><br><span class="line"><span class="comment">//大小写无关的djb哈希算法</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + (<span class="built_in">tolower</span>(*buf++)); <span class="comment">/* hash * 33 + c */</span></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------------------------- API implementation ------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset an hashtable already initialized with ht_init().</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This function should only called by ht_destroy(). */</span></span><br><span class="line"><span class="comment">//初始化或重置哈希表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    ht-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">    ht-&gt;size = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;sizemask = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new hash table */</span></span><br><span class="line"><span class="comment">//创建新的空字典</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *privDataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</span><br><span class="line">    <span class="comment">//申请到空间后做初始化</span></span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    <span class="comment">//返回字典指针</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the hash table */</span></span><br><span class="line"><span class="comment">//字典的初始化函数</span></span><br><span class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</span><br><span class="line">        <span class="keyword">void</span> *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重置字典的两个哈希表</span></span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//初始化赋值</span></span><br><span class="line">    d-&gt;type = type;</span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//返回成功的状态码</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USER/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="comment">//调整字典d中哈希表的size，保证每个节点占一个单独的桶，但长度可能有冗余，因为哈希表长度必须是DICT_HT_INITIAL_SIZE乘以2的幂次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line">    <span class="comment">//如果不支持resize，或者字典正在rehash，返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">//桶的数量定为0号哈希表的总节点数，但不能少于初始化的DICT_HT_INITIAL_SIZE</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="comment">//调用dictExpand对哈希表扩容</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand or create the hashtable */</span></span><br><span class="line"><span class="comment">//哈希表扩容函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht n; <span class="comment">/* the new hashtable */</span></span><br><span class="line">    <span class="comment">//计算实际的扩容长度，结果是DICT_HT_INITIAL_SIZE乘以2的幂次</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hashtable */</span></span><br><span class="line">    <span class="comment">//若字典正在rehash，需要等待rehash完成再扩容</span></span><br><span class="line">    <span class="comment">//若节点数大于扩容的长度，说明出了问题，具体什么问题？</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hashtable and initialize all pointers to NULL */</span></span><br><span class="line">    <span class="comment">//初始化扩容的哈希表</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it's not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前字典的0号哈希表是空，就把新哈希表赋给0号，可以直接使用</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    <span class="comment">//如果当前字典有正在使用的0号哈希表，就把新哈希表先赋给1号，之后rehash的时候再赋给0号</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * thank one key as we use chaining) from the old to the new hash table. */</span></span><br><span class="line"><span class="comment">//字典的rehash函数，采用分n步渐进式的rehash，因为当前的字典可能非常庞大，如果一次性把0号表的节点全部迁移到1号表，可能会占用大量时间和资源，影响系统性能，所以redis实际上是把rehash操作平摊到 dictAddRaw 、dictGetRandomKey 、dictFind 、dictGenericDelete 这些函数里，每当这些函数被执行的时候, 就会顺便执行_dictRehashStep函数，_dictRehashStep再调用dictRehash来迁移部分节点。此外还有dictRehashMilliseconds函数，支持在给定的时间段内集中进行rehash。</span></span><br><span class="line"><span class="comment">//参数n表示本次要迁移的桶的数量</span></span><br><span class="line"><span class="comment">//返回1说明rehash还没完，继续下一步，返回0就表示rehash已经完成</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询字典的rehashidx标志，如果表示已经rehash完毕，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环迁移n个桶中的节点</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="comment">//辅助指针，用于迭代当前桶中的节点链表</span></span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">        <span class="comment">//0号表节点数为0说明已经全部迁移完成，此时用1号表替换0号表，然后重置1号表，修改rehashidx标志，返回0表示rehash完毕</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">            zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">            d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        <span class="comment">//当前的桶迁移完毕后开始迁移下一个桶</span></span><br><span class="line">        <span class="comment">//这里桶的索引不会越界，因为越界说明0号表已经全部清空了，这在前面已经判断过了</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</span><br><span class="line">        <span class="comment">//把当前桶中节点链表的头节点赋给de</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="comment">//把当前桶中的所有节点迁移到1号表</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">//用字典的type函数簇里的哈希函数计算当前节点key的哈希值，与1号表的掩码按位与，得到在1号表中的桶索引</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            <span class="comment">//节点总是被插入到1号表的节点链表的表头</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            <span class="comment">//更新两个表的节点数</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为迁移过程是用辅助指针做的，所以最后还要把0号表当前桶中的链表指针设为NULL，表示桶已经清空</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否rehash完毕要在函数头部检查，此时无脑返回1即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的毫秒时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">timeInMilliseconds</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">long</span> <span class="keyword">long</span>)tv.tv_sec)*<span class="number">1000</span>)+(tv.tv_usec/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</span></span><br><span class="line"><span class="comment">//在给定的毫秒时间段内集中进行rehash</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次迁移100个桶</span></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//时间到了就中止rehash</span></span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回桶索引</span></span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function performs just a step of rehashing, and only if there are</span></span><br><span class="line"><span class="comment"> * no safe iterators bound to our hash table. When we have iterators in the</span></span><br><span class="line"><span class="comment"> * middle of a rehashing we can't mess with the two hash tables otherwise</span></span><br><span class="line"><span class="comment"> * some element can be missed or duplicated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called by common lookup or update operations in the</span></span><br><span class="line"><span class="comment"> * dictionary so that the hash table automatically migrates from H1 to H2</span></span><br><span class="line"><span class="comment"> * while it is actively used. */</span></span><br><span class="line"><span class="comment">//如果当前字典没有迭代器，执行一步rehash，迁移一个桶的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="comment">//向字典插入dictEntry节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="comment">//根据节点的key计算应该放入的桶序号。哈希碰撞指的是索引冲突</span></span><br><span class="line">    <span class="comment">//当key已经在字典中，插入失败，返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocates the memory and stores key */</span></span><br><span class="line">    <span class="comment">//如果正在rehash，就往1号表里插，否则直接往0号表插</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">//插入到节点链表的头部</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    <span class="comment">//把key和val赋给新节点</span></span><br><span class="line">    dictSetHashKey(d, entry, key);</span><br><span class="line">    dictSetHashVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add an element, discarding the old if the key already exists.</span></span><br><span class="line"><span class="comment"> * Return 1 if the key was added from scratch, 0 if there was already an</span></span><br><span class="line"><span class="comment"> * element with such key and dictReplace() just performed a value update</span></span><br><span class="line"><span class="comment"> * operation. */</span></span><br><span class="line"><span class="comment">//向字典插入dictEntry节点，若key已经存在就更新val</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry, auxentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to add the element. If the key</span></span><br><span class="line"><span class="comment">     * does not exists dictAdd will suceed. */</span></span><br><span class="line">    <span class="comment">//能插就插</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* It already exists, get the entry */</span></span><br><span class="line">    <span class="comment">//插入失败说明key已经存在，获取对应的节点</span></span><br><span class="line">    entry = dictFind(d, key);</span><br><span class="line">    <span class="comment">/* Free the old value and set the new one */</span></span><br><span class="line">    <span class="comment">/* Set the new value and free the old one. Note that it is important</span></span><br><span class="line"><span class="comment">     * to do that in this order, as the value may just be exactly the same</span></span><br><span class="line"><span class="comment">     * as the previous one. In this context, think to reference counting,</span></span><br><span class="line"><span class="comment">     * you want to increment (set), and then decrement (free), and not the</span></span><br><span class="line"><span class="comment">     * reverse. */</span></span><br><span class="line">    <span class="comment">//更新节点的val，释放旧的val指针</span></span><br><span class="line">    auxentry = *entry;</span><br><span class="line">    dictSetHashVal(d, entry, val);</span><br><span class="line">    dictFreeEntryVal(d, &amp;auxentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search and remove an element */</span></span><br><span class="line"><span class="comment">//删除字典中给定key的结点，可控制是否调用释放方法</span></span><br><span class="line"><span class="comment">//节点指针一定会被释放，nofree参数用于指定是否要释放节点中key和val的指针</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line">    <span class="comment">//如果字典的0号表是NULL，返回错误码。空的表size一般不是0，没初始化的表才是NULL</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR; <span class="comment">/* d-&gt;ht[0].table is NULL */</span></span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//用字典的type函数簇里的哈希函数计算节点key的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">//不知道节点在哪个表，所以都查一遍</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">//key的哈希值与表的掩码按位与，得到桶索引</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">//得到节点链表的头节点</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="comment">//保存前一个节点，删除节点后用于重连</span></span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="comment">//比较两个key，如果type函数簇中有自定义的比较函数，调用之</span></span><br><span class="line">            <span class="keyword">if</span> (dictCompareHashKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="comment">//断开目标节点的链接</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeEntryKey(d, he);</span><br><span class="line">                    dictFreeEntryVal(d, he);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//释放节点指针</span></span><br><span class="line">                zfree(he);</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> DICT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历完0号表，如果当前没有在rehash，就不用再查1号表了，因为肯定是空的</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点，同时释放节点的key和val指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点，但不释放节点的key和val指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy an entire dictionary */</span></span><br><span class="line"><span class="comment">//清空字典中指定的哈希表</span></span><br><span class="line"><span class="keyword">int</span> _dictClear(dict *d, dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free all the elements */</span></span><br><span class="line">    <span class="comment">//遍历指定表ht的桶</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        dictEntry *he, *nextHe;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((he = ht-&gt;table[i]) == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//逐个节点进行free</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            nextHe = he-&gt;next;</span><br><span class="line">            dictFreeEntryKey(d, he);</span><br><span class="line">            dictFreeEntryVal(d, he);</span><br><span class="line">            zfree(he);</span><br><span class="line">            ht-&gt;used--;</span><br><span class="line">            he = nextHe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Free the table and the allocated cache structure */</span></span><br><span class="line">    <span class="comment">//所有桶都清空后，释放哈希表的指针</span></span><br><span class="line">    zfree(ht-&gt;table);</span><br><span class="line">    <span class="comment">/* Re-initialize the table */</span></span><br><span class="line">    <span class="comment">//把ht重置成NULL</span></span><br><span class="line">    _dictReset(ht);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">/* never fails */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clear &amp; Release the hash table */</span></span><br><span class="line"><span class="comment">//清空整个字典，也就是先分别清空两个哈希表，再释放字典指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    zfree(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字典中指定key的节点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    <span class="comment">//0号表是NULL，说明整个字典都是空的</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* We don't have a table at all */</span></span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//计算key的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">//遍历两个哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">//计算桶索引</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">//获取节点链表的表头</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="comment">//遍历节点链表，找到就返回</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareHashKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前没有在rehash，不用再查1号表</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定key节点的val指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dictFetchValue</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    he = dictFind(d,key);</span><br><span class="line">    <span class="keyword">return</span> he ? dictGetEntryVal(he) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器，默认迭代0号表(迭代完会自动切换到1号表)，不安全，只设置字典而不设置节点指针</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line"></span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取安全迭代器</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器获取下一个节点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没设置节点指针，先获取迭代的表</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;safe &amp;&amp; iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//条件里有safe，所以字典的iterators属性其实是记录安全迭代器的数量</span></span><br><span class="line">                iter-&gt;d-&gt;iterators++;</span><br><span class="line">            <span class="comment">//桶索引归零</span></span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">//如果恰好遍历完当前的表，桶索引会越界</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">signed</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="comment">//如果遍历完的是0号表且正在rehash，说明1号表也有节点，把迭代的表切换到1号表</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//如果遍历完的是1号表，或者没有在rehash，说明整个字典的全部节点都遍历完了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置当前迭代的节点</span></span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//entry不为NULL，表示应该返回nextEntry</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the 'next' here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            <span class="comment">//用户怎么处理得到的entry节点都无所谓，反正已经事先设置了nextEntry节点，迭代器不会丢失指针</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//字典的iterators增加后，迭代器的index一定不是-1，所以(iter-&gt;index == -1 &amp;&amp; iter-&gt;table == 0)说明没有调用过dictNext，字典的iterators也就没有增加过，所以不需要减一</span></span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;safe &amp;&amp; !(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>))</span><br><span class="line">        iter-&gt;d-&gt;iterators--;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a random entry from the hash table. Useful to</span></span><br><span class="line"><span class="comment"> * implement randomized algorithms */</span></span><br><span class="line"><span class="comment">//获取字典中一个随机的节点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictGetRandomKey</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he, *orighe;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">int</span> listlen, listele;</span><br><span class="line">    <span class="comment">//如果两个哈希表的总节点数是0，就没有可返回的节点</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//如果正在rehash，随机的范围就是两个表的桶，通过判断桶里的表头指针是不是NULL，可以保证随机到的桶不是空的</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() % (d-&gt;ht[<span class="number">0</span>].size+d-&gt;ht[<span class="number">1</span>].size);</span><br><span class="line">            he = (h &gt;= d-&gt;ht[<span class="number">0</span>].size) ? d-&gt;ht[<span class="number">1</span>].table[h - d-&gt;ht[<span class="number">0</span>].size] :</span><br><span class="line">                                      d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果没有在rehash，随机的范围只有0号表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() &amp; d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">            he = d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we found a non empty bucket, but it is a linked</span></span><br><span class="line"><span class="comment">     * list and we need to get a random element from the list.</span></span><br><span class="line"><span class="comment">     * The only sane way to do so is counting the elements and</span></span><br><span class="line"><span class="comment">     * select a random index. */</span></span><br><span class="line">    listlen = <span class="number">0</span>;</span><br><span class="line">    orighe = he;</span><br><span class="line">    <span class="comment">//计算桶里的节点数</span></span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">        listlen++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机选一个节点</span></span><br><span class="line">    listele = random() % listlen;</span><br><span class="line">    he = orighe;</span><br><span class="line">    <span class="keyword">while</span>(listele--) he = he-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------- private functions ------------------------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="comment">//推断是否需要扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="comment">//如果正在扩容，返回0，表示不需要</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the intial size. */</span></span><br><span class="line">    <span class="comment">//如果0号表长度是0，先扩展到长度下限DICT_HT_INITIAL_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the "safe" threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="comment">//如果字典支持resize，每当负载因子大于等于1，就触发扩容</span></span><br><span class="line">    <span class="comment">//如果不支持resize，只有负载因子超过预设的dict_force_resize_ratio时，才触发强制扩容</span></span><br><span class="line">    <span class="comment">//扩容后的长度是总节点数的两倍</span></span><br><span class="line">    <span class="comment">//先扩容才能rehash</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里为什么还要判断d-&gt;ht[0].size &gt; d-&gt;ht[0].used？</span></span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, ((d-&gt;ht[<span class="number">0</span>].size &gt; d-&gt;ht[<span class="number">0</span>].used) ?</span><br><span class="line">                                    d-&gt;ht[<span class="number">0</span>].size : d-&gt;ht[<span class="number">0</span>].used)*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="comment">//计算哈希表实际的扩容长度</span></span><br><span class="line"><span class="comment">//实际长度必须是DICT_HT_INITIAL_SIZE值乘以2的幂次，结果不小于给定的size，但不能大于long int的上限</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the index of a free slot that can be populated with</span></span><br><span class="line"><span class="comment"> * an hash entry for the given 'key'.</span></span><br><span class="line"><span class="comment"> * If the key already exists, -1 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if we are in the process of rehashing the hash table, the</span></span><br><span class="line"><span class="comment"> * index is always returned in the context of the second (new) hash table. */</span></span><br><span class="line"><span class="comment">//计算给定的key在哈希表中的索引</span></span><br><span class="line"><span class="comment">//字典的key是唯一的，但索引是可以冲突的。哈希碰撞不是key重复，而是不同的key被放在了同一个桶里</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hashtable if needed */</span></span><br><span class="line">    <span class="comment">//先判断要不要扩容，返回错误码说明需要扩容但是扩容失败</span></span><br><span class="line">    <span class="comment">//但是为什么选在这个时候扩容？</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* Compute the key hash value */</span></span><br><span class="line">    <span class="comment">//计算key的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">//依次计算在两个表中的桶索引，如果正在rehash，返回的就是1号表中的索引，否则返回0号表中的索引</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareHashKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空整个字典，清空和销毁不一样，只释放哈希表指针，不释放字典指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调试函数，输出哈希表的相关信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_STATS_VECTLEN 50</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictPrintStatsHt(dictht *ht) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i, slots = <span class="number">0</span>, chainlen, maxchainlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> totchainlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> clvector[DICT_STATS_VECTLEN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;used == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No stats available for empty dictionaries\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DICT_STATS_VECTLEN; i++) clvector[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size; i++) &#123;</span><br><span class="line">        dictEntry *he;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ht-&gt;table[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            clvector[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slots++;</span><br><span class="line">        <span class="comment">/* For each hash entry on this slot... */</span></span><br><span class="line">        chainlen = <span class="number">0</span>;</span><br><span class="line">        he = ht-&gt;table[i];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            chainlen++;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        clvector[(chainlen &lt; DICT_STATS_VECTLEN) ? chainlen : (DICT_STATS_VECTLEN<span class="number">-1</span>)]++;</span><br><span class="line">        <span class="keyword">if</span> (chainlen &gt; maxchainlen) maxchainlen = chainlen;</span><br><span class="line">        totchainlen += chainlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hash table stats:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" table size: %ld\n"</span>, ht-&gt;size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" number of elements: %ld\n"</span>, ht-&gt;used);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" different slots: %ld\n"</span>, slots);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" max chain length: %ld\n"</span>, maxchainlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" avg chain length (counted): %.02f\n"</span>, (<span class="keyword">float</span>)totchainlen/slots);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" avg chain length (computed): %.02f\n"</span>, (<span class="keyword">float</span>)ht-&gt;used/slots);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" Chain length distribution:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DICT_STATS_VECTLEN<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clvector[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   %s%ld: %ld (%.02f%%)\n"</span>,(i == DICT_STATS_VECTLEN<span class="number">-1</span>)?<span class="string">"&gt;= "</span>:<span class="string">""</span>, i, clvector[i], ((<span class="keyword">float</span>)clvector[i]/ht-&gt;size)*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调试函数，输出字典的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictPrintStats</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    _dictPrintStatsHt(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-- Rehashing into ht[1]:\n"</span>);</span><br><span class="line">        _dictPrintStatsHt(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制是否允许resize</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following are just example hash table types implementations.</span></span><br><span class="line"><span class="comment"> * Not useful for Redis so they are commented out.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//作者的样例代码</span></span><br><span class="line"><span class="comment">/* ----------------------- StringCopy Hash Table Type ------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> _dictStringCopyHTHashFunction(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenHashFunction(key, <span class="built_in">strlen</span>(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_dictStringDup(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="keyword">char</span> *copy = zmalloc(len+<span class="number">1</span>);</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(copy, key, len);</span><br><span class="line">    copy[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictStringCopyHTKeyCompare(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *key2)</span><br><span class="line">&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(key1, key2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictStringDestructor(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    zfree(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictType dictTypeHeapStringCopyKey = &#123;</span><br><span class="line">    _dictStringCopyHTHashFunction, <span class="comment">/* hash function */</span></span><br><span class="line">    _dictStringDup,                <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* val dup */</span></span><br><span class="line">    _dictStringCopyHTKeyCompare,   <span class="comment">/* key compare */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                           <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is like StringCopy but does not auto-duplicate the key.</span></span><br><span class="line"><span class="comment"> * It's used for intepreter's shared strings. */</span></span><br><span class="line">dictType dictTypeHeapStrings = &#123;</span><br><span class="line">    _dictStringCopyHTHashFunction, <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* val dup */</span></span><br><span class="line">    _dictStringCopyHTKeyCompare,   <span class="comment">/* key compare */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                           <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is like StringCopy but also automatically handle dynamic</span></span><br><span class="line"><span class="comment"> * allocated C strings as values. */</span></span><br><span class="line">dictType dictTypeHeapStringCopyKeyValue = &#123;</span><br><span class="line">    _dictStringCopyHTHashFunction, <span class="comment">/* hash function */</span></span><br><span class="line">    _dictStringDup,                <span class="comment">/* key dup */</span></span><br><span class="line">    _dictStringDup,                <span class="comment">/* val dup */</span></span><br><span class="line">    _dictStringCopyHTKeyCompare,   <span class="comment">/* key compare */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<h2 id="2-5-跳跃表"><a href="#2-5-跳跃表" class="headerlink" title="2.5 跳跃表"></a>2.5 跳跃表</h2><h3 id="redis-h-跳跃表相关部分）"><a href="#redis-h-跳跃表相关部分）" class="headerlink" title="redis.h(跳跃表相关部分）"></a>redis.h(跳跃表相关部分）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳跃表就是给有序list添加多级索引，能够以更大的步长遍历list，提高查找效率，属于空间换时间。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32 <span class="comment">/* Should be enough for 2^32 elements */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//跳跃表的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//节点真正存储的数据，类型是redis定义的对象，也是在redis.h中定义的</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">//分值。在跳跃表中，节点按各自所保存的分值从小到大排列</span></span><br><span class="line">    <span class="comment">//跳跃表中各个节点保存的对象必须是唯一的，但多个节点的分值可以是相同的，分值相同的节点将按照对象在字典序中的大小来进行排序</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//后退指针，用于从表尾向表头遍历</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//节点所在层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">//前进指针，用于从表头向表尾遍历</span></span><br><span class="line">        <span class="comment">//一个节点有多个不同跨度的前进指针，但只有一个后退指针，所以只有正向遍历是跳跃的，反向遍历只能退到前一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度(步长)，记录了前进指针所指向的节点到当前节点的距离。因为是有跨度的遍历，所以遍历到某个节点后，将沿途所有经过的节点的跨度相加，就是该节点在跳跃表中的次序(rank)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳跃表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量,表头节点不计算在内，因为头结点只存储层次不存储数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数,表头节点的层数不计算在内</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sorted sets data type */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span></span>;</span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="t-zset-c-跳跃表相关部分"><a href="#t-zset-c-跳跃表相关部分" class="headerlink" title="t_zset.c(跳跃表相关部分)"></a>t_zset.c(跳跃表相关部分)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建跳跃表的节点。设置存储对象和分值，level参数只用于申请空间，level数组并没有初始化</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;obj = obj;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建跳跃表</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">//初始化最高层数是1，不考虑头结点</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//初始节点数0</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//头结点的层数设成上限，分值是0(最小)，存储的对象是NULL。每层初始化前进指针和跨度</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点，这里不用考虑表的链接，因为只有两种情况会释放节点，一个是要释放整个表，链接自然就不用管了，另一个是先删除节点再释放节点，删除节点的函数中已经调整好链接了，这里就不用管了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFreeNode</span><span class="params">(zskiplistNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//节点存储的对象的引用计数减一，在object.c中定义的</span></span><br><span class="line">    decrRefCount(node-&gt;obj);</span><br><span class="line">    <span class="comment">//释放节点指针</span></span><br><span class="line">    zfree(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放跳跃表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next;</span><br><span class="line">    <span class="comment">//先释放头结点</span></span><br><span class="line">    zfree(zsl-&gt;header);</span><br><span class="line">    <span class="comment">//沿着第0层遍历节点并释放，因为第0层的跨度是1，就等于按顺序遍历全部节点</span></span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslFreeNode(node);</span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后释放表的指针</span></span><br><span class="line">    zfree(zsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个介于1和ZSKIPLIST_MAXLEVEL之间的随机值，作为节点的层数</span></span><br><span class="line"><span class="comment">//根据幂次定律(power law)，越大的层数产生的几率就越小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//random返回一个long int范围内的随机整数，random()&amp;0xFFFF的结果就是一个0到65535的随机整数</span></span><br><span class="line">    <span class="comment">//ZSKIPLIST_P=0.25，每次level只有1/4的概率加一，所以结果就是越大的数越难得到</span></span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定分值和存储对象，创建新节点并插入跳跃表，返回该节点指针</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//update数组存放寻找新节点位置的过程中经过的节点</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">//rank数组存放寻找新节点位置的过程中经过的节点的跨度累加和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line">    <span class="comment">//从头节点正向遍历</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//从高层到低层遍历，相当于先查高层索引再查低层索引，步子迈得越来越小，最后定位到新节点应该存放的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        <span class="comment">//遍历过程中记录的跨度是累加和，不是单个节点的跨度</span></span><br><span class="line">        <span class="comment">//因为i是从大到小，所以最终的跨度和是存在rank[0]里，所以这里是先把上一层的rank值继承下来</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//因为跳跃表从小到大排序，所以要找到当前层第一个分值大于新节点，或者分值相同但字典序大于新节点的节点，此时退出循环，x就是本层中新节点的左侧邻居节点。但新节点插入的位置必须精确到真正相邻的两个节点之间，而高层里相邻的节点跨度可能大于1，并不是真正相邻，所以要进入下一层继续精确新节点的左邻居，直到新节点的左右邻居跨度是1，新节点只能插入这个唯一的间隙中，才算真正确定了插入位置。</span></span><br><span class="line">        <span class="comment">//只有在没找到本层的左邻居时，rank值才会增加，所以rank[i]并不包括update[i]的跨度，所以rank[i]代表的是找到左邻居的过程中在本层遍历的总距离。又因为在当前层一定是从上一层左邻居的位置开始向右遍历，所以最后累加得到的rank[0]就是从头节点到新节点真正左邻居的距离。</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="comment">//继承下来的rank值加上当前节点的rank值</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录新节点在第i层的左邻居</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the key is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, and the re-insertion of score and redis object should never</span></span><br><span class="line"><span class="comment">     * happpen since the caller of zslInsert() should test in the hash table</span></span><br><span class="line"><span class="comment">     * if the element is already inside or not. */</span></span><br><span class="line">    <span class="comment">//新节点的最高层数是随机的</span></span><br><span class="line">    <span class="comment">//为什么不把索引设成固定间隔的？随机的会不会性能不太好？</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">//如果新节点的最高层比整个表的最高层(不包括头节点)低，那么新节点最高层以上的层次就不用关心了</span></span><br><span class="line">    <span class="comment">//反之，如果新节点最高层创了新高，就需要多做一些修改</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//因为是前所未有的新高层，所以左邻居只能是头节点</span></span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            <span class="comment">//头节点的跨度为什么是节点数？不应该是rank[0]吗？</span></span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新跳跃表的最高层数</span></span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新节点</span></span><br><span class="line">    x = zslCreateNode(level,score,obj);</span><br><span class="line">    <span class="comment">//与每一层的左右邻居做链接</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">//插入以后，原本是新节点左邻居的右邻居就成了新节点的右邻居，用前进指针链接</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">//新节点x就成了他左邻居的右邻居，用前进指针链接</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        <span class="comment">//update[i]-&gt;level[i].span是第i层中左邻居到右邻居的跨度，rank[0]-rank[i]是第i层左邻居到第0层左邻居的距离，所以二者相减得到的是第0层左邻居到第i层右邻居的跨度。新节点插入后，新节点到第i层右邻居的跨度就等于原本第0层左邻居到第i层右邻居的跨度。</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        <span class="comment">//左邻居的跨度要改成左邻居到新节点的距离</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="comment">//新节点最高层以上的层次找到的也都是左邻居，所以新节点插入后它们的跨度都加一</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后退指针指向左邻居，后退指针只和第0层有关，所以不用循环</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//如果新节点有右邻居，就把右邻居的后退指针指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果没有右邻居，自然就成了尾结点</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    <span class="comment">//跳跃表节点数加一</span></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></span><br><span class="line"><span class="comment">//删除节点x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//遍历update每一层的节点，一定是x左边的节点，但不一定是左邻居，因为x的最高层数可能低于i</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="comment">//如果是左邻居，就要继承x的跨度，前进指针指向x的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">//如果不是左邻居，只是跨度减一</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果x有右邻居，就把右邻居的后退指针指向x的左邻居</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    <span class="comment">//如果没有右邻居，x就是尾结点，重新设置尾结点就行了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果删掉的节点是最高的，就需要重新设置跳跃表的最高层数</span></span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">    <span class="comment">//节点数减一</span></span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete an element with matching score/object from the skiplist. */</span></span><br><span class="line"><span class="comment">//删除跳跃表中包含给定对象和分值的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//和插入节点的逻辑一样，根据分值从高层到底层找左邻居，记录左邻居是为了删除节点后调整指针链接</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="comment">//找到分值相同的节点之后，再找存储的对象是obj的节点</span></span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</span><br><span class="line">        <span class="comment">//先删除再释放节点</span></span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec. */</span></span><br><span class="line"><span class="comment">//分值范围</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//最小值和最大值</span></span><br><span class="line">    <span class="keyword">double</span> min, max;</span><br><span class="line">    <span class="comment">//最小值和最大值是否包含在本范围里，表示区间开闭</span></span><br><span class="line">    <span class="comment">//ex是exclusive的意思，所以0表示包含(闭区间)，1表示不包含(开区间)</span></span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zrangespec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete all the elements with score between min and max from the skiplist.</span></span><br><span class="line"><span class="comment"> * Min and mx are inclusive, so a score &gt;= min || score &lt;= max is deleted.</span></span><br><span class="line"><span class="comment"> * Note that this function takes the reference to the hash table view of the</span></span><br><span class="line"><span class="comment"> * sorted set, in order to remove the elements from the hash table too. */</span></span><br><span class="line"><span class="comment">//给定一个分值范围，删除跳跃表中所有在这个范围之内的节点，同时也在字典中删除该节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslDeleteRangeByScore</span><span class="params">(zskiplist *zsl, zrangespec range, dict *dict)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//找到分值范围的左邻居</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (range.minex ?</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt;= range.min :</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt; range.min))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Current node is the last with score &lt; or &lt;= min. */</span></span><br><span class="line">    <span class="comment">//在第0层非跳跃地遍历节点</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete nodes while in range. */</span></span><br><span class="line">    <span class="comment">//在跳跃表和字典中删除节点，最后释放该节点</span></span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; (range.maxex ? x-&gt;score &lt; range.max : x-&gt;score &lt;= range.max)) &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回删除的节点数</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete all the elements with rank between start and end from the skiplist.</span></span><br><span class="line"><span class="comment"> * Start and end are inclusive. Note that start and end need to be 1-based */</span></span><br><span class="line"><span class="comment">//给定一个排序范围，删除跳跃表中所有在这个范围之内的节点</span></span><br><span class="line"><span class="comment">//大体逻辑同zslDeleteRangeByScore，最后也是返回删除的节点数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslDeleteRangeByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">int</span> start, <span class="keyword">unsigned</span> <span class="keyword">int</span> end, dict *dict)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>, removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt; start) &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traversed++;</span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; traversed &lt;= end) &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        traversed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the first node having a score equal or greater than the specified one.</span></span><br><span class="line"><span class="comment"> * Returns NULL if there is no match. */</span></span><br><span class="line"><span class="comment">//获取第一个分值不小于给定分值的节点</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslFirstWithScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//直接从高层到低层找，不用记录左邻居了。最后找到第0层，得到的就是真正的左邻居</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; x-&gt;level[i].forward-&gt;score &lt; score)</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    <span class="comment">//返回左邻居的下个节点</span></span><br><span class="line">    <span class="keyword">return</span> x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the rank for an element by both score and key.</span></span><br><span class="line"><span class="comment"> * Returns 0 when the element cannot be found, rank otherwise.</span></span><br><span class="line"><span class="comment"> * Note that the rank is 1-based due to the span of zsl-&gt;header to the</span></span><br><span class="line"><span class="comment"> * first element. */</span></span><br><span class="line"><span class="comment">//返回包含给定对象和分值的节点在跳跃表中的排序</span></span><br><span class="line"><span class="comment">//和zslInsert中一样，从高层到低层遍历，通过累加途径节点的跨度来得到节点在表中的rank值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//和</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></span><br><span class="line"><span class="comment">//返回跳跃表在给定排序上的节点</span></span><br><span class="line"><span class="comment">//从高层到底层遍历，记录节点的rank值，每当下个节点的rank值高于给定的rank，就跳到下一层继续遍历，因为到了下一层右邻居会更左</span></span><br><span class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Populate the rangespec according to the objects min and max. */</span></span><br><span class="line"><span class="comment">//把spec的左右边界设成min和max</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zslParseRange</span><span class="params">(robj *min, robj *max, zrangespec *spec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line">    <span class="comment">//初始默认是闭区间</span></span><br><span class="line">    spec-&gt;minex = spec-&gt;maxex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the min-max interval. If one of the values is prefixed</span></span><br><span class="line"><span class="comment">     * by the "(" character, it's considered "open". For instance</span></span><br><span class="line"><span class="comment">     * ZRANGEBYSCORE zset (1.5 (2.5 will match min &lt; x &lt; max</span></span><br><span class="line"><span class="comment">     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min &lt;= x &lt;= max */</span></span><br><span class="line">    <span class="comment">//对象的ptr指针指向底层的数据结构</span></span><br><span class="line">    <span class="comment">//如果对象的数据结构是整型，直接赋给spec，也是默认闭区间</span></span><br><span class="line">    <span class="keyword">if</span> (min-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        spec-&gt;min = (<span class="keyword">long</span>)min-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是整型，对象就是用字符串表示的数</span></span><br><span class="line">        <span class="comment">//字符串以'('开头表示开区间</span></span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">char</span>*)min-&gt;ptr)[<span class="number">0</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="comment">//strtod将ptr指向的字符串转换成浮点数，如果发生错误就让eptr指针指向出错的字符</span></span><br><span class="line">            spec-&gt;min = strtod((<span class="keyword">char</span>*)min-&gt;ptr+<span class="number">1</span>,&amp;eptr);</span><br><span class="line">            <span class="comment">//如果转换出错了，返回错误码</span></span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;min)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            <span class="comment">//开区间的exclusive是1</span></span><br><span class="line">            spec-&gt;minex = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            spec-&gt;min = strtod((<span class="keyword">char</span>*)min-&gt;ptr,&amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;min)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右边界设置同上</span></span><br><span class="line">    <span class="keyword">if</span> (max-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        spec-&gt;max = (<span class="keyword">long</span>)max-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">char</span>*)max-&gt;ptr)[<span class="number">0</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">            spec-&gt;max = strtod((<span class="keyword">char</span>*)max-&gt;ptr+<span class="number">1</span>,&amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;max)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            spec-&gt;maxex = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            spec-&gt;max = strtod((<span class="keyword">char</span>*)max-&gt;ptr,&amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;max)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置成功，返回成功码</span></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="3-内存编码结构相关"><a href="#3-内存编码结构相关" class="headerlink" title="3 内存编码结构相关"></a>3 内存编码结构相关</h1><h2 id="3-1-整数集合数据结构"><a href="#3-1-整数集合数据结构" class="headerlink" title="3.1 整数集合数据结构"></a>3.1 整数集合数据结构</h2><h3 id="intset-h"><a href="#intset-h" class="headerlink" title="intset.h"></a>intset.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __INTSET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INTSET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式，包括int16_t、int32_t和int64_t</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合中元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//存储元素的有序数组，要实现的集合是无序的，但底层的数组是有序的</span></span><br><span class="line">    <span class="comment">//虽然contents属性声明为int8_t类型的数组，但实际上contents数组的真正类型取决于encoding属性的值</span></span><br><span class="line">    <span class="comment">//由于contents所有元素的类型要一致，因此contents的类型是由其中最大的数决定的</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span></span>;</span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span></span>;</span><br><span class="line"><span class="keyword">uint8_t</span> intsetFind(intset *is, <span class="keyword">int64_t</span> value);</span><br><span class="line"><span class="keyword">int64_t</span> intsetRandom(intset *is);</span><br><span class="line"><span class="keyword">uint8_t</span> intsetGet(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value);</span><br><span class="line"><span class="keyword">uint32_t</span> intsetLen(intset *is);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __INTSET_H</span></span></span><br></pre></td></tr></table></figure></div>
<h3 id="intset-c"><a href="#intset-c" class="headerlink" title="intset.c"></a>intset.c</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"intset.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="comment">//int的编码方式</span></span><br><span class="line"><span class="comment">//int16_t，2bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="comment">//int32_t，4bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="comment">//int64_t，8bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the required encoding for the provided value. */</span></span><br><span class="line"><span class="comment">//根据给定数的大小，返回满足需求又最省空间的int类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at pos, given an encoding. */</span></span><br><span class="line"><span class="comment">//得到enc编码方式下的第pos个位置的值</span></span><br><span class="line"><span class="comment">//因为呈现给用户的intset是无序的，所以能访问底层数组contents的函数必须是声明为static的内部函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGetEncoded(intset *is, <span class="keyword">int</span> pos, <span class="keyword">uint8_t</span> enc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enc == INTSET_ENC_INT64)</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (enc == INTSET_ENC_INT32)</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="comment">//得到is中第pos个位置的值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGet(intset *is, <span class="keyword">int</span> pos) &#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGetEncoded(is,pos,is-&gt;encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="comment">//把集合is第pos个位置的值设为value</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT64)</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT32)</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an empty intset. */</span></span><br><span class="line"><span class="comment">//创建空的整数集合</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    <span class="comment">//默认使用int16_t，只支持升级，不支持降级</span></span><br><span class="line">    is-&gt;encoding = INTSET_ENC_INT16;</span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the intset */</span></span><br><span class="line"><span class="comment">//因为结构体的内存空间是连续的，所以添加新元素之前要先扩容，删除元素之后要收缩。len是新的元素总数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//is-&gt;encoding就是表示一个整数需要的bit数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*is-&gt;encoding;</span><br><span class="line">    <span class="comment">//需要的空间是结构体大小加所有元素需要的大小</span></span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search for the position of "value". Return 1 when the value was found and</span></span><br><span class="line"><span class="comment"> * sets "pos" to the position of the value within the intset. Return 0 when</span></span><br><span class="line"><span class="comment"> * the value is not present in the intset and sets "pos" to the position</span></span><br><span class="line"><span class="comment"> * where "value" can be inserted. */</span></span><br><span class="line"><span class="comment">//在集合的有序数组中查询给定的value，如果找到，把索引赋给pos，如果找不到，把value能插入的位置赋给pos</span></span><br><span class="line"><span class="comment">//返回1表示找到了，返回0表示没找到</span></span><br><span class="line"><span class="comment">//采用二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = is-&gt;length<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="comment">//集合是空的，直接返回0，pos=0表示value可以直接插在数组头部</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="comment">//因为数组是有序的，所以先和数组收尾比较，如果value小于左边界或大于右边界，就说明不在数组中，pos设置为数组的头或尾</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,is-&gt;length<span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = is-&gt;length;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找，cur记录的是数组中mid索引的值</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = (min+max)/<span class="number">2</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出上面循环的一种情况是value==cur，pos设为cur的索引mid</span></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//另一种情况是max&lt;min，此时value的插入位置就是新的min(想一想就知道)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="comment">//升级is的编码(int类型)，并插入新的value</span></span><br><span class="line"><span class="comment">//因为调用该函数的条件是value超过了is支持的表示范围，所以编码要先升级，而且value一定是插在数组头或尾</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = is-&gt;encoding;</span><br><span class="line">    <span class="comment">//选择刚好适合新元素value的int类型</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">int</span> length = is-&gt;length;</span><br><span class="line">    <span class="comment">//负数插在数组头，正数插在数组尾</span></span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    <span class="comment">//修改is的encoding，再为新元素扩容</span></span><br><span class="line">    is-&gt;encoding = newenc;</span><br><span class="line">    is = intsetResize(is,is-&gt;length+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don't overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the "prepend" variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="comment">//在扩容以后的数组中</span></span><br><span class="line">    <span class="comment">//如果value是负数，就从后到前把每个元素插到它后面的位置，最后空出数组头来存放value</span></span><br><span class="line">    <span class="comment">//如果value是正数，就从后到前把每个元素插到它当前的位置，相当于啥也没干，最后空出数组尾来存放value</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="comment">//负数插在数组头，正数插在数组尾</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,is-&gt;length,value);</span><br><span class="line">    <span class="comment">//元素数量加一</span></span><br><span class="line">    is-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把集合中从from位置开始的所有元素移动到从to位置开始</span></span><br><span class="line"><span class="comment">//memmove比memcpy更安全。如果目标区域和源区域有重叠的话，memmove能够保证被覆盖之前将重叠区域的字节拷贝到目标区域中</span></span><br><span class="line"><span class="comment">//使用memmove要设定移动的长度，所以要分别考虑三种不同长度的int类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="comment">//bytes是from之后的总元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = is-&gt;length-from;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        <span class="comment">//元素数量乘以单个元素占用的空间就是要移动的内存长度</span></span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="keyword">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="keyword">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line"><span class="comment">//向集合is中插入value</span></span><br><span class="line"><span class="comment">//success只是个flag，大概只有测试的时候用得到</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询适合value的int类型</span></span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="comment">//初始默认插入成功</span></span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="comment">//适合value的int长度比is支持的要长，就要先扩容再添加，而且超出规格说明value本来也不在is中</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; is-&gt;encoding) &#123;</span><br><span class="line">        <span class="comment">/* This always succeeds, so we don't need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate "pos" with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="comment">//如果value已经在is中了，集合元素不能重复，success设为0表示插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先给新元素扩容</span></span><br><span class="line">        is = intsetResize(is,is-&gt;length+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//之前调用intsetSearch时，已经把应该插入的位置赋给了pos</span></span><br><span class="line">        <span class="comment">//插入前要把pos之后的全部元素后移一位</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; is-&gt;length) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在pos处插入新元素</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete integer from intset */</span></span><br><span class="line"><span class="comment">//从is中移除元素value</span></span><br><span class="line"><span class="comment">//和intsetAdd的基本逻辑相同</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valenc &lt;= is-&gt;encoding &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">        <span class="comment">/* We know we can delete */</span></span><br><span class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Overwrite value with tail and update length */</span></span><br><span class="line">        <span class="comment">//删除pos位置的元素，就是把pos+1之后的元素都前移一位</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; (is-&gt;length<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</span><br><span class="line">        <span class="comment">//数组长度收缩一位</span></span><br><span class="line">        is = intsetResize(is,is-&gt;length<span class="number">-1</span>);</span><br><span class="line">        is-&gt;length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine whether a value belongs to this set */</span></span><br><span class="line"><span class="comment">//查询value是否在集合is中</span></span><br><span class="line"><span class="comment">//intsetSearch函数里是直接查，但是实际情况中要先判断value是否超出了集合支持的int类型的表示范围</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetFind(intset *is, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= is-&gt;encoding &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return random member */</span></span><br><span class="line"><span class="comment">//随机返回集合中一个元素</span></span><br><span class="line"><span class="keyword">int64_t</span> intsetRandom(intset *is) &#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGet(is,rand()%is-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sets the value to the value at the given position. When this position is</span></span><br><span class="line"><span class="comment"> * out of range the function returns 0, when in range it returns 1. */</span></span><br><span class="line"><span class="comment">//获取pos位置上的元素</span></span><br><span class="line"><span class="comment">//仅仅是在_intsetGet之前判断了pos索引是否越界，没必要单独写成一个函数</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetGet(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; is-&gt;length) &#123;</span><br><span class="line">        *value = _intsetGet(is,pos);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return intset length */</span></span><br><span class="line"><span class="comment">//返回集合的元素总数</span></span><br><span class="line"><span class="keyword">uint32_t</span> intsetLen(intset *is) &#123;</span><br><span class="line">    <span class="keyword">return</span> is-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面是测试代码，略</span></span><br></pre></td></tr></table></figure></div>
<h2 id="3-2-压缩列表"><a href="#3-2-压缩列表" class="headerlink" title="3.2 压缩列表"></a>3.2 压缩列表</h2><h3 id="ziplist-h"><a href="#ziplist-h" class="headerlink" title="ziplist.h"></a>ziplist.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistIndex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **sval, <span class="keyword">unsigned</span> <span class="keyword">int</span> *slen, <span class="keyword">long</span> <span class="keyword">long</span> *lval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDeleteRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistCompare</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistSize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="ziplist-c"><a href="#ziplist-c" class="headerlink" title="ziplist.c"></a>ziplist.c</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h1 id="4-数据类型相关"><a href="#4-数据类型相关" class="headerlink" title="4 数据类型相关"></a>4 数据类型相关</h1><h1 id="5-单机数据库相关"><a href="#5-单机数据库相关" class="headerlink" title="5 单机数据库相关"></a>5 单机数据库相关</h1><h1 id="6-客户端和服务器端相关"><a href="#6-客户端和服务器端相关" class="headerlink" title="6 客户端和服务器端相关"></a>6 客户端和服务器端相关</h1><h1 id="7-多机数据库相关"><a href="#7-多机数据库相关" class="headerlink" title="7 多机数据库相关"></a>7 多机数据库相关</h1><h1 id="8-测试类文件"><a href="#8-测试类文件" class="headerlink" title="8 测试类文件"></a>8 测试类文件</h1><h3 id="testhelp-h"><a href="#testhelp-h" class="headerlink" title="testhelp.h"></a>testhelp.h</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a really minimal testing framework for C.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * test_cond("Check if 1 == 1", 1==1)</span></span><br><span class="line"><span class="comment"> * test_cond("Check if 5 &gt; 10", 5 &gt; 10)</span></span><br><span class="line"><span class="comment"> * test_report()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TESTHELP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TESTHELP_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试失败次数</span></span><br><span class="line"><span class="keyword">int</span> __failed_tests = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//测试总次数</span></span><br><span class="line"><span class="keyword">int</span> __test_num = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_cond(descr,_c) do &#123; \</span></span><br><span class="line">    <span class="comment">//测试次数加一，先输出描述信息</span></span><br><span class="line">    __test_num++; <span class="built_in">printf</span>(<span class="string">"%d - %s: "</span>, __test_num, descr); \</span><br><span class="line">    <span class="comment">//执行_c表示的表达式，输出成功或失败提示</span></span><br><span class="line">    <span class="keyword">if</span>(_c) <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>); <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">"FAILED\n"</span>); __failed_tests++;&#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试报告</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_report() do &#123; \</span></span><br><span class="line">    <span class="comment">//输出测试总次数，成功次数和失败次数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d tests, %d passed, %d failed\n"</span>, __test_num, \</span><br><span class="line">                    __test_num-__failed_tests, __failed_tests); \</span><br><span class="line">    <span class="comment">//如果有失败的样例就报warning</span></span><br><span class="line">    <span class="keyword">if</span> (__failed_tests) &#123; \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"=== WARNING === We have failed tests here...\n"</span>); \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<h1 id="9-工具类文件"><a href="#9-工具类文件" class="headerlink" title="9 工具类文件"></a>9 工具类文件</h1><h1 id="10-封装类文件"><a href="#10-封装类文件" class="headerlink" title="10 封装类文件"></a>10 封装类文件</h1></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:wkx1996@foxmail.com">w.k.x.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://shivakasu.github.io/2020/06/20/redis0/">http://shivakasu.github.io/2020/06/20/redis0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://shivakasu.github.io">SHIVAKASU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis    </a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库    </a></div><div class="post_share"><div class="social-share" data-image="http://file.shivakasu.cn/21c5b06bdbaf2dd7ebf7/redis.png" data-sites="facebook,twitter,wechat,weibo,qq,qzone,douban,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="http://file.shivakasu.cn/4a84dcfb31806db98b2a/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="http://file.shivakasu.cn/982f781ef31cbc46968b/alipay.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/06/14/haskell0/"><img class="next_cover lazyload" data-src="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Haskell Programming From First Principles notes (更新中)</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'qIfwEiuSjlc5vyminB1rx2qX-gzGzoHsz',
  appKey:'erfVXuW3AybzbWGqxSGxnBRp',
  placeholder:'来都来了，说点儿什么吧~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By w.k.x.</div><div class="framework-info"><span>driven by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>京ICP备19001969号-1</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>