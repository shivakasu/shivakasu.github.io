<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHIVAKASU</title>
  <icon>https://www.gravatar.com/avatar/db3726c77acefe0355d29843a28e9ca4</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shivakasu.cn/"/>
  <updated>2020-07-05T15:34:20.000Z</updated>
  <id>https://shivakasu.cn/</id>
  
  <author>
    <name>w.k.x.</name>
    <email>wkx1996@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>叶秀山版《西方哲学史》笔记之第二卷：古希腊罗马哲学</title>
    <link href="https://shivakasu.cn/2020/06/29/phi4/"/>
    <id>https://shivakasu.cn/2020/06/29/phi4/</id>
    <published>2020-06-28T16:28:20.000Z</published>
    <updated>2020-07-05T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><ul><li>古希腊罗马哲学，始于公元前6世纪初的早期希腊哲学，终于公元529年，东罗马帝国皇帝查士丁尼关闭雅典的柏拉图学园标志着古希腊罗马哲学的终结。</li><li>西欧古典文明，是古希腊罗马哲学赖以发展的社会和文化基础，也是西方文化的一大源泉。西欧古典文明发端于公元前2000年的克里特文明，崛起于古埃及文明和两河流域文明之后，终结于公元476年西罗马帝国灭亡。西欧古典文明划分为爱琴文明、希腊古典文明、希腊化文明和罗马文明这四个阶段。</li><li>西欧古典文明最早起源于爱琴海地区，在爱琴文明中，各部落历经动荡和曲折，终于形成了后来作为希腊哲学主体的希腊民族，发展出城邦奴隶制文明，也产生了萌发哲学思想的希腊神话，所以爱琴文明是希腊民族与希腊文化的摇篮。</li><li>希腊古典文明时期，始于公元前6世纪初，终于公元前4世纪30年代，是西欧古典文明奠立根基和全面鼎盛的时代，也是希腊哲学产生并发展至全盛的时代。雅典民主制的确立使其称为希腊古典文明的中心，希波战争的胜利也使得早期希腊哲学向希腊本土转移而趋于兴盛，所以早期希腊哲学是科学启蒙与民主精神的产物。而后在伯利克里时期，民主政治的革新提供了较大的科学文化自由，希腊古典哲学与文化空前繁荣。希腊古典文明由盛转衰的转折点是伯罗奔尼撒战争的失败，这场战争激化了希腊城邦奴隶制的各种内在矛盾，造成了全希腊的政治秩序、精神生活与道德价值陷入极大的混乱与危机。最终，直到亚历山大大帝征服希腊和亚里士多德去世，才标志着希腊古典文明终结并进入希腊化文明。</li><li>随着城邦奴隶制的内部矛盾愈益严重，小国寡民、分散自治的城邦奴隶制转向帝国型统一集权的大规模奴隶制已成为必然。而由于希腊本土城邦已经衰弱枯竭，所以只能依靠外部力量的征服来推动希腊本土的转型。于是，藉由亚历山大征服希腊，开启了近300年的希腊化文明时代。</li><li>“希腊化”原意是指随着亚历山大东征，大批希腊人流向东方取得统治地位，并将希腊文化播撒到广大的东方世界，同时，与东方文明的交流也深刻影响了希腊文化，由此演变为一种融合希腊古典文化与东方文化的多民族、多元化的新型文明。这场文化大融合影响深远，一方面影响了东方原本的传统文化，为后世伊斯兰阿拉伯文化吸纳希腊文化提供了历史准备，另一方面也让希腊文化与犹太教的希伯来文化相结合，为基督教神学的诞生作了早期铺垫。</li><li>随着帝国型奴隶制的内在矛盾日益凸显，三大王国腐败衰弱，最终被罗马人征服。罗马帝国的崛起，终结了希腊化时代，希腊文化却逐渐融入了罗马文明，被罗马人延续并传播下去。而到了罗马文明后期，由于贵族奴隶制所导致的腐败，罗马帝国也不可避免地衰败下去，最终无力抵御蛮族入侵，走向了灭亡。</li><li>远古的希腊人由于认识能力的局限，还不能用科学的思维方式理解自然力与人类自身，主要采用神话的形象思维方式去解释世界。希腊神话有两种演变途径，一是通向因对自然力与支配人类命运的力量的恐惧无知而发生的宗教，被吸纳为古希腊宗教思想的主要组成部分，二是在形象地解释世界中孕育了哲学思想，成为产生古希腊哲学的温床。</li></ul><h1 id="上篇-早期希腊哲学"><a href="#上篇-早期希腊哲学" class="headerlink" title="上篇 早期希腊哲学"></a>上篇 早期希腊哲学</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>早期希腊哲学发生在希腊古典文明的前期，是在希腊城邦奴隶制基本确立并趋向成熟的历史背景中产生与发展的。</li><li>亚里士多德认为，人们研究哲学的起因是诧异，希腊哲学产生的必要社会条件与动因是人们的闲暇与求知。希波战争的胜利促进了奴隶制商品经济的发展，为人们探究无功利性的哲学提供了闲暇的保证，加之人们对天地万物、宇宙奥秘的诧异与探究，使一种超越了实用技术的科学思想产生出来，它促使孕育于希腊神话与宗教中的哲学思想脱胎而出，独立形成一种与科学思想融为一体又涵括全部知识的自由的学问。</li><li>早期希腊哲学的一个显著特征是哲学与科学思想相辅相成、互动互渗。一方面，科学思想令原始哲学思维摆脱了与宗教、神话相关的神秘主义色彩。另一方面，希腊哲学不局限于对自然表面现象的简单解释和功利性的实用技术层面，开创了以科学理性探索自然奥秘的风气，促使希腊早期的科学思想逐步深化。正是由于早期希腊哲学重点探究自然万物的本原，与自然科学思想水乳交融，所以也被称早期自然哲学。</li><li>早期希腊哲学有两条主要线索，一是伊奥尼亚哲学，包括米利都学派和爱菲斯学派，二是南意大利哲学，包括毕达哥拉斯学派和爱利亚学派。后来的恩培多克勒、阿那克萨戈拉、德谟克利特等人的学说都是对这两种哲学传统的综合，而不仅仅是对某一条路线的延伸。</li><li>早期希腊哲学的中心主题是“本原”。伊奥尼亚哲学传统注重对生灭变动的自然的观察经验作哲学概括，比如直观的水火土气，南意大利哲学传统则注重对世界全体的数理结构与本质作形而上的思辨，比如高度抽象的“数”和“一”。后来的哲学家综合了这两种传统，主张微观的物质性基本粒子是万物的本原，克服了前两种哲学中现象世界和本质世界的对立，将本原论提高到一个崭新的水平。</li><li>早期希腊哲学的另一个重要主题是宇宙论问题，即宇宙的生成、演化与结构问题。早先的哲学家简单地用某种具体物质本原的物态变化来说明宇宙与天体的生成，朴素而直观。随着科学思想的进步，形成了两种对近现代西方宇宙学说有深远影响的理论，一是有限宇宙与天体结构说，有数理天文学思想萌芽的特色，二是漩涡运动起源说。</li></ul><h2 id="1-米利都学派"><a href="#1-米利都学派" class="headerlink" title="1 米利都学派"></a>1 米利都学派</h2><ul><li>希腊哲学最早开创于米利都，泰勒斯、阿那克西曼德和阿那克西米尼三代传人是希腊最早的哲学家。米利都学派开创了伊奥尼亚哲学传统，包含着一种朴素的唯物论思想。</li></ul><h3 id="1-1-泰勒斯"><a href="#1-1-泰勒斯" class="headerlink" title="1.1 泰勒斯"></a>1.1 泰勒斯</h3><ul><li>泰勒斯没有留下任何著述，只有极少的第二手转述资料。亚里士多德最早指出了泰勒斯的本原论主张，认为泰勒斯是哲学的创始人。自亚里士多德之后，学界公认泰勒斯是第一位哲学家。</li><li>关于泰勒斯的生卒年没有可靠记载，但是他曾准确预言过一次日食，把那年作为他的鼎盛年，可以大致推算出他的生卒年代。</li><li>泰勒斯名列“七贤”之一，不仅在经济事务和政治活动中比较活跃，还是“七贤”中唯一一位懂得自然哲学、追求科学智慧的学者，主要在数学和天文学领域取得了杰出成就。他向埃及人学过几何学，但没有局限在描述经验上，而是高度概括出了五条几何定理。他热衷于观测天文现象，总结了许多天体运行的规律。</li><li>亚里士多德在《形而上学》中说：“在第一批哲学家中间，大多数认为质料性的本原是所有事物的唯一本原”。泰勒斯就是这一派哲学的创始人，他最先用哲学语言提出了“水是本原”这一基本命题，标志着早期希腊自然哲学已从神话世界观脱胎而出，开始用科学的理性思维来理解自然世界。</li><li>关于泰勒斯为什么认为水是本原，古代学者有两种解释。一是生物学的解释，据亚里士多德推测，泰勒斯正是观察到所有事物的滋养物都是潮湿的，同时主张物活论的泰勒斯认为万物都有来源于热的一种灵魂或活力，所以水作为湿气与热的共同来源就会被认为是万物本原。二是天文、气象学的解释，艾修斯认为，水在自然中的物态变化会让人误以为它是最容易变化、最有活力的一种元素，泰勒斯对水的理解可能就是如此朴素。</li><li>泰勒斯的本原论是一种原始、自发的朴素唯物论观点。伊奥尼亚的哲学家们都将世界的本原归结为某种特殊的物质，是因为他们还没有形成普遍物质的概念，所以也更不可能高度抽象出“一”、“存在”这样的概念。</li><li>泰勒斯也是最早研究宇宙论或宇宙生成的哲学家，基于他的本原论，他认为宇宙与天体是由水生成的，主张一种水成论的宇宙观。太阳与星辰的“火”并非是水的对立面，而是水蒸气的精致部分燃成以太的结果。由于希腊人所处的大地被海洋包围，所以泰勒斯也自然而然地以为大地是浮在水上的。泰勒斯的宇宙观虽然很幼稚，但是意义在于突破了神创宇宙观，开启了一种自然哲学的宇宙论研究。</li><li>泰勒斯还提出了一种“物活论”的思想，认为万物皆有灵魂与神灵。但他所谓的灵魂与神灵并不是某种精神实体或是具有神话色彩的神，只不过是对宇宙万物中蕴含的生命力、活力的一种模糊的表达，毕竟他认为磁石的相互吸引也是灵魂在起作用，所以与我们定义的唯心主义还是很不同的。</li></ul><h3 id="1-2-阿那克西曼德"><a href="#1-2-阿那克西曼德" class="headerlink" title="1.2 阿那克西曼德"></a>1.2 阿那克西曼德</h3><ul><li>阿那克西曼德是泰勒斯的好友和学生，也是一名出色的科学思想家。据史料记载，他通过实地考察撰写了《大地描述》，记录了各地的地理情况和民情风貌，同时绘制了第一张希腊地图。他还热衷于天文、气象的观测，发明了第一个日晷指时针，最先画出了陆地和海洋的轮廓，制造了可能是某个天体模型的“天球”。</li><li>阿那克西曼德提出“本原是阿派朗”，阿派朗的希腊文是 apeiron，原意是“无限制、无界限、无规定、无定形”。阿派朗的定义很容易被曲解，它不是什么精神实体，不是抽象的“无限”，也不是类似原子的“普遍物质”。阿派朗的提出仅仅是为了解决泰勒斯的水为本原难以说明生成万物与自然界的多样性的统一的问题，因为水的物态变化始终是狭隘的，所以阿那克西曼德在此基础上提出了一种比水更无定形、更有变化能力的东西，在这个意义上，阿派朗和泰勒斯的水一样，都是一种具体的、物质性的质料，所以依然没有脱离朴素唯物论的思想。这一点从他的传人阿那克西米尼的观点上可以推断出来，阿派朗可能只是对“无定形”的一种不明晰的表述，所以继承者阿那克西米尼才会把这种无定形具象化为“气”，提出“本原是气”。</li><li>阿派朗在空间的量、运动与时间上是无限的，因为包括阿那克西曼德在内的有一部分哲学家认为，无限是神圣的，无限包容一切又支配一切，所以无限自身再没有本原，只能是它作为其他万物的本原。</li><li>阿那克西曼德对本原论的深化，还体现在他认为阿派朗的运动变化具有万物产生于它、毁灭后又复归于它的必然性，这相当于明确提出了本原生成与变易万物是处在时间进程中的、有必然规律的深刻思想。</li><li>阿派朗中潜蕴着无限多的“对立”，但阿那克西曼德并没有把这种对立的范畴上升到普遍法则、辩证法规律的高度，他仅仅把对立解释为冷热、干湿这样的基本物态成分。阿那克西曼德基于此提出了一种“分离”说的宇宙论，认为永恒运动的、无限的阿派朗将其潜蕴的无限多的“对立”分离出来，就形成了无数个世界与宇宙万物。这里的“无数个世界”颇具争议，有人认为是时间上的连续相继，也有人认为是空间上的同时并存。此外，对于阿派朗具体以一种什么样的运动分离成万物又使万物复归于它，阿那克西曼德也没有详细解释，引起了学界的争论。</li><li>阿那克西曼德最先对各个行星的大小和距离进行估算，认为大地是宇宙的中心，提出了西方天文学史上最早的地心说。他还基于经验观察解释了风雨雷电等自然现象，虽然很幼稚很粗糙，但是却开创了气象学的研究。</li><li>阿那克西曼德最早提出了关于动物与人类起源的论述，他认为人是由鱼变来的，因为潮湿的东西中更可能孕育生命。虽然也很幼稚，但已经有了朴素的生物进化思想的萌芽了。</li></ul><h3 id="1-3-阿那克西米尼"><a href="#1-3-阿那克西米尼" class="headerlink" title="1.3 阿那克西米尼"></a>1.3 阿那克西米尼</h3><ul><li>阿那克西米尼是阿那克西曼德的学生，也是米利都衰落前的最后一位本土哲学家。他与出生于伊奥尼亚的毕达哥拉斯貌似是朋友，后来毕达哥拉斯跑到克罗顿开创了南意大利哲学传统，很可能曾受到过米利都学派的思想熏陶。</li><li>阿那克西米尼也认为本原应该是无限的，但他不认同本原是完全无定形、不可捉摸的，所以他提出了“气是本原”，把多样性的物质世界统一于一种具体物质形态的规定性。他的本原论有三个思想特征：<ul><li>综合了数量、空间的无定形和质上的确定性。水太狭隘与肤浅，阿派朗又太偏想象性的推断，所以“气是本原”是对二者的继承、发展与超越，而不是单纯的从无定形到有定形的思想倒退，毕竟阿派朗也算不上一种高度抽象的理性思辨。</li><li>无限的气永恒运动变化，内在动力因是气内的冷热、干湿等对立物态成分。泰勒斯压根没提过动力因，而阿那克西曼德的分离说仅仅把这种对立作为分离的对象，却对分离的动力因避而不谈，阿那克西米尼则明确地指出这些对立成分是一切运动变化的动因。</li><li>基于“气是本原”，阿那克西米尼进而解释了万物的起源与复归、宇宙论乃至生命与灵魂，形成了一套一以贯之、自圆其说的哲学理论系统。</li></ul></li><li>阿那克西米尼认为气生万物的动力因是内部冷热的对立，具体的变化过程是冷热所造成的气的稀散与浓聚。冷热是物态成分，稀散与浓聚是空间中的分布，所以该思想蕴含着空间量的规定性。此外，单一物质在空间量上的变化能衍生出万物，也蕴含了量变引起质变的思想萌芽，只不过阿那克西米尼没有明确探讨到“质”的层面。</li><li>阿那克西米尼首次用气来解释生命与灵魂的本性，将气本原说扩展到生命有机体的范围，大概是因为他观察到呼吸是维持生命的关键。他虽然提到了灵魂，但他是把灵魂与生命等价，所以并没有探讨到精神意识的层面。米利都学派不可能触及到精神意识问题，因为当时还没有开始探究精神意识的科学认识前提与逻辑思想前提。阿那克西米尼甚至认为神也诞生自气本原，所以气是比神更神圣的东西。</li><li>基于气本原说，阿那克西米尼提出了气成宇宙论，认为宇宙是从气生成的，宇宙中充满了气，各个天体规律性的运动是靠气的推动所维持的。他是第一位提出天体按照圆形轨道作有规律运行的科学思想家，对后来的各种天体运行结构论都有着开创性的影响。</li><li>气本原说本质上是对阿派朗的稍加改良，这里的气与现在空气的概念不同，它仍是一种不明晰的物态成分，所以当时对于气并没有什么粒子层面、物理层面的认知。气和阿派朗其实并没有太大区别，阿那克西米尼真正的伟大之处是用本原论相对完整又严谨地解释了世界。</li></ul><h2 id="2-赫拉克利特-艾菲斯学派"><a href="#2-赫拉克利特-艾菲斯学派" class="headerlink" title="2 赫拉克利特(艾菲斯学派)"></a>2 赫拉克利特(艾菲斯学派)</h2><ul><li>赫拉克利特继承和发展了米利都哲学，他以火为本原，也是探求一种具体的宏观物质形态作为世界的本原并用以解释宇宙的成因。火本原说，和泰勒斯的水以及阿那克西米尼的气一脉相承，都是寻求质料因，可以说在经验观察方面，赫拉克利特相比于米利都学派并无进步，但逻格斯的提出使他在哲学的思辨理性方面比米利都学派有了很大的跃升。</li><li>“这个有秩序的宇宙(科斯摩斯)对万物都是相同的，它既不是神也不是人所创造的，它过去、现在和将来永远是一团永恒的活火，按一定尺度燃烧，一定尺度熄灭。”</li><li>在古希腊人看来，火不只是一种燃烧现象，它本身就是一种能燃烧与熄灭的特殊形态的东西。米利都学派的水、阿派朗、气都难以解释永恒无限的运动和质变的多样性，也未能说明本原和其动因的内在一致性。而火不仅是一种具体的物质形态，也是一种有内在动力的、永远活跃着的运动过程，是能动的本原和运动的内力的统一。</li><li>在动力因上，赫拉克利特袭用了阿那克西米尼的“稀散与浓聚”的说法。同时他认为火转化为万物不是一个纷乱的过程，而是循着必然的途径和周期，由土到水到气到火是上升之路，反过来则是下降之路，上升之路和下降之路构成了一个首尾联结的循环。在这个转化路线中，水和气有着仅次于火的重要地位，赫拉克利特几乎将每一事物的产生都归于海的蒸汽，可以看出受到了水本原说和气本原说的影响。</li><li>赫拉克利特用火本原来解释灵魂的本性、差异与转化，与阿那克西米尼基于气本原的解释并无太大区别，二人都还没有严格区分物质和精神，只不过火有明确的运动属性，更容易被接受。此外他还提出了两个新的解释，一是用火生的热气和水生的湿气来区别灵魂认知能力的优劣，二是用上升之路和下降之路来改造奥菲斯教的灵魂轮回说，大概意思是灵魂在上升之路中从水中产生，而在下降之路中死亡最终变成土。</li><li>赫拉克利特将运动变化看做一切事物的基本规定，他提出“人不能两次踏进同一条河流”，又进而提出“我们踏进又不踏进同一条河流，我们存在又不存在”。这里的存在和巴门尼德的存在不同，赫拉克利特的“存在”只是一种内涵为“有”的，基本独立于精神意识的狭义的客观实在，巴门尼德的“存在”则兼有“是”、“有”、“真”三重含义，其次，赫拉克利特的“存在”和“不存在”是对立统一的，而巴门尼德的“存在”与“非存在”是严格对立的。</li><li>赫拉克利特虽然主张万物都在运动变化中，但他仍然认为变动中有相对稳定性和质的规定性，比如火本原论中上升之路和下降之路的每个环节都是相对稳定的，后来他的学生克拉底鲁只承认绝对运动不承认相对静止，陷入了相对主义和不可知论，其实是偏离了赫拉克利特的哲学思想。</li><li>由于赫拉克利特在经验观察方面相比米利都学派并无进步，所以除了提出火成宇宙的观点，他对于天体、气象方面的认识还是停留在米利都学派的认识层面，只是一些简单地猜测和主观臆测。</li><li>逻格斯有四重含义：<ul><li>具有普遍性意义，是人们必须共同理解与遵从的，那些与逻格斯格格不入、背道而驰的人是无知的。</li><li>一种支配万物运动、变化、生灭的普遍的必然法则，一种统一、共同的宇宙秩序。</li><li>当逻格斯体现在自然、人与社会的各领域，包括灵魂与法律时，是普遍中见特殊。每个人都有各自的逻格斯，社会的逻格斯则是一个神圣的、自然的法律，这种高于人为法的神圣法，蕴含了后来“自然法”的思想萌芽。</li><li>逻格斯主要靠思想把握。一方面，首要把握的一定是客观的、普遍的逻格斯，另一方面主体逻格斯和客体逻格斯具有一致性，只有先清醒地认识自己才能有把握逻格斯的健全思想，隐约蕴含着一种“人的哲学”的意味。</li></ul></li><li>赫拉克利特还用逻格斯突破了传统的神控命运观，指出命运也是一种逻格斯，是人的思想、智慧可以把握的自然的必然性。</li><li>赫拉克利特最早提出了对立统一的辩证法思想，此前的阿那克西曼德虽然提出了冷热干湿的对立，但没有明确论述他们之间对立统一的辩证关系，毕达哥拉斯也是只提出对立而没有论述和谐统一。赫拉克利特主要从三个方面论述：<ul><li>对立双方互相依存，结成统一体。</li><li>对立双方互相排斥的斗争是事物产生的根本动因。和谐并不是静态的和谐，而是在永恒斗争中动态产生与消逝的和谐。</li><li>对立双方的同一在于他们能互相渗透、互相转化，是动态的同一。米利都学派也提及过这一点，认为冷热、干湿是可以互相转化的。</li></ul></li><li>赫拉克利特区分了感性认识和理性认识，并且重理性轻感性。他认为只有理性认识才能把握逻格斯，而感性认识是愚蠢的、不可靠的。但这仅仅是对感性和理性的初步理解，还远远没有达到需要区分属于经验论还是唯理论的深度，因此争辩他的认识论倾向没什么意义。</li><li>米利都学派虽然突破了传统神话与宗教，但他们并没有公开、正面批评传统宗教，赫拉克利特则明确地批判了传统宗教。他反对一切的偶像崇拜和向神祈祷，他从火本原论和逻格斯的哲学原则出发以泛神论来解释“神”，从根本上颠覆了传统或流行的人格化多神教。他所谓的“神”，就是作为宇宙法则的逻格斯，更像是一种“天理”而不像是传统观念中的神，因为神是逻格斯，所以神体现在宇宙万物中，因此可以说赫拉克利特主张的是一种泛神论。</li></ul><h2 id="3-毕达哥拉斯学派"><a href="#3-毕达哥拉斯学派" class="headerlink" title="3 毕达哥拉斯学派"></a>3 毕达哥拉斯学派</h2><ul><li>毕达哥拉斯组建了毕达哥拉斯盟会，是西方历史上最早的一个有严密组织的科学共同体，也是一个严格而自有教义的宗教社团。其中从事数理研究的成员在数学、天文等方面取得了开创性的成就，在尚未建立逻辑学的背景下，就已经运用缜密的理性分析确定了数学的概念与命题，证明了一些几何定理，并将这种数理方法运用于天文学与声学。</li><li>毕达哥拉斯学派研究了整数的变化和规律，区分出了奇数、偶数、素数、平方数、完全数、三角树、五角数等。在几何学方面，研究了多边形内角和、黄金分割、正多面体等，最著名的莫过于毕达哥拉斯定理(勾股定理的名字取自我国的《周髀算经》，跟毕达哥拉斯学派没关系)。此外，毕达哥拉斯学派还发现了无理数，大概是源于在计算直角三角形斜边长时发现不可约，无理数对于毕达哥拉斯学派是一次数学危机，颠覆了学派以整数为基石的数理体系，以至于无理数的发现在很长一段时间内被禁止泄露出去。</li><li>毕达哥拉斯盟会还是一个带有神秘色彩的宗教社团，主要崇扬奥菲斯教，也混合了斐瑞居德教的一些思想，因此毕达哥拉斯也主张灵魂不死与灵魂轮回转世。但与早期的奥菲斯教不同，早期奥菲斯教崇拜狂放粗犷就酒神与收获之神狄奥尼索斯，而毕达哥拉斯盟会则崇拜庄重优雅的日神阿波罗。</li><li>毕达哥拉斯盟会将宗教与科学、哲理结为一体，使宗教走向理智化和伦理化，主要体现在两方面：<ul><li>在奥菲斯教义中纳入哲理性内容。毕达哥拉斯是西方历史上第一个使用哲学这个词并称自己是哲学家(爱智者)的人，他的数本原论与他改良版的奥菲斯教义紧密相关，他认为数是神的智慧，也是人的灵魂净化的最高境界。“净化”不再只是净水洗身这样肤浅的宗教仪式，而是被提升到了灵魂理智化的高度。毕达哥拉斯盟会研究的两个重点是医学和音乐(谐音学)，他们认为医学能净化身体，而音乐能净化灵魂。</li><li>在奥菲斯教中注入某些伦理与道德精神。盟会的成员们认为道德修养是灵魂避免玷污、获得净化的最可靠手段，所以他们对内心修养和行为规范有着严格的训练与要求。这种恪守伦理与道德规范的生活方式，是毕达哥拉斯盟会得以稳定治理南意大利诸城邦的重要原因。</li></ul></li><li>毕达哥拉斯学派热衷于研究数学，他们研究的数不是纯概念的数，而是与几何紧密结合的一种图形数、几何数。推广到哲学层面，数就成了宇宙万物的本原，同时他们强调以理智的沉思从数量关系与空间的几何形式结构去把握事物本身内在的本性。伊奥尼亚哲学传统从某种具体物质寻找万物派生与复归的本原，而南意大利哲学传统是从事物内在的数的规定性发现宇宙万物的本性或原理。</li><li>数既是构成万物的本原，又规定了事物存在的结构和状态，因此数既是事物的质料因也是形式因。我们现在认识的“数”是高度抽象出来的量的概念，但毕达哥拉斯的数是质料与形式的结合，是不能与可感事物分离的东西。数的局限性在于不能自圆其说地解释自然事物的运动变化，更不能说明万物生成的动力因。除了解释自然事物，毕达哥拉斯学派还用数解释人世命运、生活价值等，体现出一种神秘主义和宗教色彩。</li><li>以数本原论为总原理，毕达哥拉斯学派从自然事物中概括出十种对立，并称它们也是本原(原理)，可以说是希腊哲学史上第一次规整地提出了对立的范畴表。这十种对立是：有限与无限，奇与偶，一与多，右与左，雄与雌，静与动，直与曲，明与暗，善与恶，正方与长方。毕达哥拉斯学派虽然不是最先提出对立的范畴，但却最先把对立上升到本原的高度。这里的有限与无限不是指时间和空间量度上的限制，而是有定形和无定形。这十种对立中，前者都是有定形的，具有积极正面的价值，后者都是无定形的，只具有消极负面的价值。在本原论上，如果说伊奥尼亚哲学推崇无定形，那么毕达哥拉斯学派可以说是“反无定形学派”。</li><li>毕达哥拉斯学派的数更偏向于对事物存在状态的概括，而不探究其动因，所以他们所谓的对立是狭隘的、静止的、没有过程的对立，并没有上升到对立统一的辩证法的高度。</li><li>毕达哥拉斯学派研究了谐音与音乐中存在的某种数量比例关系，开创了声学理论的研究，但因为声学属于力学的分支，当时还没有人研究力学理论，所以以当时的声学研究并没有取得太大的进展。他们还基于数学与声学的研究提出了“和谐”(harmonia)的概念，原意是“将不同的东西美好地连接、调和在一起”，体现出了该学派的审美与伦理价值观念。</li><li>基于“和谐”的理念，他们提出一种有天籁的天体运行结构说，并把天称作科斯莫斯(cosmos，原意是秩序)。他们认为各个天体的自身大小、相互距离与运动速度不同，就会产生不同的音调，形成和谐的音乐，即天体的谐音。这种根据数学比例的推断而提出的有限、和谐的宇宙模型与天体运行结构论，比前人的假说要科学得多。</li><li>毕达哥拉斯学派最先提出了有确定轨道的天体运行系统，描述为十个天体围绕同心圆中心在圆周轨道上有序运行，但其实他们只观测到九个天体，因为“十”是表征完善性的数，所以他们凭空设想了一个天体“对地”来凑数。相比于前人，他们的天体理论中有三点值得重视：<ul><li>认为大地是球形的，并不处于宇宙的中心。但这并没有动摇地心说的统治地位，直到文艺复兴时期，哥白尼的日心说才真正颠覆了地心说。</li><li>认为宇宙中心是火团，也叫中心火，太阳也是围绕中心火运行，并且把中心火的光和热反射给地球。这可能是收到了赫拉克利特的火成宇宙论的影响，中心火说虽然不是日心说，但对日心说的提出有很大的引领作用。</li><li>认为宇宙外缘有要素成分最纯的“奥林帕斯”，在更远的外部有“无限的嘘气”，也称“普纽玛”。这里的“无限”依然是无定形的意思，“嘘气”很可能就是阿那克西米尼提出的“气”，可以看到毕达哥拉斯学派确实受到了伊奥尼亚哲学传统的影响，但又因为毕达哥拉斯学派崇尚有定形而轻视无定形，所以不再把“气”视为本原，只是作为一种漂浮在宇宙万物之外的没什么用的东西。</li></ul></li><li>简而言之，毕达哥拉斯学派的宇宙论有两大贡献：一是指出了宇宙的和谐与秩序，这一点影响了后期伊奥尼亚哲学中宇宙论的演变，比如阿那克萨戈拉强调“努斯”造就了宇宙秩序。二是用数理知识建立宇宙模型，这一点得到了柏拉图和亚里士多德的继承，他们都倡导用几何学(尤其是立体几何)来研究天文学，形成了数理天文学的流派。</li></ul><h2 id="4-爱利亚学派"><a href="#4-爱利亚学派" class="headerlink" title="4 爱利亚学派"></a>4 爱利亚学派</h2><h3 id="4-1-塞诺芬尼"><a href="#4-1-塞诺芬尼" class="headerlink" title="4.1 塞诺芬尼"></a>4.1 塞诺芬尼</h3><ul><li>塞诺芬尼出生在伊奥尼亚的一个城邦，作为吟游诗人长期漂泊，在南意大利的爱利亚有过长期活动，据说是巴门尼德的老师，但没有确凿证据。我们说塞诺芬尼是爱利亚学派的思想先驱，并不依据他在爱利亚建立过学派或与巴门尼德有直接的师承关系，而是认为他的哲理思想在学脉上是该学派的先导。他虽然受到过伊奥尼亚哲学的影响，但最终从自然哲学过渡到了一种理性神论和新的思辨哲学，与该学派的巴门尼德、芝诺、麦里梭等人的思想有着一脉相承的内在逻辑。</li><li>希腊的传统宗教如奥林帕斯神系的宗教和奥菲斯教，都是拟人化的多神教，将种种自然力量与社会力量幻化为人格化的多神，神人同形同性。塞诺芬尼从理性与道德的高度对传统的拟人化多神教表达了批判，后来也被苏格拉底和柏拉图所承袭与发挥，塞诺芬尼的批判主要分三方面：<ul><li>批判他们赋予神以人的形象，因为不同地域的人种长相是不同的，神不可能去迎合每一个人种的外貌。</li><li>批判他们将诸神描绘成可以是不道德的，因为不道德的行为只是人间的丑恶，神是不可能有的。</li><li>批判他们虚构诸神之间有统治关系。</li></ul></li><li>塞诺芬尼认为“一”就是神，这个神是非人格化的不动不变的整体，以其思想支配宇宙万物。虽然毕达哥拉斯学派的改良版奥菲斯教义已经开始走向了理智化和伦理化，但他们没有颠覆传统的神的观念，只是从崇拜酒神变成了崇拜日神。塞诺芬尼的理性神自然不应是崇拜和祭祀的偶像，而应通过人的理智去把握。值得注意的是，塞诺芬尼仍然容忍、保留了传统多神，只是提出了一个高于诸神的理性神来主宰、改造他们，古希腊罗马的很多哲学流派都采取了这种在学理上说理性神、在实际生活中却容忍甚至维护传统多神教的态度。塞诺芬尼的贡献在于开启了拟人化多神教向有理性与伦理内涵的一神教演化的历程。</li><li>由于受到了伊奥尼亚自然哲学的熏陶，塞诺芬尼从经验观察出发，借助自然哲学的科学思想解释了很多自然事物与现象。</li></ul><h3 id="4-2-巴门尼德"><a href="#4-2-巴门尼德" class="headerlink" title="4.2 巴门尼德"></a>4.2 巴门尼德</h3><ul><li>巴门尼德最早用“存在”(being)这一抽象而有普遍本质的哲学范畴，来深入规定世界全体的原理，并强调了理性思维在认识真理中的重要意义，这对伊奥尼亚自然哲学注重从经验直观中探求万物本原与毕达哥拉斯学派只停留在从数量和空间形式结构层面把握万物的原理，都是一种哲学思维上的超越。</li><li>巴门尼德是爱利亚本地人，是否师承于塞诺芬尼并没有确凿证据，但由于当时毕达哥拉斯学派在南意大利影响甚大，加之他与一位毕达哥拉斯学派的成员阿美尼亚交往甚密，所以他一定受到了毕达哥拉斯学派哲学思想的熏陶。</li><li>巴门尼德流传下来的著作只有一部哲理诗《论自然》，其中关键的一段话是：“只有两种探究之路可考虑。一种就是存在，存在不可能不存在，这是真理之路。另一种就是非存在，非存在必定要不存在，我告诉你，那是一条没人能完全学到真知之路。因为你不能对非存在有知识，也不能言说他，因为能被思想的和能存在的是同样的东西。”</li><li>我们现在理解的“存在”是与思维对立的客观的、具体的事物，而巴门尼德的“存在”是世界全体的普遍的、必然的本质，是一种表示世界全体统一的本性，那些客观具体的事物反而被他认为是“非存在”，中文翻译成“存在”纯粹是因为翻译能力有限，所以容易造成误解。巴门尼德将塞诺芬尼的“一”在哲学意义上明确地展开，他提出“存在”就是全体的“一”，是不动变、不生灭、永恒的、连续不可分的整体。</li><li>巴门尼德受到了毕达哥拉斯学派数理哲学和重有限轻无限思想的熏陶，同时又不能像后来的柏拉图、亚里士多德一样用完全高度的抽象的语言来界定、表述“存在”的哲学意义，所以巴门尼德就把“存在”描述为一个有限定的滚圆的球体。</li><li>由于当时物质与精神范畴还没有明确地分化确立，现在看来巴门尼德的思想兼有唯物与唯心的倾向。一方面，他强调只有思想(区别于感觉)才能把握世界的普遍本性，另一方面，他又肯定了存在是有限定的、不动变的、球体的、连续的，启发了后来的元素说、种子说、原子论等唯物主义色彩的学说。</li><li>巴门尼德说的“非存在”就是变动生灭的现象世界，意见之路就是凭感知与常识性的看法认知非存在的现象世界，不能把握住世界的本性。他首次表现了将世界二重化、将认识区分为真理与意见两段的初步思想，后来柏拉图将它发展成现象世界与理念世界的二重化，将认识划分为意见和知识两大阶段。</li></ul><h3 id="4-3-芝诺"><a href="#4-3-芝诺" class="headerlink" title="4.3 芝诺"></a>4.3 芝诺</h3><ul><li>芝诺提出了一与多、动与静、连续与间断等存在的悖论，目的是要否定现象的多、动和可分的间断性，以归谬法来反证“一”即不动、连续的存在才是世界全体的合理本性。他的结论虽是否定变化生灭为万物本性这种形而上学，但实际上是以一种逻辑论证的主观辩证法揭示了客观世界和思想的矛盾。</li><li>芝诺悖论首创了一种主观辩证法，客观上揭示了在时空中运动的事物所固有的内在矛盾。芝诺悖论的局限不在于遵循形式逻辑的思维，而是在于只强调一与多、动与静、连续与间断的对立，而不承认他们的对立统一，于是这些悖论的前提本身就已经否定了客观辩证法，所以芝诺只能以主观辩证法这种扭曲的方式折射出客观事物的辩证法。</li></ul><h3 id="4-4-麦里梭"><a href="#4-4-麦里梭" class="headerlink" title="4.4 麦里梭"></a>4.4 麦里梭</h3><ul><li>麦里梭生活在恩培多克勒、阿那克萨戈拉、留基伯等一代新哲学家辈出之时，巴门尼德的存在学说不仅遭到老的学派的反对，也遇到了新的更有综合性、更为深化的自然哲学的挑战，而且人们的抽象认识与逻辑思维能力也有了提高，所以麦里梭不再固守巴门尼德的原始思想，开始提出新的阐发与论证，同时也糅合了伊奥尼亚哲学和其他新的哲学思想，但依然没有挽回爱利亚学派被淘汰的命运。</li><li>麦里梭主要在三方面提供了新的论证：<ul><li>主张存在是无限的，而不是有限的。这里的无限不仅包含了无限定、无定形的意思，也开始有了时间上无开端与终结的意思。可以看出麦里梭受到了伊奥尼亚自然哲学中崇尚无定形的思想的影响。</li><li>主张存在是无形体的。超越了巴门尼德“存在是球体”的论断，从高度抽象的层面来描述存在。</li><li>主张存在是不带任何情感色彩的宇宙秩序，是理性神。没有情感意味着没有人格，所以这也是对希腊传统的拟人化多神教的否定。</li></ul></li></ul><h2 id="5-恩培多克勒"><a href="#5-恩培多克勒" class="headerlink" title="5 恩培多克勒"></a>5 恩培多克勒</h2><ul><li>恩培多克勒、阿那克萨戈拉和德谟克利特是公元前5世纪下半叶希腊自然哲学的代表人物。这一时期的自然哲学有以下特点：<ul><li>从探索物质结构这一新途径来解决万物的本原问题，力图克服伊奥尼亚和南意大利两大哲学传统的对立，对两大哲学传统都作了扬弃。</li><li>致力于克服伊奥尼亚和南意大利哲学传统关于本原问题的两种一元论的对立，在本原探究上经过多元论最后达到一元和多元的统一。</li><li>在阐述物质粒子的基本特性、描述自然总画面和宇宙演化时，都还处于朴素的直观中，保留和发扬了伊奥尼亚哲学的自发辩证法光彩，但也有所消退，带有机械性。</li><li>开始以日渐明朗的方式产生了对物质和精神分化的认识。</li><li>开始重视研究认识问题，力图将比较粗浅的认识论思想和本原论贯通起来，形成了朴素的反映论。</li><li>更多地关注人和社会问题，较多地显露、增进着人文精神。</li></ul></li><li>恩培多克勒先师从爱利亚学派，后又师从毕达哥拉斯学派，他的元素论学说吸收并改造了巴门尼德的存在说和毕达哥拉斯的数本原论的思想。留存下来的两部著作《论自然》和《净化篇》都是采用了哲理诗的体裁。</li><li>恩培多克勒是一位自然哲学家，主张结合观察自然的经验和对世界全体的理智思索，不仅仅局限于抽象的逻辑思辨或某种感觉的直观，而要综合感知经验的全体。他提出了基于水火土气四元素的本原论，也叫“四根说”，四元素本身永恒不变，只是由于它们相互组合和分解，才造成了世界万物循环性的产生和毁灭，这包含着一与多的对立统一的思想。</li><li>四根说是综合、改造爱利亚学派哲学和伊奥尼亚哲学两大传统的结果。一方面，四元素本质上就是把巴门尼德的存在一分为四，用四种物质性元素替换掉了抽象空泛的存在。另一方面，恩培多克勒又站在伊奥尼亚自然哲学的角度，用冷热、干湿、明暗等物态性质描述四元素。</li><li>四根说是最早的物理学意义上的微观粒子结构说，它强调物质的有定形的数量比例与形式结构，显然是受到了毕达哥拉斯学派的影响，四根说主要有三大特点：<ul><li>四元素是粒子化了的，是构造物质的基本单元。</li><li>微粒元素组合万物，具有特定的孔道结构，只有孔道相吻合的粒子才能进行结合与分离。</li><li>物体的元素结构有一定的数量比例，元素按不同数量比例结合，就形成了不同的自然物体。</li></ul></li><li>对于四元素结合与分离的动力因，恩培多克勒提出了爱(philotes)和争(neikos，又译作憎或恨)。爱是一种结合的力量，争是一种分离的力量，这两种对立的动力此消彼长，所以万物就处于经常的生灭变易之中。恩培多克勒是第一个从自然本原以外去寻找动力因，且假定了不止一种动力因的哲学家，他的爱与争具有对立统一的辩证法色彩。但他没有进一步解释爱与争此消彼长的动力又是什么。</li><li>恩培多克勒还没有明确区分物质与精神，所以他没有说明爱和争到底是物质性还是精神性的东西，以至于爱和争除了是动力因外，还具有质料因的特点。恩培多克勒的这种含混表述引起了后世西方学者间的争论。</li><li>恩培多克勒承袭了巴门尼德的观点，认为宇宙是个球体，永远处于周期性的循环演化之中，四元素是它的基本质料，爱和争是其演化的动力。宇宙的每个循环周期分成四个演化阶段：<ul><li>第一阶段，爱的力量占主导支配地位，争的力量只能处于宇宙球体的外层最边缘，宇宙中的一切都绝对地混合，处于没有任何区别、纷争、冲突的和谐状态。</li><li>第二阶段，争的力量崛起，争从外层边缘侵入球体，将爱的力量向球体中心压迫，同爱发生冲突。各元素从绝对混合中分化，形成自然万物。</li><li>第三阶段，争的力量达到高峰，占据绝对的主导地位，将爱压迫至球体的中心点。自然万物进一步分离解体，最终不复存在，宇宙中只剩下四种元素。</li><li>第四阶段，爱的力量重新崛起，从球体的中心点扩张开来，将争的力量驱散到球体的外层边缘。分离的元素又重新结合起来，最终回到第一阶段的绝对混合。</li></ul></li><li>恩培多克勒还基于四根说解释了生命体的起源与演化，反对了神合理安排一切的观点，用朴素的语言论述了适者生存、自然淘汰的进化原则，可以算是蕴含了进化论的思想萌芽。</li><li>恩培多克勒最早开始比较具体地研究认识论问题，主要研究各种感知认识形式及其生理基础，提出了同类相知的流射说这种朴素的反映论，并从感知的生理机制剖析认识的主体方面，形成一种认识活动的感官生理学。</li><li>流射说认为任何物体都在连续不断地放射细微不可见的元素粒子，不同的感官有不同的孔道结构，能够接受特定的元素粒子，所以感觉就是物质的元素粒子在流射中通过孔道相互作用的结果。同类相知就是指感觉的主体与客体要通过孔道匹配上，所以一种感官不能认识另一种感官的对象。</li><li>恩培多克勒对人的理智和情感的生理基础也提出了见解。他不认为脑是意识中枢，而认为人用心和血液思想，因为只有心和血液连通着全身上下的感官。他还区分了感觉与理智，认为感官只能考察事物的个别部分，只有心灵才能认识全体，但理智必须通过感官的渠道。</li><li>由于当时奥菲斯教在南意大利影响甚广，恩培多克勒专门写了《净化篇》来论述灵魂轮回、人神关系以及人的宗教道德生活。他用爱和争为动因来论述灵魂轮回，爱使灵魂从善而升华，争使灵魂作恶而堕落，灵魂轮回要通过四元素，灵魂在轮回中可寄托在自然界各种植物和动物中，这是一种认同万物有灵的泛神论思想。</li><li>人是灵魂轮回的最高形式，人必须通过净化手段，洗涤罪恶，才能使灵魂返回到和诸神同在的极乐至境。恩培多克勒提出了三种净化手段：<ul><li>禁吃肉和豆类、月桂。因为月桂树叶是灵魂在植物中寄托的最高形式，豆类与人的生命有亲缘关系，动物的躯体则寄托着与人的灵魂有亲缘关系的灵魂。</li><li>戒绝邪恶。因为灵魂在邪恶的重压下是不能解脱的。</li><li>知识净化。因为人和乐园中的诸神并无截然的区别，只是知识的高低不同，灵魂要获救，要返璞归真，就必须向诸神看齐，靠理智去获得丰富的知识，包括自然、宗教和道德的知识。这种知识净化说将理智和知识成分吸纳入宗教思想中，促使拟人化多神教向理性一神思想过渡。</li></ul></li></ul><h2 id="6-阿那克萨戈拉和复兴伊奥尼亚哲学的思潮"><a href="#6-阿那克萨戈拉和复兴伊奥尼亚哲学的思潮" class="headerlink" title="6 阿那克萨戈拉和复兴伊奥尼亚哲学的思潮"></a>6 阿那克萨戈拉和复兴伊奥尼亚哲学的思潮</h2><ul><li>阿那克萨戈拉最先将伊奥尼亚的自然哲学带到希腊本土，他定居雅典30年，是伯利克里的良师益友，受到了伯利克里的重视和推崇，这有力地促进了雅典的思想启蒙，对民主制黄金时代的科学昌盛和文化繁荣作出了开创性的重要贡献。后来在贵族寡头派与民主派的争斗中，他惨遭陷害，经由伯利克里的大力营救，得以逃离雅典回到伊奥尼亚，继续执教授徒。</li><li>阿那克萨戈拉主要继承和发展伊奥尼亚哲学传统，但他的种子说却表现出受到了巴门尼德的影响，他所谓的种子就是将“存在”彻底打碎成无限多元的异质粒子。区别于恩培多克勒的四根说，种子说有三个特点：<ul><li>种子无穷异质、无限多元、无定形。这是对伊奥尼亚哲学无定形思想的继承，同时他将多元论推到极点，也就避免了伊奥尼亚哲学用单一的物质本原转化生成万物所遇到的困难。但是将自然物质的无限多样性直接还原为种子本身在质上的无限多元性，就使阿那克萨戈拉忽视了对物质构造中的数量比例和形式结构的探讨。</li><li>种子和物体具有无限可分割性。种子本身就是物理分割的一个“微分”，可以无限分割，但分割得再小仍然是种子，所以种子的大小是不确定的、相对的。它不会被分割到非存在，也不会被分割成数学上抽象的、不可再分割的几何点，它就是能无限分割下去的物质。</li><li>种子包含万物的成分。种子可以无限分割，每一个种子本身又包含着万物的一切成分，所以种子本身就是间断性和连续性、一和多的统一体。但阿那克萨戈拉没有解释所谓万物的成分到底是什么，导致了后世的学者一直在争论这些成分是不是冷热、干湿等对立。</li></ul></li><li>“努斯”(nous)本来是希腊语中的常用词，相当于中文的“心”、“心灵”，泛指感觉、思想、理智、意志等精神活动以及这些活动的主体。在阿那克萨戈拉以前，努斯只有认识论和心理学、生物学上的意义，哲学家们讨论的灵魂也没有与物质实体明确对立起来，从他开始，努斯具有了本体论意义，他明确提出努斯是精神性本原，种子和努斯就构成了他的二元论倾向哲学的两根平行的支柱，物质与精神两大哲学范畴的分化开始明朗起来。</li><li>作为与种子和万物相对立的精神性本原，努斯有四个特征：<ul><li>万物无限多元、异质。努斯虽然无限，却是单纯、单一、自身同质的。</li><li>万物不能完全分开，是互相渗透的混合体。努斯是同万物完全分开、不相混合的独立存在的单纯体。</li><li>万物不能自动，只能由努斯的启动和安排而运动。努斯是自身能动的动因，能启动宇宙的漩涡运动，支配和安排万物。</li><li>万物和种子不具有精神性功能，不能认识别的事物。只有努斯才具有认识全部事物的本性并且决定宇宙事物的能力。</li></ul></li><li>阿那克萨戈拉结合了种子与努斯的本原论描述是：“在每一事物中都包含除了努斯以外的一切事物的成分，但在有些事物中也有努斯”。这里的“有些事物”就是指有精神理智活动的生命体。</li><li>阿那克萨戈拉之所以在提出物质本原后又提出了一种精神本原，目的有三：<ul><li>把物质和运动分开，努斯充当动力因。</li><li>把灵魂的理智功能外化为努斯即心智这种精神本原。努斯比灵魂的含义要小，任何动物都有灵魂，而努斯是最高级的灵魂即理智、理性。</li><li>努斯是安排宇宙合理秩序的原因，蕴含了某种目的论思想因素。恩培多克勒的爱与争的目的论意义并不明显，阿那克萨戈拉的努斯才明显地有了目的论意义，直到亚里士多德才正式形成了“目的因”的哲学范畴。</li></ul></li><li>为了区别于传统的无所不能的神，阿那克萨戈拉的科学理性精神实际上限制了努斯的作用，表现为两点：<ul><li>在宇宙演化中，努斯仅作为最初启动的动因，即第一推动力，努斯并不是一切的动力因。</li><li>阿那克萨戈拉的认识论没有因努斯而形成先验论，仍局限于偏重对感知认识及其生理基础的探讨。只是在无法说明某些事物的必然原因是什么时，才拉进了努斯，而在其他一切场合，他总是用别的原因来说明事件。</li></ul></li><li>宇宙的生成过程是在努斯的启动下的一种分离式漩涡运动的过程。宇宙最初的状态是静止的，无限的种子绝对混合在一起，努斯提供了第一推动力后，宇宙就开始了永恒的漩涡运动。种子形成万物的原理是，在漩涡运动的分离作用下，种子内部的某些优势成分显示出来，使其具有了某种质的规定性。恩培多克勒的宇宙论是一种循环式的漩涡运动，爱和争轮流主导，实现结合与分离的无限循环。而阿那克萨戈拉的宇宙论是一次性分离的漩涡运动，既有分离又有结合，先是从绝对混合中分离出种子，然后种子结合形成自然万物。</li><li>古希腊研究感知问题的理论可以分为同类相知和异类相知。巴门尼德、恩培多克勒和柏拉图支持同类相知，阿那克萨戈拉和赫拉克利特支持异类相知。后者主张只有具有不同性质的物体才能互相产生物理变化，而相似的物体彼此并不发生影响，符合相反相成的辩证法思想。二者都属于朴素的反映论。</li><li>他也指出感官的认识能力是有局限性的，因为种子已经包含了构成万物的所有成分，而感官只能肤浅地感知到其中最优势的成分，所以只有凭借理性才能认识到其中所有的物质成分。然而，由于当时对认识论的研究刚刚起步，他就没有对人的理性认识进行深入研究。</li><li>阿那克萨戈拉将伊奥尼亚哲学带到希腊本土后，以雅典为中心的希腊本土上兴起了一股复兴伊奥尼亚哲学的思潮，这一思潮的主导倾向是宣扬理性、促进科学发展，与同时期的智者派运动的人文主义精神平行发展，是伯利克里时代希腊古典文明盛期启蒙运动的一个方面。代表人物是阿凯劳斯、第欧根尼和希波克拉底。</li><li>阿凯劳斯据说是阿那克萨戈拉的学生，也是苏格拉底的老师。他不认同阿那克萨戈拉的二元论思想，因为二元论不能阐明世界的统一性，于是他回到了阿那克西米尼的气本原一元论，但他的气是物质本原和努斯的综合体，是一种有生命力的能动的本原。他虽然承认努斯是运动的始因，但在描述宇宙演化时，却又只提及气的浓聚与稀散，所以他实际上否定了努斯是第一推动力。</li><li>第欧根尼则是吸收了巴门尼德的存在说和原子论先驱留基伯的虚空思想，进一步将气本原说革新为一元论的粒子结构本原观，他的哲学算是伊奥尼亚哲学到原子论的一个演进环节。第欧根尼的气一元论有三个特点：<ul><li>“气”即“存在”，它虽能化生万物，但它自身的本质特性是不变的，实际上是粒子化的“气”，他还提出“虚空”是气粒子运动变化的场所。这种“气”已经有了原子的思想萌芽，大概是因为第欧根尼的科学抽象能力不够高，只能将它说成物质元素中最具有抽象意义的“气”。</li><li>他偏重于从生命现象的角度将气阐释为一种有生命力的特别是包含理智能力的本原，企图以此来克服阿那克萨戈拉的二元论的内在矛盾。他的气具有物质与精神本原的双重功能，但这种调和方式并不能成功，因为他只是将物质与精神简单地合二为一。</li><li>他以气粒子本原观考察感知认识形式的生理机制和解释自然现象。他支持同类相知的理论，认为感觉的产生源于感官内外的气相结合。他也认为脑是感知和思想的中枢器官，呼吸进并传遍全身的气的最精粹的部分都留在了脑中，形成了理智。</li></ul></li><li>希波克拉底是希腊科斯医学学派的领袖，被称为“西方医学之父”。当时的医学与哲学是相互关联、相辅相成的，医学上的实践探索丰富和促进了自然哲学的发展，同时医学理论的发展又需要哲学原则。他在《论古代医学》中论述了医学和自然哲学的关系，从哲学角度批判地总结了古代医学发展的经验，主张医学发展应当基于科学实践。</li><li>希波克拉底批判了当时医学中的两种倾向：<ul><li>恪守陈旧的自然哲学原则，将空洞的假设作为医学的理论基础，从而使医学故步自封，不求新发展。比如直接把冷热、干湿等对立的概念生搬硬套进医学理论中，却根本无法合理解释解剖和实验中的现象。他并不是否认冷热干湿可以解释医学，而只是反对从抽象空洞的原则出发以致忽视了实践经验。然而，他仅仅反对陈旧过时的自然哲学原则，还不能像后来的实证论者那样将科学和传统哲学完全对立起来。</li><li>医务中的宗教迷信和巫医活动。他坚持从自然本身研究人的生理和病理现象，宣扬科学精神，表现出无神论的倾向。他表面上没有否定希腊传统宗教中的诸神，但却提出诸神根本不干预自然和人体生命现象，巧妙地驳斥了那些宗教骗子，指责他们亵渎了神。然而，希波克拉底的批判也有失偏颇，比如他不区别南意大利医派的合理理论、有效的临床经验和所夹杂的宗教巫术成分，不分青红皂白地将它们都看作巫医邪术，全盘否定。</li></ul></li><li>关于希波克拉底的医学理论，略~</li></ul><h2 id="7-留基伯和德谟克利特"><a href="#7-留基伯和德谟克利特" class="headerlink" title="7 留基伯和德谟克利特"></a>7 留基伯和德谟克利特</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://shivakasu.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哲学" scheme="https://shivakasu.cn/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>tinyhttpd 源码阅读</title>
    <link href="https://shivakasu.cn/2020/06/28/webserver0/"/>
    <id>https://shivakasu.cn/2020/06/28/webserver0/</id>
    <published>2020-06-28T10:41:20.000Z</published>
    <updated>2020-06-28T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="httpd-c"><a href="#httpd-c" class="headerlink" title="httpd.c"></a>httpd.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* J. David's webserver */</span></span><br><span class="line"><span class="comment">/* This is a simple webserver.</span></span><br><span class="line"><span class="comment"> * Created November 1999 by J. David Blackstone.</span></span><br><span class="line"><span class="comment"> * CSE 4344 (Network concepts), Prof. Zeigler</span></span><br><span class="line"><span class="comment"> * University of Texas at Arlington</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* This program compiles for Sparc Solaris 2.6.</span></span><br><span class="line"><span class="comment"> * To compile for Linux:</span></span><br><span class="line"><span class="comment"> *  1) Comment out the #include &lt;pthread.h&gt; line.</span></span><br><span class="line"><span class="comment"> *  2) Comment out the line that defines the variable newthread.</span></span><br><span class="line"><span class="comment"> *  3) Comment out the two lines that run pthread_create().</span></span><br><span class="line"><span class="comment"> *  4) Uncomment the line that runs accept_request().</span></span><br><span class="line"><span class="comment"> *  5) Remove -lsocket from the Makefile.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISspace(x) isspace((int)(x))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_STRING <span class="meta-string">"Server: jdbhttpd/0.1.0\r\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDIN   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDERR  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理从套接字上监听到的HTTP请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_request</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="comment">//向客户端发送400报文</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_request</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//读取服务器上某个文件写入套接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">(<span class="keyword">int</span>, FILE *)</span></span>;</span><br><span class="line"><span class="comment">//向客户端发送500报文，表明执行cgi程序时出现错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//把错误信息写到perror并退出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">//运行cgi程序处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">//读取套接字的一行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//把HTTP响应的头部写到套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headers</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">//向客户端发送404的响应报文，表明找不到请求的文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_found</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//调用cat把服务器文件返回给客户端</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_file</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">//初始化httpd服务，包括建立套接字、绑定端口、进行监听等</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startup</span><span class="params">(u_short *)</span></span>;</span><br><span class="line"><span class="comment">//向客户端发送501的响应报文，表明收到的HTTP请求所用的method不被支持</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unimplemented</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* A request has caused a call to accept() on the server port to</span></span><br><span class="line"><span class="comment"> * return.  Process the request appropriately.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket connected to the client */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//处理从套接字上监听到的HTTP请求</span></span><br><span class="line"><span class="comment">//参数arg是accept函数返回的结果，是一个用于与连接成功的客户端进行通信的套接字描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_request</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//intptr_t是为了跨平台，其长度总是所在平台的位数</span></span><br><span class="line">    <span class="keyword">int</span> client = (<span class="keyword">intptr_t</span>)arg;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">size_t</span> numchars;</span><br><span class="line">    <span class="keyword">char</span> method[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">char</span> url[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">size_t</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cgi = <span class="number">0</span>;      <span class="comment">/* becomes true if server decides this is a CGI</span></span><br><span class="line"><span class="comment">                       * program */</span></span><br><span class="line">    <span class="keyword">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从套接口读取http请求的第一行，格式是：Method Request-URI HTTP-Version CRLF</span></span><br><span class="line">    numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    i = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//解析Method，即第一个空格之前的内容，如果把method数组读满了，说明请求的Method是瞎写的</span></span><br><span class="line">    <span class="keyword">while</span> (!ISspace(buf[i]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(method) - <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        method[i] = buf[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    j=i;</span><br><span class="line">    method[i] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只支持GET和POST方法</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) &amp;&amp; strcasecmp(method, <span class="string">"POST"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        unimplemented(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//POST请求要调用cgi函数处理</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>)</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//跳过多余的空格</span></span><br><span class="line">    <span class="keyword">while</span> (ISspace(buf[j]) &amp;&amp; (j &lt; numchars))</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">//读取请求的url</span></span><br><span class="line">    <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; numchars))</span><br><span class="line">    &#123;</span><br><span class="line">        url[i] = buf[j];</span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        query_string = url;</span><br><span class="line">        <span class="comment">//解析参数之前的url</span></span><br><span class="line">        <span class="keyword">while</span> ((*query_string != <span class="string">'?'</span>) &amp;&amp; (*query_string != <span class="string">'\0'</span>))</span><br><span class="line">            query_string++;</span><br><span class="line">        <span class="comment">//带参数的GET请求也要调用cgi函数处理</span></span><br><span class="line">        <span class="keyword">if</span> (*query_string == <span class="string">'?'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">            *query_string = <span class="string">'\0'</span>;</span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的静态资源文件和cgi程序文件都默认放在htdocs目录下，url默认以'/'开头，所以"htdocs"后面就不用加了</span></span><br><span class="line">    <span class="comment">//path字符串存储的就是htdocs+url的路径</span></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">"htdocs%s"</span>, url);</span><br><span class="line">    <span class="comment">//如果请求的url是目录而不是个文件，默认返回该目录下的index.html</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">'/'</span>)</span><br><span class="line">        <span class="comment">//strcat用于拼接两个字符串</span></span><br><span class="line">        <span class="built_in">strcat</span>(path, <span class="string">"index.html"</span>);</span><br><span class="line">    <span class="comment">//stat函数用于获取文件信息并保存在st里。获取成功返回0，失败返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (stat(path, &amp;st) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//把套接口的接受缓冲读完，相当于清空缓冲区</span></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))  <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">            numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//返回404报文</span></span><br><span class="line">        not_found(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//st_mode记录了文件的类型、设置、权限等信息，和S_IFMT进行按位与得到的是其中记录文件类型的bits，再和S_IFDIR比较判断是否是目录</span></span><br><span class="line">        <span class="comment">//因为目录有可能不以'/'结尾，所以还要判断一次，是目录就默认返回其下的index.html</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFDIR)</span><br><span class="line">            <span class="built_in">strcat</span>(path, <span class="string">"/index.html"</span>);</span><br><span class="line">        <span class="comment">//判断文件是否有可执行权限，包括所有者、用户组、其他用户这三类人的权限</span></span><br><span class="line">        <span class="comment">//对可执行文件的请求也要交给cgi函数处理</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IXUSR) ||</span><br><span class="line">                (st.st_mode &amp; S_IXGRP) ||</span><br><span class="line">                (st.st_mode &amp; S_IXOTH)    )</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果不需要调用cgi函数，就直接给客户端返回文件</span></span><br><span class="line">        <span class="keyword">if</span> (!cgi)</span><br><span class="line">            serve_file(client, path);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            execute_cgi(client, path, method, query_string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理完请求后关闭套接口</span></span><br><span class="line">    close(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a request it has made has a problem.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//向客户端发送400报文</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_request</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 400 BAD REQUEST\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"Content-type: text/html\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;P&gt;Your browser sent a bad request, "</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"such as a POST without a Content-Length.\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Put the entire contents of a file out on a socket.  This function</span></span><br><span class="line"><span class="comment"> * is named after the UNIX "cat" command, because it might have been</span></span><br><span class="line"><span class="comment"> * easier just to do something like pipe, fork, and exec("cat").</span></span><br><span class="line"><span class="comment"> * Parameters: the client socket descriptor</span></span><br><span class="line"><span class="comment"> *             FILE pointer for the file to cat */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//读取服务器上某个文件写入套接口。其实就是以1024个字节为单位，把resource文件的内容send到套接口的发送缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cat</span><span class="params">(<span class="keyword">int</span> client, FILE *resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line">    <span class="keyword">while</span> (!feof(resource))</span><br><span class="line">    &#123;</span><br><span class="line">        send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a CGI script could not be executed.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket descriptor. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//向客户端发送500报文，表明执行cgi程序时出现错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cannot_execute</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 500 Internal Server Error\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"Content-type: text/html\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;P&gt;Error prohibited CGI execution.\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Print out an error message with perror() (for system errors; based</span></span><br><span class="line"><span class="comment"> * on value of errno, which indicates system call errors) and exit the</span></span><br><span class="line"><span class="comment"> * program indicating an error. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//把错误信息写到perror并退出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//把错误信息输出到stderr</span></span><br><span class="line">    perror(sc);</span><br><span class="line">    <span class="comment">//exit(0)表示正常退出，exit(1)表示异常退出</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Execute a CGI script.  Will need to set environment variables as</span></span><br><span class="line"><span class="comment"> * appropriate.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket descriptor</span></span><br><span class="line"><span class="comment"> *             path to the CGI script */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//运行cgi程序处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_cgi</span><span class="params">(<span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *method, <span class="keyword">const</span> <span class="keyword">char</span> *query_string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> cgi_output[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> cgi_input[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> numchars = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> content_length = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">'A'</span>; buf[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">//如果是GET请求，只需要url，后面的内容都清空。所以其实没有实现处理带参数的GET请求</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))  <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">            numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>) <span class="comment">/*POST*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对于POST请求，循环读取请求信息直到找到Content-Length字段，获取Content-Length字段的值</span></span><br><span class="line">        <span class="comment">//因为请求报文中，报文头和数据段之间有一个换行符，所以读到换行时strcmp("\n", buf)==0，退出循环，此时已经读完了报文头，接着要读的就是POST携带的数据</span></span><br><span class="line">        numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//结束符设在中间，后面的字符串就不会参与strcmp</span></span><br><span class="line">            buf[<span class="number">15</span>] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (strcasecmp(buf, <span class="string">"Content-Length:"</span>) == <span class="number">0</span>)</span><br><span class="line">                content_length = atoi(&amp;(buf[<span class="number">16</span>]));</span><br><span class="line">            numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Content-Length是-1可能是由于请求携带的数据太大了，因为atoi函数对数字大小有限制，数字过大可能就会返回-1</span></span><br><span class="line">        <span class="comment">//此时返回400错误的报文</span></span><br><span class="line">        <span class="keyword">if</span> (content_length == <span class="number">-1</span>) &#123;</span><br><span class="line">            bad_request(client);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//既不是GET也不是POST，在accept_request函数中已经判断过了，所以不可能执行到这一行</span></span><br><span class="line">    <span class="keyword">else</span><span class="comment">/*HEAD or other*/</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用管道实现进程间通信</span></span><br><span class="line">    <span class="comment">//pipe函数用于建立管道，成功返回0，失败返回-1。参数数组包含两个文件的描述符，通过cgi_output[0]读管道，通过cgi_output[1]写管道</span></span><br><span class="line">    <span class="comment">//cgi_output通道用于子进程向主进程发送cgi程序执行的输出信息，cgi_input通道用于主进程向子进程发送POST请求的数据</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(cgi_output) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//管道建立失败，返回500错误报文</span></span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pipe(cgi_input) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fork出一个子进程运行cgi程序，以下的代码就会有两个进程共同执行</span></span><br><span class="line">    <span class="comment">//如果fork成功，子进程返回0，父进程返回子进程ID，如果失败则返回-1</span></span><br><span class="line">    <span class="keyword">if</span> ( (pid = fork()) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回成功的状态码</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前是子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)  <span class="comment">/* child: CGI script */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> meth_env[<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">char</span> query_env[<span class="number">255</span>];</span><br><span class="line">        <span class="keyword">char</span> length_env[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dup2用于复制文件描述符</span></span><br><span class="line">        <span class="comment">//把output管道的写口重定向到标准输出</span></span><br><span class="line">        dup2(cgi_output[<span class="number">1</span>], STDOUT);</span><br><span class="line">        <span class="comment">//把input管道的读口重定向到标准输入</span></span><br><span class="line">        dup2(cgi_input[<span class="number">0</span>], STDIN);</span><br><span class="line">        <span class="comment">//关闭output管道的读口和input管道的写口</span></span><br><span class="line">        close(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_input[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">sprintf</span>(meth_env, <span class="string">"REQUEST_METHOD=%s"</span>, method);</span><br><span class="line">        <span class="comment">//增加或修改环境变量，因为服务器与CGI程序交换信息的协作方式是通过环境变量实现的</span></span><br><span class="line">        putenv(meth_env);</span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(query_env, <span class="string">"QUERY_STRING=%s"</span>, query_string);</span><br><span class="line">            putenv(query_env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">/* POST */</span></span><br><span class="line">            <span class="built_in">sprintf</span>(length_env, <span class="string">"CONTENT_LENGTH=%d"</span>, content_length);</span><br><span class="line">            putenv(length_env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//默认请求的文件是.cgi结尾的可执行文件，调用execl来执行该文件</span></span><br><span class="line">        execl(path, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//正常退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果当前是父进程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* parent */</span></span><br><span class="line">        <span class="comment">//关闭output管道的写口和input管道的读口</span></span><br><span class="line">        close(cgi_output[<span class="number">1</span>]);</span><br><span class="line">        close(cgi_input[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//如果是POST请求，此前已经读完了请求头，现在就是把POST的数据写入input管道，然后子进程中运行的cgi程序从该管道读取数据，执行相应操作</span></span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(method, <span class="string">"POST"</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; content_length; i++) &#123;</span><br><span class="line">                recv(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                write(cgi_input[<span class="number">1</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//从output通道中读取子进程运行的cgi程序的返回信息，并发送给客户端</span></span><br><span class="line">        <span class="keyword">while</span> (read(cgi_output[<span class="number">0</span>], &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            send(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        close(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_input[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//请求响应完成，清理子进程</span></span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Get a line from a socket, whether the line ends in a newline,</span></span><br><span class="line"><span class="comment"> * carriage return, or a CRLF combination.  Terminates the string read</span></span><br><span class="line"><span class="comment"> * with a null character.  If no newline indicator is found before the</span></span><br><span class="line"><span class="comment"> * end of the buffer, the string is terminated with a null.  If any of</span></span><br><span class="line"><span class="comment"> * the above three line terminators is read, the last character of the</span></span><br><span class="line"><span class="comment"> * string will be a linefeed and the string will be terminated with a</span></span><br><span class="line"><span class="comment"> * null character.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket descriptor</span></span><br><span class="line"><span class="comment"> *             the buffer to save the data in</span></span><br><span class="line"><span class="comment"> *             the size of the buffer</span></span><br><span class="line"><span class="comment"> * Returns: the number of bytes stored (excluding null) */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//读取套接字的一行</span></span><br><span class="line"><span class="comment">//buf存储读取的数据，size是buf的长度，本文件里用到的buf都是1024bytes，返回值是buf的有效长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_line</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buf满了或者读到换行符就停止</span></span><br><span class="line">    <span class="keyword">while</span> ((i &lt; size - <span class="number">1</span>) &amp;&amp; (c != <span class="string">'\n'</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//recv函数从套接口中读取数据。套接口有发送缓冲和接受缓冲，send函数只是把数据写入发送缓冲，recv函数只是从接受缓冲中复制数据，而真正的数据传输是从发送缓冲传送到接受缓冲，这个传送过程是由协议完成的，这个接受缓冲其实就是TCP的滑动窗口</span></span><br><span class="line">        <span class="comment">//第一个参数是套接字描述符</span></span><br><span class="line">        <span class="comment">//第二个参数指明一个缓冲区，用来存放读取到的数据，因为每次只读一个字符，所以c就是一个char</span></span><br><span class="line">        <span class="comment">//第三个参数是缓冲区的长度</span></span><br><span class="line">        <span class="comment">//第四个参数用于设置收发数据的一些条件，一般设置为0</span></span><br><span class="line">        <span class="comment">//返回的是从接受缓冲中复制的字节数</span></span><br><span class="line">        n = recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* DEBUG printf("%02X\n", c); */</span></span><br><span class="line">        <span class="comment">//如果读到了数据</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果读到回车符'\r'，下一个字符必须是换行符</span></span><br><span class="line">            <span class="comment">//回车符和换行符不会存到buf里</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\r'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//MSG_PEEK表示只从缓冲区读取内容而不清除缓冲区，下次读取的还是相同的内容</span></span><br><span class="line">                <span class="comment">//不清除缓冲区是为了防止不小心读到下一行，确定是换行符后再重新读取并清除缓冲区</span></span><br><span class="line">                n = recv(sock, &amp;c, <span class="number">1</span>, MSG_PEEK);</span><br><span class="line">                <span class="comment">/* DEBUG printf("%02X\n", c); */</span></span><br><span class="line">                <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">'\n'</span>))</span><br><span class="line">                    recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    c = <span class="string">'\n'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没读到换行符就已经读完了，则退出循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c = <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">//i是buf中实际存储的字节数</span></span><br><span class="line">    <span class="keyword">return</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Return the informational HTTP headers about a file. */</span></span><br><span class="line"><span class="comment">/* Parameters: the socket to print the headers on</span></span><br><span class="line"><span class="comment"> *             the name of the file */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//把HTTP响应的头部写到套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headers</span><span class="params">(<span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//filename没用上，可以根据文件类型设置Content-Type字段</span></span><br><span class="line">    (<span class="keyword">void</span>)filename;  <span class="comment">/* could use filename to determine file type */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, SERVER_STRING);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">"\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Give a client a 404 not found status message. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//向客户端发送404的响应报文，表明找不到请求的文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_found</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 404 NOT FOUND\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;BODY&gt;&lt;P&gt;The server could not fulfill\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"your request because the resource specified\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"is unavailable or nonexistent.\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;/BODY&gt;&lt;/HTML&gt;\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Send a regular file to the client.  Use headers, and report</span></span><br><span class="line"><span class="comment"> * errors to client if they occur.</span></span><br><span class="line"><span class="comment"> * Parameters: a pointer to a file structure produced from the socket</span></span><br><span class="line"><span class="comment"> *              file descriptor</span></span><br><span class="line"><span class="comment"> *             the name of the file to serve */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//调用cat把服务器文件返回给客户端</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_file</span><span class="params">(<span class="keyword">int</span> client, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *resource = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> numchars = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先给buf随便写入一个'\0'结尾的字符串，因为下一行调用strcmp时，如果strcmp在buf中找不到结束符，可能会发生不可预料的错误，strcmp可能会一直向后比较，超出buf的空间范围，直到找到一个结束符为止</span></span><br><span class="line">    <span class="comment">//随便往buf里写什么都无所谓，反正在get_line函数里都会被覆盖掉</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">'A'</span>; buf[<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//都已经知道请求的文件路径了，套接口接收缓冲里面剩下的东西就没用了，直接清空，大概是一些header相关的数据</span></span><br><span class="line">    <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"\n"</span>, buf))  <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">        numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    resource = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="comment">//难道stat函数会出错？为什么还要判断一次文件存不存在？</span></span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="literal">NULL</span>)</span><br><span class="line">        not_found(client);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把报文头和文件内容发送到套接口的发送缓冲</span></span><br><span class="line">        headers(client, filename);</span><br><span class="line">        cat(client, resource);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* This function starts the process of listening for web connections</span></span><br><span class="line"><span class="comment"> * on a specified port.  If the port is 0, then dynamically allocate a</span></span><br><span class="line"><span class="comment"> * port and modify the original port variable to reflect the actual</span></span><br><span class="line"><span class="comment"> * port.</span></span><br><span class="line"><span class="comment"> * Parameters: pointer to variable containing the port to connect on</span></span><br><span class="line"><span class="comment"> * Returns: the socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//初始化httpd服务，包括建立套接字、绑定端口、进行监听等</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startup</span><span class="params">(u_short *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接受socket的返回值</span></span><br><span class="line">    <span class="keyword">int</span> httpd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//网络通信的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="comment">//第一个参数是地址族，也就是IP地址类型，PF_INET表示IPv4地址。在windows中AF_INET与PF_INET完全一样，AF是Address Family的意思，PF是Protocol Family的意思，二者在linux或unix系统中可能有微小差别。</span></span><br><span class="line">    <span class="comment">//第二个参数是通信类型，SOCK_STREAM表示流格式套接字，采用TCP协议进行传输。另一个选择是SOCK_DGRAM，表示数据报格式套接字，采用UDP协议传输。</span></span><br><span class="line">    <span class="comment">//第三个参数是需要使用的协议，可以显式指定IPPROTO_TCP或IPPROTO_UDP，如果是0则根据前两个参数使用默认的协议。但是如果有多种协议支持给定的地址族和通信类型，系统就无法确定默认的协议。</span></span><br><span class="line">    <span class="comment">//返回值是一个文件描述符，用于唯一标识一个socket。成功时返回非负整数值，失败时返回-1。文件描述符是一个非负整数，相当于系统给文件创造的索引值，比如0,1,2分别表示标准输入、标准输出、标准错误</span></span><br><span class="line">    httpd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果创建失败就向系统报错</span></span><br><span class="line">    <span class="keyword">if</span> (httpd == <span class="number">-1</span>)</span><br><span class="line">        error_die(<span class="string">"socket"</span>);</span><br><span class="line">    <span class="comment">//地址的所有字段初始化为0</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));</span><br><span class="line">    <span class="comment">//设置地址的协议族字段，在socket编程中只能是AF_INET</span></span><br><span class="line">    name.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//设置地址的端口号。htons函数用于将整型变量从主机字节顺序转变成big-endian的网络字节顺序，网络字节顺序是TCP/IP中规定好的一种系统无关的数据表示格式</span></span><br><span class="line">    <span class="comment">//htons用于转换2个字节的整数，而main函数中定义的port恰好是2个字节的u_short类型</span></span><br><span class="line">    name.sin_port = htons(*port);</span><br><span class="line">    <span class="comment">//设置ip地址。htonl和htons功能相同，用于转换4个字节的整数。INADDR_ANY表示通配地址(0.0.0.0)，也就是服务器上所有的网卡，不管是哪个网卡接收到的数据，只要端口匹配上就进行处理</span></span><br><span class="line">    name.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//setsockopt用于设置与套接字关联的选项</span></span><br><span class="line">    <span class="comment">//第一个参数是配置选项的目标套接字描述符</span></span><br><span class="line">    <span class="comment">//第二个参数是被设置的选项的级别，SOL_SOCKET表示通用套接字选项</span></span><br><span class="line">    <span class="comment">//第三个参数是被设置的选项名，SO_REUSEADDR选项控制的是打开或关闭端口复用功能</span></span><br><span class="line">    <span class="comment">//第四个参数是设置的选项值，on=1表示打开端口复用功能</span></span><br><span class="line">    <span class="comment">//第五个参数是选项值的长度</span></span><br><span class="line">    <span class="comment">//成功返回0。失败返回-1</span></span><br><span class="line">    <span class="comment">//在调用bind之前一般都要打开SO_REUSEADDR选项，允许端口复用，也就是允许多个套接字绑定在同一个端口上</span></span><br><span class="line">    <span class="keyword">if</span> ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on))) &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        error_die(<span class="string">"setsockopt failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bind绑定套接字和本地地址，成功返回0。失败返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (bind(httpd, (struct sockaddr *)&amp;name, <span class="keyword">sizeof</span>(name)) &lt; <span class="number">0</span>)</span><br><span class="line">        error_die(<span class="string">"bind"</span>);</span><br><span class="line">    <span class="comment">//端口号0是一种由系统指定动态生成的端口，如果把端口参数设为0，操作系统就会从动态端口号范围内搜索接下来可以使用的端口号</span></span><br><span class="line">    <span class="keyword">if</span> (*port == <span class="number">0</span>)  <span class="comment">/* if dynamically allocating a port */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//socklen_t其实就是int的别名</span></span><br><span class="line">        <span class="keyword">socklen_t</span> namelen = <span class="keyword">sizeof</span>(name);</span><br><span class="line">        <span class="comment">//getsockname返回与给定套接字关联的本地协议地址，获取的地址存储在name中。在以端口号0调用bind后，getsockname用于返回内核赋予的本地端口号。</span></span><br><span class="line">        <span class="comment">//成功返回0。失败返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span>)</span><br><span class="line">            error_die(<span class="string">"getsockname"</span>);</span><br><span class="line">        <span class="comment">//从系统分配的地址中解析出端口号赋给指针port</span></span><br><span class="line">        *port = ntohs(name.sin_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上的操作是在创建和配置套接字，也就是一个套接口的描述字，listen函数才是真正创建一个可接受连接的套接口，并监听申请的连接</span></span><br><span class="line">    <span class="comment">//第二个参数5表示等待连接队列的最大长度</span></span><br><span class="line">    <span class="comment">//创建成功返回0。失败返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (listen(httpd, <span class="number">5</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        error_die(<span class="string">"listen"</span>);</span><br><span class="line">    <span class="comment">//返回套接字</span></span><br><span class="line">    <span class="keyword">return</span>(httpd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that the requested web method has not been</span></span><br><span class="line"><span class="comment"> * implemented.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">//向客户端发送501的响应报文，表明收到的HTTP请求所用的method不被支持</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unimplemented</span><span class="params">(<span class="keyword">int</span> client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 501 Method Not Implemented\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;/TITLE&gt;&lt;/HEAD&gt;\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"&lt;/BODY&gt;&lt;/HTML&gt;\r\n"</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_sock = <span class="number">-1</span>;</span><br><span class="line">    u_short port = <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">int</span> client_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_name</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>  client_name_len = <span class="keyword">sizeof</span>(client_name);</span><br><span class="line">    <span class="comment">//linux下的pthread_t其实是unsigned long int的别名，代表线程的标识符</span></span><br><span class="line">    <span class="keyword">pthread_t</span> newthread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化服务，获取套接字</span></span><br><span class="line">    server_sock = startup(&amp;port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"httpd running on port %d\n"</span>, port);</span><br><span class="line">    <span class="comment">//死循环监听连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//accept函数从server_sock的等待连接队列中抽取第一个连接，创建一个与server_sock同类的新的套接口</span></span><br><span class="line">        <span class="comment">//返回值是一个新的套接字描述符，这个socket包含的是客户端的ip和port信息，代表的是和客户端的新的连接</span></span><br><span class="line">        <span class="comment">//client_name用于存储客户端的地址。client_name_len在调用函数时被设置为client_name结构体的长度，accept函数会根据client_name_len值的大小往client_name所指向的地址里写信息，当写入完成后，client_name_len会被重新设置为client_name中实际地址信息的长度</span></span><br><span class="line">        <span class="comment">//成功时返回非负整数值，失败时返回-1</span></span><br><span class="line">        <span class="comment">//所以server_sock仅仅用来监听新的连接，每次接收到新的连接都会创建新的socket来与客户端通信</span></span><br><span class="line">        client_sock = accept(server_sock,</span><br><span class="line">                (struct sockaddr *)&amp;client_name,</span><br><span class="line">                &amp;client_name_len);</span><br><span class="line">        <span class="keyword">if</span> (client_sock == <span class="number">-1</span>)</span><br><span class="line">            <span class="comment">//客户端建立连接失败就退出整个程序，why？</span></span><br><span class="line">            error_die(<span class="string">"accept"</span>);</span><br><span class="line">        <span class="comment">/* accept_request(&amp;client_sock); */</span></span><br><span class="line">        <span class="comment">//pthread_create用于创建线程</span></span><br><span class="line">        <span class="comment">//第一个参数是指向线程标识符的指针</span></span><br><span class="line">        <span class="comment">//第二个参数用来设置线程属性，NULL表示使用默认属性</span></span><br><span class="line">        <span class="comment">//第三个参数是线程所执行的函数的起始地址</span></span><br><span class="line">        <span class="comment">//第四个参数默认为NULL，若上述函数需要参数，则在此设置函数参数的地址</span></span><br><span class="line">        <span class="comment">//线程创建成功时返回0，创建失败则返回出错编号，反正不是0</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;newthread , <span class="literal">NULL</span>, (<span class="keyword">void</span> *)accept_request, (<span class="keyword">void</span> *)(<span class="keyword">intptr_t</span>)client_sock) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//线程创建失败只报错，不退出程序，相当于丢弃这个客户端连接</span></span><br><span class="line">            perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//close函数用于关闭文件，因为套接字的描述符本质上就是个文件描述符，所以close可以用来关闭套接口</span></span><br><span class="line">    <span class="comment">//上面的死循环没有break，error_die直接退出程序，按理说应该不会执行到这一行呀？？？</span></span><br><span class="line">    close(server_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="simpleclient-c"><a href="#simpleclient-c" class="headerlink" title="simpleclient.c"></a>simpleclient.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">    address.sin_port = htons(<span class="number">9734</span>);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    result = connect(sockfd, (struct sockaddr *)&amp;address, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"oops: client1"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    read(sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char from server = %c\n"</span>, ch);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="https://shivakasu.cn/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="webserver" scheme="https://shivakasu.cn/tags/webserver/"/>
    
      <category term="网络编程" scheme="https://shivakasu.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读(更新中)</title>
    <link href="https://shivakasu.cn/2020/06/20/redis0/"/>
    <id>https://shivakasu.cn/2020/06/20/redis0/</id>
    <published>2020-06-20T10:41:20.000Z</published>
    <updated>2020-07-04T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><ul><li>redis版本：2.2.15</li><li>看的很老的版本，因为代码少 v^^7</li><li>阅读顺序参考自博文 <a href="https://blog.csdn.net/terence1212/article/details/53541908" target="_blank" rel="noopener">https://blog.csdn.net/terence1212/article/details/53541908</a></li></ul><h1 id="2-数据结构相关"><a href="#2-数据结构相关" class="headerlink" title="2 数据结构相关"></a>2 数据结构相关</h1><h2 id="2-1-内存分配"><a href="#2-1-内存分配" class="headerlink" title="2.1 内存分配"></a>2.1 内存分配</h2><h3 id="config-h"><a href="#config-h" class="headerlink" title="config.h"></a>config.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;AvailabilityMacros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use tcmalloc's malloc_size() when available.</span></span><br><span class="line"><span class="comment"> * When tcmalloc is used, native OSX malloc_size() may never be used because</span></span><br><span class="line"><span class="comment"> * this expects a different allocation scheme. Therefore, *exclusively* use</span></span><br><span class="line"><span class="comment"> * either tcmalloc or OSX's malloc_size()! */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果系统中存在Google的TC_MALLOC库，redis_malloc_size函数就当做tc_malloc_size函数使用</span></span><br><span class="line"><span class="comment">//tc_malloc比原始的malloc性能好</span></span><br><span class="line"><span class="comment">//redis_malloc_size的功能是获得参数p所指向的内存块的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TC_VERSION_MAJOR &gt;= 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6</span></span><br><span class="line"><span class="comment">//HAVE_MALLOC_SIZE用来标记是否定义了redis_malloc_size函数</span></span><br><span class="line"><span class="comment">//可是为什么不直接检查redis_malloc_size是否存在，还要额外定义一个标记呢？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_malloc_size(p) tc_malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//或者，如果系统是Mac系统，那么redis_malloc_size函数就当做原始的malloc_size函数使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_malloc_size(p) malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define redis_fstat to fstat or fstat64() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) &amp;&amp; !defined(MAC_OS_X_VERSION_10_6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_fstat fstat64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_stat stat64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_fstat fstat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> redis_stat stat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for proc filesystem */</span></span><br><span class="line"><span class="comment">//如果是linux系统，当前文件系统就是procfs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_PROCFS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for task_info() */</span></span><br><span class="line"><span class="comment">//如果是unix系统，就可以使用task_info，macos是基于unix的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_TASKINFO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for backtrace() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__linux__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_BACKTRACE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* test for polling API */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_EPOLL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(__APPLE__) &amp;&amp; defined(MAC_OS_X_VERSION_10_6)) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__NetBSD__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_KQUEUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define aof_fsync to fdatasync() in Linux and fsync() for all the rest */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fdatasync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aof_fsync fsync</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="zmalloc-c"><a href="#zmalloc-c" class="headerlink" title="zmalloc.c"></a>zmalloc.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zmalloc - total amount of allocated memory aware version of malloc()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//redis是基于内存的数据库，所以内存管理很重要。</span></span><br><span class="line"><span class="comment">//redis把C语言的内存分配函数封装成zmalloc、zfree等z开头的函数，来屏蔽各底层平台的差异。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果定义了HAVE_MALLOC_SIZE，即定义了redis_malloc_size函数，PREFIX_SIZE就是0</span></span><br><span class="line"><span class="comment">//PREFIX_SIZE用于在分配到的的空间头部存储原本申请空间的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//如果没有定义HAVE_MALLOC_SIZE，且当前系统是Solaris，PREFIX_SIZE就是long long类型的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//否则，PREFIX_SIZE就是size_t的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Explicitly override malloc/free etc when using tcmalloc. */</span></span><br><span class="line"><span class="comment">//如果使用了tcmalloc库，就用tcmalloc库函数替换原始的malloc库函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) tc_malloc(size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calloc(count,size) tc_calloc(count,size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> realloc(ptr,size) tc_realloc(ptr,size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free(ptr) tc_free(ptr)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//update_zmalloc_stat_alloc用于在分配内存的时候更新已分配大小</span></span><br><span class="line"><span class="comment">//__n是实际分配到的空间大小，__size是程序原本请求的空间大小</span></span><br><span class="line"><span class="comment">//__size应该是改了代码以后忘记删掉的参数</span></span><br><span class="line"><span class="comment">//使用do-while(0)封装成代码块，防止宏定义展开的时候出问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n,__size) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="comment">//64位系统中，sizeof(long)通常是8</span></span><br><span class="line">    <span class="comment">//malloc分配的内存是8字节对齐的，如果请求分配的内存不是8的倍数，那么malloc就会多分配一点来凑成8的倍数</span></span><br><span class="line">    <span class="comment">//如果_n值不是内存分配单元(sizeof(long))的整数倍，说明当前分配的内存大小有碎片，为了与malloc的实际结果匹配，需要补齐到8的整数倍</span></span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</span><br><span class="line">        <span class="comment">//如果要考虑线程安全，先加锁再修改used_memory</span></span><br><span class="line">        pthread_mutex_lock(&amp;used_memory_mutex);  \</span><br><span class="line">        used_memory += _n; \</span><br><span class="line">        pthread_mutex_unlock(&amp;used_memory_mutex); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        <span class="comment">//不考虑线程安全时，直接修改used_memory</span></span><br><span class="line">        used_memory += _n; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//update_zmalloc_stat_free用于释放已经分配的空间</span></span><br><span class="line"><span class="comment">//__n是待释放的空间大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</span><br><span class="line">        pthread_mutex_lock(&amp;used_memory_mutex);  \</span><br><span class="line">        used_memory -= _n; \</span><br><span class="line">        pthread_mutex_unlock(&amp;used_memory_mutex); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        used_memory -= _n; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配得到的内存大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//是否要考虑线程安全，默认不考虑</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//保证线程安全的锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//oom的错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把错误信息输出到stderr流文件中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    <span class="comment">//刷新缓冲，把stderr中的数据发给错误输出设备</span></span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="comment">//终止当前进程，但不清理任何对象</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 是分配的内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际多申请了PREFIX_SIZE大小的空间</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line">    <span class="comment">// 如果分配失败，调用zmalloc_oom函数打印oom的错误信息，然后退出进程</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">//如果已经定义了redis_malloc_size函数，直接计算ptr的实际大小，然后更新used_memory</span></span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(ptr),size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//否则，先在分配到的空间的第一个字长处保存住原本请求的空间大小size</span></span><br><span class="line">    <span class="comment">//然后只能默认size+PREFIX_SIZE是已分配的大小(大概没有malloc_size算出来的靠谱)，更新used_memory</span></span><br><span class="line">    <span class="comment">//多申请的PREFIX_SIZE空间就是用来存储size的，所以当定义了redis_malloc_size函数时PREFIX_SIZE就是0，因为已经不需要存储size了</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对calloc的封装，更新了used_memory</span></span><br><span class="line"><span class="comment">//调用calloc时，第一个参数固定为1，所以每次只会分配一个size+PREFIX_SIZE大小的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(ptr),size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对realloc的封装，重新分配内存，重置并更新了used_memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = redis_malloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom(size);</span><br><span class="line"></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(redis_malloc_size(newptr),size);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom(size);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(size,size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对free的封装，重置了used_memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(redis_malloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对strdup的封装，复制一个字符串到新的内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前的used_memory</span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) pthread_mutex_lock(&amp;used_memory_mutex);</span><br><span class="line">    um = used_memory;</span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) pthread_mutex_unlock(&amp;used_memory_mutex);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在vm.c中被调用，当系统支持多线程时，要保证线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_enable_thread_safeness</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zmalloc_thread_safe = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the RSS information in an OS-specific way.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: the function zmalloc_get_rss() is not designed to be fast</span></span><br><span class="line"><span class="comment"> * and may not be called in the busy loops where Redis tries to release</span></span><br><span class="line"><span class="comment"> * memory expiring or swapping out objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For this kind of "fast RSS reporting" usages use instead the</span></span><br><span class="line"><span class="comment"> * function RedisEstimateRSS() that is a much faster (and less precise)</span></span><br><span class="line"><span class="comment"> * version of the funciton. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//zmalloc_get_rss用于获取当前进程实际所驻留在内存中的空间大小</span></span><br><span class="line"><span class="comment">//rss全称是Resident Set Size，即驻留集。因为程序申请的内存空间不会全部常驻于内存，系统会把其中暂时不用的部分从内存中置换到swap区，所以rss表示的就是不包括swap区的实际驻留在内存中的空间大小</span></span><br><span class="line"><span class="comment">//在linux系统中，可以通过读取/proc/pid/stat文件获取，该文件的第24个字段是rss的信息，pid为当前进程的进程号。读取到的不是byte数，而是内存页数。通过系统调用sysconf(_SC_PAGESIZE)可以获得当前系统的内存页大小。</span></span><br><span class="line"><span class="comment">//Unix系统可以直接通过task_info直接获取rss，比linux系统简单的多。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是linux的procfs文件系统，就读取/proc/pid/stat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PROCFS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">//获取内存页大小</span></span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">size_t</span> rss;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//snprintf的作用是把stat文件的绝对路径复制到filename</span></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">"/proc/%d/stat"</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为什么只读4096个字符呢？</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    <span class="comment">//第24个字段是rss的信息，所以找到第23个空格，后面就是rss</span></span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串转换成10进制的数</span></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    rss *= page;</span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是unix系统，就使用task_info获取rss</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAVE_TASKINFO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">task_t</span> task = MACH_PORT_NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_basic_info</span> <span class="title">t_info</span>;</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> t_info_count = TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task_for_pid(current_task(), getpid(), &amp;task) != KERN_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    task_info(task, TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>)&amp;t_info, &amp;t_info_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t_info.resident_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">size_t</span> zmalloc_get_rss(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">/* If we can't get the RSS in an OS-specific way for this system just</span></span><br><span class="line"><span class="comment">     * return the memory usage we estimated in zmalloc()..</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Fragmentation will appear to be always 1 (no fragmentation)</span></span><br><span class="line"><span class="comment">     * of course... */</span></span><br><span class="line">    <span class="comment">//获取不到rss，说明当前系统就不用考虑碎片</span></span><br><span class="line">    <span class="keyword">return</span> zmalloc_used_memory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fragmentation = RSS / allocated-bytes */</span></span><br><span class="line"><span class="comment">//获得进程的RSS后，可以计算目前的内存碎片率，直接用rss除以used_memory。rss包含进程的所有内存使用，包括代码，共享库，堆栈等。但是由于通常情况下redis在内存中数据的量要远远大于这些数据所占用的内存，因此这个简单的计算还是比较准确的。</span></span><br><span class="line"><span class="comment">//之所以会产生碎片，是因为malloc并不是严格按照参数的值来分配内存。比如程序只请求一个byte的内存，malloc通常会基于内存对齐等方面的考虑而分配4个byte。malloc进行小内存分配是很浪费的，浪费的空间因为用不上就不会在rss中</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)zmalloc_get_rss()/zmalloc_used_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-动态字符串"><a href="#2-2-动态字符串" class="headerlink" title="2.2 动态字符串"></a>2.2 动态字符串</h2><h3 id="sds-h"><a href="#sds-h" class="headerlink" title="sds.h"></a>sds.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDSLib, A C dynamic strings library</span></span><br><span class="line"><span class="comment">//比起 C 字符串， SDS 具有以下优点：常数复杂度获取字符串长度，杜绝缓冲区溢出，减少修改字符串长度时所需的内存重分配次数，二进制安全，兼容部分 C 字符串函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SDS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SDS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//记录buf数组中已使用字节的数量，有效字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="comment">//C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存，所以sizeof(struct sdshdr)==8。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果用的gcc编译器，需要提醒编译器检查可变参数的类型或者个数是否正确</span></span></span><br><span class="line"><span class="function">    __<span class="title">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="sds-c"><a href="#sds-c" class="headerlink" title="sds.c"></a>sds.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDSLib, A C dynamic strings library</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_ABORT_ON_OOM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sds.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//oom错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sdsOomAbort</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"SDS: Out Of Memory (SDS_ABORT_ON_OOM defined)\n"</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据初始化的字符串init和给定的字符串长度initlen，创建新的sdshdr</span></span><br><span class="line"><span class="comment">//const void *init表示可以修改指针本身的指向，但不能修改指针指向的内容</span></span><br><span class="line"><span class="comment">//void * const init指的才是不能修改指针本身</span></span><br><span class="line"><span class="comment">//返回值类型sds定义成了char指针的别名</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//buf数组不被计算在sizeof里，所以initlen要单独加上，再多分配一个字节给'\0'</span></span><br><span class="line">    sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//已经明确define过SDS_ABORT_ON_OOM了还做判断，莫名其妙</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//内存分配失败就报oom的error</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据initlen把init复制到sh的buf数组中</span></span><br><span class="line">    <span class="keyword">if</span> (initlen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (init) <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,initlen);</span><br><span class="line">    &#125;</span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">//返回的是buf数组而不是结构体</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成只包含'\0'的空的sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定字符串init并调用sdsnewlen，来创建sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回sdshdr结构体中len字段的值</span></span><br><span class="line"><span class="keyword">size_t</span> sdslen(<span class="keyword">const</span> sds s) &#123;</span><br><span class="line">    <span class="comment">//参数s是sdshdr结构体末尾的buf数组的指针，需要重建sdshdr结构体才能得到len字段的值</span></span><br><span class="line">    <span class="comment">//给结构体分配的内存空间是连续的，因此只需要将s指针回退一段距离就是原始结构体的头地址，回退的长度是len和free两个字段的大小，也就是sizeof(struct sdshdr)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定buf数组创建新的sdshdr，相当于复制原始的sdshdr</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放sdshdr对象的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//s指针回退得到指向sdshdr对象头部的指针，调用zfree释放空间</span></span><br><span class="line">    zfree(s-<span class="keyword">sizeof</span>(struct sdshdr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回sdshdr结构体中free字段的值</span></span><br><span class="line"><span class="keyword">size_t</span> sdsavail(sds s) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据buf数组的内容调整len和free的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到结构体对象的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="comment">//计算真实长度</span></span><br><span class="line">    <span class="keyword">int</span> reallen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">//根据真实长度调整free和len</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> += (sh-&gt;len-reallen);</span><br><span class="line">    sh-&gt;len = reallen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使buf数组有足够的额外空间容纳addlen个字节的数据</span></span><br><span class="line"><span class="comment">//静态函数，只能本文件内调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若剩余空间已经足够，不做修改直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//实际分配的数组大小是申请的两倍，减少可能的重分配次数</span></span><br><span class="line">    newlen = (len+addlen)*<span class="number">2</span>;</span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//空间不足报oom的error</span></span><br><span class="line">    <span class="comment">//空间不足为什么不试试只申请len+addlen的空间呢？</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//len是不变的，扩容只是增加free</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grow the sds to have the specified length. Bytes that were not part of</span></span><br><span class="line"><span class="comment"> * the original length of the sds will be set to zero. */</span></span><br><span class="line"><span class="comment">//将buf数组扩容到指定长度，指定len字段的值，并用0填充新空间</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen, curlen = sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若目标长度比当前长度小，就不用了扩容了</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//实际增加的长度是(curlen+len-curlen)*2==len*2</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure added region doesn't contain garbage */</span></span><br><span class="line">    sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//增加了2个len长度，实际只对一个len长度填充0</span></span><br><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span><br><span class="line">    totlen = sh-&gt;len+sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//指定len字段的值</span></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">//这个free值有什么意义？</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-sh-&gt;len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长度为len的字符串t追加到sdshdr的有效字符串末尾</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先对buf数组扩容</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="comment">//返回NULL表示空间不足</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">//从有效字符串的末尾开始，将长度为len的字符串t复制到指针指向的位置</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="comment">//有效字符串长度增加len</span></span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    <span class="comment">//剩余空间减少len</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求个字符串长度而已，多此一举</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用长度为len的字符串t从头覆盖buf数组</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;</span><br><span class="line">        <span class="comment">//若buf数组长度比要存的字符串短，先扩容，但是扩容的长度不是与buf数组总长度的差，而是与有效字符串长度的差</span></span><br><span class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从buf数组头部开始覆盖</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span><br><span class="line">    <span class="comment">//标记新有效字符串的末尾</span></span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">//后面存的是什么都无所谓了，反正都算free</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样的多此一举</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把ap里的所有参数格式化后拼接到buf数组s的后面</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    va_list cpy;</span><br><span class="line">    <span class="keyword">char</span> *buf, *t;</span><br><span class="line">    <span class="comment">//缓冲区初始长度设为16</span></span><br><span class="line">    <span class="keyword">size_t</span> buflen = <span class="number">16</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        buf = zmalloc(buflen);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//缓冲区的倒数第二位设为结束符</span></span><br><span class="line">        <span class="comment">//为什么不是最后一位？</span></span><br><span class="line">        buf[buflen<span class="number">-2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">//把ap指针复制到cpy，之后回到sdscatprintf函数里ap指针还要free掉，所以这里不能直接用</span></span><br><span class="line">        va_copy(cpy,ap);</span><br><span class="line">        <span class="comment">//把可变参数表格式化并输出到缓冲区</span></span><br><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span><br><span class="line">        <span class="comment">//如果缓冲区的结束符被覆盖了，说明缓冲区长度不够，直接free掉，加大长度重新zmalloc</span></span><br><span class="line">        <span class="keyword">if</span> (buf[buflen<span class="number">-2</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            zfree(buf);</span><br><span class="line">            buflen *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把缓冲区数据追加到s末尾</span></span><br><span class="line">    t = sdscat(s, buf);</span><br><span class="line">    zfree(buf);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据fmt格式化参数列表，结果追加到s末尾并返回。使用了可变参数，所以要在&lt;sds.h&gt;中提示编译器检查可变参数</span></span><br><span class="line"><span class="comment">//s只是作为一个容器而已，原本的内容不会被修改</span></span><br><span class="line"><span class="comment">//va_开头的是&lt;stdarg.h&gt;中定义的结构和函数</span></span><br><span class="line"><span class="comment">//va_list是用于存放参数列表的结构，实际上是char*的别名，通过移动指针取参数</span></span><br><span class="line"><span class="comment">//va_start函数根据fmt指针来初始化参数列表ap，其实就是让ap指向可变参数表里面的第一个参数。因为fmt是紧挨着可变参数表的前一个参数，所以就让ap指向fmt后面的第一个参数</span></span><br><span class="line"><span class="comment">//va_end函数负责清理参数列表，因为ap是字符指针，所以最后需要释放</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("Sum is: ");</span></span><br><span class="line"><span class="comment"> * s = sdscatprintf(s,"%d+%d = %d",a,b,a+b)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    t = sdscatvprintf(s,fmt,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从s数组左右两端分别移除所有在cset字符串中出现过的字符，也就是保证s两端的两个字符不在cset中</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s,"Aa. :");  =&gt; "Hello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头标记和尾标记设为s的两端</span></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//两端分别逐位判断字符是否在cset中，一旦匹配失败就退出</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//用sp到ep的子串从头覆盖buf数组，因为是子串所以不用判断溢出</span></span><br><span class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</span><br><span class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用s中start到end的子串覆盖原始的s</span></span><br><span class="line"><span class="comment">/* Example:</span></span><br><span class="line"><span class="comment"> * s = sdsnew("Hello World");</span></span><br><span class="line"><span class="comment"> * sdsrange(s,1,-1); =&gt; "ello World"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> newlen, len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//先把负下标换成正数</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start = len+start;</span><br><span class="line">        <span class="comment">//负过头了就归0</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        end = len+end;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子串的长度</span></span><br><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newlen != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//若start超出buf的有效字符串长度，则子串不存在，长度设为0</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            newlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若end越界超出buf的有效字符串长度，则退回到有效字符串末尾</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            end = len<span class="number">-1</span>;</span><br><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用子串覆盖buf数组</span></span><br><span class="line">    <span class="keyword">if</span> (start &amp;&amp; newlen) memmove(sh-&gt;buf, sh-&gt;buf+start, newlen);</span><br><span class="line">    <span class="comment">//结束符为什么不是'\0'</span></span><br><span class="line">    sh-&gt;buf[newlen] = <span class="number">0</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-newlen);</span><br><span class="line">    sh-&gt;len = newlen;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组转小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">tolower</span>(s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组转大写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">toupper</span>(s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(sds s1, sds s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l1, l2, minlen;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">    l1 = sdslen(s1);</span><br><span class="line">    l2 = sdslen(s2);</span><br><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span><br><span class="line">    cmp = <span class="built_in">memcmp</span>(s1,s2,minlen);</span><br><span class="line">    <span class="comment">//相等应该直接返回0，为什么多此一举非要算出个0？</span></span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> l1-l2;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split 's' with separator in 'sep'. An array</span></span><br><span class="line"><span class="comment"> * of sds strings is returned. *count will be set</span></span><br><span class="line"><span class="comment"> * by reference to the number of tokens returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On out of memory, zero length string, zero length</span></span><br><span class="line"><span class="comment"> * separator, NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that 'sep' is able to split a string using</span></span><br><span class="line"><span class="comment"> * a multi-character separator. For example</span></span><br><span class="line"><span class="comment"> * sdssplit("foo_-_bar","_-_"); will return two</span></span><br><span class="line"><span class="comment"> * elements "foo" and "bar".</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This version of the function is binary-safe but</span></span><br><span class="line"><span class="comment"> * requires length arguments. sdssplit() is just the</span></span><br><span class="line"><span class="comment"> * same function but for zero-terminated strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用分隔符(字符串)sep分割字符串s，返回一个sds数组，同时count存放分割后子串数量，因为是指针所以能修改数值</span></span><br><span class="line"><span class="comment">//len是s的长度，seplen是sep的长度</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>, slots = <span class="number">5</span>, start = <span class="number">0</span>, j;</span><br><span class="line">    <span class="comment">//slots是预设的子串数量，因为要申请空间所以要先预设，不够再扩容</span></span><br><span class="line">    <span class="comment">//sds本身是char*，所以tokens实际上是指针数组的指针</span></span><br><span class="line">    sds *tokens = zmalloc(<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">    <span class="comment">//空间不足就返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">NULL</span>) sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span> || tokens == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//s为空，则返回空的tokens，count设为0</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (len-(seplen<span class="number">-1</span>)); j++) &#123;</span><br><span class="line">        <span class="comment">/* make sure there is room for the next element and the final one */</span></span><br><span class="line">        <span class="comment">//tokens数组要有至少存放两个sds的空位，不够就扩容成两倍</span></span><br><span class="line">        <span class="comment">//因为后面在循环体内部要存入一个sds，又因为循环下标截止到len-(seplen-1)，循环结束后还会存入最后一个sds，所以要预留两个空位</span></span><br><span class="line">        <span class="keyword">if</span> (slots &lt; elements+<span class="number">2</span>) &#123;</span><br><span class="line">            sds *newtokens;</span><br><span class="line"></span><br><span class="line">            slots *= <span class="number">2</span>;</span><br><span class="line">            newtokens = zrealloc(tokens,<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line">            <span class="comment">//若空间不足扩容失败，报错并释放tokens指针</span></span><br><span class="line">            <span class="keyword">if</span> (newtokens == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            tokens = newtokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* search the separator */</span></span><br><span class="line">        <span class="comment">//sep只有一个字符时直接比较，有多个字符时用memcmp比较</span></span><br><span class="line">        <span class="keyword">if</span> ((seplen == <span class="number">1</span> &amp;&amp; *(s+j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s+j,sep,seplen) == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//构造新的sds，空间不足就退出</span></span><br><span class="line">            tokens[elements] = sdsnewlen(s+start,j-start);</span><br><span class="line">            <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下标加一</span></span><br><span class="line">            elements++;</span><br><span class="line">            start = j+seplen;</span><br><span class="line">            j = j+seplen<span class="number">-1</span>; <span class="comment">/* skip the separator */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add the final element. We are sure there is room in the tokens array. */</span></span><br><span class="line">    <span class="comment">//存入最后一个子串</span></span><br><span class="line">    tokens[elements] = sdsnewlen(s+start,len-start);</span><br><span class="line">    <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line">                sdsOomAbort();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    elements++;</span><br><span class="line">    *count = elements;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SDS_ABORT_ON_OOM</span></span><br><span class="line"><span class="comment">//tokens是指针数组的指针，所以tokens指针和其内部的指针元素要分别释放</span></span><br><span class="line">cleanup:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) sdsfree(tokens[i]);</span><br><span class="line">        zfree(tokens);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和cleanup基本重复了，如果sdssplitlen里直接用count计数而不用额外的elements计数，就能合并了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tokens) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">        sdsfree(tokens[count]);</span><br><span class="line">    zfree(tokens);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长整型数据转成字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//buf和p的作用重复了，没必要</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>], *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">    v = (value &lt; <span class="number">0</span>) ? -value : value;</span><br><span class="line">    <span class="comment">//其实long long int最长就20位，没必要留这么多位置</span></span><br><span class="line">    <span class="comment">//从后往前赋值，最后p就指向了字符串头部</span></span><br><span class="line">    p = buf+<span class="number">31</span>; <span class="comment">/* point to the last character */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *p-- = <span class="string">'0'</span>+(v%<span class="number">10</span>);</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) *p-- = <span class="string">'-'</span>;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="comment">//指定p和p的长度创建sds</span></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(p,<span class="number">32</span>-(p-buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将长度为len的字符串p以带引号的格式追加到s的末尾，也就是添加引用字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s末尾添加'"'，作为引用字符串的开头</span></span><br><span class="line">    s = sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">        <span class="comment">//把non-printable characters转换成printable characters</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">            s = sdscatprintf(s,<span class="string">"\\%c"</span>,*p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>: s = sdscatlen(s,<span class="string">"\\n"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>: s = sdscatlen(s,<span class="string">"\\r"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>: s = sdscatlen(s,<span class="string">"\\t"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\a'</span>: s = sdscatlen(s,<span class="string">"\\a"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\b'</span>: s = sdscatlen(s,<span class="string">"\\b"</span>,<span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//isprint判断是否为printable character</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isprint</span>(*p))</span><br><span class="line">                s = sdscatprintf(s,<span class="string">"%c"</span>,*p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//不可打印的用两位十六进制字符串表示</span></span><br><span class="line">                s = sdscatprintf(s,<span class="string">"\\x%02x"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后添加'"'，作为引用字符串的结束</span></span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Helper function for sdssplitargs() that returns non zero if 'c'</span></span><br><span class="line"><span class="comment"> * is a valid hex digit. */</span></span><br><span class="line"><span class="comment">//判断一个给定字符是否是十六进制数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_hex_digit</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) ||</span><br><span class="line">           (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Helper function for sdssplitargs() that converts an hex digit into an</span></span><br><span class="line"><span class="comment"> * integer from 0 to 15 */</span></span><br><span class="line"><span class="comment">//把单个十六进制字符转换为相应的十进制数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex_digit_to_int</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'1'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>: <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'4'</span>: <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'5'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'6'</span>: <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'7'</span>: <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'8'</span>: <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'9'</span>: <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>: <span class="keyword">case</span> <span class="string">'B'</span>: <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>: <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'d'</span>: <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'E'</span>: <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'f'</span>: <span class="keyword">case</span> <span class="string">'F'</span>: <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split a line into arguments, where every argument can be in the</span></span><br><span class="line"><span class="comment"> * following programming-language REPL-alike form:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * foo bar "newline are supported\n" and "\xff\x00otherstuff"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The number of arguments is stored into *argc, and an array</span></span><br><span class="line"><span class="comment"> * of sds is returned. The caller should sdsfree() all the returned</span></span><br><span class="line"><span class="comment"> * strings and finally zfree() the array itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that sdscatrepr() is able to convert back a string into</span></span><br><span class="line"><span class="comment"> * a quoted string in the same format sdssplitargs() is able to parse.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//命令行解析，argc存放解析后的参数个数</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = line;</span><br><span class="line">    <span class="keyword">char</span> *current = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> **<span class="built_in">vector</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* skip blanks */</span></span><br><span class="line">        <span class="keyword">while</span>(*p &amp;&amp; <span class="built_in">isspace</span>(*p)) p++;</span><br><span class="line">        <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">            <span class="comment">/* get a token */</span></span><br><span class="line">            <span class="keyword">int</span> inq=<span class="number">0</span>; <span class="comment">/* set to 1 if we are in "quotes" */</span></span><br><span class="line">            <span class="keyword">int</span> done=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面已经把current重置成NULL了，这个判断多此一举</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) current = sdsempty();</span><br><span class="line">            <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">                <span class="comment">//双引号内的解析</span></span><br><span class="line">                <span class="comment">//在双引号内部不关心分隔符，读到右双引号才算读完一个参数</span></span><br><span class="line">                <span class="keyword">if</span> (inq) &#123;</span><br><span class="line">                    <span class="comment">//读到一个以'\x'开头的表示两位十六进制整数的字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="string">'x'</span> &amp;&amp;</span><br><span class="line">                                             is_hex_digit(*(p+<span class="number">2</span>)) &amp;&amp;</span><br><span class="line">                                             is_hex_digit(*(p+<span class="number">3</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</span><br><span class="line">                        <span class="comment">//转换成十进制格式的字符串</span></span><br><span class="line">                        byte = (hex_digit_to_int(*(p+<span class="number">2</span>))*<span class="number">16</span>)+</span><br><span class="line">                                hex_digit_to_int(*(p+<span class="number">3</span>));</span><br><span class="line">                        <span class="comment">//追加到current尾部</span></span><br><span class="line">                        current = sdscatlen(current,(<span class="keyword">char</span>*)&amp;byte,<span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//跳过这个十六进制的数，接着读下个字符</span></span><br><span class="line">                        p += <span class="number">3</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="comment">//处理'\'开头的特殊字符</span></span><br><span class="line">                        <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">                        p++;</span><br><span class="line">                        <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'n'</span>: c = <span class="string">'\n'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'r'</span>: c = <span class="string">'\r'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'t'</span>: c = <span class="string">'\t'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'b'</span>: c = <span class="string">'\b'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'a'</span>: c = <span class="string">'\a'</span>; <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: c = *p; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//特殊字符也追加到current尾部，因为都在一个双引号的引用内</span></span><br><span class="line">                        current = sdscatlen(current,&amp;c,<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'"'</span>) &#123;</span><br><span class="line">                        <span class="comment">/* closing quote must be followed by a space */</span></span><br><span class="line">                        <span class="comment">//读到右双引号表示读取完毕，跳出循环，但是与下个参数的分隔符必须是空格，否则报错</span></span><br><span class="line">                        <span class="keyword">if</span> (*(p+<span class="number">1</span>) &amp;&amp; !<span class="built_in">isspace</span>(*(p+<span class="number">1</span>))) <span class="keyword">goto</span> err;</span><br><span class="line">                        done=<span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!*p) &#123;</span><br><span class="line">                        <span class="comment">/* unterminated quotes */</span></span><br><span class="line">                        <span class="comment">//没读到右双引号就读完了，说明命令行参数写错了，报error</span></span><br><span class="line">                        <span class="keyword">goto</span> err;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//剩下的情况就是一般字符，直接追加到current尾部</span></span><br><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//双引号外的解析</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">switch</span>(*p) &#123;</span><br><span class="line">                    <span class="comment">//读到分割符，done=1表示当前参数解析完毕</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\0'</span>:</span><br><span class="line">                        done=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//读到双引号</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                        inq=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">//如果是一般字符，就追加到current尾部，跳出循环开始读下个字符</span></span><br><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没有break就接着读下个字符</span></span><br><span class="line">                <span class="keyword">if</span> (*p) p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* add the token to the vector */</span></span><br><span class="line">            <span class="comment">//事先不知道能解析出多少个参数，只能读到一个就扩容一个空位</span></span><br><span class="line">            <span class="built_in">vector</span> = zrealloc(<span class="built_in">vector</span>,((*argc)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">            <span class="comment">//读出的参数先是保存在current中，再存入vector中</span></span><br><span class="line">            <span class="built_in">vector</span>[*argc] = current;</span><br><span class="line">            (*argc)++;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//返回解析出的参数列表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="comment">//和上面的tokens一样，指针数组的指针要内外分别释放</span></span><br><span class="line">    <span class="keyword">while</span>((*argc)--)</span><br><span class="line">        sdsfree(<span class="built_in">vector</span>[*argc]);</span><br><span class="line">    zfree(<span class="built_in">vector</span>);</span><br><span class="line">    <span class="keyword">if</span> (current) sdsfree(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-双端链表"><a href="#2-3-双端链表" class="headerlink" title="2.3 双端链表"></a>2.3 双端链表</h2><h3 id="adlist-h"><a href="#adlist-h" class="headerlink" title="adlist.h"></a>adlist.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adlist.h - A generic doubly linked list implementation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ADLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ADLIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//指向后一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//value是void类型，表示链表可以保存各种不同类型的值，相当于多态</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于访问链表的迭代器，双向链表自然支持双向迭代</span></span><br><span class="line"><span class="comment">//迭代器并不保存链表，只是标记链表的一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    <span class="comment">//下个待访问的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="comment">//迭代访问的方向，AL_START_HEAD表示向前，AL_START_TAIL表示向后，在后面的宏定义里</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向头结点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//指向尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//提供了三个函数指针, 供用户传入自定义函数</span></span><br><span class="line">    <span class="comment">//dup用于复制节点所保存的值，free用于释放节点所保存的值(因为节点值是void指针)，match用于匹配节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//链表长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="comment">//把指针的操作封装成了宏的类型，方便了程序员的使用</span></span><br><span class="line"><span class="comment">//l表示list指针，n表示listNode指针，m表示函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="comment">//迭代链表的方向</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __ADLIST_H__ */</span></span></span><br></pre></td></tr></table></figure><h3 id="adlist-c"><a href="#adlist-c" class="headerlink" title="adlist.c"></a>adlist.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adlist.c - A generic doubly linked list implementation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"adlist.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new list. The created list can be freed with</span></span><br><span class="line"><span class="comment"> * AlFreeList(), but private value of every node need to be freed</span></span><br><span class="line"><span class="comment"> * by the user before to call AlFreeList().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned. Otherwise the pointer to the new list. */</span></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="comment">//空参数实际上表示函数需要不确定个数的参数，比如main()，而void参数才是明确告诉编译器函数不需要参数</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line">    <span class="comment">//空间不足就退出</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//返回链表指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free the whole list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can't fail. */</span></span><br><span class="line"><span class="comment">//释放链表</span></span><br><span class="line"><span class="comment">//先释放listNode的value指针，再释放listNode指针，释放完所有节点后再释放list指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new node to the list, to head, contaning the specified 'value'</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the 'list' pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="comment">//给定一个值value和链表list，根据value构造新节点添加到list的表头</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line">    <span class="comment">//申请空节点</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//给节点赋值</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="comment">//设置链表的头尾指针和新节点的前后指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新链表长度</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new node to the list, to tail, contaning the specified 'value'</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the 'list' pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="comment">//给定一个值value和链表list，根据value构造新节点添加到list的尾部</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个包含给定值value的新节点添加到给定节点old_node的之前或者之后</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="comment">//after==0表示新节点添加到old_node前面，否则就是添加到后面</span></span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让新节点的前后节点指向该新节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove the specified node from the specified list.</span></span><br><span class="line"><span class="comment"> * It's up to the caller to free the private value of the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can't fail. */</span></span><br><span class="line"><span class="comment">//从链表中删除给定节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a list iterator 'iter'. After the initialization every</span></span><br><span class="line"><span class="comment"> * call to listNext() will return the next element of the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can't fail. */</span></span><br><span class="line"><span class="comment">//指定迭代方向，获取链表的迭代器</span></span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">    <span class="comment">//正向迭代从头结点开始</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//反向迭代从尾结点开始</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release the iterator memory */</span></span><br><span class="line"><span class="comment">//释放迭代器，就是给zfree指定了参数类型，多此一举</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an iterator in the list private iterator structure */</span></span><br><span class="line"><span class="comment">//重置迭代器li，起点设为链表头结点，方向设为自前向后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置迭代器li，起点设为链表尾结点，方向设为自后向前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the next element of an iterator.</span></span><br><span class="line"><span class="comment"> * It's valid to remove the currently returned element using</span></span><br><span class="line"><span class="comment"> * listDelNode(), but not to remove other elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns a pointer to the next element of the list,</span></span><br><span class="line"><span class="comment"> * or NULL if there are no more elements, so the classical usage patter</span></span><br><span class="line"><span class="comment"> * is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * iter = listGetIterator(list,&lt;direction&gt;);</span></span><br><span class="line"><span class="comment"> * while ((node = listNext(iter)) != NULL) &#123;</span></span><br><span class="line"><span class="comment"> *     doSomethingWith(listNodeValue(node));</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">//返回迭代器指向的下一个节点，然后根据迭代方向更新迭代器指向的节点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Duplicate the whole list. On out of memory NULL is returned.</span></span><br><span class="line"><span class="comment"> * On success a copy of the original list is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The 'Dup' method set with listSetDupMethod() function is used</span></span><br><span class="line"><span class="comment"> * to copy the node value. Otherwise the same pointer value of</span></span><br><span class="line"><span class="comment"> * the original node is used as value of the copied node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The original list both on success or error is never modified. */</span></span><br><span class="line"><span class="comment">//复制整个链表orig，返回新副本链表的指针</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//先复制orig的三个方法</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    <span class="comment">//获取orig的迭代器，逐个节点进行复制</span></span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//复制出错，清理迭代器和copy并退出</span></span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="comment">//根据value构造新节点添加到copy末尾</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器用完就释放</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search the list for a node matching a given key.</span></span><br><span class="line"><span class="comment"> * The match is performed using the 'match' method</span></span><br><span class="line"><span class="comment"> * set with listSetMatchMethod(). If no 'match' method</span></span><br><span class="line"><span class="comment"> * is set, the 'value' pointer of every node is directly</span></span><br><span class="line"><span class="comment"> * compared with the 'key' pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success the first matching node pointer is returned</span></span><br><span class="line"><span class="comment"> * (search starts from head). If no matching node exists</span></span><br><span class="line"><span class="comment"> * NULL is returned. */</span></span><br><span class="line"><span class="comment">//获取链表中节点值等于给定key的节点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line">    <span class="comment">//利用迭代器遍历</span></span><br><span class="line">    iter = listGetIterator(<span class="built_in">list</span>, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the element at the specified zero-based index</span></span><br><span class="line"><span class="comment"> * where 0 is the head, 1 is the element next to head</span></span><br><span class="line"><span class="comment"> * and so on. Negative integers are used in order to count</span></span><br><span class="line"><span class="comment"> * from the tail, -1 is the last element, -2 the penultimante</span></span><br><span class="line"><span class="comment"> * and so on. If the index is out of range NULL is returned. */</span></span><br><span class="line"><span class="comment">//返回链表在给定索引上的节点</span></span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line">    <span class="comment">//支持负索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//负索引是从尾节点倒着数</span></span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//正索引是从头结点正着数</span></span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-字典"><a href="#2-4-字典" class="headerlink" title="2.4 字典"></a>2.4 字典</h2><h3 id="dict-h"><a href="#dict-h" class="headerlink" title="dict.h"></a>dict.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hash Tables Implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DICT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DICT_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的状态码，DICT_OK表示对字典的操作成功，DICT_ERR表示操作失败</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_OK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_ERR 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unused arguments generate annoying warnings... */</span></span><br><span class="line"><span class="comment">//没用到</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_NOTUSED(V) ((void) V)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字典表项，一个key-value对</span></span><br><span class="line"><span class="comment">//因为采用拉链法处理哈希碰撞，所以需要一个指针所在链表的下一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">void</span> *val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典需要的一组函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="comment">//字典使用的哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组，数组中的每个元素都是一个指向某个dictEntry的指针</span></span><br><span class="line">    <span class="comment">//也就是拉链法需要的链表的链表，第一层链表(桶链表)的每个元素是第二层链表的头节点，第二层的链表(节点链表)存储哈希值相同的dictEntry元素</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//table的大小，也就是桶的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值。sizemask=size-1，给定dictEntry节点的key的哈希值计算出来后，与sizemask进行按位与操作，决定该节点应该被放在桶链表的哪个桶里</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//哈希表已有dictEntry节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">//为字典设置的针对不同数据类型的特定函数簇</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据，保存了需要传给type中特定函数的可选参数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//一个字典使用了两个哈希表，用户使用的是0号哈希表，1号哈希表用于对0号哈希表进行rehash</span></span><br><span class="line">    <span class="comment">//rehash的目的是提高哈希表的查找效率。因为要映射哈希值的缘故，桶链表的长度在创建以后就不能改了，随着节点的增多，哈希表的负载因子会越来越大(负载因子=总节点数/桶链表长度)，表现为桶不够用了，使得节点链表过长，查询操作会在节点链表上浪费时间。所以rehash就是新建一个更长的桶链表，把节点疏散开。反之，如果节点数过少，rehash的过程就是新建一个更短的桶链表，不让节点分布太疏散。rehash完成后，就用1号哈希表替换0号哈希表，所以1号哈希表只是辅助rehash的，用户无需访问。</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash标示，为-1表示不在rehash，不为0表示正在rehash的桶序号</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">//当前正在运行的安全迭代器数量</span></span><br><span class="line">    <span class="comment">//存在安全迭代器就不会进行rehash，也就不会有节点被偷偷迁移到1号哈希表，保证了迭代的准确性</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iteartor, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="comment">//字典的迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    <span class="comment">//被迭代的字典</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="comment">//table是当前正在迭代的哈希表序号，取值为0或1</span></span><br><span class="line">    <span class="comment">//index是迭代器当前所指向的桶索引位置</span></span><br><span class="line">    <span class="comment">//safe标识此迭代器是否安全。safe=1表示安全，迭代时可以对节点增删改查，否则就是不安全的，只能迭代哈希表而不能修改</span></span><br><span class="line">    <span class="keyword">int</span> table, index, safe;</span><br><span class="line">    <span class="comment">//entry是当前迭代到的节点的指针</span></span><br><span class="line">    <span class="comment">//nextEntry是当前迭代节点的下一个节点。因为在迭代时entry指针可能会被修改，所以要单独保存下个节点的地址，防止丢失链接</span></span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">&#125; dictIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the initial size of every hash table */</span></span><br><span class="line"><span class="comment">//哈希表的初始长度，即桶的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HT_INITIAL_SIZE     4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------- Macros ------------------------------------*/</span></span><br><span class="line"><span class="comment">//宏定义函数，d表示字典dict，entry表示节点dictEntry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点的val指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeEntryVal(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;val)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置节点的val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetHashVal(d, entry, _val_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span><br><span class="line">        <span class="comment">//如果定义了复制值的函数，就调用该函数完成</span></span><br><span class="line">        entry-&gt;val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;val = (_val_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点的key指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeEntryKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置节点的key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetHashKey(d, entry, _key_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span><br><span class="line">        entry-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;key = (_key_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictCompareHashKeys(d, key1, key2) \</span></span><br><span class="line">    (((d)-&gt;type-&gt;keyCompare) ? \</span><br><span class="line">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span><br><span class="line">        (key1) == (key2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算key的哈希值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取节点的key和val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetEntryKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetEntryVal(he) ((he)-&gt;val)</span></span><br><span class="line"><span class="comment">//计算字典中两个哈希表的总大小(桶的数量)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)</span></span><br><span class="line"><span class="comment">//计算字典中两个哈希表的总节点数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="comment">//是否正在进行rehash</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictIsRehashing(ht) ((ht)-&gt;rehashidx != -1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hash table types */</span></span><br><span class="line"><span class="comment">//作者的样例代码用到的，实际没啥用</span></span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStringCopyKey;</span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStrings;</span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStringCopyKeyValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __DICT_H */</span></span></span><br></pre></td></tr></table></figure><h3 id="dict-c"><a href="#dict-c" class="headerlink" title="dict.c"></a>dict.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hash Tables Implementation.*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fmacros.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dict.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Using dictEnableResize() / dictDisableResize() we make possible to</span></span><br><span class="line"><span class="comment"> * enable/disable resizing of the hash table as needed. This is very important</span></span><br><span class="line"><span class="comment"> * for Redis, as we use copy-on-write and don't want to move too much memory</span></span><br><span class="line"><span class="comment"> * around when there is a child performing saving operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that even when dict_can_resize is set to 0, not all resizes are</span></span><br><span class="line"><span class="comment"> * prevented: an hash table is still allowed to grow if the ratio between</span></span><br><span class="line"><span class="comment"> * the number of elements and the buckets &gt; dict_force_resize_ratio. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dict_can_resize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dict_force_resize_ratio = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------- private prototypes ---------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *ht);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictInit(dict *ht, dictType *type, <span class="keyword">void</span> *privDataPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------- hash functions -------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thomas Wang's 32 bit Mix Function */</span></span><br><span class="line"><span class="comment">//针对整型的哈希函数，把整型key转换成对应的哈希值，作为哈希表的键值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictIntHashFunction</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">10</span>);</span><br><span class="line">    key +=  (key &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">6</span>);</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">11</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Identity hash function for integer keys */</span></span><br><span class="line"><span class="comment">//不使用哈希函数，直接把整型作为哈希表的key</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictIdentityHashFunction</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generic hash function (a popular one from Bernstein).</span></span><br><span class="line"><span class="comment"> * I tested a few and this was the best. */</span></span><br><span class="line"><span class="comment">//djb哈希算法，一种通用的哈希函数，计算字符串buf的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//hash seed</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">        <span class="comment">//字符串的ascii值与hash seed做运算</span></span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + (*buf++); <span class="comment">/* hash * 33 + c */</span></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* And a case insensitive version */</span></span><br><span class="line"><span class="comment">//大小写无关的djb哈希算法</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + (<span class="built_in">tolower</span>(*buf++)); <span class="comment">/* hash * 33 + c */</span></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------------------------- API implementation ------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset an hashtable already initialized with ht_init().</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This function should only called by ht_destroy(). */</span></span><br><span class="line"><span class="comment">//初始化或重置哈希表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    ht-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">    ht-&gt;size = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;sizemask = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new hash table */</span></span><br><span class="line"><span class="comment">//创建新的空字典</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *privDataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</span><br><span class="line">    <span class="comment">//申请到空间后做初始化</span></span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    <span class="comment">//返回字典指针</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the hash table */</span></span><br><span class="line"><span class="comment">//字典的初始化函数</span></span><br><span class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</span><br><span class="line">        <span class="keyword">void</span> *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重置字典的两个哈希表</span></span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//初始化赋值</span></span><br><span class="line">    d-&gt;type = type;</span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//返回成功的状态码</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USER/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="comment">//调整字典d中哈希表的size，保证每个节点占一个单独的桶，但长度可能有冗余，因为哈希表长度必须是DICT_HT_INITIAL_SIZE乘以2的幂次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line">    <span class="comment">//如果不支持resize，或者字典正在rehash，返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">//桶的数量定为0号哈希表的总节点数，但不能少于初始化的DICT_HT_INITIAL_SIZE</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="comment">//调用dictExpand对哈希表扩容</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand or create the hashtable */</span></span><br><span class="line"><span class="comment">//哈希表扩容函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht n; <span class="comment">/* the new hashtable */</span></span><br><span class="line">    <span class="comment">//计算实际的扩容长度，结果是DICT_HT_INITIAL_SIZE乘以2的幂次</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hashtable */</span></span><br><span class="line">    <span class="comment">//若字典正在rehash，需要等待rehash完成再扩容</span></span><br><span class="line">    <span class="comment">//若节点数大于扩容的长度，说明出了问题，具体什么问题？</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hashtable and initialize all pointers to NULL */</span></span><br><span class="line">    <span class="comment">//初始化扩容的哈希表</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it's not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前字典的0号哈希表是空，就把新哈希表赋给0号，可以直接使用</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    <span class="comment">//如果当前字典有正在使用的0号哈希表，就把新哈希表先赋给1号，之后rehash的时候再赋给0号</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * thank one key as we use chaining) from the old to the new hash table. */</span></span><br><span class="line"><span class="comment">//字典的rehash函数，采用分n步渐进式的rehash，因为当前的字典可能非常庞大，如果一次性把0号表的节点全部迁移到1号表，可能会占用大量时间和资源，影响系统性能，所以redis实际上是把rehash操作平摊到 dictAddRaw 、dictGetRandomKey 、dictFind 、dictGenericDelete 这些函数里，每当这些函数被执行的时候, 就会顺便执行_dictRehashStep函数，_dictRehashStep再调用dictRehash来迁移部分节点。此外还有dictRehashMilliseconds函数，支持在给定的时间段内集中进行rehash。</span></span><br><span class="line"><span class="comment">//参数n表示本次要迁移的桶的数量</span></span><br><span class="line"><span class="comment">//返回1说明rehash还没完，继续下一步，返回0就表示rehash已经完成</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询字典的rehashidx标志，如果表示已经rehash完毕，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环迁移n个桶中的节点</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="comment">//辅助指针，用于迭代当前桶中的节点链表</span></span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">        <span class="comment">//0号表节点数为0说明已经全部迁移完成，此时用1号表替换0号表，然后重置1号表，修改rehashidx标志，返回0表示rehash完毕</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">            zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">            d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        <span class="comment">//当前的桶迁移完毕后开始迁移下一个桶</span></span><br><span class="line">        <span class="comment">//这里桶的索引不会越界，因为越界说明0号表已经全部清空了，这在前面已经判断过了</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</span><br><span class="line">        <span class="comment">//把当前桶中节点链表的头节点赋给de</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="comment">//把当前桶中的所有节点迁移到1号表</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">//用字典的type函数簇里的哈希函数计算当前节点key的哈希值，与1号表的掩码按位与，得到在1号表中的桶索引</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            <span class="comment">//节点总是被插入到1号表的节点链表的表头</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            <span class="comment">//更新两个表的节点数</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为迁移过程是用辅助指针做的，所以最后还要把0号表当前桶中的链表指针设为NULL，表示桶已经清空</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否rehash完毕要在函数头部检查，此时无脑返回1即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前的毫秒时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">timeInMilliseconds</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">long</span> <span class="keyword">long</span>)tv.tv_sec)*<span class="number">1000</span>)+(tv.tv_usec/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</span></span><br><span class="line"><span class="comment">//在给定的毫秒时间段内集中进行rehash</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次迁移100个桶</span></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//时间到了就中止rehash</span></span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回桶索引</span></span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function performs just a step of rehashing, and only if there are</span></span><br><span class="line"><span class="comment"> * no safe iterators bound to our hash table. When we have iterators in the</span></span><br><span class="line"><span class="comment"> * middle of a rehashing we can't mess with the two hash tables otherwise</span></span><br><span class="line"><span class="comment"> * some element can be missed or duplicated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called by common lookup or update operations in the</span></span><br><span class="line"><span class="comment"> * dictionary so that the hash table automatically migrates from H1 to H2</span></span><br><span class="line"><span class="comment"> * while it is actively used. */</span></span><br><span class="line"><span class="comment">//如果当前字典没有迭代器，执行一步rehash，迁移一个桶的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="comment">//向字典插入dictEntry节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="comment">//根据节点的key计算应该放入的桶序号。哈希碰撞指的是索引冲突</span></span><br><span class="line">    <span class="comment">//当key已经在字典中，插入失败，返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocates the memory and stores key */</span></span><br><span class="line">    <span class="comment">//如果正在rehash，就往1号表里插，否则直接往0号表插</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">//插入到节点链表的头部</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    <span class="comment">//把key和val赋给新节点</span></span><br><span class="line">    dictSetHashKey(d, entry, key);</span><br><span class="line">    dictSetHashVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add an element, discarding the old if the key already exists.</span></span><br><span class="line"><span class="comment"> * Return 1 if the key was added from scratch, 0 if there was already an</span></span><br><span class="line"><span class="comment"> * element with such key and dictReplace() just performed a value update</span></span><br><span class="line"><span class="comment"> * operation. */</span></span><br><span class="line"><span class="comment">//向字典插入dictEntry节点，若key已经存在就更新val</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry, auxentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to add the element. If the key</span></span><br><span class="line"><span class="comment">     * does not exists dictAdd will suceed. */</span></span><br><span class="line">    <span class="comment">//能插就插</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* It already exists, get the entry */</span></span><br><span class="line">    <span class="comment">//插入失败说明key已经存在，获取对应的节点</span></span><br><span class="line">    entry = dictFind(d, key);</span><br><span class="line">    <span class="comment">/* Free the old value and set the new one */</span></span><br><span class="line">    <span class="comment">/* Set the new value and free the old one. Note that it is important</span></span><br><span class="line"><span class="comment">     * to do that in this order, as the value may just be exactly the same</span></span><br><span class="line"><span class="comment">     * as the previous one. In this context, think to reference counting,</span></span><br><span class="line"><span class="comment">     * you want to increment (set), and then decrement (free), and not the</span></span><br><span class="line"><span class="comment">     * reverse. */</span></span><br><span class="line">    <span class="comment">//更新节点的val，释放旧的val指针</span></span><br><span class="line">    auxentry = *entry;</span><br><span class="line">    dictSetHashVal(d, entry, val);</span><br><span class="line">    dictFreeEntryVal(d, &amp;auxentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search and remove an element */</span></span><br><span class="line"><span class="comment">//删除字典中给定key的结点，可控制是否调用释放方法</span></span><br><span class="line"><span class="comment">//节点指针一定会被释放，nofree参数用于指定是否要释放节点中key和val的指针</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line">    <span class="comment">//如果字典的0号表是NULL，返回错误码。空的表size一般不是0，没初始化的表才是NULL</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR; <span class="comment">/* d-&gt;ht[0].table is NULL */</span></span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//用字典的type函数簇里的哈希函数计算节点key的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">//不知道节点在哪个表，所以都查一遍</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">//key的哈希值与表的掩码按位与，得到桶索引</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">//得到节点链表的头节点</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="comment">//保存前一个节点，删除节点后用于重连</span></span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="comment">//比较两个key，如果type函数簇中有自定义的比较函数，调用之</span></span><br><span class="line">            <span class="keyword">if</span> (dictCompareHashKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="comment">//断开目标节点的链接</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeEntryKey(d, he);</span><br><span class="line">                    dictFreeEntryVal(d, he);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//释放节点指针</span></span><br><span class="line">                zfree(he);</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> DICT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历完0号表，如果当前没有在rehash，就不用再查1号表了，因为肯定是空的</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点，同时释放节点的key和val指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点，但不释放节点的key和val指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destroy an entire dictionary */</span></span><br><span class="line"><span class="comment">//清空字典中指定的哈希表</span></span><br><span class="line"><span class="keyword">int</span> _dictClear(dict *d, dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free all the elements */</span></span><br><span class="line">    <span class="comment">//遍历指定表ht的桶</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        dictEntry *he, *nextHe;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((he = ht-&gt;table[i]) == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//逐个节点进行free</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            nextHe = he-&gt;next;</span><br><span class="line">            dictFreeEntryKey(d, he);</span><br><span class="line">            dictFreeEntryVal(d, he);</span><br><span class="line">            zfree(he);</span><br><span class="line">            ht-&gt;used--;</span><br><span class="line">            he = nextHe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Free the table and the allocated cache structure */</span></span><br><span class="line">    <span class="comment">//所有桶都清空后，释放哈希表的指针</span></span><br><span class="line">    zfree(ht-&gt;table);</span><br><span class="line">    <span class="comment">/* Re-initialize the table */</span></span><br><span class="line">    <span class="comment">//把ht重置成NULL</span></span><br><span class="line">    _dictReset(ht);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">/* never fails */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clear &amp; Release the hash table */</span></span><br><span class="line"><span class="comment">//清空整个字典，也就是先分别清空两个哈希表，再释放字典指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    zfree(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字典中指定key的节点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    <span class="comment">//0号表是NULL，说明整个字典都是空的</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* We don't have a table at all */</span></span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//计算key的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">//遍历两个哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">//计算桶索引</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">//获取节点链表的表头</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="comment">//遍历节点链表，找到就返回</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareHashKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前没有在rehash，不用再查1号表</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定key节点的val指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dictFetchValue</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    he = dictFind(d,key);</span><br><span class="line">    <span class="keyword">return</span> he ? dictGetEntryVal(he) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器，默认迭代0号表(迭代完会自动切换到1号表)，不安全，只设置字典而不设置节点指针</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line"></span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取安全迭代器</span></span><br><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器获取下一个节点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没设置节点指针，先获取迭代的表</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;safe &amp;&amp; iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//条件里有safe，所以字典的iterators属性其实是记录安全迭代器的数量</span></span><br><span class="line">                iter-&gt;d-&gt;iterators++;</span><br><span class="line">            <span class="comment">//桶索引归零</span></span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">//如果恰好遍历完当前的表，桶索引会越界</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">signed</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="comment">//如果遍历完的是0号表且正在rehash，说明1号表也有节点，把迭代的表切换到1号表</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//如果遍历完的是1号表，或者没有在rehash，说明整个字典的全部节点都遍历完了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置当前迭代的节点</span></span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//entry不为NULL，表示应该返回nextEntry</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the 'next' here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            <span class="comment">//用户怎么处理得到的entry节点都无所谓，反正已经事先设置了nextEntry节点，迭代器不会丢失指针</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//字典的iterators增加后，迭代器的index一定不是-1，所以(iter-&gt;index == -1 &amp;&amp; iter-&gt;table == 0)说明没有调用过dictNext，字典的iterators也就没有增加过，所以不需要减一</span></span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;safe &amp;&amp; !(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>))</span><br><span class="line">        iter-&gt;d-&gt;iterators--;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a random entry from the hash table. Useful to</span></span><br><span class="line"><span class="comment"> * implement randomized algorithms */</span></span><br><span class="line"><span class="comment">//获取字典中一个随机的节点</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictGetRandomKey</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he, *orighe;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">int</span> listlen, listele;</span><br><span class="line">    <span class="comment">//如果两个哈希表的总节点数是0，就没有可返回的节点</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//如果正在rehash，顺便执行一步</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//如果正在rehash，随机的范围就是两个表的桶，通过判断桶里的表头指针是不是NULL，可以保证随机到的桶不是空的</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() % (d-&gt;ht[<span class="number">0</span>].size+d-&gt;ht[<span class="number">1</span>].size);</span><br><span class="line">            he = (h &gt;= d-&gt;ht[<span class="number">0</span>].size) ? d-&gt;ht[<span class="number">1</span>].table[h - d-&gt;ht[<span class="number">0</span>].size] :</span><br><span class="line">                                      d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果没有在rehash，随机的范围只有0号表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() &amp; d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">            he = d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we found a non empty bucket, but it is a linked</span></span><br><span class="line"><span class="comment">     * list and we need to get a random element from the list.</span></span><br><span class="line"><span class="comment">     * The only sane way to do so is counting the elements and</span></span><br><span class="line"><span class="comment">     * select a random index. */</span></span><br><span class="line">    listlen = <span class="number">0</span>;</span><br><span class="line">    orighe = he;</span><br><span class="line">    <span class="comment">//计算桶里的节点数</span></span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">        listlen++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机选一个节点</span></span><br><span class="line">    listele = random() % listlen;</span><br><span class="line">    he = orighe;</span><br><span class="line">    <span class="keyword">while</span>(listele--) he = he-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------- private functions ------------------------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="comment">//推断是否需要扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="comment">//如果正在扩容，返回0，表示不需要</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the intial size. */</span></span><br><span class="line">    <span class="comment">//如果0号表长度是0，先扩展到长度下限DICT_HT_INITIAL_SIZE</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the "safe" threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="comment">//如果字典支持resize，每当负载因子大于等于1，就触发扩容</span></span><br><span class="line">    <span class="comment">//如果不支持resize，只有负载因子超过预设的dict_force_resize_ratio时，才触发强制扩容</span></span><br><span class="line">    <span class="comment">//扩容后的长度是总节点数的两倍</span></span><br><span class="line">    <span class="comment">//先扩容才能rehash</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里为什么还要判断d-&gt;ht[0].size &gt; d-&gt;ht[0].used？</span></span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, ((d-&gt;ht[<span class="number">0</span>].size &gt; d-&gt;ht[<span class="number">0</span>].used) ?</span><br><span class="line">                                    d-&gt;ht[<span class="number">0</span>].size : d-&gt;ht[<span class="number">0</span>].used)*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="comment">//计算哈希表实际的扩容长度</span></span><br><span class="line"><span class="comment">//实际长度必须是DICT_HT_INITIAL_SIZE值乘以2的幂次，结果不小于给定的size，但不能大于long int的上限</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the index of a free slot that can be populated with</span></span><br><span class="line"><span class="comment"> * an hash entry for the given 'key'.</span></span><br><span class="line"><span class="comment"> * If the key already exists, -1 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if we are in the process of rehashing the hash table, the</span></span><br><span class="line"><span class="comment"> * index is always returned in the context of the second (new) hash table. */</span></span><br><span class="line"><span class="comment">//计算给定的key在哈希表中的索引</span></span><br><span class="line"><span class="comment">//字典的key是唯一的，但索引是可以冲突的。哈希碰撞不是key重复，而是不同的key被放在了同一个桶里</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hashtable if needed */</span></span><br><span class="line">    <span class="comment">//先判断要不要扩容，返回错误码说明需要扩容但是扩容失败</span></span><br><span class="line">    <span class="comment">//但是为什么选在这个时候扩容？</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* Compute the key hash value */</span></span><br><span class="line">    <span class="comment">//计算key的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">//依次计算在两个表中的桶索引，如果正在rehash，返回的就是1号表中的索引，否则返回0号表中的索引</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareHashKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空整个字典，清空和销毁不一样，只释放哈希表指针，不释放字典指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调试函数，输出哈希表的相关信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_STATS_VECTLEN 50</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictPrintStatsHt(dictht *ht) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i, slots = <span class="number">0</span>, chainlen, maxchainlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> totchainlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> clvector[DICT_STATS_VECTLEN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;used == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No stats available for empty dictionaries\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DICT_STATS_VECTLEN; i++) clvector[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size; i++) &#123;</span><br><span class="line">        dictEntry *he;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ht-&gt;table[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            clvector[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slots++;</span><br><span class="line">        <span class="comment">/* For each hash entry on this slot... */</span></span><br><span class="line">        chainlen = <span class="number">0</span>;</span><br><span class="line">        he = ht-&gt;table[i];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            chainlen++;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        clvector[(chainlen &lt; DICT_STATS_VECTLEN) ? chainlen : (DICT_STATS_VECTLEN<span class="number">-1</span>)]++;</span><br><span class="line">        <span class="keyword">if</span> (chainlen &gt; maxchainlen) maxchainlen = chainlen;</span><br><span class="line">        totchainlen += chainlen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hash table stats:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" table size: %ld\n"</span>, ht-&gt;size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" number of elements: %ld\n"</span>, ht-&gt;used);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" different slots: %ld\n"</span>, slots);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" max chain length: %ld\n"</span>, maxchainlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" avg chain length (counted): %.02f\n"</span>, (<span class="keyword">float</span>)totchainlen/slots);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" avg chain length (computed): %.02f\n"</span>, (<span class="keyword">float</span>)ht-&gt;used/slots);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" Chain length distribution:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DICT_STATS_VECTLEN<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clvector[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   %s%ld: %ld (%.02f%%)\n"</span>,(i == DICT_STATS_VECTLEN<span class="number">-1</span>)?<span class="string">"&gt;= "</span>:<span class="string">""</span>, i, clvector[i], ((<span class="keyword">float</span>)clvector[i]/ht-&gt;size)*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调试函数，输出字典的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictPrintStats</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    _dictPrintStatsHt(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-- Rehashing into ht[1]:\n"</span>);</span><br><span class="line">        _dictPrintStatsHt(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制是否允许resize</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following are just example hash table types implementations.</span></span><br><span class="line"><span class="comment"> * Not useful for Redis so they are commented out.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//作者的样例代码</span></span><br><span class="line"><span class="comment">/* ----------------------- StringCopy Hash Table Type ------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> _dictStringCopyHTHashFunction(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenHashFunction(key, <span class="built_in">strlen</span>(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_dictStringDup(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(key);</span><br><span class="line">    <span class="keyword">char</span> *copy = zmalloc(len+<span class="number">1</span>);</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(copy, key, len);</span><br><span class="line">    copy[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictStringCopyHTKeyCompare(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *key2)</span><br><span class="line">&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(key1, key2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictStringDestructor(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    zfree(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictType dictTypeHeapStringCopyKey = &#123;</span><br><span class="line">    _dictStringCopyHTHashFunction, <span class="comment">/* hash function */</span></span><br><span class="line">    _dictStringDup,                <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* val dup */</span></span><br><span class="line">    _dictStringCopyHTKeyCompare,   <span class="comment">/* key compare */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                           <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is like StringCopy but does not auto-duplicate the key.</span></span><br><span class="line"><span class="comment"> * It's used for intepreter's shared strings. */</span></span><br><span class="line">dictType dictTypeHeapStrings = &#123;</span><br><span class="line">    _dictStringCopyHTHashFunction, <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                          <span class="comment">/* val dup */</span></span><br><span class="line">    _dictStringCopyHTKeyCompare,   <span class="comment">/* key compare */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                           <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is like StringCopy but also automatically handle dynamic</span></span><br><span class="line"><span class="comment"> * allocated C strings as values. */</span></span><br><span class="line">dictType dictTypeHeapStringCopyKeyValue = &#123;</span><br><span class="line">    _dictStringCopyHTHashFunction, <span class="comment">/* hash function */</span></span><br><span class="line">    _dictStringDup,                <span class="comment">/* key dup */</span></span><br><span class="line">    _dictStringDup,                <span class="comment">/* val dup */</span></span><br><span class="line">    _dictStringCopyHTKeyCompare,   <span class="comment">/* key compare */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    _dictStringDestructor,         <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="2-5-跳跃表"><a href="#2-5-跳跃表" class="headerlink" title="2.5 跳跃表"></a>2.5 跳跃表</h2><h3 id="redis-h-跳跃表相关部分）"><a href="#redis-h-跳跃表相关部分）" class="headerlink" title="redis.h(跳跃表相关部分）"></a>redis.h(跳跃表相关部分）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳跃表就是给有序list添加多级索引，能够以更大的步长遍历list，提高查找效率，属于空间换时间。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32 <span class="comment">/* Should be enough for 2^32 elements */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//跳跃表的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//节点真正存储的数据，类型是redis定义的对象，也是在redis.h中定义的</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">//分值。在跳跃表中，节点按各自所保存的分值从小到大排列</span></span><br><span class="line">    <span class="comment">//跳跃表中各个节点保存的对象必须是唯一的，但多个节点的分值可以是相同的，分值相同的节点将按照对象在字典序中的大小来进行排序</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//后退指针，用于从表尾向表头遍历</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//节点所在层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">//前进指针，用于从表头向表尾遍历</span></span><br><span class="line">        <span class="comment">//一个节点有多个不同跨度的前进指针，但只有一个后退指针，所以只有正向遍历是跳跃的，反向遍历只能退到前一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度(步长)，记录了前进指针所指向的节点到当前节点的距离。因为是有跨度的遍历，所以遍历到某个节点后，将沿途所有经过的节点的跨度相加，就是该节点在跳跃表中的次序(rank)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳跃表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量,表头节点不计算在内，因为头结点只存储层次不存储数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数,表头节点的层数不计算在内</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sorted sets data type */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span></span>;</span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="t-zset-c-跳跃表相关部分"><a href="#t-zset-c-跳跃表相关部分" class="headerlink" title="t_zset.c(跳跃表相关部分)"></a>t_zset.c(跳跃表相关部分)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建跳跃表的节点。设置存储对象和分值，level参数只用于申请空间，level数组并没有初始化</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;obj = obj;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建跳跃表</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">//初始化最高层数是1，不考虑头结点</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//初始节点数0</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//头结点的层数设成上限，分值是0(最小)，存储的对象是NULL。每层初始化前进指针和跨度</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放节点，这里不用考虑表的链接，因为只有两种情况会释放节点，一个是要释放整个表，链接自然就不用管了，另一个是先删除节点再释放节点，删除节点的函数中已经调整好链接了，这里就不用管了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFreeNode</span><span class="params">(zskiplistNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//节点存储的对象的引用计数减一，在object.c中定义的</span></span><br><span class="line">    decrRefCount(node-&gt;obj);</span><br><span class="line">    <span class="comment">//释放节点指针</span></span><br><span class="line">    zfree(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放跳跃表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next;</span><br><span class="line">    <span class="comment">//先释放头结点</span></span><br><span class="line">    zfree(zsl-&gt;header);</span><br><span class="line">    <span class="comment">//沿着第0层遍历节点并释放，因为第0层的跨度是1，就等于按顺序遍历全部节点</span></span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslFreeNode(node);</span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后释放表的指针</span></span><br><span class="line">    zfree(zsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个介于1和ZSKIPLIST_MAXLEVEL之间的随机值，作为节点的层数</span></span><br><span class="line"><span class="comment">//根据幂次定律(power law)，越大的层数产生的几率就越小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//random返回一个long int范围内的随机整数，random()&amp;0xFFFF的结果就是一个0到65535的随机整数</span></span><br><span class="line">    <span class="comment">//ZSKIPLIST_P=0.25，每次level只有1/4的概率加一，所以结果就是越大的数越难得到</span></span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定分值和存储对象，创建新节点并插入跳跃表，返回该节点指针</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//update数组存放寻找新节点位置的过程中经过的节点</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">//rank数组存放寻找新节点位置的过程中经过的节点的跨度累加和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line">    <span class="comment">//从头节点正向遍历</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//从高层到低层遍历，相当于先查高层索引再查低层索引，步子迈得越来越小，最后定位到新节点应该存放的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        <span class="comment">//遍历过程中记录的跨度是累加和，不是单个节点的跨度</span></span><br><span class="line">        <span class="comment">//因为i是从大到小，所以最终的跨度和是存在rank[0]里，所以这里是先把上一层的rank值继承下来</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//因为跳跃表从小到大排序，所以要找到当前层第一个分值大于新节点，或者分值相同但字典序大于新节点的节点，此时退出循环，x就是本层中新节点的左侧邻居节点。但新节点插入的位置必须精确到真正相邻的两个节点之间，而高层里相邻的节点跨度可能大于1，并不是真正相邻，所以要进入下一层继续精确新节点的左邻居，直到新节点的左右邻居跨度是1，新节点只能插入这个唯一的间隙中，才算真正确定了插入位置。</span></span><br><span class="line">        <span class="comment">//只有在没找到本层的左邻居时，rank值才会增加，所以rank[i]并不包括update[i]的跨度，所以rank[i]代表的是找到左邻居的过程中在本层遍历的总距离。又因为在当前层一定是从上一层左邻居的位置开始向右遍历，所以最后累加得到的rank[0]就是从头节点到新节点真正左邻居的距离。</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="comment">//继承下来的rank值加上当前节点的rank值</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录新节点在第i层的左邻居</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the key is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, and the re-insertion of score and redis object should never</span></span><br><span class="line"><span class="comment">     * happpen since the caller of zslInsert() should test in the hash table</span></span><br><span class="line"><span class="comment">     * if the element is already inside or not. */</span></span><br><span class="line">    <span class="comment">//新节点的最高层数是随机的</span></span><br><span class="line">    <span class="comment">//为什么不把索引设成固定间隔的？随机的会不会性能不太好？</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">//如果新节点的最高层比整个表的最高层(不包括头节点)低，那么新节点最高层以上的层次就不用关心了</span></span><br><span class="line">    <span class="comment">//反之，如果新节点最高层创了新高，就需要多做一些修改</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//因为是前所未有的新高层，所以左邻居只能是头节点</span></span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            <span class="comment">//头节点的跨度为什么是节点数？不应该是rank[0]吗？</span></span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新跳跃表的最高层数</span></span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新节点</span></span><br><span class="line">    x = zslCreateNode(level,score,obj);</span><br><span class="line">    <span class="comment">//与每一层的左右邻居做链接</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">//插入以后，原本是新节点左邻居的右邻居就成了新节点的右邻居，用前进指针链接</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">//新节点x就成了他左邻居的右邻居，用前进指针链接</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        <span class="comment">//update[i]-&gt;level[i].span是第i层中左邻居到右邻居的跨度，rank[0]-rank[i]是第i层左邻居到第0层左邻居的距离，所以二者相减得到的是第0层左邻居到第i层右邻居的跨度。新节点插入后，新节点到第i层右邻居的跨度就等于原本第0层左邻居到第i层右邻居的跨度。</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        <span class="comment">//左邻居的跨度要改成左邻居到新节点的距离</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="comment">//新节点最高层以上的层次找到的也都是左邻居，所以新节点插入后它们的跨度都加一</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后退指针指向左邻居，后退指针只和第0层有关，所以不用循环</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//如果新节点有右邻居，就把右邻居的后退指针指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果没有右邻居，自然就成了尾结点</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    <span class="comment">//跳跃表节点数加一</span></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></span><br><span class="line"><span class="comment">//删除节点x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//遍历update每一层的节点，一定是x左边的节点，但不一定是左邻居，因为x的最高层数可能低于i</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="comment">//如果是左邻居，就要继承x的跨度，前进指针指向x的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">//如果不是左邻居，只是跨度减一</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果x有右邻居，就把右邻居的后退指针指向x的左邻居</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    <span class="comment">//如果没有右邻居，x就是尾结点，重新设置尾结点就行了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果删掉的节点是最高的，就需要重新设置跳跃表的最高层数</span></span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">    <span class="comment">//节点数减一</span></span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete an element with matching score/object from the skiplist. */</span></span><br><span class="line"><span class="comment">//删除跳跃表中包含给定对象和分值的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//和插入节点的逻辑一样，根据分值从高层到底层找左邻居，记录左邻居是为了删除节点后调整指针链接</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="comment">//找到分值相同的节点之后，再找存储的对象是obj的节点</span></span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</span><br><span class="line">        <span class="comment">//先删除再释放节点</span></span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec. */</span></span><br><span class="line"><span class="comment">//分值范围</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//最小值和最大值</span></span><br><span class="line">    <span class="keyword">double</span> min, max;</span><br><span class="line">    <span class="comment">//最小值和最大值是否包含在本范围里，表示区间开闭</span></span><br><span class="line">    <span class="comment">//ex是exclusive的意思，所以0表示包含(闭区间)，1表示不包含(开区间)</span></span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zrangespec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete all the elements with score between min and max from the skiplist.</span></span><br><span class="line"><span class="comment"> * Min and mx are inclusive, so a score &gt;= min || score &lt;= max is deleted.</span></span><br><span class="line"><span class="comment"> * Note that this function takes the reference to the hash table view of the</span></span><br><span class="line"><span class="comment"> * sorted set, in order to remove the elements from the hash table too. */</span></span><br><span class="line"><span class="comment">//给定一个分值范围，删除跳跃表中所有在这个范围之内的节点，同时也在字典中删除该节点</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslDeleteRangeByScore</span><span class="params">(zskiplist *zsl, zrangespec range, dict *dict)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//找到分值范围的左邻居</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (range.minex ?</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt;= range.min :</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt; range.min))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Current node is the last with score &lt; or &lt;= min. */</span></span><br><span class="line">    <span class="comment">//在第0层非跳跃地遍历节点</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete nodes while in range. */</span></span><br><span class="line">    <span class="comment">//在跳跃表和字典中删除节点，最后释放该节点</span></span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; (range.maxex ? x-&gt;score &lt; range.max : x-&gt;score &lt;= range.max)) &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回删除的节点数</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete all the elements with rank between start and end from the skiplist.</span></span><br><span class="line"><span class="comment"> * Start and end are inclusive. Note that start and end need to be 1-based */</span></span><br><span class="line"><span class="comment">//给定一个排序范围，删除跳跃表中所有在这个范围之内的节点</span></span><br><span class="line"><span class="comment">//大体逻辑同zslDeleteRangeByScore，最后也是返回删除的节点数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslDeleteRangeByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">int</span> start, <span class="keyword">unsigned</span> <span class="keyword">int</span> end, dict *dict)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>, removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt; start) &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traversed++;</span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; traversed &lt;= end) &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        traversed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the first node having a score equal or greater than the specified one.</span></span><br><span class="line"><span class="comment"> * Returns NULL if there is no match. */</span></span><br><span class="line"><span class="comment">//获取第一个分值不小于给定分值的节点</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslFirstWithScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//直接从高层到低层找，不用记录左邻居了。最后找到第0层，得到的就是真正的左邻居</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; x-&gt;level[i].forward-&gt;score &lt; score)</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    <span class="comment">//返回左邻居的下个节点</span></span><br><span class="line">    <span class="keyword">return</span> x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the rank for an element by both score and key.</span></span><br><span class="line"><span class="comment"> * Returns 0 when the element cannot be found, rank otherwise.</span></span><br><span class="line"><span class="comment"> * Note that the rank is 1-based due to the span of zsl-&gt;header to the</span></span><br><span class="line"><span class="comment"> * first element. */</span></span><br><span class="line"><span class="comment">//返回包含给定对象和分值的节点在跳跃表中的排序</span></span><br><span class="line"><span class="comment">//和zslInsert中一样，从高层到低层遍历，通过累加途径节点的跨度来得到节点在表中的rank值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//和</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></span><br><span class="line"><span class="comment">//返回跳跃表在给定排序上的节点</span></span><br><span class="line"><span class="comment">//从高层到底层遍历，记录节点的rank值，每当下个节点的rank值高于给定的rank，就跳到下一层继续遍历，因为到了下一层右邻居会更左</span></span><br><span class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Populate the rangespec according to the objects min and max. */</span></span><br><span class="line"><span class="comment">//把spec的左右边界设成min和max</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zslParseRange</span><span class="params">(robj *min, robj *max, zrangespec *spec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line">    <span class="comment">//初始默认是闭区间</span></span><br><span class="line">    spec-&gt;minex = spec-&gt;maxex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the min-max interval. If one of the values is prefixed</span></span><br><span class="line"><span class="comment">     * by the "(" character, it's considered "open". For instance</span></span><br><span class="line"><span class="comment">     * ZRANGEBYSCORE zset (1.5 (2.5 will match min &lt; x &lt; max</span></span><br><span class="line"><span class="comment">     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min &lt;= x &lt;= max */</span></span><br><span class="line">    <span class="comment">//对象的ptr指针指向底层的数据结构</span></span><br><span class="line">    <span class="comment">//如果对象的数据结构是整型，直接赋给spec，也是默认闭区间</span></span><br><span class="line">    <span class="keyword">if</span> (min-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        spec-&gt;min = (<span class="keyword">long</span>)min-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是整型，对象就是用字符串表示的数</span></span><br><span class="line">        <span class="comment">//字符串以'('开头表示开区间</span></span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">char</span>*)min-&gt;ptr)[<span class="number">0</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="comment">//strtod将ptr指向的字符串转换成浮点数，如果发生错误就让eptr指针指向出错的字符</span></span><br><span class="line">            spec-&gt;min = strtod((<span class="keyword">char</span>*)min-&gt;ptr+<span class="number">1</span>,&amp;eptr);</span><br><span class="line">            <span class="comment">//如果转换出错了，返回错误码</span></span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;min)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            <span class="comment">//开区间的exclusive是1</span></span><br><span class="line">            spec-&gt;minex = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            spec-&gt;min = strtod((<span class="keyword">char</span>*)min-&gt;ptr,&amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;min)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右边界设置同上</span></span><br><span class="line">    <span class="keyword">if</span> (max-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        spec-&gt;max = (<span class="keyword">long</span>)max-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">char</span>*)max-&gt;ptr)[<span class="number">0</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">            spec-&gt;max = strtod((<span class="keyword">char</span>*)max-&gt;ptr+<span class="number">1</span>,&amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;max)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            spec-&gt;maxex = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            spec-&gt;max = strtod((<span class="keyword">char</span>*)max-&gt;ptr,&amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(spec-&gt;max)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置成功，返回成功码</span></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-内存编码结构相关"><a href="#3-内存编码结构相关" class="headerlink" title="3 内存编码结构相关"></a>3 内存编码结构相关</h1><h2 id="3-1-整数集合数据结构"><a href="#3-1-整数集合数据结构" class="headerlink" title="3.1 整数集合数据结构"></a>3.1 整数集合数据结构</h2><h3 id="intset-h"><a href="#intset-h" class="headerlink" title="intset.h"></a>intset.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __INTSET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INTSET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式，包括int16_t、int32_t和int64_t</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合中元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//存储元素的有序数组，要实现的集合是无序的，但底层的数组是有序的</span></span><br><span class="line">    <span class="comment">//虽然contents属性声明为int8_t类型的数组，但实际上contents数组的真正类型取决于encoding属性的值</span></span><br><span class="line">    <span class="comment">//由于contents所有元素的类型要一致，因此contents的类型是由其中最大的数决定的</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __INTSET_H</span></span></span><br></pre></td></tr></table></figure><h3 id="intset-c"><a href="#intset-c" class="headerlink" title="intset.c"></a>intset.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"intset.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="comment">//int的编码方式</span></span><br><span class="line"><span class="comment">//int16_t，2bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="comment">//int32_t，4bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="comment">//int64_t，8bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the required encoding for the provided value. */</span></span><br><span class="line"><span class="comment">//根据给定数的大小，返回满足需求又最省空间的int类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at pos, given an encoding. */</span></span><br><span class="line"><span class="comment">//得到enc编码方式下的第pos个位置的值</span></span><br><span class="line"><span class="comment">//因为呈现给用户的intset是无序的，所以能访问底层数组contents的函数必须是声明为static的内部函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGetEncoded(intset *is, <span class="keyword">int</span> pos, <span class="keyword">uint8_t</span> enc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enc == INTSET_ENC_INT64)</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (enc == INTSET_ENC_INT32)</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="comment">//得到is中第pos个位置的值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGet(intset *is, <span class="keyword">int</span> pos) &#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGetEncoded(is,pos,is-&gt;encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="comment">//把集合is第pos个位置的值设为value</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT64)</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT32)</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an empty intset. */</span></span><br><span class="line"><span class="comment">//创建空的整数集合</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    <span class="comment">//默认使用int16_t，只支持升级，不支持降级</span></span><br><span class="line">    is-&gt;encoding = INTSET_ENC_INT16;</span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the intset */</span></span><br><span class="line"><span class="comment">//因为结构体的内存空间是连续的，所以添加新元素之前要先扩容，删除元素之后要收缩。len是新的元素总数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//is-&gt;encoding就是表示一个整数需要的bit数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*is-&gt;encoding;</span><br><span class="line">    <span class="comment">//需要的空间是结构体大小加所有元素需要的大小</span></span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search for the position of "value". Return 1 when the value was found and</span></span><br><span class="line"><span class="comment"> * sets "pos" to the position of the value within the intset. Return 0 when</span></span><br><span class="line"><span class="comment"> * the value is not present in the intset and sets "pos" to the position</span></span><br><span class="line"><span class="comment"> * where "value" can be inserted. */</span></span><br><span class="line"><span class="comment">//在集合的有序数组中查询给定的value，如果找到，把索引赋给pos，如果找不到，把value能插入的位置赋给pos</span></span><br><span class="line"><span class="comment">//返回1表示找到了，返回0表示没找到</span></span><br><span class="line"><span class="comment">//采用二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = is-&gt;length<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="comment">//集合是空的，直接返回0，pos=0表示value可以直接插在数组头部</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="comment">//因为数组是有序的，所以先和数组收尾比较，如果value小于左边界或大于右边界，就说明不在数组中，pos设置为数组的头或尾</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,is-&gt;length<span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = is-&gt;length;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找，cur记录的是数组中mid索引的值</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = (min+max)/<span class="number">2</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出上面循环的一种情况是value==cur，pos设为cur的索引mid</span></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//另一种情况是max&lt;min，此时value的插入位置就是新的min(想一想就知道)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="comment">//升级is的编码(int类型)，并插入新的value</span></span><br><span class="line"><span class="comment">//因为调用该函数的条件是value超过了is支持的表示范围，所以编码要先升级，而且value一定是插在数组头或尾</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = is-&gt;encoding;</span><br><span class="line">    <span class="comment">//选择刚好适合新元素value的int类型</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">int</span> length = is-&gt;length;</span><br><span class="line">    <span class="comment">//负数插在数组头，正数插在数组尾</span></span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    <span class="comment">//修改is的encoding，再为新元素扩容</span></span><br><span class="line">    is-&gt;encoding = newenc;</span><br><span class="line">    is = intsetResize(is,is-&gt;length+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don't overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the "prepend" variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="comment">//在扩容以后的数组中</span></span><br><span class="line">    <span class="comment">//如果value是负数，就从后到前把每个元素插到它后面的位置，最后空出数组头来存放value</span></span><br><span class="line">    <span class="comment">//如果value是正数，就从后到前把每个元素插到它当前的位置，相当于啥也没干，最后空出数组尾来存放value</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="comment">//负数插在数组头，正数插在数组尾</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,is-&gt;length,value);</span><br><span class="line">    <span class="comment">//元素数量加一</span></span><br><span class="line">    is-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把集合中从from位置开始的所有元素移动到从to位置开始</span></span><br><span class="line"><span class="comment">//memmove比memcpy更安全。如果目标区域和源区域有重叠的话，memmove能够保证被覆盖之前将重叠区域的字节拷贝到目标区域中</span></span><br><span class="line"><span class="comment">//使用memmove要设定移动的长度，所以要分别考虑三种不同长度的int类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="comment">//bytes是from之后的总元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = is-&gt;length-from;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        <span class="comment">//元素数量乘以单个元素占用的空间就是要移动的内存长度</span></span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="keyword">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="keyword">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line"><span class="comment">//向集合is中插入value</span></span><br><span class="line"><span class="comment">//success只是个flag，大概只有测试的时候用得到</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询适合value的int类型</span></span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="comment">//初始默认插入成功</span></span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="comment">//适合value的int长度比is支持的要长，就要先扩容再添加，而且超出规格说明value本来也不在is中</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; is-&gt;encoding) &#123;</span><br><span class="line">        <span class="comment">/* This always succeeds, so we don't need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate "pos" with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="comment">//如果value已经在is中了，集合元素不能重复，success设为0表示插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先给新元素扩容</span></span><br><span class="line">        is = intsetResize(is,is-&gt;length+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//之前调用intsetSearch时，已经把应该插入的位置赋给了pos</span></span><br><span class="line">        <span class="comment">//插入前要把pos之后的全部元素后移一位</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; is-&gt;length) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在pos处插入新元素</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete integer from intset */</span></span><br><span class="line"><span class="comment">//从is中移除元素value</span></span><br><span class="line"><span class="comment">//和intsetAdd的基本逻辑相同</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valenc &lt;= is-&gt;encoding &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">        <span class="comment">/* We know we can delete */</span></span><br><span class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Overwrite value with tail and update length */</span></span><br><span class="line">        <span class="comment">//删除pos位置的元素，就是把pos+1之后的元素都前移一位</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; (is-&gt;length<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</span><br><span class="line">        <span class="comment">//数组长度收缩一位</span></span><br><span class="line">        is = intsetResize(is,is-&gt;length<span class="number">-1</span>);</span><br><span class="line">        is-&gt;length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine whether a value belongs to this set */</span></span><br><span class="line"><span class="comment">//查询value是否在集合is中</span></span><br><span class="line"><span class="comment">//intsetSearch函数里是直接查，但是实际情况中要先判断value是否超出了集合支持的int类型的表示范围</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetFind(intset *is, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= is-&gt;encoding &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return random member */</span></span><br><span class="line"><span class="comment">//随机返回集合中一个元素</span></span><br><span class="line"><span class="keyword">int64_t</span> intsetRandom(intset *is) &#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGet(is,rand()%is-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sets the value to the value at the given position. When this position is</span></span><br><span class="line"><span class="comment"> * out of range the function returns 0, when in range it returns 1. */</span></span><br><span class="line"><span class="comment">//获取pos位置上的元素</span></span><br><span class="line"><span class="comment">//仅仅是在_intsetGet之前判断了pos索引是否越界，没必要单独写成一个函数</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetGet(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; is-&gt;length) &#123;</span><br><span class="line">        *value = _intsetGet(is,pos);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return intset length */</span></span><br><span class="line"><span class="comment">//返回集合的元素总数</span></span><br><span class="line"><span class="keyword">uint32_t</span> intsetLen(intset *is) &#123;</span><br><span class="line">    <span class="keyword">return</span> is-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-压缩列表"><a href="#3-2-压缩列表" class="headerlink" title="3.2 压缩列表"></a>3.2 压缩列表</h2><h3 id="ziplist-h"><a href="#ziplist-h" class="headerlink" title="ziplist.h"></a>ziplist.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标记ziplist的头部和尾部，在插入新元素时会用到</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL 1</span></span><br></pre></td></tr></table></figure><h3 id="ziplist-c"><a href="#ziplist-c" class="headerlink" title="ziplist.c"></a>ziplist.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ziplist是为了节约内存而设计的特殊的双端队列，Ziplist能存储strings和integer值，整型值被存储为实际的整型值而不是字符串。Ziplist在头部和尾部的操作时间O(1)，但是由于ziplist的操作都需要重新分配内存，所以实际的复杂度和ziplist使用的内存大小有关。</span></span><br><span class="line"><span class="comment"> * ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZIPLIST OVERALL LAYOUT:</span></span><br><span class="line"><span class="comment"> * The general layout of the ziplist is as follows:</span></span><br><span class="line"><span class="comment"> * &lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;&lt;entry&gt;&lt;zlend&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zlbytes，uint32_t，4字节，记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用</span></span><br><span class="line"><span class="comment"> * zltail，uint32_t，4字节，记录压缩列表最后一个entry距离压缩列表的起始地址有多少字节，通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</span></span><br><span class="line"><span class="comment"> * zllen，uint16_t，2字节，记录了压缩列表包含的节点数量，当这个属性的值小于 UINT16_MAX(65535)时，这个属性的值就是压缩列表包含节点的数量，当这个值等于UINT16_MAX 时，节点的真实数量需要遍历整个压缩列表才能计算得出。</span></span><br><span class="line"><span class="comment"> * zlend，uint8_t，1字节，特殊值 0xFF(十进制255)，用于标记压缩列表的末端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZIPLIST ENTRIES:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 每个压缩列表节点都由 previous_entry_length 、encoding 、content 三个部分组成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 节点的 previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度，previous_entry_length的长度可以是1字节或者5字节。如果前一节点的长度小于254字节，那么previous_entry_length长度就是1字节，因为1字节可以表示0~253(0xFD)范围内的值。如果前一节点的长度大于等于254字节，那么previous_entry_length的长度就是5字节，其中第一个字节会被设置为 0xFE(254)，而之后的四个字节则用于保存前一节点的长度。这是由于0xFF已经是ziplist的结束标字节了，所以entry的flag字节最大只能是0xFE，所以表示的数就以254为界限分成上述两种情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度。如果是1字节、2字节或者5字节长，且值的最高位对应着分别为00、01或10，表示节点的content保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录。如果是1字节长，且值的最高位以11，表示节点的content保存着整数值，整数值的类型由编码除去最高两位之后的其他位记录，整数的长度无需记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * |00pppppp| - 1 byte</span></span><br><span class="line"><span class="comment"> *      String value with length less than or equal to 63 bytes (6 bits).</span></span><br><span class="line"><span class="comment"> * |01pppppp|qqqqqqqq| - 2 bytes</span></span><br><span class="line"><span class="comment"> *      String value with length less than or equal to 16383 bytes (14 bits).</span></span><br><span class="line"><span class="comment"> * |10______|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes</span></span><br><span class="line"><span class="comment"> *      String value with length greater than or equal to 16384 bytes.</span></span><br><span class="line"><span class="comment"> * |1100____| - 1 byte</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int16_t (2 bytes).</span></span><br><span class="line"><span class="comment"> * |1101____| - 1 byte</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int32_t (4 bytes).</span></span><br><span class="line"><span class="comment"> * |1110____| - 1 byte</span></span><br><span class="line"><span class="comment"> *      Integer encoded as int64_t (8 bytes).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 节点的 content 属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的 encoding 属性决定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ziplist.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把long long类型的value转换成字符串，字符串存储在s中，len是s的最大长度</span></span><br><span class="line"><span class="comment">//返回值是s的实际长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ll2string</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0xFF，也就是zlend的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_END 255</span></span><br><span class="line"><span class="comment">//previous_entry_length两种情况的分界</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_BIGLEN 254</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Different encoding/length possibilities */</span></span><br><span class="line"><span class="comment">//entry可使用的编码</span></span><br><span class="line"><span class="comment">//1字节，00开头，后6位表示字节数组的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)</span></span><br><span class="line"><span class="comment">//2字节，01开头，后14位表示字节数组的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="comment">//5字节，10000000开头，后32位表示字节数组的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)</span></span><br><span class="line"><span class="comment">//整数的编码是1字节，前两位都是11，后六位表示int类型</span></span><br><span class="line"><span class="comment">//11000000，int16_t，后面的content是16位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)</span></span><br><span class="line"><span class="comment">//11010000，int32_t，后面的content是32位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)</span></span><br><span class="line"><span class="comment">//11100000，int64_t，后面的content是64位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro's to determine type */</span></span><br><span class="line"><span class="comment">//判断节点存的是不是字符串，特征是编码的第一字节小于0xc0(11000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_IS_STR(enc) (((enc) &amp; 0xc0) &lt; 0xc0)</span></span><br><span class="line"><span class="comment">//判断节点存的是不是整数，!ZIP_IS_STR(enc)说明是11开头，(enc) &amp; 0x30) &lt; 0x30说明不是1111开头，因为支持的三种整数编码没有1111开头的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_IS_INT(enc) (!ZIP_IS_STR(enc) &amp;&amp; ((enc) &amp; 0x30) &lt; 0x30)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Utility macros */</span></span><br><span class="line"><span class="comment">//zl就是ziplist，本质其实就是一个字符串</span></span><br><span class="line"><span class="comment">//返回zlbytes字段的指针，在zl的1~4字节，(uint32_t*)表示取zl前4个字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="comment">//返回zltail字段的指针，在zl的5~8字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="comment">//返回zllen字段的指针，在zl的9~10字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"><span class="comment">//返回zl的header的长度，就是zlbytes、zltail、zllen三个字段的总长</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="comment">//返回第一个节点的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span></span><br><span class="line"><span class="comment">//返回最后一个节点的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+ZIPLIST_TAIL_OFFSET(zl))</span></span><br><span class="line"><span class="comment">//返回zlend字段的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+ZIPLIST_BYTES(zl)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We know a positive increment can only be 1 because entries can only be</span></span><br><span class="line"><span class="comment"> * pushed one at a time. */</span></span><br><span class="line"><span class="comment">//增加ziplist的节点数，就是修改zllen字段的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_INCR_LENGTH(zl,incr) &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> (ZIPLIST_LENGTH(zl) &lt; UINT16_MAX) ZIPLIST_LENGTH(zl)+=incr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ziplist的节点</span></span><br><span class="line"><span class="comment">//entry是ziplist字符串的一个子串</span></span><br><span class="line"><span class="comment">//zlentry结构体用于描述entry的各个属性的一种结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="comment">//prevrawlen是前一个entry子串content字段的长度(字节数)</span></span><br><span class="line">    <span class="comment">//prevrawlensize是当前entry中表示prevrawlen所需的字节数</span></span><br><span class="line">    <span class="comment">//这两个属性对应entry的previous_entry_length字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize, prevrawlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len是当前entry子串content字段的长度(字节数)</span></span><br><span class="line">    <span class="comment">//lensize是表示len所需的字节数</span></span><br><span class="line">    <span class="comment">//这两个属性对应entry的、encoding字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize, len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前entry子串中header的字节数，headersize=prevrawlensize+lensize</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;</span><br><span class="line">    <span class="comment">//当前节点值所使用的编码类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;</span><br><span class="line">    <span class="comment">//指向当前节点表示的entry子串的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">&#125; zlentry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the encoding pointer to by 'p'. */</span></span><br><span class="line"><span class="comment">//返回p指向的entry的编码类型</span></span><br><span class="line"><span class="comment">//该函数用于计算zlentry结构体中的encoding属性，因为encoding属性的char类型，是1个字节，所以函数返回的也应该是char类型。entry的编码类型确实只需要一个字节就能表示六种编码：ZIP_STR_06B是0x00，ZIP_STR_14B是0x40，ZIP_STR_32B是0x80，ZIP_INT_16B是0xc0，ZIP_INT_32B是0xd0，ZIP_INT_64B是0xe0</span></span><br><span class="line"><span class="comment">//因为编码类型要从encoding字段中解析，所以p不应该指向entry的头部，而是要向后偏移prevrawlensize个字节，指向entry的encoding字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipEntryEncoding</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* String encoding: 2 MSBs */</span></span><br><span class="line">    <span class="comment">//如果是字符串类型，b就是0x00、0x40或0x80</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b = p[<span class="number">0</span>] &amp; <span class="number">0xc0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0xc0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="comment">//如果是整数类型，p[0] &amp; 0xf0的结果就是0xc0、0xd0或0xe0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Integer encoding: 4 MSBs */</span></span><br><span class="line">        <span class="keyword">return</span> p[<span class="number">0</span>] &amp; <span class="number">0xf0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是字符串也不是整数，强制让assert为false，向stderr报错</span></span><br><span class="line">    assert(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return bytes needed to store integer encoded by 'encoding' */</span></span><br><span class="line"><span class="comment">//用于返回整数节点的len属性，也就是content字段存储的整数的字节数，三种int分别是2字节、4字节和8字节</span></span><br><span class="line"><span class="comment">//一个字符串的长度是不固定的，但是一个整数的长度是固定的，所以不需要计算，根据int类型就能知道整数占多少字节</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipIntSize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_16B: <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_32B: <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_64B: <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入的编码不支持，向stderr报错</span></span><br><span class="line">    assert(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the encoded length pointed by 'p'. If a pointer to 'lensize' is</span></span><br><span class="line"><span class="comment"> * provided, it is set to the number of bytes required to encode the length. */</span></span><br><span class="line"><span class="comment">//用于解析entry的encoding字段，得到zlentry结构体的len和lensize属性</span></span><br><span class="line"><span class="comment">//p指向entry子串的encoding字段，len是content字段的字节数，lensize是表示len需要的字节数，</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipDecodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> *lensize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取p的编码类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = zipEntryEncoding(p);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(encoding) &#123;</span><br><span class="line">        <span class="comment">//00开头的1字节编码</span></span><br><span class="line">        <span class="keyword">case</span> ZIP_STR_06B:</span><br><span class="line">            <span class="comment">//后6位是字符串长度，0x3f表示把p[0]的最高两位置0，len就是后6位表示的整数值</span></span><br><span class="line">            len = p[<span class="number">0</span>] &amp; <span class="number">0x3f</span>;</span><br><span class="line">            <span class="comment">//6bit的整数需要1个字节表示</span></span><br><span class="line">            <span class="keyword">if</span> (lensize) *lensize = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//01开头的2字节编码</span></span><br><span class="line">        <span class="keyword">case</span> ZIP_STR_14B:</span><br><span class="line">            <span class="comment">//后14位是字符串长度，0x3f表示把p[0]的最高两位置0，len就是后14位表示的整数值</span></span><br><span class="line">            len = ((p[<span class="number">0</span>] &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">8</span>) | p[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//14bit的整数需要2个字节表示</span></span><br><span class="line">            <span class="keyword">if</span> (lensize) *lensize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//10000000开头的5字节编码</span></span><br><span class="line">        <span class="keyword">case</span> ZIP_STR_32B:</span><br><span class="line">            <span class="comment">//后32位是字符串长度，用不到第一个字节，所以就不用考虑高位置0，len就是后4个字节表示的整数值</span></span><br><span class="line">            len = (p[<span class="number">1</span>] &lt;&lt; <span class="number">24</span>) | (p[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (p[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | p[<span class="number">4</span>];</span><br><span class="line">            <span class="comment">//4个字节的无符号整数，为什么需要5个字节表示呢？</span></span><br><span class="line">            <span class="keyword">if</span> (lensize) *lensize = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//都不是就报错</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            assert(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果是整数类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//整数的长度只能是2字节、4字节或8字节</span></span><br><span class="line">        len = zipIntSize(encoding);</span><br><span class="line">        <span class="comment">//2、4和8只需要1个字节表示</span></span><br><span class="line">        <span class="keyword">if</span> (lensize) *lensize = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode the length 'l' writing it in 'p'. If p is NULL it just returns</span></span><br><span class="line"><span class="comment"> * the amount of bytes required to encode such a length. */</span></span><br><span class="line"><span class="comment">//rawlen是某个entry的content字段的长度(字节数)，返回的是表示rawlen需要的字节数</span></span><br><span class="line"><span class="comment">//p指针指向entry的encoding字段，如果p!=NULL，就把算出来的encoding字段写到p地址上</span></span><br><span class="line"><span class="comment">//传进来的encoding是zlentry的属性，只有1个字节，要算出的是entry字符串中的encoding字段，可能是1字节、2字节或5字节</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding, <span class="keyword">unsigned</span> <span class="keyword">int</span> rawlen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//len是表示rawlen需要的字节数，默认是1</span></span><br><span class="line">    <span class="comment">//buf存的是encoding字段的值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> len = <span class="number">1</span>, buf[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//如果是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="comment">/* Although encoding is given it may not be set for strings,</span></span><br><span class="line"><span class="comment">         * so we determine it here using the raw length. */</span></span><br><span class="line">        <span class="comment">//如果rawlen不大于6bit整数的上限</span></span><br><span class="line">        <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3f</span>) &#123;</span><br><span class="line">            <span class="comment">//需要1个字节表示</span></span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            <span class="comment">//ZIP_STR_06B后6位是0，相当于给rawlen加上00的前缀，变成encoding字段的值</span></span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_06B | rawlen;</span><br><span class="line">        <span class="comment">//如果rawlen不大于14bit整数的上限</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3fff</span>) &#123;</span><br><span class="line">            <span class="comment">//需要2个字节表示</span></span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            <span class="comment">//ZIP_STR_14B后14位是0，相当于先对rawlen最高两位置0，再给rawlen加上01的前缀，变成encoding字段的值</span></span><br><span class="line">            <span class="comment">//为什么要置0呢？不大于0x3fff已经能确定最高两位是00了呀？</span></span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_14B | ((rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x3f</span>);</span><br><span class="line">            buf[<span class="number">1</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="comment">//否则就是需要5个字节表示</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            <span class="comment">//buf就是ZIP_STR_32B前缀加上rawlen的后4个字节</span></span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_32B;</span><br><span class="line">            buf[<span class="number">1</span>] = (rawlen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = (rawlen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = (rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">4</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果是整数编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Implies integer encoding, so length is always 1. */</span></span><br><span class="line">        <span class="comment">//默认的一个字节就足够</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="comment">//对于整数，zlentry的encoding属性和entry的encoding字段是相同的，因为只表示int类型不表示长度</span></span><br><span class="line">        <span class="comment">//而对于字符串，即使都是一个字节，两个encoding的值也不相同，因为zlentry的encoding属性后6位是0，而entry的encoding字段后6位表示字符串长度</span></span><br><span class="line">        buf[<span class="number">0</span>] = encoding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store this length at p */</span></span><br><span class="line">    <span class="comment">//把buf的前len个字节写到p地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,buf,len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the length of the previous element stored at "p". */</span></span><br><span class="line"><span class="comment">//返回前一个entry的content长度</span></span><br><span class="line"><span class="comment">//与上面的p不同，这里的p指向entry头部</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipPrevDecodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> *lensize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = *p;</span><br><span class="line">    <span class="comment">//第一个字节小于254，说明前一个entry的content小于254个字节</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">        <span class="comment">//需要1个字节就能表示</span></span><br><span class="line">        <span class="keyword">if</span> (lensize) *lensize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//第一个字节等于254，说明前一个entry的content大于等于254</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//需要多1个字节，因为第一个字节默认是0xfe的标志</span></span><br><span class="line">        <span class="keyword">if</span> (lensize) *lensize = <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        <span class="comment">//跳过第一个字节，读取长度值并赋给len</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;len,p+<span class="number">1</span>,<span class="keyword">sizeof</span>(len));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode the length of the previous entry and write it to "p". Return the</span></span><br><span class="line"><span class="comment"> * number of bytes needed to encode this length if "p" is NULL. */</span></span><br><span class="line"><span class="comment">//返回表示len需要的字节数</span></span><br><span class="line"><span class="comment">//和zipPrevDecodeLength逻辑正好相反</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipPrevEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (len &lt; ZIP_BIGLEN) ? <span class="number">1</span> : <span class="keyword">sizeof</span>(len)+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">            <span class="comment">//跳过第一个字节，把长度值从第二个字节开始写入previous_entry_length字段</span></span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode the length of the previous entry and write it to "p". This only</span></span><br><span class="line"><span class="comment"> * uses the larger encoding (required in __ziplistCascadeUpdate). */</span></span><br><span class="line"><span class="comment">//强制将上一个entry的content长度以0xfe开头5字节形式写入当前entry的previous_entry_length字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipPrevEncodeLengthForceLarge</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">    <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the difference in number of bytes needed to store the new length</span></span><br><span class="line"><span class="comment"> * "len" on the entry pointed to by "p". */</span></span><br><span class="line"><span class="comment">//计算表示len需要的字节数与上个entry的previous_entry_length字段的字节数之差</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zipPrevLenByteDiff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize;</span><br><span class="line">    <span class="comment">//prevlensize记录上个entry的previous_entry_length字段的字节数</span></span><br><span class="line">    zipPrevDecodeLength(p,&amp;prevlensize);</span><br><span class="line">    <span class="keyword">return</span> zipPrevEncodeLength(<span class="literal">NULL</span>,len)-prevlensize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if string pointed to by 'entry' can be encoded as an integer.</span></span><br><span class="line"><span class="comment"> * Stores the integer value in 'v' and its encoding in 'encoding'. */</span></span><br><span class="line"><span class="comment">//判断entrylen个字节的字符串类型的content能否转换为数值，如果可以返回1，否则返回0，并将拿到的数字赋值给*v, 将encoding字段赋值给 *encoding</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zipTryEncoding</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *entry, <span class="keyword">unsigned</span> <span class="keyword">int</span> entrylen, <span class="keyword">long</span> <span class="keyword">long</span> *v, <span class="keyword">unsigned</span> <span class="keyword">char</span> *encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最高支持32字节的有符号整数</span></span><br><span class="line">    <span class="keyword">if</span> (entrylen &gt;= <span class="number">32</span> || entrylen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//'-'开头表示是负数</span></span><br><span class="line">    <span class="keyword">if</span> (entry[<span class="number">0</span>] == <span class="string">'-'</span> || (entry[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; entry[<span class="number">0</span>] &lt;= <span class="string">'9'</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> slen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Perform a back-and-forth conversion to make sure that</span></span><br><span class="line"><span class="comment">         * the string turned into an integer is not losing any info. */</span></span><br><span class="line">        <span class="comment">//把字符串全部复制到buf数组</span></span><br><span class="line">        <span class="built_in">memcpy</span>(buf,entry,entrylen);</span><br><span class="line">        <span class="comment">//字符串的结束标记</span></span><br><span class="line">        buf[entrylen] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">//把buf转换成10进制的long long int类型整数，eptr返回可转换的子串的下一个字符</span></span><br><span class="line">        value = strtoll(buf,&amp;eptr,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//可转换的子串下一个字符不是结束符，说明从eptr位置开始不能转换成整数，退出函数</span></span><br><span class="line">        <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把value再转换成最长32字节的字符串</span></span><br><span class="line">        slen = ll2string(buf,<span class="number">32</span>,value);</span><br><span class="line">        <span class="comment">//转成数值再转回来，如果长度不相等，或者buf和entry不相等，说明出了问题</span></span><br><span class="line">        <span class="comment">//为什么会出问题？</span></span><br><span class="line">        <span class="keyword">if</span> (entrylen != (<span class="keyword">unsigned</span>)slen || <span class="built_in">memcmp</span>(buf,entry,slen)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Great, the string can be encoded. Check what's the smallest</span></span><br><span class="line"><span class="comment">         * of our encoding types that can hold this value. */</span></span><br><span class="line">        <span class="comment">//根据value选择合适的编码</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_16B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_32B;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *encoding = ZIP_INT_64B;</span><br><span class="line">        &#125;</span><br><span class="line">        *v = value;</span><br><span class="line">        <span class="comment">//成功就返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store integer 'value' at 'p', encoded as 'encoding' */</span></span><br><span class="line"><span class="comment">//指定编码类型，在p地址写入整数value，p指向entry的content字段</span></span><br><span class="line"><span class="comment">//参数的value是8字节的，根据encoding判断前多少个字节是有效的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipSaveInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int64_t</span> value, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        i16 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i16,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        i32 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i32,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        i64 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i64,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read integer encoded as 'encoding' from 'p' */</span></span><br><span class="line"><span class="comment">//指定编码类型，从p地址取出存储的整数，p指向entry的content字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int64_t <span class="title">zipLoadInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i16,p,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">        ret = i16;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i32,p,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">        ret = i32;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i64,p,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">        ret = i64;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a struct with all information about an entry. */</span></span><br><span class="line"><span class="comment">//解析指针p指向的entry字符串，生成zlentry结构</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> zlentry <span class="title">zipEntry</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    zlentry e;</span><br><span class="line">    <span class="comment">//p指向entry头部，解析previous_entry_length字段</span></span><br><span class="line">    <span class="comment">//得到上个entry的content字段的字节数prevrawlen，以及表示prevrawlen所需的字节数prevrawlensize</span></span><br><span class="line">    e.prevrawlen = zipPrevDecodeLength(p,&amp;e.prevrawlensize);</span><br><span class="line">    <span class="comment">//p指向entry的encoding字段，解析encoding字段</span></span><br><span class="line">    <span class="comment">//得到当前entry的content字段的字节数prevrawlen，以及表示len所需的字节数lensize</span></span><br><span class="line">    e.len = zipDecodeLength(p+e.prevrawlensize,&amp;e.lensize);</span><br><span class="line">    <span class="comment">//计算headersize，也就是header部分(content之前)的字节数</span></span><br><span class="line">    e.headersize = e.prevrawlensize+e.lensize;</span><br><span class="line">    <span class="comment">//获取当前节点的编码类型</span></span><br><span class="line">    e.encoding = zipEntryEncoding(p+e.prevrawlensize);</span><br><span class="line">    <span class="comment">//指针指向entry头部</span></span><br><span class="line">    e.p = p;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the total number of bytes used by the entry at "p". */</span></span><br><span class="line"><span class="comment">//返回p指向的entry的总字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipRawEntryLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析成zlentry结构</span></span><br><span class="line">    zlentry e = zipEntry(p);</span><br><span class="line">    <span class="comment">//总字节数就是header字节数加content字节数</span></span><br><span class="line">    <span class="keyword">return</span> e.headersize + e.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="comment">//创建空的ziplist</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ziplist的header固定10个字节，再加上末尾的zlend是1个字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    <span class="comment">//zlbytes字段记录整个ziplist的总字节数，也就是bytes</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = bytes;</span><br><span class="line">    <span class="comment">//zltail字段记录表尾节点到表头的距离，因为新列表还没有节点，所以尾节点默认在header后面</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = ZIPLIST_HEADER_SIZE;</span><br><span class="line">    <span class="comment">//zllen字段记录entry的个数</span></span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最后一个字节是0xff</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the ziplist. */</span></span><br><span class="line"><span class="comment">//重新设置ziplist的大小，参数len是整个ziplist的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    zl = zrealloc(zl,len);</span><br><span class="line">    ZIPLIST_BYTES(zl) = len;</span><br><span class="line">    zl[len<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When an entry is inserted, we need to set the prevlen field of the next</span></span><br><span class="line"><span class="comment"> * entry to equal the length of the inserted entry. It can occur that this</span></span><br><span class="line"><span class="comment"> * length cannot be encoded in 1 byte and the next entry needs to be grow</span></span><br><span class="line"><span class="comment"> * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,</span></span><br><span class="line"><span class="comment"> * because this only happens when an entry is already being inserted (which</span></span><br><span class="line"><span class="comment"> * causes a realloc and memmove). However, encoding the prevlen may require</span></span><br><span class="line"><span class="comment"> * that this entry is grown as well. This effect may cascade throughout</span></span><br><span class="line"><span class="comment"> * the ziplist when there are consecutive entries with a size close to</span></span><br><span class="line"><span class="comment"> * ZIP_BIGLEN, so we need to check that the prevlen can be encoded in every</span></span><br><span class="line"><span class="comment"> * consecutive entry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this effect can also happen in reverse, where the bytes required</span></span><br><span class="line"><span class="comment"> * to encode the prevlen field can shrink. This effect is deliberately ignored,</span></span><br><span class="line"><span class="comment"> * because it can cause a "flapping" effect where a chain prevlen fields is</span></span><br><span class="line"><span class="comment"> * first grown and then shrunk again after consecutive inserts. Rather, the</span></span><br><span class="line"><span class="comment"> * field is allowed to stay larger than necessary, because a large prevlen</span></span><br><span class="line"><span class="comment"> * field implies the ziplist is holding large entries anyway.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pointer "p" points to the first entry that does NOT need to be</span></span><br><span class="line"><span class="comment"> * updated, i.e. consecutive fields MAY need an update. */</span></span><br><span class="line"><span class="comment">//连锁更新函数</span></span><br><span class="line"><span class="comment">//当在ziplist中插入新entry后，如果前一个entry长度大于254个字节，而新entry的previous_entry_length字段只有一个字节，就需要对新entry扩容，同时如果新entry长度大于254个字节，而后一个entry的previous_entry_length字段只有一个字节，就需要对后一个entry扩容。所以在插入新entry后，可能会对包括新entry在内的之后连续的几个entry进行扩容，这个过程叫做连锁更新。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p) &#123;</span><br><span class="line">    <span class="comment">//curlen是当前ziplist的总字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> curlen = ZIPLIST_BYTES(zl), rawlen, rawlensize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, noffset, extra;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line">    <span class="comment">//从p指针指向的entry开始检查，每次遍历到p指向的entry时，实际要修改的是下个entry的字段</span></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">//生成当前entry的zlentry结构</span></span><br><span class="line">        cur = zipEntry(p);</span><br><span class="line">        <span class="comment">//rawlen是当前entry的总字节数</span></span><br><span class="line">        rawlen = cur.headersize + cur.len;</span><br><span class="line">        <span class="comment">//rawlensize是表示rawlen需要的字节数</span></span><br><span class="line">        rawlensize = zipPrevEncodeLength(<span class="literal">NULL</span>,rawlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort if there is no next entry. */</span></span><br><span class="line">        <span class="comment">//后面没有entry了，所以就没有待修改的entry了，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//生成下个entry的zlentry结构</span></span><br><span class="line">        next = zipEntry(p+rawlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort when "prevlen" has not changed. */</span></span><br><span class="line">        <span class="comment">//如果下个entry的prevrawlen属性等于当前entry的字节数，说明后面所有entry的previous_entry_length都不用改了，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果下个entry的previous_entry_length的字节数不足以表示当前entry的长度，就要对ziplist扩容</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</span><br><span class="line">            <span class="comment">/* The "prevlen" field of "next" needs more bytes to hold</span></span><br><span class="line"><span class="comment">             * the raw length of "cur". */</span></span><br><span class="line">            <span class="comment">//offset是ziplist中当前entry之前的字节数，也就是当前entry头部到ziplist头部的字节数</span></span><br><span class="line">            offset = p-zl;</span><br><span class="line">            <span class="comment">//需要增加的字节数量</span></span><br><span class="line">            extra = rawlensize-next.prevrawlensize;</span><br><span class="line">            <span class="comment">//把ziplist的字节数设为当前字节数加extra</span></span><br><span class="line">            zl = ziplistResize(zl,curlen+extra);</span><br><span class="line">            <span class="comment">//ziplist扩容后，当前entry之前的部分没有变化，所以新的ziplist中offset的位置仍然是当前entry</span></span><br><span class="line">            p = zl+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Current pointer and offset for next element. */</span></span><br><span class="line">            <span class="comment">//下个entry的地址</span></span><br><span class="line">            np = p+rawlen;</span><br><span class="line">            <span class="comment">//下个entry到ziplist头部的字节数</span></span><br><span class="line">            noffset = np-zl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update tail offset when next element is not the tail element. */</span></span><br><span class="line">            <span class="comment">//zltail是最后一个entry到ziplist头部的字节数，如果下个entry不是最后一个，扩容多出来的几个字节应该算在zltail里</span></span><br><span class="line">            <span class="keyword">if</span> ((zl+ZIPLIST_TAIL_OFFSET(zl)) != np)</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) += extra;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move the tail to the back. */</span></span><br><span class="line">            <span class="comment">//增加下个entry的previous_entry_length字段的长度，就是把ziplist中从下个entry的encoding开始的后面的部分全部后移extra个字节。换言之，把旧的encoding字段开始的后半段移动到新的encoding字段开始的地址上。</span></span><br><span class="line">            <span class="comment">//np+rawlensize就是下个entry的encoding字段在新ziplist的起始位置，np+next.prevrawlensize就是下个entry的encoding字段在旧ziplist的起始位置，移动的后半段的字节数是curlen-noffset-next.prevrawlensize-1</span></span><br><span class="line">            memmove(np+rawlensize,</span><br><span class="line">                np+next.prevrawlensize,</span><br><span class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//把新的previous_entry_length字段写入下个entry的头部</span></span><br><span class="line">            zipPrevEncodeLength(np,rawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Advance the cursor */</span></span><br><span class="line">            <span class="comment">//继续检查下个entry</span></span><br><span class="line">            p += rawlen;</span><br><span class="line">            <span class="comment">//更新ziplist总字节数</span></span><br><span class="line">            curlen += extra;</span><br><span class="line">        <span class="comment">//如果下个entry的previous_entry_length的字节数足够表示当前entry的长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前entry的长度只需要1字节表示，但是下个entry的previous_entry_length有5字节，说明容量多了。但此时不缩减ziplist的长度，而是把rawlensize以5字节的记录方式写入下个entry的previous_entry_length</span></span><br><span class="line">            <span class="comment">//所以连锁更新的时候ziplist只扩容不收缩，为啥呢？</span></span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></span><br><span class="line"><span class="comment">                 * So, set "rawlen" in the available bytes. */</span></span><br><span class="line">                zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);</span><br><span class="line">            <span class="comment">//如果恰好都是1字节，就直接把rawlen写入下个entry的previous_entry_length</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zipPrevEncodeLength(p+rawlen,rawlen);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Stop here, as the raw length of "next" has not changed. */</span></span><br><span class="line">            <span class="comment">//在这种情况下，下个entry只需要修改字段值，而不需要扩容，所以连锁更新到此为止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete "num" entries, starting at "p". Returns pointer to the ziplist. */</span></span><br><span class="line"><span class="comment">//在zl中，从p指向的entry开始，删除num个entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistDelete(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, totlen, deleted = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> offset, nextdiff = <span class="number">0</span>;</span><br><span class="line">    zlentry first, tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原始的p指针保存在first中</span></span><br><span class="line">    first = zipEntry(p);</span><br><span class="line">    <span class="comment">//p指针移动到所有要删除的entry的末尾</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; p[<span class="number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</span><br><span class="line">        p += zipRawEntryLength(p);</span><br><span class="line">        deleted++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要删除的总字节数就是现在的p地址和原始的p地址的位置差</span></span><br><span class="line">    totlen = p-first.p;</span><br><span class="line">    <span class="keyword">if</span> (totlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//p没有到ziplist末尾，说明没有删除最后一个entry</span></span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">/* Tricky: storing the prevlen in this entry might reduce or</span></span><br><span class="line"><span class="comment">             * increase the number of bytes needed, compared to the current</span></span><br><span class="line"><span class="comment">             * prevlen. Note that we can always store this length because</span></span><br><span class="line"><span class="comment">             * it was previously stored by an entry that is being deleted. */</span></span><br><span class="line">            <span class="comment">//原始的p地址和现在的p地址之间被删掉了，所以要重新连接的是原来的p指向的entry的上个entry，和现在的p指向的entry。所以要更新的就是现在的p指向的entry的previous_entry_length字段，也就是让现在的p指向的entry的previous_entry_length字段存储first.prevrawlen表示的数值</span></span><br><span class="line">            <span class="comment">//如果当前entry的previous_entry_length字段不足以表示first.prevrawlen的值，nextdiff存储的就是额外需要的字节数</span></span><br><span class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</span><br><span class="line">            <span class="comment">//不需要扩容，额外的字节从p前面找，反正前面的entry是准备删掉的，直接覆盖写入就好，到时候少删掉nextdiff个字节就ok了</span></span><br><span class="line">            zipPrevEncodeLength(p-nextdiff,first.prevrawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update offset for tail */</span></span><br><span class="line">            <span class="comment">//zltail要减去删除掉的字节数</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) -= totlen;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">             * "nextdiff" in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">             * size of prevlen doesn't have an effect on the *tail* offset. */</span></span><br><span class="line">            tail = zipEntry(p);</span><br><span class="line">            <span class="comment">//长度对不上，是因为上面多删了nextdiff个字节，所以在这里要加回来</span></span><br><span class="line">            <span class="keyword">if</span> (p[tail.headersize+tail.len] != ZIP_END)</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) += nextdiff;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move tail to the front of the ziplist */</span></span><br><span class="line">            <span class="comment">//把p-nextdiff开始的内容复制到first.p开始的地址，就相当于把中间的部分删除了</span></span><br><span class="line">            memmove(first.p,p-nextdiff,ZIPLIST_BYTES(zl)-(p-zl)<span class="number">-1</span>+nextdiff);</span><br><span class="line">        <span class="comment">//p就是ziplist末尾，说明原始的p地址后面所有的entry都删掉了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The entire tail was deleted. No need to move memory. */</span></span><br><span class="line">            <span class="comment">//zltail是最后一个entry到ziplist头部的字节数，first.p-zl是最初的p指向的entry到ziplist头部的字节数，但因为这个entry也被删掉了，所以还要移动到上个entry的头部，也就是回退first.prevrawlen个字节</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) = (first.p-zl)-first.prevrawlen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Resize and update length */</span></span><br><span class="line">        <span class="comment">//记录第一个删除的节点的头地址</span></span><br><span class="line">        offset = first.p-zl;</span><br><span class="line">        <span class="comment">//减少ziplist的总字节数</span></span><br><span class="line">        zl = ziplistResize(zl, ZIPLIST_BYTES(zl)-totlen+nextdiff);</span><br><span class="line">        <span class="comment">//修改zllen字段的值，zllen表示ziplist中entry的数量，所以减去deleted</span></span><br><span class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</span><br><span class="line">        <span class="comment">//调整完ziplist的长度后，定位第一个删除的节点的头地址</span></span><br><span class="line">        p = zl+offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">         * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">        <span class="comment">//nextdiff不等于0，说明p指向的entry的previous_entry_length字段被延长了，也就是这个entry的总长度变了，所以需要从这个entry开始连锁更新，但是是从下个entry的previous_entry_length字段开始更新，p指向的entry不变</span></span><br><span class="line">        <span class="keyword">if</span> (nextdiff != <span class="number">0</span>)</span><br><span class="line">            zl = __ziplistCascadeUpdate(zl,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert item at "p". */</span></span><br><span class="line"><span class="comment">//在zl的位置p插入一个新entry，s是被插入的entry，slen是s的content字段的字节数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="comment">//curlen是当前ziplist的总字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> curlen = ZIPLIST_BYTES(zl), reqlen, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    zlentry entry, tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></span><br><span class="line">    <span class="comment">//p是插入entry的位置，所以当前p指向的entry就是新entry的后一个entry，所以p指向的entry的previous_entry_length字段应该存在新entry里</span></span><br><span class="line">    <span class="comment">//如果p没有指向ZIP_END，说明新entry的后面还有entry，也就是p指向的entry</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">//获取p指向的entry的prevrawlen属性</span></span><br><span class="line">        entry = zipEntry(p);</span><br><span class="line">        prevlen = entry.prevrawlen;</span><br><span class="line">    <span class="comment">//如果p指向ZIP_END，说明新entry的后面没有entry了，所以新entry的prevrawlen属性就不能从后面的entry头部找，而是直接解析前一个entry，也就是zltail指向的entry</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if the entry can be encoded */</span></span><br><span class="line">    <span class="comment">//在ziplist中，整型值被存储为实际的整型值而不是字符串。所以插入新entry时要检查content字段是否可以当做整数存储，如果可以转成整数，就不用存成字符串了，这样可以节省空间</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* 'encoding' is set to the appropriate integer encoding */</span></span><br><span class="line">        <span class="comment">//如果能转成整数，reqlen就是该整数类型需要的字节数</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 'encoding' is untouched, however zipEncodeLength will use the</span></span><br><span class="line"><span class="comment">         * string length to figure out how to encode it. */</span></span><br><span class="line">        <span class="comment">//否则，reqlen就是新entry的content字段的字节数</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We need space for both the length of the previous entry and</span></span><br><span class="line"><span class="comment">     * the length of the payload. */</span></span><br><span class="line">    <span class="comment">//reqlen再加上新entry的previous_entry_length字段所需的字节数</span></span><br><span class="line">    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">//reqlen再加上表示新entry需要的字节数，也就是新entry的encoding字段的字节数</span></span><br><span class="line">    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line">    <span class="comment">//三个字段都算上了，现在的reqlen就是新entry的总字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the insert position is not equal to the tail, we need to</span></span><br><span class="line"><span class="comment">     * make sure that the next entry can hold this entry's length in</span></span><br><span class="line"><span class="comment">     * its prevlen field. */</span></span><br><span class="line">    <span class="comment">//如果新entry后面还有entry，需要考虑后面entry的previous_entry_length字段是否足够表示新entry的长度</span></span><br><span class="line">    <span class="comment">//nextdiff就是后面的entry的previous_entry_length字段需要延长的字节数</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    <span class="comment">//因为是在p地址后面插入，所以要保存p地址到ziplist头部的距离</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    <span class="comment">//给ziplist扩容，增加的长度是新entry所需的字节数加上后面entry需要延长的字节数</span></span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    <span class="comment">//在新的ziplist中重定位p的位置</span></span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class="line">        <span class="comment">//p-nextdiff是后面的entry的头地址，把这之后的所有内容后移reqlen个字节，给新entry腾出位置</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Encode this entry's raw length in the next entry. */</span></span><br><span class="line">        <span class="comment">//更新后面entry的previous_entry_length，来表示新entry的总字节数reqlen</span></span><br><span class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update offset for tail */</span></span><br><span class="line">        <span class="comment">//zltail的值要增加</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) += reqlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">         * "nextdiff" in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">         * size of prevlen doesn't have an effect on the *tail* offset. */</span></span><br><span class="line">        tail = zipEntry(p+reqlen);</span><br><span class="line">        <span class="comment">//如果后面的entry头部被延长了，就需要给zltail补回nextdiff</span></span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END)</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) += nextdiff;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This element will be the new tail. */</span></span><br><span class="line">        <span class="comment">//如果新entry就是最后一个entry，zltail就是新entry头地址到ziplist头地址的距离</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = p-zl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">    <span class="comment">//如果后面的entry被延长了，需要连锁更新</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the entry */</span></span><br><span class="line">    <span class="comment">//填写新entry各个字段的值</span></span><br><span class="line">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">    p += zipEncodeLength(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//zllen表示entry总数，插入新entry后要加一</span></span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向zl中插入s，插入位置可以选择是头部或尾部</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns an offset to use for iterating with ziplistNext. When the given</span></span><br><span class="line"><span class="comment"> * index is negative, the list is traversed back to front. When the list</span></span><br><span class="line"><span class="comment"> * doesn't contain an element at the provided index, NULL is returned. */</span></span><br><span class="line"><span class="comment">//返回zl中第index个entry的头地址</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistIndex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="comment">//支持负索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//负索引是从最后一个entry向前数</span></span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            entry = zipEntry(p);</span><br><span class="line">            <span class="comment">//每跳过一个entry，指针p就减去这个entry的长度，相当于退到前一个entry</span></span><br><span class="line">            <span class="keyword">while</span> (entry.prevrawlen &gt; <span class="number">0</span> &amp;&amp; index--) &#123;</span><br><span class="line">                p -= entry.prevrawlen;</span><br><span class="line">                entry = zipEntry(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从第一个entry开始，每跳过一个entry，指针p就加上这个entry的长度，最后p指向的就是第index个entry</span></span><br><span class="line">        p = ZIPLIST_ENTRY_HEAD(zl);</span><br><span class="line">        <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END &amp;&amp; index--) &#123;</span><br><span class="line">            p += zipRawEntryLength(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果索引越界，就返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END || index &gt; <span class="number">0</span>) ? <span class="literal">NULL</span> : p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return pointer to next entry in ziplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zl is the pointer to the ziplist</span></span><br><span class="line"><span class="comment"> * p is the pointer to the current element</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The element after 'p' is returned, otherwise NULL if we are at the end. */</span></span><br><span class="line"><span class="comment">//返回p指向的entry的下一个entry的头地址</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>) zl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* "p" could be equal to ZIP_END, caused by ziplistDelete,</span></span><br><span class="line"><span class="comment">     * and we should return NULL. Otherwise, we should return NULL</span></span><br><span class="line"><span class="comment">     * when the *next* element is ZIP_END (there is no next entry). */</span></span><br><span class="line">    <span class="comment">//如果p是ZIP_END，后面就没有entry了</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//其实就是把p后移，后移长度是p指向的entry的长度</span></span><br><span class="line">        p = p+zipRawEntryLength(p);</span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END) ? <span class="literal">NULL</span> : p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return pointer to previous entry in ziplist. */</span></span><br><span class="line"><span class="comment">//返回p指向的entry的前一个entry的头地址</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterating backwards from ZIP_END should return the tail. When "p" is</span></span><br><span class="line"><span class="comment">     * equal to the first element of the list, we're already at the head,</span></span><br><span class="line"><span class="comment">     * and should return NULL. */</span></span><br><span class="line">    <span class="comment">//如果p是ZIP_END，上一个entry就是最后一个entry</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="comment">//如果最后一个entry也是ZIP_END，说明zl是空的</span></span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END) ? <span class="literal">NULL</span> : p;</span><br><span class="line">    <span class="comment">//如果p指向的就是第一个entry，前面就没有entry了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == ZIPLIST_ENTRY_HEAD(zl)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则就是把p前移，前移长度是p指向的entry的长度</span></span><br><span class="line">        <span class="comment">//这时就体现出previous_entry_length字段的作用了，之所以要记录前一个entry的长度，就是为了从后向前遍历</span></span><br><span class="line">        entry = zipEntry(p);</span><br><span class="line">        assert(entry.prevrawlen &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> p-entry.prevrawlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get entry pointer to by 'p' and store in either 'e' or 'v' depending</span></span><br><span class="line"><span class="comment"> * on the encoding of the entry. 'e' is always set to NULL to be able</span></span><br><span class="line"><span class="comment"> * to find out whether the string pointer or the integer value was set.</span></span><br><span class="line"><span class="comment"> * Return 0 if 'p' points to the end of the zipmap, 1 otherwise. */</span></span><br><span class="line"><span class="comment">//读取p指向的entry的content字段，如果是字符串就赋给sstr，同时字符串长度赋给slen，如果是整数就赋给sval</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **sstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> *slen, <span class="keyword">long</span> <span class="keyword">long</span> *sval)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="comment">//如果p指向的不是entry，就返回0，表示读取失败</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p[<span class="number">0</span>] == ZIP_END) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sstr) *sstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    entry = zipEntry(p);</span><br><span class="line">    <span class="comment">//如果content的类型的字符串</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">        <span class="comment">//判断一下，防止传进来的sstr指针本身就是NULL</span></span><br><span class="line">        <span class="keyword">if</span> (sstr) &#123;</span><br><span class="line">            *slen = entry.len;</span><br><span class="line">            *sstr = p+entry.headersize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sval) &#123;</span><br><span class="line">            *sval = zipLoadInteger(p+entry.headersize,entry.encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert an entry at "p". */</span></span><br><span class="line"><span class="comment">//毫无意义的函数，和__ziplistInsert参数一样，只是对__ziplistInsert的调用</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a single entry from the ziplist, pointed to by *p.</span></span><br><span class="line"><span class="comment"> * Also update *p in place, to be able to iterate over the</span></span><br><span class="line"><span class="comment"> * ziplist, while deleting entries. */</span></span><br><span class="line"><span class="comment">//在zl中删除p指向的entry，再把下个entry的地址赋给p</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset = *p-zl;</span><br><span class="line">    zl = __ziplistDelete(zl,*p,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store pointer to current element in p, because ziplistDelete will</span></span><br><span class="line"><span class="comment">     * do a realloc which might result in a different "zl"-pointer.</span></span><br><span class="line"><span class="comment">     * When the delete direction is back to front, we might delete the last</span></span><br><span class="line"><span class="comment">     * entry and end up with "p" pointing to ZIP_END, so check this. */</span></span><br><span class="line">    *p = zl+offset;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a range of entries from the ziplist. */</span></span><br><span class="line"><span class="comment">//从第index个entry开始，删除num个entry</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDeleteRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(zl,index);</span><br><span class="line">    <span class="comment">//把p==NULL的判断放在__ziplistDelete里，就不必写成两个函数了</span></span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">NULL</span>) ? zl : __ziplistDelete(zl,p,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare entry pointer to by 'p' with 'entry'. Return 1 if equal. */</span></span><br><span class="line"><span class="comment">//把p指向的entry的content字段，和长度为slen的字符串sstr作比较，相同返回1，不相同返回0</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistCompare</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *sstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sencoding;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> zval, sval;</span><br><span class="line">    <span class="comment">//如果p指向的不是entry，就退出</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    entry = zipEntry(p);</span><br><span class="line">    <span class="comment">//如果content的内容是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">        <span class="comment">/* Raw compare */</span></span><br><span class="line">        <span class="comment">//用memcmp比较字符串</span></span><br><span class="line">        <span class="keyword">if</span> (entry.len == slen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">memcmp</span>(p+entry.headersize,sstr,slen) == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果content的内容是整数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Try to compare encoded values */</span></span><br><span class="line">        <span class="comment">//先把字符串表示的整数转换成int类型</span></span><br><span class="line">        <span class="keyword">if</span> (zipTryEncoding(sstr,slen,&amp;sval,&amp;sencoding)) &#123;</span><br><span class="line">            <span class="comment">//encoding相不相等其实无所谓吧，encoding不相等的话值肯定不会相等的，存疑？</span></span><br><span class="line">            <span class="keyword">if</span> (entry.encoding == sencoding) &#123;</span><br><span class="line">                zval = zipLoadInteger(p+entry.headersize,entry.encoding);</span><br><span class="line">                <span class="keyword">return</span> zval == sval;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return length of ziplist. */</span></span><br><span class="line"><span class="comment">//返回zllen字段的值，也就是ziplist中存储的entry的数量</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//因为zllen的类型是uint16_t，所以如果zllen小于UINT16_MAX，说明表示的值是有效的</span></span><br><span class="line">    <span class="keyword">if</span> (ZIPLIST_LENGTH(zl) &lt; UINT16_MAX) &#123;</span><br><span class="line">        len = ZIPLIST_LENGTH(zl);</span><br><span class="line">    <span class="comment">//如果zllen等于UINT16_MAX，说明溢出了，需要遍历ziplist数entry的个数，数量存在len变量里</span></span><br><span class="line">    <span class="comment">//len是uint32_t，所以ziplist支持的最大entry数量是uint32_t的上界</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//p定位在第一个entry的头地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zl+ZIPLIST_HEADER_SIZE;</span><br><span class="line">        <span class="keyword">while</span> (*p != ZIP_END) &#123;</span><br><span class="line">            p += zipRawEntryLength(p);</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Re-store length if small enough */</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; UINT16_MAX) ZIPLIST_LENGTH(zl) = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return size in bytes of ziplist. */</span></span><br><span class="line"><span class="comment">//返回zlbytes字段的值，也就是ziplist的总字节数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistSize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ZIPLIST_BYTES(zl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印ziplist的结构，debug用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ziplistRepr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    zlentry entry;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"&#123;total bytes %d&#125; "</span></span><br><span class="line">        <span class="string">"&#123;length %u&#125;\n"</span></span><br><span class="line">        <span class="string">"&#123;tail offset %u&#125;\n"</span>,</span><br><span class="line">        ZIPLIST_BYTES(zl),</span><br><span class="line">        ZIPLIST_LENGTH(zl),</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl));</span><br><span class="line">    p = ZIPLIST_ENTRY_HEAD(zl);</span><br><span class="line">    <span class="keyword">while</span>(*p != ZIP_END) &#123;</span><br><span class="line">        entry = zipEntry(p);</span><br><span class="line">        <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">"&#123;"</span></span><br><span class="line">                <span class="string">"addr 0x%08lx, "</span></span><br><span class="line">                <span class="string">"index %2d, "</span></span><br><span class="line">                <span class="string">"offset %5ld, "</span></span><br><span class="line">                <span class="string">"rl: %5u, "</span></span><br><span class="line">                <span class="string">"hs %2u, "</span></span><br><span class="line">                <span class="string">"pl: %5u, "</span></span><br><span class="line">                <span class="string">"pls: %2u, "</span></span><br><span class="line">                <span class="string">"payload %5u"</span></span><br><span class="line">            <span class="string">"&#125; "</span>,</span><br><span class="line">            (<span class="keyword">long</span> <span class="keyword">unsigned</span>)p,</span><br><span class="line">            index,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (p-zl),</span><br><span class="line">            entry.headersize+entry.len,</span><br><span class="line">            entry.headersize,</span><br><span class="line">            entry.prevrawlen,</span><br><span class="line">            entry.prevrawlensize,</span><br><span class="line">            entry.len);</span><br><span class="line">        p += entry.headersize;</span><br><span class="line">        <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.len &gt; <span class="number">40</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fwrite(p,<span class="number">40</span>,<span class="number">1</span>,<span class="built_in">stdout</span>) == <span class="number">0</span>) perror(<span class="string">"fwrite"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"..."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.len &amp;&amp;</span><br><span class="line">                    fwrite(p,entry.len,<span class="number">1</span>,<span class="built_in">stdout</span>) == <span class="number">0</span>) perror(<span class="string">"fwrite"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>) zipLoadInteger(p,entry.encoding));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        p += entry.len;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#123;end&#125;\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-压缩字典"><a href="#3-3-压缩字典" class="headerlink" title="3.3 压缩字典"></a>3.3 压缩字典</h2><h3 id="zipmap-c"><a href="#zipmap-c" class="headerlink" title="zipmap.c"></a>zipmap.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; String Map data structure optimized for size.</span></span><br><span class="line"><span class="comment">//和ziplist类似，zipmap是为节省内存而设计的一种存储String-&gt;String数据的字符串形式的字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory layout of a zipmap, for the map "foo" =&gt; "bar", "hello" =&gt; "world":</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;zmlen&gt;&lt;len&gt;"foo"&lt;len&gt;&lt;free&gt;"bar"&lt;len&gt;"hello"&lt;len&gt;&lt;free&gt;"world"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zmlen字段存储的是zipmap中的key-value对的数量，只有1字节，当zipmap长度超过254时，zmlen的值就失效了，需要遍历zipmap来得到真实的key-value数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个len字段存储的是它后面的数据的字节数，数据可能是key也可能是value，len字段长度是1字节或5字节。当第一个字节值小于254时，表示len字段只有1个字节，该字节的值就是数据的长度。当第一个字节值等于254时，表示len字段有5个字节，后面4个字节的值才是数据的长度。当第一个字节值等于255时，表示到了zipmap的末尾。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 因为每个字符串前面都有len字段，所以执行查询操作时，不需要逐字节比较，直接取len长度的字符串用memcmp比较一次即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * free字段存储的是可用的空闲字节数，如果把某个value字符串替换成更短的字符串，后面就会留出多余的字节。空闲字节数只需要1个字节表示，如果空出来的字节数过多，zipmap会被realloc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The most compact representation of the above two elements hash is actually:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * "\x02\x03foo\x03\x00bar\x05hello\x05\x00world\xff"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zmalloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//254是len字段的分界值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_BIGLEN 254</span></span><br><span class="line"><span class="comment">//255是zipmap尾部的标记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_END 255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following defines the max value for the &lt;free&gt; field described in the</span></span><br><span class="line"><span class="comment"> * comments above, that is, the max number of trailing bytes in a value. */</span></span><br><span class="line"><span class="comment">//zipmap允许的最大free字节数3(4是不可取的上限)，所以free字段只需要1个字节表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_VALUE_MAX_FREE 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following macro returns the number of bytes needed to encode the length</span></span><br><span class="line"><span class="comment"> * for the integer value _l, that is, 1 byte for lengths &lt; ZIPMAP_BIGLEN and</span></span><br><span class="line"><span class="comment"> * 5 bytes for all the other lengths. */</span></span><br><span class="line"><span class="comment">//返回表示长度_l的len字段所需的字节数，如果小于254就只需要1个字节，否则需要5个字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_LEN_BYTES(_l) (((_l) &lt; ZIPMAP_BIGLEN) ? 1 : sizeof(unsigned int)+1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new empty zipmap. */</span></span><br><span class="line"><span class="comment">//创建空的zipmap</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zm = zmalloc(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//没存储key-value时，只有zmlen字段和表示结尾的len字段，zmlen=0表示存储了0个key-value对，len=255是zipmap末尾的标记</span></span><br><span class="line">    zm[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">/* Length */</span></span><br><span class="line">    zm[<span class="number">1</span>] = ZIPMAP_END;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the encoded length pointed by 'p' */</span></span><br><span class="line"><span class="comment">//获取len字段表示的数值，p指向的是某个len字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapDecodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//len是int类型，所以默认取1个字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = *p;</span><br><span class="line">    <span class="comment">//第一个字节的值小于254，说明len字段只有1个字节</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; ZIPMAP_BIGLEN) <span class="keyword">return</span> len;</span><br><span class="line">    <span class="comment">//否则len的值就是p后面的4个字节表示的值</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;len,p+<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Encode the length 'l' writing it in 'p'. If p is NULL it just returns</span></span><br><span class="line"><span class="comment"> * the amount of bytes required to encode such a length. */</span></span><br><span class="line"><span class="comment">//返回表示长度len需要的字节数，并把len的数值写入p指向的len字段</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果p没有指向len字段，就只获取需要的字节数，不必把len写入p</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ZIPMAP_LEN_BYTES(len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//以ZIPMAP_BIGLEN为分界判断需要1个字节还是5个字节</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIPMAP_BIGLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[<span class="number">0</span>] = ZIPMAP_BIGLEN;</span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search for a matching key, returning a pointer to the entry inside the</span></span><br><span class="line"><span class="comment"> * zipmap. Returns NULL if the key is not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If NULL is returned, and totlen is not NULL, it is set to the entire</span></span><br><span class="line"><span class="comment"> * size of the zimap, so that the calling function will be able to</span></span><br><span class="line"><span class="comment"> * reallocate the original zipmap to make room for more entries. */</span></span><br><span class="line"><span class="comment">//在zm中查找长度为klen的key并返回，同时把zm的总字节数存入参数totlen中</span></span><br><span class="line"><span class="comment">//因为这两种操作都需要进行遍历，所以索性写在一个函数里</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapLookupRaw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">int</span> *totlen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//跳过zmlen字段，p指向第一个len字段</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zm+<span class="number">1</span>, *k = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l,llen;</span><br><span class="line">    <span class="comment">//p指向的字节的值不是ZIPMAP_END，说明后面还有key-value对</span></span><br><span class="line">    <span class="keyword">while</span>(*p != ZIPMAP_END) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Match or skip the key */</span></span><br><span class="line">        <span class="comment">//l是下个key的字节数，llen是len字段的字节数</span></span><br><span class="line">        l = zipmapDecodeLength(p);</span><br><span class="line">        llen = zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">        <span class="comment">//如果参数的key和zipmap中的key相等</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">NULL</span> &amp;&amp; l == klen &amp;&amp; !<span class="built_in">memcmp</span>(p+llen,key,l)) &#123;</span><br><span class="line">            <span class="comment">/* Only return when the user doesn't care</span></span><br><span class="line"><span class="comment">             * for the total length of the zipmap. */</span></span><br><span class="line">            <span class="comment">//totlen != NULL说明需要返回zm的总字节数，即使找到了给定的key也要遍历完整个zipmap</span></span><br><span class="line">            <span class="keyword">if</span> (totlen != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                k = p;</span><br><span class="line">            <span class="comment">//totlen == NULL说明不需要返回zm的总字节数，找到了给定的key就结束</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跳过了&lt;len&gt;&lt;key&gt;两个字段，开始解析&lt;len&gt;&lt;free&gt;&lt;value&gt;三个字段</span></span><br><span class="line">        <span class="comment">//一个key-value对包含&lt;len&gt;&lt;key&gt;&lt;len&gt;&lt;free&gt;&lt;value&gt;这5个字段</span></span><br><span class="line">        p += llen+l;</span><br><span class="line">        <span class="comment">/* Skip the value as well */</span></span><br><span class="line">        <span class="comment">//因为查找的目标是key，所以value不用比较</span></span><br><span class="line">        <span class="comment">//p指针移动的长度包含四部分，len字段，free字段，value字段，以及free字段标示的value尾部的空余字节</span></span><br><span class="line">        l = zipmapDecodeLength(p);</span><br><span class="line">        p += zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">        <span class="built_in">free</span> = p[<span class="number">0</span>];</span><br><span class="line">        p += l+<span class="number">1</span>+<span class="built_in">free</span>; <span class="comment">/* +1 to skip the free byte */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历到ZIPMAP_END后，把zm的总字节数存入totlen</span></span><br><span class="line">    <span class="keyword">if</span> (totlen != <span class="literal">NULL</span>) *totlen = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(p-zm)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定key的长度和value的长度，返回存储该key-value对需要的总字节数</span></span><br><span class="line"><span class="comment">//也就是&lt;len&gt;&lt;key&gt;&lt;len&gt;&lt;free&gt;&lt;value&gt;的总字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zipmapRequiredLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line">    <span class="comment">//两个len字段和free字段默认都是1个字节</span></span><br><span class="line">    l = klen+vlen+<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//如果长度超过253个字节，len字段需要5个字节</span></span><br><span class="line">    <span class="keyword">if</span> (klen &gt;= ZIPMAP_BIGLEN) l += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (vlen &gt;= ZIPMAP_BIGLEN) l += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the total amount used by a key (encoded length + payload) */</span></span><br><span class="line"><span class="comment">//p指向len字段，返回&lt;len&gt;&lt;key&gt;两个字段的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapRawKeyLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//l是key的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l = zipmapDecodeLength(p);</span><br><span class="line">    <span class="comment">//zipmapEncodeLength得到的是记录l需要的len字段的字节数</span></span><br><span class="line">    <span class="keyword">return</span> zipmapEncodeLength(<span class="literal">NULL</span>,l) + l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the total amount used by a value</span></span><br><span class="line"><span class="comment"> * (encoded length + single byte free count + payload) */</span></span><br><span class="line"><span class="comment">//p指向len字段，返回&lt;len&gt;&lt;free&gt;&lt;value&gt;三个字段的字节数，但value尾部的空余字节不被计入</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapRawValueLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l = zipmapDecodeLength(p);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> used;</span><br><span class="line">    <span class="comment">//used得到的是value字段的有效长度，而不是全部长度，因为排除了尾部的空余字节</span></span><br><span class="line">    used = zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">    used += p[used] + <span class="number">1</span> + l;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If 'p' points to a key, this function returns the total amount of</span></span><br><span class="line"><span class="comment"> * bytes used to store this entry (entry = key + associated value + trailing</span></span><br><span class="line"><span class="comment"> * free space if any). */</span></span><br><span class="line"><span class="comment">//p指向len字段，返回一个key-value对，也就是&lt;len&gt;&lt;key&gt;&lt;len&gt;&lt;free&gt;&lt;value&gt;5个字段的字节数</span></span><br><span class="line"><span class="comment">//仿照ziplist，这样一个key-value对也叫做一个entry</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapRawEntryLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l = zipmapRawKeyLength(p);</span><br><span class="line">    <span class="keyword">return</span> l + zipmapRawValueLength(p+l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新调整zipmap的大小，参数len是zipmap的总字节数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    zm = zrealloc(zm, len);</span><br><span class="line">    zm[len<span class="number">-1</span>] = ZIPMAP_END;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set key to value, creating the key if it does not already exist.</span></span><br><span class="line"><span class="comment"> * If 'update' is not NULL, *update is set to 1 if the key was</span></span><br><span class="line"><span class="comment"> * already preset, otherwise to 0. */</span></span><br><span class="line"><span class="comment">//把长度为klen的vlen的key-value对插入到zm中。如果key已经存在，就变成更新对应的value，同时把参数update设为1</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapSet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">int</span> *update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> zmlen, offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> freelen, reqlen = zipmapRequiredLength(klen,vlen);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> empty, vempty;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">   </span><br><span class="line">    freelen = reqlen;</span><br><span class="line">    <span class="keyword">if</span> (update) *update = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//在zm中查找key，同时把zm的总字节数存在变量zmlen中</span></span><br><span class="line">    p = zipmapLookupRaw(zm,key,klen,&amp;zmlen);</span><br><span class="line">    <span class="comment">//如果key不存在，就是插入新的key-value</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Key not found: enlarge */</span></span><br><span class="line">        <span class="comment">//先给zm扩容，增加的reqlen是存储key-value需要的字节数</span></span><br><span class="line">        zm = zipmapResize(zm, zmlen+reqlen);</span><br><span class="line">        <span class="comment">//默认在尾部插入，所以把p指向到倒数第二个字节，因为最后一个字节是0xff的结束符</span></span><br><span class="line">        p = zm+zmlen<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//新zipmap的总字节数</span></span><br><span class="line">        zmlen = zmlen+reqlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increase zipmap length (this is an insert) */</span></span><br><span class="line">        <span class="comment">//如果zmlen字段没有溢出，就加一表示zm的真实长度</span></span><br><span class="line">        <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>]++;</span><br><span class="line">    <span class="comment">//如果key已经存在，就是更新value</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Key found. Is there enough space for the new value? */</span></span><br><span class="line">        <span class="comment">/* Compute the total length: */</span></span><br><span class="line">        <span class="keyword">if</span> (update) *update = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//得到当前key所在的整个entry的字节数</span></span><br><span class="line">        freelen = zipmapRawEntryLength(p);</span><br><span class="line">        <span class="comment">//如果目标entry的长度不够，就要先扩容</span></span><br><span class="line">        <span class="keyword">if</span> (freelen &lt; reqlen) &#123;</span><br><span class="line">            <span class="comment">/* Store the offset of this key within the current zipmap, so</span></span><br><span class="line"><span class="comment">             * it can be resized. Then, move the tail backwards so this</span></span><br><span class="line"><span class="comment">             * pair fits at the current position. */</span></span><br><span class="line">            offset = p-zm;</span><br><span class="line">            <span class="comment">//增加的长度是reqlen-freelen，也就是新entry比旧entry多的字节数</span></span><br><span class="line">            <span class="comment">//因为&lt;len&gt;&lt;key&gt;&lt;free&gt;三个字段长度都不变，所以增加的长度是&lt;len&gt;&lt;value&gt;两个字段的</span></span><br><span class="line">            zm = zipmapResize(zm, zmlen-freelen+reqlen);</span><br><span class="line">            <span class="comment">//在新的zm中定位到当前entry</span></span><br><span class="line">            p = zm+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The +1 in the number of bytes to be moved is caused by the</span></span><br><span class="line"><span class="comment">             * end-of-zipmap byte. Note: the *original* zmlen is used. */</span></span><br><span class="line">            <span class="comment">//更新的value不一定在zm尾部，所以要把后面的内容后移，防止数据覆盖</span></span><br><span class="line">            <span class="comment">//p+freelen是旧zm中下个entry的地址，p+reqlen是新zm中下个entry应该在的地址</span></span><br><span class="line">            memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+<span class="number">1</span>));</span><br><span class="line">            <span class="comment">//计算新zm的总字节数</span></span><br><span class="line">            zmlen = zmlen-freelen+reqlen;</span><br><span class="line">            freelen = reqlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We now have a suitable block where the key/value entry can</span></span><br><span class="line"><span class="comment">     * be written. If there is too much free space, move the tail</span></span><br><span class="line"><span class="comment">     * of the zipmap a few bytes to the front and shrink the zipmap,</span></span><br><span class="line"><span class="comment">     * as we want zipmaps to be very space efficient. */</span></span><br><span class="line">    <span class="comment">//需要扩容的情况一定是扩容到刚刚好，所以value尾部不会有空余字节。</span></span><br><span class="line">    <span class="comment">//只有在更新value且新value长度比旧value小的情况下，才会有空余字节</span></span><br><span class="line">    empty = freelen-reqlen;</span><br><span class="line">    <span class="comment">//空余字节大于等于ZIPMAP_VALUE_MAX_FREE，就需要收缩zm</span></span><br><span class="line">    <span class="keyword">if</span> (empty &gt;= ZIPMAP_VALUE_MAX_FREE) &#123;</span><br><span class="line">        <span class="comment">/* First, move the tail &lt;empty&gt; bytes to the front, then resize</span></span><br><span class="line"><span class="comment">         * the zipmap to be &lt;empty&gt; bytes smaller. */</span></span><br><span class="line">        offset = p-zm;</span><br><span class="line">        memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+<span class="number">1</span>));</span><br><span class="line">        zmlen -= empty;</span><br><span class="line">        zm = zipmapResize(zm, zmlen);</span><br><span class="line">        p = zm+offset;</span><br><span class="line">        vempty = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则就留着空余字节，把字节数记在free字段</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vempty = empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just write the key + value and we are done. */</span></span><br><span class="line">    <span class="comment">/* Key: */</span></span><br><span class="line">    <span class="comment">//写入第一个len字段，p移动到key字段</span></span><br><span class="line">    p += zipmapEncodeLength(p,klen);</span><br><span class="line">    <span class="comment">//写入key字段</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,key,klen);</span><br><span class="line">    <span class="comment">//p移动到第二个len字段</span></span><br><span class="line">    p += klen;</span><br><span class="line">    <span class="comment">/* Value: */</span></span><br><span class="line">    <span class="comment">//写入第二个len字段，p移动到free字段</span></span><br><span class="line">    p += zipmapEncodeLength(p,vlen);</span><br><span class="line">    <span class="comment">//写入free字段，p移动到value字段</span></span><br><span class="line">    *p++ = vempty;</span><br><span class="line">    <span class="comment">//写入value</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,val,vlen);</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove the specified key. If 'deleted' is not NULL the pointed integer is</span></span><br><span class="line"><span class="comment"> * set to 0 if the key was not found, to 1 if it was found and deleted. */</span></span><br><span class="line"><span class="comment">//删除给定key的key-value对</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapDel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">int</span> *deleted)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> zmlen, freelen;</span><br><span class="line">    <span class="comment">//查找key，并得到zm总字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zipmapLookupRaw(zm,key,klen,&amp;zmlen);</span><br><span class="line">    <span class="comment">//找到key了</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="comment">//得到entry的字节数</span></span><br><span class="line">        freelen = zipmapRawEntryLength(p);</span><br><span class="line">        <span class="comment">//把目标entry后面的内容复制到entry头部，相当于覆盖了待删除的entry</span></span><br><span class="line">        memmove(p, p+freelen, zmlen-((p-zm)+freelen+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//收缩zm的长度</span></span><br><span class="line">        zm = zipmapResize(zm, zmlen-freelen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Decrease zipmap length */</span></span><br><span class="line">        <span class="comment">//如果zmlen字段的值有效就维护起来</span></span><br><span class="line">        <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>]--;</span><br><span class="line">        <span class="comment">//标记为删除成功</span></span><br><span class="line">        <span class="keyword">if</span> (deleted) *deleted = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//没找到key直接标记为删除失败</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deleted) *deleted = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call it before to iterate trought elements via zipmapNext() */</span></span><br><span class="line"><span class="comment">//用于开始迭代zipmap时，跳过zmlen字段，功能太简单，没必要单独写成函数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapRewind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zm+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is used to iterate through all the zipmap elements.</span></span><br><span class="line"><span class="comment"> * In the first call the first argument is the pointer to the zipmap + 1.</span></span><br><span class="line"><span class="comment"> * In the next calls what zipmapNext returns is used as first argument.</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * unsigned char *i = zipmapRewind(my_zipmap);</span></span><br><span class="line"><span class="comment"> * while((i = zipmapNext(i,&amp;key,&amp;klen,&amp;value,&amp;vlen)) != NULL) &#123;</span></span><br><span class="line"><span class="comment"> *     printf("%d bytes key at $p\n", klen, key);</span></span><br><span class="line"><span class="comment"> *     printf("%d bytes value at $p\n", vlen, value);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//一步的遍历，只遍历zm指针指向的entry，然后zm指向下一个entry，遍历得到的entry信息保存在参数里的四个指针里</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> **key, <span class="keyword">unsigned</span> <span class="keyword">int</span> *klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> **value, <span class="keyword">unsigned</span> <span class="keyword">int</span> *vlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (zm[<span class="number">0</span>] == ZIPMAP_END) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        *key = zm;</span><br><span class="line">        *klen = zipmapDecodeLength(zm);</span><br><span class="line">        *key += ZIPMAP_LEN_BYTES(*klen);</span><br><span class="line">    &#125;</span><br><span class="line">    zm += zipmapRawKeyLength(zm);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        *value = zm+<span class="number">1</span>;</span><br><span class="line">        *vlen = zipmapDecodeLength(zm);</span><br><span class="line">        *value += ZIPMAP_LEN_BYTES(*vlen);</span><br><span class="line">    &#125;</span><br><span class="line">    zm += zipmapRawValueLength(zm);</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search a key and retrieve the pointer and len of the associated value.</span></span><br><span class="line"><span class="comment"> * If the key is found the function returns 1, otherwise 0. */</span></span><br><span class="line"><span class="comment">//给定长度为klen的key，查询对应的value值并存入参数的value指针，同时把value的长度存入参数的vlen指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipmapGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> **value, <span class="keyword">unsigned</span> <span class="keyword">int</span> *vlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = zipmapLookupRaw(zm,key,klen,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    p += zipmapRawKeyLength(p);</span><br><span class="line">    *vlen = zipmapDecodeLength(p);</span><br><span class="line">    *value = p + ZIPMAP_LEN_BYTES(*vlen) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return 1 if the key exists, otherwise 0 is returned. */</span></span><br><span class="line"><span class="comment">//查询长度为klen的key是否在zm中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipmapExists</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zipmapLookupRaw(zm,key,klen,<span class="literal">NULL</span>) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the number of entries inside a zipmap */</span></span><br><span class="line"><span class="comment">//遍历zipmap，返回entry的数量</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果zmlen字段的值有效，直接返回这个值，无需遍历</span></span><br><span class="line">    <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) &#123;</span><br><span class="line">        len = zm[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//如果zmlen字段溢出了，就需要遍历整个zipmap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zipmapRewind(zm);</span><br><span class="line">        <span class="keyword">while</span>((p = zipmapNext(p,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) != <span class="literal">NULL</span>) len++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Re-store length if small enough */</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>] = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印zipmap的结构，debug用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zipmapRepr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#123;status %u&#125;"</span>,*p++);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIPMAP_END) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;end&#125;"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> e;</span><br><span class="line"></span><br><span class="line">            l = zipmapDecodeLength(p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;key %u&#125;"</span>,l);</span><br><span class="line">            p += zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">            <span class="keyword">if</span> (l != <span class="number">0</span> &amp;&amp; fwrite(p,l,<span class="number">1</span>,<span class="built_in">stdout</span>) == <span class="number">0</span>) perror(<span class="string">"fwrite"</span>);</span><br><span class="line">            p += l;</span><br><span class="line"></span><br><span class="line">            l = zipmapDecodeLength(p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;value %u&#125;"</span>,l);</span><br><span class="line">            p += zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">            e = *p++;</span><br><span class="line">            <span class="keyword">if</span> (l != <span class="number">0</span> &amp;&amp; fwrite(p,l,<span class="number">1</span>,<span class="built_in">stdout</span>) == <span class="number">0</span>) perror(<span class="string">"fwrite"</span>);</span><br><span class="line">            p += l+e;</span><br><span class="line">            <span class="keyword">if</span> (e) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"["</span>);</span><br><span class="line">                <span class="keyword">while</span>(e--) <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-数据类型相关"><a href="#4-数据类型相关" class="headerlink" title="4 数据类型相关"></a>4 数据类型相关</h1><h2 id="4-1-对象系统"><a href="#4-1-对象系统" class="headerlink" title="4.1 对象系统"></a>4.1 对象系统</h2><h3 id="redis-h-对象系统相关部分"><a href="#redis-h-对象系统相关部分" class="headerlink" title="redis.h(对象系统相关部分)"></a>redis.h(对象系统相关部分)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Error codes */</span></span><br><span class="line"><span class="comment">//状态码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_OK                0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ERR               -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Virtual memory object-&gt;where field. */</span></span><br><span class="line"><span class="comment">//对象存储的位置</span></span><br><span class="line"><span class="comment">//内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VM_MEMORY 0       <span class="comment">/* The object is on memory */</span></span></span><br><span class="line"><span class="comment">//磁盘</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VM_SWAPPED 1      <span class="comment">/* The object is on disk */</span></span></span><br><span class="line"><span class="comment">//正在从内存换出到磁盘</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VM_SWAPPING 2     <span class="comment">/* Redis is swapping this object on disk */</span></span></span><br><span class="line"><span class="comment">//正在从磁盘换入内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VM_LOADING 3      <span class="comment">/* Redis is loading this object from disk */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="comment">//对象类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_VMPOINTER 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The 'encoding' field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="comment">//对象编码，其实就是所使用的底层数据结构</span></span><br><span class="line"><span class="comment">//简单动态字符串sds</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="comment">//压缩字典</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="comment">//双端链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="comment">//压缩列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="comment">//整数集合</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="comment">//跳跃表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="comment">//逻辑时钟的最大位数，类似现实中的表盘，划分了最大的刻度。计算出的实际LRU时间要对最大刻度LRU_CLOCK_MAX取模</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;21)-1) /* Max value of obj-&gt;lru */</span></span></span><br><span class="line"><span class="comment">//LRU算法的精度，即一个LRU的单位是多长</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_CLOCK_RESOLUTION 10 <span class="comment">/* LRU clock resolution in seconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顶层对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">//对象类型，有6种对象，所以需要4bits表示</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//存储位置，有4种取值，所以需要2bits表示</span></span><br><span class="line">    <span class="keyword">unsigned</span> storage:<span class="number">2</span>;     <span class="comment">/* REDIS_VM_MEMORY or REDIS_VM_SWAPPING */</span></span><br><span class="line">    <span class="comment">//编码，有8中取值，需要4bits表示</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;        <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="comment">//引用计数，用于垃圾回收</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">//指向底层数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">/* VM fields are only allocated if VM is active, otherwise the</span></span><br><span class="line"><span class="comment">     * object allocation function will just allocate</span></span><br><span class="line"><span class="comment">     * sizeof(redisObjct) minus sizeof(redisObjectVM), so using</span></span><br><span class="line"><span class="comment">     * Redis without VM active will not have any overhead. */</span></span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The VM pointer structure - identifies an object in the swap file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This object is stored in place of the value</span></span><br><span class="line"><span class="comment"> * object in the main key-&gt;value hash table representing a database.</span></span><br><span class="line"><span class="comment"> * Note that the first fields (type, storage) are the same as the redisObject</span></span><br><span class="line"><span class="comment"> * structure so that vmPointer strucuters can be accessed even when casted</span></span><br><span class="line"><span class="comment"> * as redisObject structures.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is useful as we don't know if a value object is or not on disk, but we</span></span><br><span class="line"><span class="comment"> * are always able to read obj-&gt;storage to check this. For vmPointer</span></span><br><span class="line"><span class="comment"> * structures "type" is set to REDIS_VMPOINTER (even if without this field</span></span><br><span class="line"><span class="comment"> * is still possible to check the kind of object from the value of 'storage').*/</span></span><br><span class="line"><span class="comment">//标记对象在磁盘交换区的存储位置</span></span><br><span class="line"><span class="comment">//当value存储在内存中时，Redis使用一个RedisObject与之关联；而当value存储在磁盘中时，Redis使用一个VMPointer与之关联。要知道value存储在磁盘中还是内存中，只需判断storage字段。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vmPointer</span> &#123;</span></span><br><span class="line">    <span class="comment">//type和storage两个字段与robj一样</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> storage:<span class="number">2</span>; <span class="comment">/* REDIS_VM_SWAPPED or REDIS_VM_LOADING */</span></span><br><span class="line">    <span class="keyword">unsigned</span> notused:<span class="number">26</span>;</span><br><span class="line">    <span class="comment">//交换出去的对象类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vtype; <span class="comment">/* type of the object stored in the swap file */</span></span><br><span class="line">    <span class="comment">//记录对象在交换区中从哪页开始</span></span><br><span class="line">    <span class="keyword">off_t</span> page;         <span class="comment">/* the page at witch the object is stored on disk */</span></span><br><span class="line">    <span class="comment">//记录对象共包含几页</span></span><br><span class="line">    <span class="keyword">off_t</span> usedpages;    <span class="comment">/* number of pages used on disk */</span></span><br><span class="line">&#125; vmpointer;</span><br></pre></td></tr></table></figure><h3 id="object-c"><a href="#object-c" class="headerlink" title="object.c"></a>object.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给定对象类型和底层数据结构的指针，创建新的robj</span></span><br><span class="line"><span class="comment">//默认是基于sds的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    <span class="comment">//先默认ptr是简单动态字符串</span></span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    <span class="comment">//生成对象后引用计数设为1</span></span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution).</span></span><br><span class="line"><span class="comment">     * We do this regardless of the fact VM is active as LRU is also</span></span><br><span class="line"><span class="comment">     * used for the maxmemory directive when Redis is used as cache.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that this code may run in the context of an I/O thread</span></span><br><span class="line"><span class="comment">     * and accessing server.lruclock in theory is an error</span></span><br><span class="line"><span class="comment">     * (no locks). But in practice this is safe, and even if we read</span></span><br><span class="line"><span class="comment">     * garbage Redis will not fail. */</span></span><br><span class="line">    <span class="comment">//设置对象的最后访问时间</span></span><br><span class="line">    <span class="comment">//server.lruclock来源于redis.h定义的redisServer结构体中</span></span><br><span class="line">    o-&gt;lru = server.lruclock;</span><br><span class="line">    <span class="comment">/* The following is only needed if VM is active, but since the conditional</span></span><br><span class="line"><span class="comment">     * is probably more costly than initializing the field it's better to</span></span><br><span class="line"><span class="comment">     * have every field properly initialized anyway. */</span></span><br><span class="line">    <span class="comment">//默认存储在内存中</span></span><br><span class="line">    o-&gt;storage = REDIS_VM_MEMORY;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于简单动态字符串的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createObject(REDIS_STRING,sdsnewlen(ptr,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于整数值的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">//Redis内部采用了shared integer的方式来省去分配内存的开销,即在系统启动时先分配一个从1~REDIS_SHARED_INTEGERS那么多个数值对象放在一个池子中。如果要创建的对象的整数值在这个共享池里，就不用创建新的对象，而是直接返回共享池里的对象，并增加该对象的引用计数</span></span><br><span class="line">    <span class="comment">//只共享了整数类型的对象，大概是因为只有整数的相等能在O(1)时间内验证，共享复杂的对象会影响cpu性能</span></span><br><span class="line">    <span class="comment">//要求当前线程是服务端的主线程，why？</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS &amp;&amp;</span><br><span class="line">        pthread_equal(pthread_self(),server.mainthread)) &#123;</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        o = shared.integers[value];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//支持的最大整数值是long int的上限</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</span><br><span class="line">            o = createObject(REDIS_STRING, <span class="literal">NULL</span>);</span><br><span class="line">            o-&gt;encoding = REDIS_ENCODING_INT;</span><br><span class="line">            o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</span><br><span class="line">        <span class="comment">//如果超过了上限，就不能创建基于整数值的字符串对象，而是要把整数值转成sds，创建基于sds的字符串对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = createObject(REDIS_STRING,sdsfromlonglong(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串对象的深拷贝，原对象与副本对象的ptr指针指向的不是同一个sds，因为在调用createStringObject时用sdsnewlen函数基于原对象的sds生成了一个新的sds对象</span></span><br><span class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    redisAssert(o-&gt;encoding == REDIS_ENCODING_RAW);</span><br><span class="line">    <span class="keyword">return</span> createStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于双端链表(adlist)的列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建底层的adlist</span></span><br><span class="line">    <span class="built_in">list</span> *l = listCreate();</span><br><span class="line">    <span class="comment">//指定类型是列表，创建robj</span></span><br><span class="line">    robj *o = createObject(REDIS_LIST,l);</span><br><span class="line">    <span class="comment">//把adlist的free函数设为引用计数减一的函数</span></span><br><span class="line">    listSetFreeMethod(l,decrRefCount);</span><br><span class="line">    <span class="comment">//底层数据结构设为adlist</span></span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于压缩列表(ziplist)的列表对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(REDIS_LIST,zl);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于字典(dict)的集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict *d = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    robj *o = createObject(REDIS_SET,d);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于整数集合(intset)的集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = intsetNew();</span><br><span class="line">    robj *o = createObject(REDIS_SET,is);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于压缩字典(zipmap)的哈希对象(后来的版本中取消了zipmap，使用ziplist实现哈希对象)</span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* All the Hashes start as zipmaps. Will be automatically converted</span></span><br><span class="line"><span class="comment">     * into hash tables if there are enough elements or big elements</span></span><br><span class="line"><span class="comment">     * inside. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zm = zipmapNew();</span><br><span class="line">    robj *o = createObject(REDIS_HASH,zm);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_ZIPMAP;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建基于跳跃表(skiplist)和字典(dict)的有序集合对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(REDIS_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放字符串对象</span></span><br><span class="line"><span class="comment">//为什么只释放sds类型的对象？难道是因为long int占的空间少所以没必要释放？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        sdsfree(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放列表对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line">    <span class="comment">//adlist是列表指针套着节点指针的复杂结构，所以需要单独设计的free函数，用zfree只能释放列表指针，不能释放里面的节点指针</span></span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_LINKEDLIST:</span><br><span class="line">        listRelease((<span class="built_in">list</span>*) o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//ziplist就是个字符串，所以不需要为它单独定义一个free函数，直接用zfree</span></span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST:</span><br><span class="line">        zfree(o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_HT:</span><br><span class="line">        dictRelease((dict*) o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//intset只有一个结构体指针，所以也可以用zfree释放</span></span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_INTSET:</span><br><span class="line">        zfree(o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        redisPanic(<span class="string">"Unknown set encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放有序集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    zset *zs = o-&gt;ptr;</span><br><span class="line">    <span class="comment">//zset包含一个adlist和一个dict，所以要先分别调用各自的free函数，最后再释放最外层的zset指针</span></span><br><span class="line">    dictRelease(zs-&gt;dict);</span><br><span class="line">    zslFree(zs-&gt;zsl);</span><br><span class="line">    zfree(zs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放哈希对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_HT:</span><br><span class="line">        dictRelease((dict*) o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//zipmap只是个字符串</span></span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPMAP:</span><br><span class="line">        zfree(o-&gt;ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        redisPanic(<span class="string">"Unknown hash encoding type"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的引用计数加一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    o-&gt;refcount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的引用计数加一，如果会减到0意味着要释放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(<span class="keyword">void</span> *obj)</span> </span>&#123;</span><br><span class="line">    robj *o = obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Object is a swapped out value, or in the process of being loaded. */</span></span><br><span class="line">    <span class="comment">//如果对象存在磁盘上</span></span><br><span class="line">    <span class="keyword">if</span> (server.vm_enabled &amp;&amp;</span><br><span class="line">        (o-&gt;storage == REDIS_VM_SWAPPED || o-&gt;storage == REDIS_VM_LOADING))</span><br><span class="line">    &#123;</span><br><span class="line">        vmpointer *vp = obj;</span><br><span class="line">        <span class="comment">//如果对象正在被加载到内存，先中止当前作业，因为当前作业可能会篡改对象，或者删除对象会使当前作业产生错误</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;storage == REDIS_VM_LOADING) vmCancelThreadedIOJob(o);</span><br><span class="line">        <span class="comment">//被交换到磁盘上的对象引用只能是1，所以引用计数减一就是删除对象</span></span><br><span class="line">        <span class="comment">//释放对象占用的所有页</span></span><br><span class="line">        vmMarkPagesFree(vp-&gt;page,vp-&gt;usedpages);</span><br><span class="line">        server.vm_stats_swapped_objects--;</span><br><span class="line">        <span class="comment">//最后释放对象的指针</span></span><br><span class="line">        zfree(vp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象已经没有引用了，还要求减引用就说明出bug了</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line">    <span class="comment">/* Object is in memory, or in the process of being swapped out.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the object is being swapped out, abort the operation on</span></span><br><span class="line"><span class="comment">     * decrRefCount even if the refcount does not drop to 0: the object</span></span><br><span class="line"><span class="comment">     * is referenced at least two times, as value of the key AND as</span></span><br><span class="line"><span class="comment">     * job-&gt;val in the iojob. So if we don't invalidate the iojob, when it is</span></span><br><span class="line"><span class="comment">     * done but the relevant key was removed in the meantime, the</span></span><br><span class="line"><span class="comment">     * complete jobs handler will not find the key about the job and the</span></span><br><span class="line"><span class="comment">     * assert will fail. */</span></span><br><span class="line">    <span class="comment">//如果对象存在内存里，但正在把对象交换到磁盘上，也需要先中止作业</span></span><br><span class="line">    <span class="keyword">if</span> (server.vm_enabled &amp;&amp; o-&gt;storage == REDIS_VM_SWAPPING)</span><br><span class="line">        vmCancelThreadedIOJob(o);</span><br><span class="line">    <span class="comment">//如果当前引用数是1，再减就会到0，所以直接删除对象，执行对象的free函数</span></span><br><span class="line">    <span class="keyword">if</span> (--(o-&gt;refcount) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> REDIS_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REDIS_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: redisPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;ptr = <span class="literal">NULL</span>; <span class="comment">/* defensive programming. We'll see NULL in traces. */</span></span><br><span class="line">        <span class="comment">//最后释放robj的指针</span></span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端对客户端提交的对象进行类型检查</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkType</span><span class="params">(redisClient *c, robj *o, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != type) &#123;</span><br><span class="line">        <span class="comment">//如果类型错误，把错误信息返回给客户端</span></span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to encode a string object in order to save space */</span></span><br><span class="line"><span class="comment">//尝试编码字符串对象以节省空间，其实就是尝试用整数值替换sds字符串</span></span><br><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果对象存储的已经是整数的表示了，就不需要修改</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != REDIS_ENCODING_RAW)</span><br><span class="line">        <span class="keyword">return</span> o; <span class="comment">/* Already encoded */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It's not safe to encode shared objects: shared objects can be shared</span></span><br><span class="line"><span class="comment">     * everywhere in the "object space" of Redis. Encoded objects can only</span></span><br><span class="line"><span class="comment">     * appear as "values" (and not, for instance, as keys) */</span></span><br><span class="line">    <span class="comment">//如果当前对象有多个引用，在此修改对象是不安全的，直接退出</span></span><br><span class="line">     <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Currently we try to encode only strings */</span></span><br><span class="line">    <span class="comment">//只能编码字符串对象</span></span><br><span class="line">    redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we can represent this string as a long integer */</span></span><br><span class="line">    <span class="comment">//如果当前对象存储的sds字符串不能转成整数，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (isStringRepresentableAsLong(s,&amp;value) == REDIS_ERR) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ok, this object can be encoded...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Can I use a shared object? Only if the object is inside a given</span></span><br><span class="line"><span class="comment">     * range and if this is the main thread, since when VM is enabled we</span></span><br><span class="line"><span class="comment">     * have the constraint that I/O thread should only handle non-shared</span></span><br><span class="line"><span class="comment">     * objects, in order to avoid race conditions (we don't have per-object</span></span><br><span class="line"><span class="comment">     * locking).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we also avoid using shared integers when maxmemory is used</span></span><br><span class="line"><span class="comment">     * because very object needs to have a private LRU field for the LRU</span></span><br><span class="line"><span class="comment">     * algorithm to work well. */</span></span><br><span class="line">    <span class="comment">//如果能用共享池里的对象，就删除当前对象，返回共享池里的对象</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory == <span class="number">0</span> &amp;&amp; value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS &amp;&amp;</span><br><span class="line">        pthread_equal(pthread_self(),server.mainthread)) &#123;</span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">    <span class="comment">//如果没用共享池里的对象，就修改当前对象的ptr，释放sds数据，把ptr指向相应的整型数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//把数据类型变成int</span></span><br><span class="line">        o-&gt;encoding = REDIS_ENCODING_INT;</span><br><span class="line">        sdsfree(o-&gt;ptr);</span><br><span class="line">        o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get a decoded version of an encoded object (returned as a new object).</span></span><br><span class="line"><span class="comment"> * If the object is already raw-encoded just increment the ref count. */</span></span><br><span class="line"><span class="comment">//和tryObjectEncoding相反，是把基于整数的字符串对象转换成基于sds的字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    robj *dec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果已经是基于sds的字符串对象，引用加一并返回</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        incrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type == REDIS_STRING &amp;&amp; o-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        ll2string(buf,<span class="number">32</span>,(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">        dec = createStringObject(buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare two string objects via strcmp() or alike.</span></span><br><span class="line"><span class="comment"> * Note that the objects may be integer-encoded. In such a case we</span></span><br><span class="line"><span class="comment"> * use ll2string() to get a string representation of the numbers on the stack</span></span><br><span class="line"><span class="comment"> * and compare the strings, it's much faster than calling getDecodedObject().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Important note: if objects are not integer encoded, but binary-safe strings,</span></span><br><span class="line"><span class="comment"> * sdscmp() from sds.c will apply memcmp() so this function ca be considered</span></span><br><span class="line"><span class="comment"> * binary safe. */</span></span><br><span class="line"><span class="comment">//比较两个字符串对象保存的数据是否相同，最后比较的是两个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareStringObjects</span><span class="params">(robj *a, robj *b)</span> </span>&#123;</span><br><span class="line">    redisAssert(a-&gt;type == REDIS_STRING &amp;&amp; b-&gt;type == REDIS_STRING);</span><br><span class="line">    <span class="comment">//只能比较最长128个字节的字符串</span></span><br><span class="line">    <span class="keyword">char</span> bufa[<span class="number">128</span>], bufb[<span class="number">128</span>], *astr, *bstr;</span><br><span class="line">    <span class="keyword">int</span> bothsds = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果两个指针指向的是一个对象，就说明是相等的，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果是基于整数的字符串对象，要先转成sds字符串，最后再比较两个对象的sds字符串</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        ll2string(bufa,<span class="keyword">sizeof</span>(bufa),(<span class="keyword">long</span>) a-&gt;ptr);</span><br><span class="line">        astr = bufa;</span><br><span class="line">        bothsds = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        astr = a-&gt;ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        ll2string(bufb,<span class="keyword">sizeof</span>(bufb),(<span class="keyword">long</span>) b-&gt;ptr);</span><br><span class="line">        bstr = bufb;</span><br><span class="line">        bothsds = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bstr = b-&gt;ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果都是原生的sds字符串，就用sdscmp比较，如果二者之中有整数转成的字符串，就用strcmp比较</span></span><br><span class="line">    <span class="comment">//其实根本没区别，因为二者要么是ll2string产生的字符串，要么是sdshdr结构体中的buf字符串，都是字符串，直接用strcmp就可以</span></span><br><span class="line">    <span class="keyword">return</span> bothsds ? sdscmp(astr,bstr) : <span class="built_in">strcmp</span>(astr,bstr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Equal string objects return 1 if the two objects are the same from the</span></span><br><span class="line"><span class="comment"> * point of view of a string comparison, otherwise 0 is returned. Note that</span></span><br><span class="line"><span class="comment"> * this function is faster then checking for (compareStringObject(a,b) == 0)</span></span><br><span class="line"><span class="comment"> * because it can perform some more optimization. */</span></span><br><span class="line"><span class="comment">//比较两个字符串对象保存的数据是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">equalStringObjects</span><span class="params">(robj *a, robj *b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果都存储的整数，直接比较整数</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;encoding != REDIS_ENCODING_RAW &amp;&amp; b-&gt;encoding != REDIS_ENCODING_RAW)&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;ptr == b-&gt;ptr;</span><br><span class="line">    <span class="comment">//如果不全是整数，就都转成字符串比较</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compareStringObjects(a,b) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符串对象存储的数据的长度</span></span><br><span class="line"><span class="keyword">size_t</span> stringObjectLen(robj *o) &#123;</span><br><span class="line">    redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">    <span class="comment">//对于sds直接调用sds的len函数</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        <span class="keyword">return</span> sdslen(o-&gt;ptr);</span><br><span class="line">    <span class="comment">//对于整数值，返回其转成的字符串的长度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">return</span> ll2string(buf,<span class="number">32</span>,(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串对象中获取double类型的数值，虽然字符串对象能以数值形式保存的只有整数，但浮点数可以以sds的形式存在对象中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObject</span><span class="params">(robj *o, <span class="keyword">double</span> *target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">        <span class="comment">//如果是sds就转成浮点数</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            <span class="comment">//strtod把ptr指向的字符串转成浮点数，eptr指向的是遇到的第一个无法转成数值的字符</span></span><br><span class="line">            value = strtod(o-&gt;ptr, &amp;eptr);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || isnan(value)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        <span class="comment">//如果对象存的是整数，就把整数赋给浮点数变量</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">            value = (<span class="keyword">long</span>)o-&gt;ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisPanic(<span class="string">"Unknown string encoding"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端从对象中获取double类型的数值，返回给客户端</span></span><br><span class="line"><span class="comment">//返回的值写入target指针，msg保存的是获取失败的情况下默认返回给客户端的错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDoubleFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">double</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    <span class="keyword">if</span> (getDoubleFromObject(o, &amp;value) != REDIS_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyError(c,(<span class="keyword">char</span>*)msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"value is not a double"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串对象中获取long long类型的数值，和getDoubleFromObject的逻辑相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            <span class="comment">//strtoll把ptr指向的字符串转成10进制的long long类型的值，eptr指向的是遇到的第一个无法转成数值的字符</span></span><br><span class="line">            value = strtoll(o-&gt;ptr, &amp;eptr, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (eptr[<span class="number">0</span>] != <span class="string">'\0'</span>) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            <span class="comment">//errno 是记录系统的最后一次错误代码，ERANGE是&lt;errno.h&gt;里的宏定义，表示有某个变量溢出了</span></span><br><span class="line">            <span class="comment">//为什么getDoubleFromObject里不用判断越界呢？</span></span><br><span class="line">            <span class="keyword">if</span> (errno == ERANGE &amp;&amp; (value == LLONG_MIN || value == LLONG_MAX))</span><br><span class="line">                <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">            value = (<span class="keyword">long</span>)o-&gt;ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisPanic(<span class="string">"Unknown string encoding"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target) *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端从对象中获取long long类型的数值，返回给客户端</span></span><br><span class="line"><span class="comment">//和getDoubleFromObjectOrReply逻辑相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObject(o, &amp;value) != REDIS_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyError(c,(<span class="keyword">char</span>*)msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"value is not an integer or out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端从对象中获取long类型的数值，返回给客户端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongFromObjectOrReply</span><span class="params">(redisClient *c, robj *o, <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="comment">//为什么不用专门写一个getLongFromObject函数呢？</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, o, &amp;value, msg) != REDIS_OK) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; LONG_MIN || value &gt; LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyError(c,(<span class="keyword">char</span>*)msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"value is out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把long long类型的值赋给long类型变量不会有危险吗？</span></span><br><span class="line">    *target = value;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取编码类型的字符串表示</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strEncoding</span><span class="params">(<span class="keyword">int</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_RAW: <span class="keyword">return</span> <span class="string">"raw"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_INT: <span class="keyword">return</span> <span class="string">"int"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_HT: <span class="keyword">return</span> <span class="string">"hashtable"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPMAP: <span class="keyword">return</span> <span class="string">"zipmap"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_LINKEDLIST: <span class="keyword">return</span> <span class="string">"linkedlist"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST: <span class="keyword">return</span> <span class="string">"ziplist"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_INTSET: <span class="keyword">return</span> <span class="string">"intset"</span>;</span><br><span class="line">    <span class="keyword">case</span> REDIS_ENCODING_SKIPLIST: <span class="keyword">return</span> <span class="string">"skiplist"</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">"unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given an object returns the min number of seconds the object was never</span></span><br><span class="line"><span class="comment"> * requested, using an approximated LRU algorithm. */</span></span><br><span class="line"><span class="comment">//计算给定对象的闲置时长，使用近似LRU算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.lruclock &gt;= o-&gt;lru) &#123;</span><br><span class="line">        <span class="keyword">return</span> (server.lruclock - o-&gt;lru) * REDIS_LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当server.lruclock的值超出REDIS_LRU_CLOCK_MAX时，会从头开始计算，导致其小于对象的lru，所以算的时候要加上REDIS_LRU_CLOCK_MAX</span></span><br><span class="line">        <span class="comment">//为什么认为server.lruclock只会多转一周呢？会不会加上REDIS_LRU_CLOCK_MAX还是小于o-&gt;lru？</span></span><br><span class="line">        <span class="keyword">return</span> ((REDIS_LRU_CLOCK_MAX - o-&gt;lru) + server.lruclock) *</span><br><span class="line">                    REDIS_LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is an helper function for the DEBUG command. We need to lookup keys</span></span><br><span class="line"><span class="comment"> * without any modification of LRU or other parameters. */</span></span><br><span class="line"><span class="comment">//给定key查找字典中对应的val</span></span><br><span class="line"><span class="function">robj *<span class="title">objectCommandLookup</span><span class="params">(redisClient *c, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((de = dictFind(c-&gt;db-&gt;dict,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (robj*) dictGetEntryVal(de);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定key查找字典中对应的val，如果获取失败就返回reply给客户端</span></span><br><span class="line"><span class="function">robj *<span class="title">objectCommandLookupOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span> </span>&#123;</span><br><span class="line">    robj *o = objectCommandLookup(c,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!o) addReply(c, reply);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object command allows to inspect the internals of an Redis Object.</span></span><br><span class="line"><span class="comment"> * Usage: OBJECT &lt;verb&gt; ... arguments ... */</span></span><br><span class="line"><span class="comment">//解析并执行客户端的object命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OBJECT REFCOUNT &lt;key&gt; ，返回字典中给定key对应的value被引用的次数</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"refcount"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        addReplyLongLong(c,o-&gt;refcount);</span><br><span class="line">    <span class="comment">//OBJECT ENCODING &lt;key&gt; ，返回给定key对应的value的编码类型的字符串表示</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"encoding"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        addReplyBulkCString(c,strEncoding(o-&gt;encoding));</span><br><span class="line">    <span class="comment">//OBJECT IDLETIME &lt;key&gt; ，返回给定key对应的value自储存以来的空闲时间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"idletime"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        addReplyLongLong(c,estimateObjectIdleTime(o));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"Syntax error. Try OBJECT (refcount|encoding|idletime)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h2><h3 id="t-string-c"><a href="#t-string-c" class="headerlink" title="t_string.c"></a>t_string.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * String Commands</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串长度不能超过512MB</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkStringLength</span><span class="params">(redisClient *c, <span class="keyword">long</span> <span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"string exceeds maximum allowed size (512MB)"</span>);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的SET命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> nx, robj *key, robj *val, robj *expire)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="comment">//harmness warning？</span></span><br><span class="line">    <span class="keyword">long</span> seconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid an harmness warning */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        <span class="comment">//从字符串对象中解析出long类型的值，存储在seconds变量中</span></span><br><span class="line">        <span class="keyword">if</span> (getLongFromObjectOrReply(c, expire, &amp;seconds, <span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//设置的过期时间必须大于0</span></span><br><span class="line">        <span class="keyword">if</span> (seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"invalid expire time in SETEX"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在db中查询key，同时检查是否过期，过期则删除key</span></span><br><span class="line">    lookupKeyWrite(c-&gt;db,key); <span class="comment">/* Force expire of old key if needed */</span></span><br><span class="line">    <span class="comment">//向db中插入键值对</span></span><br><span class="line">    retval = dbAdd(c-&gt;db,key,val);</span><br><span class="line">    <span class="comment">//插入失败，说明key已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (retval == REDIS_ERR) &#123;</span><br><span class="line">        <span class="comment">//如果不是SETNX命令，就用新的键值对替换旧的</span></span><br><span class="line">        <span class="keyword">if</span> (!nx) &#123;</span><br><span class="line">            dbReplace(c-&gt;db,key,val);</span><br><span class="line">            incrRefCount(val);</span><br><span class="line">        <span class="comment">//如果是SETNX命令，放弃插入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入失败，向客户端返回0(共享池中的对象)</span></span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//插入成功，value的引用加一</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        incrRefCount(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有正在watch这个key客户端，打开他们的REDIS_DIRTY_CAS标识</span></span><br><span class="line">    touchWatchedKey(c-&gt;db,key);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">//清除旧的过期时间的记录</span></span><br><span class="line">    <span class="comment">//key的过期时间保存在过期字典里，由过期时间对象指向key对象，过期字典存储的redisDb对象里</span></span><br><span class="line">    <span class="comment">//SET命令会清除过期时间，默认把对象持久化，所以SETEX和SET混用时要注意</span></span><br><span class="line">    removeExpire(c-&gt;db,key);</span><br><span class="line">    <span class="comment">//设置key的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) setExpire(c-&gt;db,key,time(<span class="literal">NULL</span>)+seconds);</span><br><span class="line">    <span class="comment">//插入成功，向客户端返回成功码</span></span><br><span class="line">    addReply(c, nx ? shared.cone : shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现set命令</span></span><br><span class="line"><span class="comment">//SET KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先尝试把value字符串转换成数值以节省空间</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    setGenericCommand(c,<span class="number">0</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Setnx(SET if Not eXists)命令</span></span><br><span class="line"><span class="comment">//SETNX KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnxCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    setGenericCommand(c,<span class="number">1</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Setex命令，为指定的key设置值及其过期时间</span></span><br><span class="line"><span class="comment">//SETEX KEY_NAME TIMEOUT VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setexCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    setGenericCommand(c,<span class="number">0</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的GET命令</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGenericCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">//在db中查询key并向客户端返回结果，shared.nullbulk是共享池里表示-1的对象，如果没找到就向客户端返回-1</span></span><br><span class="line">    <span class="comment">//没找到就返回REDIS_OK退出</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    <span class="comment">//如果找到了key但其对应的value不是字符串对象，就向客户端报错</span></span><br><span class="line">    <span class="comment">//虽然在set时会尝试把底层数据改成整型，但基于整型的字符串对象的类型还是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != REDIS_STRING) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    <span class="comment">//否则就是查找成功，把查到的value返回给客户端</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,o);</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现get命令</span></span><br><span class="line"><span class="comment">//GET KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    getGenericCommand(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现getset命令</span></span><br><span class="line"><span class="comment">//GETSET KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsetCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先get旧的value，返回给客户端</span></span><br><span class="line">    <span class="keyword">if</span> (getGenericCommand(c) == REDIS_ERR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//在db中用新的value替换旧的value</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    incrRefCount(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//遍历所有正在watch这个key客户端，打开他们的REDIS_DIRTY_CAS标识</span></span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">//getset命令也执行了set，所以要清除过期时间的记录</span></span><br><span class="line">    removeExpire(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查setbit和getbit命令中的offset参数是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBitOffsetFromArgument</span><span class="params">(redisClient *c, robj *o, <span class="keyword">size_t</span> *offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> loffset;</span><br><span class="line">    <span class="keyword">char</span> *err = <span class="string">"bit offset is not an integer or out of range"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先把offset转成long long类型的数值</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;loffset,err) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Limit offset to 512MB in bytes */</span></span><br><span class="line">    <span class="comment">//判断offset是否越界，因为offset单位是bit，字符串size单位是byte，所以offset要先右移三位</span></span><br><span class="line">    <span class="keyword">if</span> ((loffset &lt; <span class="number">0</span>) || ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)loffset &gt;&gt; <span class="number">3</span>) &gt;= (<span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyError(c,err);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有问题，就把offset数值赋给参数</span></span><br><span class="line">    *offset = (<span class="keyword">size_t</span>)loffset;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现setbit命令</span></span><br><span class="line"><span class="comment">//Setbit KEY_NAME OFFSET VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbitCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">char</span> *err = <span class="string">"bit is not an integer or out of range"</span>;</span><br><span class="line">    <span class="keyword">size_t</span> bitoffset;</span><br><span class="line">    <span class="keyword">int</span> byte, bit;</span><br><span class="line">    <span class="keyword">int</span> byteval, bitval;</span><br><span class="line">    <span class="keyword">long</span> on;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先检查offset是否越界，并把表示的数值存储在bitoffset中</span></span><br><span class="line">    <span class="keyword">if</span> (getBitOffsetFromArgument(c,c-&gt;argv[<span class="number">2</span>],&amp;bitoffset) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//读取命令中的value对象，解析出整数值，存在on中</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;on,err) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bits can only be set or cleared... */</span></span><br><span class="line">    <span class="comment">//因为是给一个bit赋值，所以value只能是0或1</span></span><br><span class="line">    <span class="keyword">if</span> (on &amp; ~<span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在db中查询key，同时检查是否过期，过期则删除key</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//如果key不存在，就创建基于sds的空字符串对象写入db</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        o = createObject(REDIS_STRING,sdsempty());</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create a copy when the object is shared or encoded. */</span></span><br><span class="line">        <span class="comment">//如果value不是原生的sds字符串，就要先转成sds。因为基于int的字符串只是节省内存的一种存储捷径，但修改某个bit时所针对的是原始sds字符串的某个bit</span></span><br><span class="line">        <span class="comment">//为什么要判断o-&gt;refcount？</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            robj *decoded = getDecodedObject(o);</span><br><span class="line">            o = createStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr));</span><br><span class="line">            <span class="comment">//调用getDecodedObject时，可能返回转过类型且引用加一的对象，也可能返回新创建引用数为1的新对象，这两种情况下都需要引用减一，来删除本次操作增加的引用，新对象的值既然已经存到对象o里了，所以引用减到0直接删除该对象。</span></span><br><span class="line">            decrRefCount(decoded);</span><br><span class="line">            dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Grow sds value to the right length if necessary */</span></span><br><span class="line">    <span class="comment">//计算offset对应的字节长度，如果比value字符串还长，就要先将value延长并补0</span></span><br><span class="line">    byte = bitoffset &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    o-&gt;ptr = sdsgrowzero(o-&gt;ptr,byte+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get current values */</span></span><br><span class="line">    <span class="comment">//先取字节值，再从字节值里取目标位的值</span></span><br><span class="line">    byteval = ((<span class="keyword">char</span>*)o-&gt;ptr)[byte];</span><br><span class="line">    bit = <span class="number">7</span> - (bitoffset &amp; <span class="number">0x7</span>);</span><br><span class="line">    bitval = byteval &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update byte with new bit value and return original value */</span></span><br><span class="line">    <span class="comment">//在byte里更新bit的值，再把byte写入字符串中</span></span><br><span class="line">    byteval &amp;= ~(<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    byteval |= ((on &amp; <span class="number">0x1</span>) &lt;&lt; bit);</span><br><span class="line">    ((<span class="keyword">char</span>*)o-&gt;ptr)[byte] = byteval;</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c, bitval ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现getbit命令</span></span><br><span class="line"><span class="comment">//GETBIT KEY_NAME OFFSET</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getbitCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">char</span> llbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">size_t</span> bitoffset;</span><br><span class="line">    <span class="keyword">size_t</span> byte, bit;</span><br><span class="line">    <span class="keyword">size_t</span> bitval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断offset合法性，并转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (getBitOffsetFromArgument(c,c-&gt;argv[<span class="number">2</span>],&amp;bitoffset) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出key对应的value字符串</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算目标的字节和其中具体的位</span></span><br><span class="line">    byte = bitoffset &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    bit = <span class="number">7</span> - (bitoffset &amp; <span class="number">0x7</span>);</span><br><span class="line">    <span class="comment">//如果value不是原生sds，要先转成字符串，再从字符串里取目标位的值</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        <span class="keyword">if</span> (byte &lt; (<span class="keyword">size_t</span>)ll2string(llbuf,<span class="keyword">sizeof</span>(llbuf),(<span class="keyword">long</span>)o-&gt;ptr))</span><br><span class="line">            bitval = llbuf[byte] &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (byte &lt; sdslen(o-&gt;ptr))</span><br><span class="line">            bitval = ((<span class="keyword">char</span>*)o-&gt;ptr)[byte] &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addReply(c, bitval ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现setrange命令</span></span><br><span class="line"><span class="comment">//SETRANGE KEY_NAME OFFSET VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setrangeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> offset;</span><br><span class="line">    sds value = c-&gt;argv[<span class="number">3</span>]-&gt;ptr;</span><br><span class="line">    <span class="comment">//把offset转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;offset,<span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"offset is out of range"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从db中取出key对应的value</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//如果key不存在，就变成了插入新的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Return 0 when setting nothing on a non-existing string */</span></span><br><span class="line">        <span class="comment">//但是如果要set的value是空字符串，就不继续插入，直接退出，因为set空的值就等于啥也没干</span></span><br><span class="line">        <span class="keyword">if</span> (sdslen(value) == <span class="number">0</span>) &#123;</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return when the resulting string exceeds allowed size */</span></span><br><span class="line">        <span class="comment">//执行set之后的字符串长度不能超过512MB，offset是修改起始点前面的长度，sdslen(value)是修改起始点后面的长度</span></span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,offset+sdslen(value)) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//创建新的字符串对象并插入db</span></span><br><span class="line">        o = createObject(REDIS_STRING,sdsempty());</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    <span class="comment">//如果key存在，就是修改对应的字符串</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> olen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Key exists, check type */</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,REDIS_STRING))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return existing string length when setting nothing */</span></span><br><span class="line">        <span class="comment">//要写入的value不能是空字符串</span></span><br><span class="line">        olen = stringObjectLen(o);</span><br><span class="line">        <span class="keyword">if</span> (sdslen(value) == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyLongLong(c,olen);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return when the resulting string exceeds allowed size */</span></span><br><span class="line">        <span class="comment">//修改后的字符串不能超过512MB</span></span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,offset+sdslen(value)) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create a copy when the object is shared or encoded. */</span></span><br><span class="line">        <span class="comment">//把非sds的对象转成基于sds的字符串后，再进行赋值</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            robj *decoded = getDecodedObject(o);</span><br><span class="line">            o = createStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr));</span><br><span class="line">            decrRefCount(decoded);</span><br><span class="line">            dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前面已经判断过sdslen(value)，这里是不是没必要？</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        o-&gt;ptr = sdsgrowzero(o-&gt;ptr,offset+sdslen(value));</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)o-&gt;ptr+offset,value,sdslen(value));</span><br><span class="line">        touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回给客户端的是被修改后的字符串长度</span></span><br><span class="line">    addReplyLongLong(c,sdslen(o-&gt;ptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现getrange命令</span></span><br><span class="line"><span class="comment">//GETRANGE KEY_NAME start end</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrangeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> start, end;</span><br><span class="line">    <span class="keyword">char</span> *str, llbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">strlen</span>;</span><br><span class="line">    <span class="comment">//把start和end转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;start,<span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;end,<span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果key不存在，或value不是字符串，就退出</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptybulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取value字符串的长度</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        str = llbuf;</span><br><span class="line">        <span class="built_in">strlen</span> = ll2string(llbuf,<span class="keyword">sizeof</span>(llbuf),(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = o-&gt;ptr;</span><br><span class="line">        <span class="built_in">strlen</span> = sdslen(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Convert negative indexes */</span></span><br><span class="line">    <span class="comment">//支持负索引，取值时先把负索引换算成正索引，还要把越界的索引拉回到边界</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="built_in">strlen</span>+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="built_in">strlen</span>+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span>)end &gt;= <span class="built_in">strlen</span>) end = <span class="built_in">strlen</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Precondition: end &gt;= 0 &amp;&amp; end &lt; strlen, so the only condition where</span></span><br><span class="line"><span class="comment">     * nothing can be returned is: start &gt; end. */</span></span><br><span class="line">    <span class="comment">//如果起点在终点之后，返回空的字符串</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        addReply(c,shared.emptybulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//取出字符串后返回给客户端</span></span><br><span class="line">        <span class="comment">//取的方法是把ptr指针指到start位置，取出长度为end-start+1的字符串</span></span><br><span class="line">        addReplyBulkCBuffer(c,(<span class="keyword">char</span>*)str+start,end-start+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现mget命令</span></span><br><span class="line"><span class="comment">//MGET KEY1 KEY2 .. KEYN</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mgetCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">//因为要向客户端返回多个值，所以先算出输出时显示的序号</span></span><br><span class="line">    addReplyMultiBulkLen(c,c-&gt;argc<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//查询所有的key并逐个返回，key不存在或value类型不是字符串的返回shared.nullbulk</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type != REDIS_STRING) &#123;</span><br><span class="line">                addReply(c,shared.nullbulk);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulk(c,o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的MSET和MSETNX命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> nx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, busykeys = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//argc从0开始计数，所以argc的值就是所有key和value的数量，所以必须是偶数</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"wrong number of arguments for MSET"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Handle the NX flag. The MSETNX semantic is to return zero and don't</span></span><br><span class="line"><span class="comment">     * set nothing at all if at least one already key exists. */</span></span><br><span class="line">    <span class="comment">//对于msetnx命令，只有当所有给定key都不存在时，才能进行set</span></span><br><span class="line">    <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lookupKeyWrite(c-&gt;db,c-&gt;argv[j]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                busykeys++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//busykeys是已存在的key的数量，放弃set，失败返回0</span></span><br><span class="line">    <span class="keyword">if</span> (busykeys) &#123;</span><br><span class="line">        addReply(c, shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set所有的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j += <span class="number">2</span>) &#123;</span><br><span class="line">        c-&gt;argv[j+<span class="number">1</span>] = tryObjectEncoding(c-&gt;argv[j+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//已经确定key不存在了，可以直接用dbAdd</span></span><br><span class="line">        dbReplace(c-&gt;db,c-&gt;argv[j],c-&gt;argv[j+<span class="number">1</span>]);</span><br><span class="line">        incrRefCount(c-&gt;argv[j+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//执行set类命令后要清除过期时间记录</span></span><br><span class="line">        removeExpire(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        touchWatchedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (c-&gt;argc<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    addReply(c, nx ? shared.cone : shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现mset命令</span></span><br><span class="line"><span class="comment">//MSET key1 value1 key2 value2 .. keyN valueN </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    msetGenericCommand(c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现msetnx命令</span></span><br><span class="line"><span class="comment">//MSETNX key1 value1 key2 value2 .. keyN valueN </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msetnxCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    msetGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的INCR和DECR类命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrDecrCommand</span><span class="params">(redisClient *c, <span class="keyword">long</span> <span class="keyword">long</span> incr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value, oldvalue;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">//获取value字符串</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//先确定value是字符串对象，再确定是否是数值或能否转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;value,<span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    oldvalue = value;</span><br><span class="line">    <span class="comment">//自增还是自减只需要设置incr参数</span></span><br><span class="line">    value += incr;</span><br><span class="line">    <span class="comment">//如果自增以后反而变小，或者自减以后反而变大，说明执行加减操作后value溢出了</span></span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span> &amp;&amp; value &gt; oldvalue) || (incr &gt; <span class="number">0</span> &amp;&amp; value &lt; oldvalue)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"increment or decrement would overflow"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新的基于整型的字符串对象，替换旧的value对象</span></span><br><span class="line">    o = createStringObjectFromLongLong(value);</span><br><span class="line">    dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">//客户端的输出是冒号-新value值-回车换行</span></span><br><span class="line">    addReply(c,shared.colon);</span><br><span class="line">    addReply(c,o);</span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现incr命令</span></span><br><span class="line"><span class="comment">//INCR KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现decr命令</span></span><br><span class="line"><span class="comment">//DECR KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现incrby命令</span></span><br><span class="line"><span class="comment">//INCRBY KEY_NAME INCR_AMOUNT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrbyCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> incr;</span><br><span class="line">    <span class="comment">//把命令里的INCR_AMOUNT转成数值</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;incr, <span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    incrDecrCommand(c,incr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现decrby命令</span></span><br><span class="line"><span class="comment">//DECRBY KEY_NAME DECREMENT_AMOUNT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrbyCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> incr;</span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;incr, <span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    incrDecrCommand(c,-incr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现append命令</span></span><br><span class="line"><span class="comment">//APPEND KEY_NAME NEW_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> totlen;</span><br><span class="line">    robj *o, *append;</span><br><span class="line"></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//如果key不存在，就相当于set命令</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Create the key */</span></span><br><span class="line">        c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        incrRefCount(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        totlen = stringObjectLen(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Key exists, check type */</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,REDIS_STRING))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* "append" is an argument, so always an sds */</span></span><br><span class="line">        append = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</span><br><span class="line">        <span class="comment">//判断追加后的字符串长度是否超过512MB</span></span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,totlen) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the object is shared or encoded, we have to make a copy */</span></span><br><span class="line">        <span class="comment">//只能追加到sds字符串后面，所以先转数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">            robj *decoded = getDecodedObject(o);</span><br><span class="line">            o = createStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr));</span><br><span class="line">            decrRefCount(decoded);</span><br><span class="line">            dbReplace(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Append the value */</span></span><br><span class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</span><br><span class="line">        totlen = sdslen(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">//返回给客户端的是追加后的字符串长度</span></span><br><span class="line">    addReplyLongLong(c,totlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现strlen命令</span></span><br><span class="line"><span class="comment">//STRLEN KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strlenCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    addReplyLongLong(c,stringObjectLen(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-列表"><a href="#4-3-列表" class="headerlink" title="4.3 列表"></a>4.3 列表</h2><h3 id="redis-h-列表相关"><a href="#redis-h-列表相关" class="headerlink" title="redis.h(列表相关)"></a>redis.h(列表相关)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Structure to hold list iteration abstraction. */</span></span><br><span class="line"><span class="comment">//列表的迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//列表对象</span></span><br><span class="line">    robj *subject;</span><br><span class="line">    <span class="comment">//列表编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;</span><br><span class="line">    <span class="comment">//迭代方向</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> direction; <span class="comment">/* Iteration direction */</span></span><br><span class="line">    <span class="comment">//下个ziplist节点的头地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;</span><br><span class="line">    <span class="comment">//下个linkedlist节点的地址</span></span><br><span class="line">    listNode *ln;</span><br><span class="line">&#125; listTypeIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure for an entry while iterating over a list. */</span></span><br><span class="line"><span class="comment">//迭代过程中存储迭代器当前节点的信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;  <span class="comment">/* Entry in ziplist */</span></span><br><span class="line">    listNode *ln;       <span class="comment">/* Entry in linked list */</span></span><br><span class="line">&#125; listTypeEntry;</span><br></pre></td></tr></table></figure><h3 id="t-list-c"><a href="#t-list-c" class="headerlink" title="t_list.c"></a>t_list.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"redis.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * List API</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the argument length to see if it requires us to convert the ziplist</span></span><br><span class="line"><span class="comment"> * to a real list. Only check raw-encoded objects because integer encoded</span></span><br><span class="line"><span class="comment"> * objects are never too long. */</span></span><br><span class="line"><span class="comment">//在向列表插入元素前调用，如果当前列表subject是基于ziplist的，且要插入的value字符串的长度超过了系统设定的ziplist单个entry的最大长度，就要把当前列表转换成基于linkedlist的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeTryConversion</span><span class="params">(robj *subject, robj *value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不是基于ziplist的列表不需要考虑转换</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding != REDIS_ENCODING_ZIPLIST) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (value-&gt;encoding == REDIS_ENCODING_RAW &amp;&amp;</span><br><span class="line">        sdslen(value-&gt;ptr) &gt; server.list_max_ziplist_value)</span><br><span class="line">            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向列表中插入元素，subject是列表对象，value是要插入的字符串对象，where是插入位置(0是表头，1是表尾)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypePush</span><span class="params">(robj *subject, robj *value, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先检查当前列表需不需要转成基于linkedlist的</span></span><br><span class="line">    listTypeTryConversion(subject,value);</span><br><span class="line">    <span class="comment">//如果当前列表基于ziplist，且存储的entry数量超过了系统设定的ziplist可容纳的最大entry数，也要把当前列表转成基于linkedlist的</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST &amp;&amp;</span><br><span class="line">        ziplistLen(subject-&gt;ptr) &gt;= server.list_max_ziplist_entries)</span><br><span class="line">            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);</span><br><span class="line">    <span class="comment">//如果是基于ziplist的列表，调用ziplistPush插入</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (where == REDIS_HEAD) ? ZIPLIST_HEAD : ZIPLIST_TAIL;</span><br><span class="line">        <span class="comment">//如果value是基于整型的字符串，要先转成基于sds的</span></span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line">        subject-&gt;ptr = ziplistPush(subject-&gt;ptr,value-&gt;ptr,sdslen(value-&gt;ptr),pos);</span><br><span class="line">        <span class="comment">//value已经存进列表了，本次对value的引用可以撤销了</span></span><br><span class="line">        decrRefCount(value);</span><br><span class="line">    <span class="comment">//如果是基于linkedlist的列表，调用listAddNodeHead和listAddNodeTail插入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (where == REDIS_HEAD) &#123;</span><br><span class="line">            listAddNodeHead(subject-&gt;ptr,value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listAddNodeTail(subject-&gt;ptr,value);</span><br><span class="line">        &#125;</span><br><span class="line">        incrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出列表元素，where是弹出位置(0是表头，1是表尾)</span></span><br><span class="line"><span class="function">robj *<span class="title">listTypePop</span><span class="params">(robj *subject, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">        <span class="keyword">int</span> pos = (where == REDIS_HEAD) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        p = ziplistIndex(subject-&gt;ptr,pos);</span><br><span class="line">        <span class="comment">//从ziplist中取出要弹出的元素，如果是字符串就存在vstr里，如果是整数就存在vlong里</span></span><br><span class="line">        <span class="keyword">if</span> (ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                <span class="comment">//返回值要求是robj对象，所以要基于弹出的元素新建robj</span></span><br><span class="line">                value = createStringObject((<span class="keyword">char</span>*)vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = createStringObjectFromLongLong(vlong);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* We only need to delete an element when it exists */</span></span><br><span class="line">            <span class="comment">//pop实际是两步，先生成并返回副本，然后删除原本</span></span><br><span class="line">            subject-&gt;ptr = ziplistDelete(subject-&gt;ptr,&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="built_in">list</span> *<span class="built_in">list</span> = subject-&gt;ptr;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        <span class="keyword">if</span> (where == REDIS_HEAD) &#123;</span><br><span class="line">            ln = listFirst(<span class="built_in">list</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ln = listLast(<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ln != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            value = listNodeValue(ln);</span><br><span class="line">            incrRefCount(value);</span><br><span class="line">            listDelNode(<span class="built_in">list</span>,ln);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回列表长度</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">listTypeLength</span><span class="params">(robj *subject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">return</span> ziplistLen(subject-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="keyword">return</span> listLength((<span class="built_in">list</span>*)subject-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize an iterator at the specified index. */</span></span><br><span class="line"><span class="comment">//创建列表的迭代器，index是指定的起始点，direction是迭代方向</span></span><br><span class="line"><span class="function">listTypeIterator *<span class="title">listTypeInitIterator</span><span class="params">(robj *subject, <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">char</span> direction)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li = zmalloc(<span class="keyword">sizeof</span>(listTypeIterator));</span><br><span class="line">    li-&gt;subject = subject;</span><br><span class="line">    li-&gt;encoding = subject-&gt;encoding;</span><br><span class="line">    li-&gt;direction = direction;</span><br><span class="line">    <span class="comment">//zi和ln分别存储ziplist和linkedlist的节点地址</span></span><br><span class="line">    <span class="comment">//对于ziplist，节点地址就是entry子串的头地址，对于linkedlist，节点地址就是指向某个listNode的指针</span></span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        li-&gt;zi = ziplistIndex(subject-&gt;ptr,index);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        li-&gt;ln = listIndex(subject-&gt;ptr,index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clean up the iterator. */</span></span><br><span class="line"><span class="comment">//释放迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeReleaseIterator</span><span class="params">(listTypeIterator *li)</span> </span>&#123;</span><br><span class="line">    zfree(li);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stores pointer to current the entry in the provided entry structure</span></span><br><span class="line"><span class="comment"> * and advances the position of the iterator. Returns 1 when the current</span></span><br><span class="line"><span class="comment"> * entry is in fact an entry, 0 otherwise. */</span></span><br><span class="line"><span class="comment">//把迭代器li的当前节点取出，存储在entry中，再让li指向下个节点</span></span><br><span class="line"><span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listTypeNext</span><span class="params">(listTypeIterator *li, listTypeEntry *entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Protect from converting when iterating */</span></span><br><span class="line">    <span class="comment">//如果迭代器最初保存的列表编码与当前的列表编码不同，说明列表被convert过，退出程序保平安</span></span><br><span class="line">    redisAssert(li-&gt;subject-&gt;encoding == li-&gt;encoding);</span><br><span class="line">    <span class="comment">//先把迭代器中的节点信息zi或ln转移到entry中，再更新迭代器中的zi或ln</span></span><br><span class="line">    entry-&gt;li = li;</span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        entry-&gt;zi = li-&gt;zi;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;zi != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (li-&gt;direction == REDIS_TAIL)</span><br><span class="line">                li-&gt;zi = ziplistNext(li-&gt;subject-&gt;ptr,li-&gt;zi);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                li-&gt;zi = ziplistPrev(li-&gt;subject-&gt;ptr,li-&gt;zi);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        entry-&gt;ln = li-&gt;ln;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;ln != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (li-&gt;direction == REDIS_TAIL)</span><br><span class="line">                li-&gt;ln = li-&gt;ln-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                li-&gt;ln = li-&gt;ln-&gt;prev;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return entry or NULL at the current position of the iterator. */</span></span><br><span class="line"><span class="comment">//返回entry中存储的节点对象</span></span><br><span class="line"><span class="function">robj *<span class="title">listTypeGet</span><span class="params">(listTypeEntry *entry)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li = entry-&gt;li;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">        redisAssert(entry-&gt;zi != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//对于ziplist是要新建robj</span></span><br><span class="line">        <span class="keyword">if</span> (ziplistGet(entry-&gt;zi,&amp;vstr,&amp;vlen,&amp;vlong)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                value = createStringObject((<span class="keyword">char</span>*)vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = createStringObjectFromLongLong(vlong);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        redisAssert(entry-&gt;ln != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//对于linkedlist就直接返回节点指针，引用加一</span></span><br><span class="line">        value = listNodeValue(entry-&gt;ln);</span><br><span class="line">        incrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将新元素value插入到entry所表示的节点之前或之后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeInsert</span><span class="params">(listTypeEntry *entry, robj *value, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *subject = entry-&gt;li-&gt;subject;</span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line">        <span class="keyword">if</span> (where == REDIS_TAIL) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点后面的节点</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *next = ziplistNext(subject-&gt;ptr,entry-&gt;zi);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果后面没有节点了，说明value应该插在表尾，直接调用ziplistPush，否则调用ziplistInsert</span></span><br><span class="line">            <span class="comment">//subject-&gt;ptr是ziplist字符串，value-&gt;ptr是要插入的字符串</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                subject-&gt;ptr = ziplistPush(subject-&gt;ptr,value-&gt;ptr,sdslen(value-&gt;ptr),REDIS_TAIL);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                subject-&gt;ptr = ziplistInsert(subject-&gt;ptr,next,value-&gt;ptr,sdslen(value-&gt;ptr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subject-&gt;ptr = ziplistInsert(subject-&gt;ptr,entry-&gt;zi,value-&gt;ptr,sdslen(value-&gt;ptr));</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (where == REDIS_TAIL) &#123;</span><br><span class="line">            listInsertNode(subject-&gt;ptr,entry-&gt;ln,value,AL_START_TAIL);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listInsertNode(subject-&gt;ptr,entry-&gt;ln,value,AL_START_HEAD);</span><br><span class="line">        &#125;</span><br><span class="line">        incrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare the given object with the entry at the current position. */</span></span><br><span class="line"><span class="comment">//对比entry中存储的节点对象和给定的对象o</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listTypeEqual</span><span class="params">(listTypeEntry *entry, robj *o)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li = entry-&gt;li;</span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="comment">//ziplistCompare只能比较字符串</span></span><br><span class="line">        <span class="comment">//如果o是基于整型的字符串，为什么不能转一下再比较？下面的equalStringObjects就考虑了ll2string</span></span><br><span class="line">        redisAssert(o-&gt;encoding == REDIS_ENCODING_RAW);</span><br><span class="line">        <span class="keyword">return</span> ziplistCompare(entry-&gt;zi,o-&gt;ptr,sdslen(o-&gt;ptr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="keyword">return</span> equalStringObjects(o,listNodeValue(entry-&gt;ln));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete the element pointed to. */</span></span><br><span class="line"><span class="comment">//删除entry中记录的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeDelete</span><span class="params">(listTypeEntry *entry)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li = entry-&gt;li;</span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = entry-&gt;zi;</span><br><span class="line">        <span class="comment">//删除p指向的entry，再把下个entry的地址重新赋给p</span></span><br><span class="line">        li-&gt;subject-&gt;ptr = ziplistDelete(li-&gt;subject-&gt;ptr,&amp;p);</span><br><span class="line">        <span class="comment">//li指向的本来就是下个节点，但是删除了当前节点后，下个节点的地址就变了，所以要重新让迭代器指向下个节点</span></span><br><span class="line">        <span class="comment">//所以结果就是entry指向的节点被删了，li指向的节点不变，但是节点地址变了</span></span><br><span class="line">        <span class="keyword">if</span> (li-&gt;direction == REDIS_TAIL)</span><br><span class="line">            li-&gt;zi = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            li-&gt;zi = ziplistPrev(li-&gt;subject-&gt;ptr,p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry-&gt;li-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *next;</span><br><span class="line">        <span class="keyword">if</span> (li-&gt;direction == REDIS_TAIL)</span><br><span class="line">            next = entry-&gt;ln-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next = entry-&gt;ln-&gt;prev;</span><br><span class="line">        listDelNode(li-&gt;subject-&gt;ptr,entry-&gt;ln);</span><br><span class="line">        li-&gt;ln = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把基于ziplist的列表转成基于linkedlist的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeConvert</span><span class="params">(robj *subject, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    redisAssert(subject-&gt;type == REDIS_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="built_in">list</span> *l = listCreate();</span><br><span class="line">        listSetFreeMethod(l,decrRefCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* listTypeGet returns a robj with incremented refcount */</span></span><br><span class="line">        <span class="comment">//创建一个原列表迭代器</span></span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">        <span class="comment">//迭代每个节点并add到新列表</span></span><br><span class="line">        <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) listAddNodeTail(l,listTypeGet(&amp;entry));</span><br><span class="line">        listTypeReleaseIterator(li);</span><br><span class="line"></span><br><span class="line">        subject-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</span><br><span class="line">        <span class="comment">//free掉原来的ziplist</span></span><br><span class="line">        zfree(subject-&gt;ptr);</span><br><span class="line">        subject-&gt;ptr = l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unsupported list conversion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * List Commands</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//处理客户端发来的lpush和rpush请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在db中根据key获取列表对象</span></span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//这里为什么要把value转成整型呢？后面调用listTypePush时明明又会把value转回字符串</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//列表不存在</span></span><br><span class="line">    <span class="keyword">if</span> (lobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果有正在等待blocking pop的客户端，就把要push的新元素直接返回给那个等待pop的客户端，就不用继续push了</span></span><br><span class="line">        <span class="keyword">if</span> (handleClientsWaitingListPush(c,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>])) &#123;</span><br><span class="line">            addReply(c,shared.cone);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有等待pop的客户端，就新建列表，把新元素push进去</span></span><br><span class="line">        lobj = createZiplistObject();</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果key对应的value不是列表对象，向客户端报错</span></span><br><span class="line">        <span class="keyword">if</span> (lobj-&gt;type != REDIS_LIST) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handleClientsWaitingListPush(c,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>])) &#123;</span><br><span class="line">            touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            addReply(c,shared.cone);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行push操作</span></span><br><span class="line">    listTypePush(lobj,c-&gt;argv[<span class="number">2</span>],where);、</span><br><span class="line">    <span class="comment">//返回给客户端的是push后列表的长度</span></span><br><span class="line">    addReplyLongLong(c,listTypeLength(lobj));</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lpush命令，2.4版本以前的lpush只接受单个value参数</span></span><br><span class="line"><span class="comment">//LPUSH KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    pushGenericCommand(c,REDIS_HEAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现rpush命令，2.4版本以前的rpush只接受单个value参数</span></span><br><span class="line"><span class="comment">//RPUSH KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    pushGenericCommand(c,REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的lpushx、rpushx和linsert请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushxGenericCommand</span><span class="params">(redisClient *c, robj *refval, robj *val, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *subject;</span><br><span class="line">    listTypeIterator *iter;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    <span class="keyword">int</span> inserted = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果目标列表不存在或不是列表对象，放弃push操作</span></span><br><span class="line">    <span class="keyword">if</span> ((subject = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,subject,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//refval不为NULL说明是linsert命令，要把val插入到refval之前或之后</span></span><br><span class="line">    <span class="keyword">if</span> (refval != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Note: we expect refval to be string-encoded because it is *not* the</span></span><br><span class="line"><span class="comment">         * last argument of the multi-bulk LINSERT. */</span></span><br><span class="line">        redisAssert(refval-&gt;encoding == REDIS_ENCODING_RAW);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We're not sure if this value can be inserted yet, but we cannot</span></span><br><span class="line"><span class="comment">         * convert the list inside the iterator. We don't want to loop over</span></span><br><span class="line"><span class="comment">         * the list twice (once to see if the value can be inserted and once</span></span><br><span class="line"><span class="comment">         * to do the actual insert), so we assume this value can be inserted</span></span><br><span class="line"><span class="comment">         * and convert the ziplist to a regular list if necessary. */</span></span><br><span class="line">        <span class="comment">//先检查当前列表需不需要转成基于linkedlist的</span></span><br><span class="line">        listTypeTryConversion(subject,val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Seek refval from head to tail */</span></span><br><span class="line">        <span class="comment">//创建迭代器，在列表中定位refval，然后插入val</span></span><br><span class="line">        iter = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">        <span class="keyword">while</span> (listTypeNext(iter,&amp;entry)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (listTypeEqual(&amp;entry,refval)) &#123;</span><br><span class="line">                listTypeInsert(&amp;entry,val,where);</span><br><span class="line">                inserted = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listTypeReleaseIterator(iter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">            <span class="comment">/* Check if the length exceeds the ziplist length threshold. */</span></span><br><span class="line">            <span class="comment">//如果当前是ziplist，还要检查插入后是否超过了允许容纳的最大entry数量</span></span><br><span class="line">            <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST &amp;&amp;</span><br><span class="line">                ziplistLen(subject-&gt;ptr) &gt; server.list_max_ziplist_entries)</span><br><span class="line">                    listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);</span><br><span class="line">            touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Notify client of a failed insert */</span></span><br><span class="line">            <span class="comment">//插入失败，给客户端返回-1</span></span><br><span class="line">            addReply(c,shared.cnegone);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果refval是NULL，正常执行push操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        listTypePush(subject,val,where);</span><br><span class="line">        touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回给客户端的是执行push后列表的长度</span></span><br><span class="line">    addReplyLongLong(c,listTypeLength(subject));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lpushx命令</span></span><br><span class="line"><span class="comment">//LPUSHX KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushxCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    pushxGenericCommand(c,<span class="literal">NULL</span>,c-&gt;argv[<span class="number">2</span>],REDIS_HEAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现rpushx命令</span></span><br><span class="line"><span class="comment">//RPUSHX KEY_NAME VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushxCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    pushxGenericCommand(c,<span class="literal">NULL</span>,c-&gt;argv[<span class="number">2</span>],REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现linsert命令</span></span><br><span class="line"><span class="comment">//LINSERT key BEFORE|AFTER pivot value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linsertCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">4</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">"after"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        pushxGenericCommand(c,c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">4</span>],REDIS_TAIL);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">"before"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        pushxGenericCommand(c,c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">4</span>],REDIS_HEAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现llen命令</span></span><br><span class="line"><span class="comment">//LLEN KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    addReplyLongLong(c,listTypeLength(o));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lindex命令</span></span><br><span class="line"><span class="comment">//LINDEX KEY_NAME INDEX_POSITION</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lindexCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">        <span class="comment">//获取第index个entry的头地址</span></span><br><span class="line">        p = ziplistIndex(o-&gt;ptr,index);</span><br><span class="line">        <span class="keyword">if</span> (ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                value = createStringObject((<span class="keyword">char</span>*)vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = createStringObjectFromLongLong(vlong);</span><br><span class="line">            &#125;</span><br><span class="line">            addReplyBulk(c,value);</span><br><span class="line">            decrRefCount(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *ln = listIndex(o-&gt;ptr,index);</span><br><span class="line">        <span class="keyword">if</span> (ln != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            value = listNodeValue(ln);</span><br><span class="line">            addReplyBulk(c,value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lset命令</span></span><br><span class="line"><span class="comment">//LSET KEY_NAME INDEX VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsetCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nokeyerr);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    robj *value = (c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">    listTypeTryConversion(o,value);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, *zl = o-&gt;ptr;</span><br><span class="line">        p = ziplistIndex(zl,index);</span><br><span class="line">        <span class="comment">//找不到第index个entry，就报索引越界的错</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c,shared.outofrangeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//set新value的逻辑是，先删掉旧的，再插入新的</span></span><br><span class="line">            o-&gt;ptr = ziplistDelete(o-&gt;ptr,&amp;p);</span><br><span class="line">            value = getDecodedObject(value);</span><br><span class="line">            o-&gt;ptr = ziplistInsert(o-&gt;ptr,p,value-&gt;ptr,sdslen(value-&gt;ptr));</span><br><span class="line">            decrRefCount(value);</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">            touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *ln = listIndex(o-&gt;ptr,index);</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c,shared.outofrangeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ziplist的entry没有引用，所以能直接删，但是linkedlist的listNode有引用，所以在重置listNode指针之前要把指向的value引用减一</span></span><br><span class="line">            <span class="comment">//ziplist的插入是把字符串hardcode到ziplist中，不是对value的引用，但是linkedlist的插入是把listNode的指针指向value，是对value的引用</span></span><br><span class="line">            decrRefCount((robj*)listNodeValue(ln));</span><br><span class="line">            listNodeValue(ln) = value;</span><br><span class="line">            incrRefCount(value);</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">            touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端发来的lpop和rpop请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//返回弹出的元素</span></span><br><span class="line">    robj *value = listTypePop(o,where);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReply(c,shared.nullbulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,value);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">        <span class="comment">//如果弹出后列表为空，就顺便从db中删除列表</span></span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lpop命令</span></span><br><span class="line"><span class="comment">//Lpop KEY_NAME </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpopCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,REDIS_HEAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现rpop命令</span></span><br><span class="line"><span class="comment">//Rpop KEY_NAME </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpopCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lrange命令</span></span><br><span class="line"><span class="comment">//LRANGE KEY_NAME START END</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrangeCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">int</span> start = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> end = atoi(c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> llen;</span><br><span class="line">    <span class="keyword">int</span> rangelen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymultibulk)) == <span class="literal">NULL</span></span><br><span class="line">         || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取列表的长度</span></span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert negative indexes */</span></span><br><span class="line">    <span class="comment">//把负索引转成正索引</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="comment">//调整边界</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        addReply(c,shared.emptymultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整边界</span></span><br><span class="line">    <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">    rangelen = (end-start)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the result in form of a multi-bulk reply */</span></span><br><span class="line">    addReplyMultiBulkLen(c,rangelen);</span><br><span class="line">    <span class="comment">//先调用ziplistIndex把指针p放在起点，再循环调用ziplistGet取出元素</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(o-&gt;ptr,start);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123;</span><br><span class="line">            ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong);</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkLongLong(c,vlong);</span><br><span class="line">            &#125;</span><br><span class="line">            p = ziplistNext(o-&gt;ptr,p);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//对于linkedlist，直接通过节点的next就能遍历</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we are nearest to the end of the list, reach the element</span></span><br><span class="line"><span class="comment">         * starting from tail and going backward, as it is faster. */</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; llen/<span class="number">2</span>) start -= llen;</span><br><span class="line">        ln = listIndex(o-&gt;ptr,start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123;</span><br><span class="line">            addReplyBulk(c,ln-&gt;value);</span><br><span class="line">            ln = ln-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"List encoding is not LINKEDLIST nor ZIPLIST!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现ltrim命令</span></span><br><span class="line"><span class="comment">//LTRIM KEY_NAME START STOP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltrimCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">int</span> start = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> end = atoi(c-&gt;argv[<span class="number">3</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> llen;</span><br><span class="line">    <span class="comment">//ltrim是从列表头部裁减掉的节点数，rtrim是从列表尾部裁减掉的节点数</span></span><br><span class="line">    <span class="keyword">int</span> j, ltrim, rtrim;</span><br><span class="line">    <span class="built_in">list</span> *<span class="built_in">list</span>;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.ok)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* convert negative indexes */</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        <span class="comment">/* Out of range start or start &gt; end result in empty list */</span></span><br><span class="line">        ltrim = llen;</span><br><span class="line">        rtrim = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//因为列表索引是从0开始的，索引为start的节点其实是第start+1个节点，所以左侧要删除的节点数是就start</span></span><br><span class="line">        ltrim = start;</span><br><span class="line">        <span class="comment">//llen-end是end右侧且包括end索引的节点数，因为end索引处的节点要保留，所以最后减一</span></span><br><span class="line">        rtrim = llen-end<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove list elements to perform the trim */</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="comment">//从列表头部开始删除ltrim个节点，左侧裁剪完成</span></span><br><span class="line">        o-&gt;ptr = ziplistDeleteRange(o-&gt;ptr,<span class="number">0</span>,ltrim);</span><br><span class="line">        <span class="comment">//从列表尾部删除时用负索引定位倒数第rtrim个节点，往后删除共rtrim个节点，右侧裁剪完成</span></span><br><span class="line">        o-&gt;ptr = ziplistDeleteRange(o-&gt;ptr,-rtrim,rtrim);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="built_in">list</span> = o-&gt;ptr;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ltrim; j++) &#123;</span><br><span class="line">            ln = listFirst(<span class="built_in">list</span>);</span><br><span class="line">            listDelNode(<span class="built_in">list</span>,ln);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; rtrim; j++) &#123;</span><br><span class="line">            ln = listLast(<span class="built_in">list</span>);</span><br><span class="line">            listDelNode(<span class="built_in">list</span>,ln);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果裁剪后列表为空，就顺便从db中删除列表</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现lrem命令</span></span><br><span class="line"><span class="comment">//LREM KEY_NAME COUNT VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lremCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *subject, *obj;</span><br><span class="line">    obj = c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//toremove是要移除的节点数，也就是命令里count参数的绝对值</span></span><br><span class="line">    <span class="keyword">int</span> toremove = atoi(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">    <span class="comment">//removed是已经移除的节点数</span></span><br><span class="line">    <span class="keyword">int</span> removed = <span class="number">0</span>;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line"></span><br><span class="line">    subject = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (subject == <span class="literal">NULL</span> || checkType(c,subject,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure obj is raw when we're dealing with a ziplist */</span></span><br><span class="line">    <span class="comment">//在ziplist中只能做字符串比较，所以要先把value转成sds字符串</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST)</span><br><span class="line">        obj = getDecodedObject(obj);</span><br><span class="line"></span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    <span class="comment">//toremove&lt;0表示从后往前遍历列表，设置好迭代器的方向后，把toremove转成正数</span></span><br><span class="line">    <span class="keyword">if</span> (toremove &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        toremove = -toremove;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">-1</span>,REDIS_HEAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代节点并删除直到 removed == toremove</span></span><br><span class="line">    <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listTypeEqual(&amp;entry,obj)) &#123;</span><br><span class="line">            listTypeDelete(&amp;entry);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            removed++;</span><br><span class="line">            <span class="keyword">if</span> (toremove &amp;&amp; removed == toremove) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listTypeReleaseIterator(li);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up raw encoded object */</span></span><br><span class="line">    <span class="comment">//之前调用getDecodedObject增加了对sds字符串的引用，这里引用要减一</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST)</span><br><span class="line">        decrRefCount(obj);</span><br><span class="line">    <span class="comment">//如果删除节点后列表为空，就顺便从db中删除列表</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(subject) == <span class="number">0</span>) dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//返回给客户端的是实际删除的节点数</span></span><br><span class="line">    addReplyLongLong(c,removed);</span><br><span class="line">    <span class="keyword">if</span> (removed) touchWatchedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the semantic of this command:</span></span><br><span class="line"><span class="comment"> *  RPOPLPUSH srclist dstlist:</span></span><br><span class="line"><span class="comment"> *    IF LLEN(srclist) &gt; 0</span></span><br><span class="line"><span class="comment"> *      element = RPOP srclist</span></span><br><span class="line"><span class="comment"> *      LPUSH dstlist element</span></span><br><span class="line"><span class="comment"> *      RETURN element</span></span><br><span class="line"><span class="comment"> *    ELSE</span></span><br><span class="line"><span class="comment"> *      RETURN nil</span></span><br><span class="line"><span class="comment"> *    END</span></span><br><span class="line"><span class="comment"> *  END</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The idea is to be able to get an element from a list in a reliable way</span></span><br><span class="line"><span class="comment"> * since the element is not just returned but pushed against another list</span></span><br><span class="line"><span class="comment"> * as well. This command was originally proposed by Ezra Zygmuntowicz.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//处理客户端发来的rpoplpush命令，负责执行push的部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpoplpushHandlePush</span><span class="params">(redisClient *origclient, redisClient *c, robj *dstkey, robj *dstobj, robj *value)</span> </span>&#123;</span><br><span class="line">    robj *aux;</span><br><span class="line">    <span class="comment">//如果有正在阻塞的客户端，就把value发送给该客户端执行push操作</span></span><br><span class="line">    <span class="keyword">if</span> (!handleClientsWaitingListPush(origclient,dstkey,value)) &#123;</span><br><span class="line">        <span class="comment">/* Create the list if the key does not exist */</span></span><br><span class="line">        <span class="comment">//如果要push的列表不存在，就先创建新列表</span></span><br><span class="line">        <span class="keyword">if</span> (!dstobj) &#123;</span><br><span class="line">            dstobj = createZiplistObject();</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstobj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            touchWatchedKey(c-&gt;db,dstkey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把value添加到列表头部</span></span><br><span class="line">        listTypePush(dstobj,value,REDIS_HEAD);</span><br><span class="line">        <span class="comment">/* If we are pushing as a result of LPUSH against a key</span></span><br><span class="line"><span class="comment">         * watched by BRPOPLPUSH, we need to rewrite the command vector</span></span><br><span class="line"><span class="comment">         * as an LPUSH.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If this is called directly by RPOPLPUSH (either directly</span></span><br><span class="line"><span class="comment">         * or via a BRPOPLPUSH where the popped list exists)</span></span><br><span class="line"><span class="comment">         * we should replicate the RPOPLPUSH command itself. */</span></span><br><span class="line">        <span class="comment">//修改客户端命令，写入AOF文件，没看懂？？？</span></span><br><span class="line">        <span class="keyword">if</span> (c != origclient) &#123;</span><br><span class="line">            aux = createStringObject(<span class="string">"LPUSH"</span>,<span class="number">5</span>);</span><br><span class="line">            rewriteClientCommandVector(origclient,<span class="number">3</span>,aux,dstkey,value);</span><br><span class="line">            decrRefCount(aux);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Make sure to always use RPOPLPUSH in the replication / AOF,</span></span><br><span class="line"><span class="comment">             * even if the original command was BRPOPLPUSH. */</span></span><br><span class="line">            aux = createStringObject(<span class="string">"RPOPLPUSH"</span>,<span class="number">9</span>);</span><br><span class="line">            rewriteClientCommandVector(origclient,<span class="number">3</span>,aux,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">            decrRefCount(aux);</span><br><span class="line">        &#125;</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Always send the pushed value to the client. */</span></span><br><span class="line">    addReplyBulk(c,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现rpoplpush命令</span></span><br><span class="line"><span class="comment">//RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpoplpushCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    robj *sobj, *value;</span><br><span class="line">    <span class="comment">//获取执行pop的列表</span></span><br><span class="line">    <span class="keyword">if</span> ((sobj = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,sobj,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//因为要执行pop，所以列表不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(sobj) == <span class="number">0</span>) &#123;</span><br><span class="line">        addReply(c,shared.nullbulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取执行push的列表</span></span><br><span class="line">        robj *dobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        robj *touchedkey = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dobj &amp;&amp; checkType(c,dobj,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//执行pop得到value</span></span><br><span class="line">        value = listTypePop(sobj,REDIS_TAIL);</span><br><span class="line">        <span class="comment">/* We saved touched key, and protect it, since rpoplpushHandlePush</span></span><br><span class="line"><span class="comment">         * may change the client command argument vector. */</span></span><br><span class="line">        incrRefCount(touchedkey);</span><br><span class="line">        <span class="comment">//把value添加到执行push的列表中，当执行rpoplpush命令时，pop和push操作都是在同一个client下完成，所以两个client参数相同</span></span><br><span class="line">        rpoplpushHandlePush(c,c,c-&gt;argv[<span class="number">2</span>],dobj,value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* listTypePop returns an object with its refcount incremented */</span></span><br><span class="line">        <span class="comment">//push完毕，value就没用了，引用减一</span></span><br><span class="line">        decrRefCount(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Delete the source list when it is empty */</span></span><br><span class="line">        <span class="comment">//对于执行pop的列表，如果pop以后列表为空，就删除该列表</span></span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(sobj) == <span class="number">0</span>) dbDelete(c-&gt;db,touchedkey);</span><br><span class="line">        touchWatchedKey(c-&gt;db,touchedkey);</span><br><span class="line">        decrRefCount(touchedkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Blocking POP operations</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Currently Redis blocking operations support is limited to list POP ops,</span></span><br><span class="line"><span class="comment"> * so the current implementation is not fully generic, but it is also not</span></span><br><span class="line"><span class="comment"> * completely specific so it will not require a rewrite to support new</span></span><br><span class="line"><span class="comment"> * kind of blocking operations in the future.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Still it's important to note that list blocking operations can be already</span></span><br><span class="line"><span class="comment"> * used as a notification mechanism in order to implement other blocking</span></span><br><span class="line"><span class="comment"> * operations at application level, so there must be a very strong evidence</span></span><br><span class="line"><span class="comment"> * of usefulness and generality before new blocking operations are implemented.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is how the current blocking POP works, we use BLPOP as example:</span></span><br><span class="line"><span class="comment"> * - If the user calls BLPOP and the key exists and contains a non empty list</span></span><br><span class="line"><span class="comment"> *   then LPOP is called instead. So BLPOP is semantically the same as LPOP</span></span><br><span class="line"><span class="comment"> *   if there is not to block.</span></span><br><span class="line"><span class="comment"> * - If instead BLPOP is called and the key does not exists or the list is</span></span><br><span class="line"><span class="comment"> *   empty we need to block. In order to do so we remove the notification for</span></span><br><span class="line"><span class="comment"> *   new data to read in the client socket (so that we'll not serve new</span></span><br><span class="line"><span class="comment"> *   requests if the blocking request is not served). Also we put the client</span></span><br><span class="line"><span class="comment"> *   in a dictionary (db-&gt;blocking_keys) mapping keys to a list of clients</span></span><br><span class="line"><span class="comment"> *   blocking for this keys.</span></span><br><span class="line"><span class="comment"> * - If a PUSH operation against a key with blocked clients waiting is</span></span><br><span class="line"><span class="comment"> *   performed, we serve the first in the list: basically instead to push</span></span><br><span class="line"><span class="comment"> *   the new element inside the list we return it to the (first / oldest)</span></span><br><span class="line"><span class="comment"> *   blocking client, unblock the client, and remove it form the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above comment and the source code should be enough in order to understand</span></span><br><span class="line"><span class="comment"> * the implementation and modify / fix it later.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set a client in blocking mode for the specified key, with the specified</span></span><br><span class="line"><span class="comment"> * timeout */</span></span><br><span class="line"><span class="comment">//因为只支持blocking pop的命令，所以阻塞客户端就是等待指定key对应的列表有可以pop的元素</span></span><br><span class="line"><span class="comment">//keys是存储所有等待pop的列表的数组，numkeys是keys数组的长度，timeout是超时时间，target是被push的列表的key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockForKeys</span><span class="params">(redisClient *c, robj **keys, <span class="keyword">int</span> numkeys, <span class="keyword">time_t</span> timeout, robj *target)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *l;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">//bpop是client的属性，记录阻塞信息</span></span><br><span class="line">    c-&gt;bpop.keys = zmalloc(<span class="keyword">sizeof</span>(robj*)*numkeys);</span><br><span class="line">    c-&gt;bpop.count = numkeys;</span><br><span class="line">    c-&gt;bpop.timeout = timeout;</span><br><span class="line">    c-&gt;bpop.target = target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        incrRefCount(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">        <span class="comment">/* Add the key in the client structure, to map clients -&gt; keys */</span></span><br><span class="line">        <span class="comment">//把所有等待pop的列表添加到c-&gt;bpop，标记阻塞的客户端正在监听哪些列表</span></span><br><span class="line">        c-&gt;bpop.keys[j] = keys[j];</span><br><span class="line">        incrRefCount(keys[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* And in the other "side", to map keys -&gt; clients */</span></span><br><span class="line">        <span class="comment">//c-&gt;db-&gt;blocking_keys字典存储正在监听某个列表的所有客户端，key是列表的键，value就是存储客户端的列表</span></span><br><span class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);</span><br><span class="line">        <span class="comment">//当前列表没有被其他客户端监听</span></span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* For every key we take a list of clients blocked for it */</span></span><br><span class="line">            <span class="comment">//新建客户端列表，存入blocking_keys字典</span></span><br><span class="line">            l = listCreate();</span><br><span class="line">            retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);</span><br><span class="line">            incrRefCount(keys[j]);</span><br><span class="line">            redisAssert(retval == DICT_OK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就是直接往客户端列表里add</span></span><br><span class="line">            l = dictGetEntryVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        listAddNodeTail(l,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Mark the client as a blocked client */</span></span><br><span class="line">    <span class="comment">//修改客户端的阻塞标记</span></span><br><span class="line">    c-&gt;flags |= REDIS_BLOCKED;</span><br><span class="line">    server.bpop_blocked_clients++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unblock a client that's waiting in a blocking operation such as BLPOP */</span></span><br><span class="line"><span class="comment">//解除客户端的阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unblockClientWaitingData</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *l;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    redisAssert(c-&gt;bpop.keys != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* The client may wait for multiple keys, so unblock it for every key. */</span></span><br><span class="line">    <span class="comment">//遍历当前客户端监视的所有列表，修改blocking_keys</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;bpop.count; j++) &#123;</span><br><span class="line">        <span class="comment">/* Remove this client from the list of clients waiting for this key. */</span></span><br><span class="line">        <span class="comment">//把客户端从blocking_keys中清除</span></span><br><span class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,c-&gt;bpop.keys[j]);</span><br><span class="line">        redisAssert(de != <span class="literal">NULL</span>);</span><br><span class="line">        l = dictGetEntryVal(de);</span><br><span class="line">        listDelNode(l,listSearchKey(l,c));</span><br><span class="line">        <span class="comment">/* If the list is empty we need to remove it to avoid wasting memory */</span></span><br><span class="line">        <span class="comment">//删除以后如果列表为空，就顺便把列表也删除</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(l) == <span class="number">0</span>)</span><br><span class="line">            dictDelete(c-&gt;db-&gt;blocking_keys,c-&gt;bpop.keys[j]);</span><br><span class="line">        decrRefCount(c-&gt;bpop.keys[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup the client structure */</span></span><br><span class="line">    <span class="comment">//解除客户端的阻塞就要把c-&gt;bpop.keys里的列表的key全部删除</span></span><br><span class="line">    zfree(c-&gt;bpop.keys);</span><br><span class="line">    c-&gt;bpop.keys = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//调用本函数前，c-&gt;bpop.target已经被handler复制下来了，所以现在就可以清除记录了</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;bpop.target) decrRefCount(c-&gt;bpop.target);</span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//修改阻塞标记和非阻塞标记</span></span><br><span class="line">    c-&gt;flags &amp;= ~REDIS_BLOCKED;</span><br><span class="line">    c-&gt;flags |= REDIS_UNBLOCKED;</span><br><span class="line">    server.bpop_blocked_clients--;</span><br><span class="line">    listAddNodeTail(server.unblocked_clients,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This should be called from any function PUSHing into lists.</span></span><br><span class="line"><span class="comment"> * 'c' is the "pushing client", 'key' is the key it is pushing data against,</span></span><br><span class="line"><span class="comment"> * 'ele' is the element pushed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the function returns 0 there was no client waiting for a list push</span></span><br><span class="line"><span class="comment"> * against this key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the function returns 1 there was a client waiting for a list push</span></span><br><span class="line"><span class="comment"> * against this key, the element was passed to this client thus it's not</span></span><br><span class="line"><span class="comment"> * needed to actually add it to the list and the caller should return asap. */</span></span><br><span class="line"><span class="comment">//每当有新元素被push到列表中时，都要先检查当前是否有正在等待的blocking pop命令</span></span><br><span class="line"><span class="comment">//c是执行push命令的client，key是执行pop的列表的key，ele是被push的新元素</span></span><br><span class="line"><span class="comment">//返回0表示没有正在等待的blocking pop，回到原函数中要继续执行push。返回1表示有正在等待的blocking pop，直接把ele返回给执行pop的client，ele就不需要再push到列表中了</span></span><br><span class="line"><span class="comment">//过程比较乱，涉及到一个pop和两个push。列表A被等待blocking pop的客户端监听，当新元素被push到A中，这个push实际不执行，直接当做pop的结果返回，如果是rpoplpush命令，后面还有一个push操作，pop出的元素会被push到列表B中，这个push是一定会执行的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handleClientsWaitingListPush</span><span class="params">(redisClient *c, robj *key, robj *ele)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">de</span>;</span></span><br><span class="line">    redisClient *receiver;</span><br><span class="line">    <span class="keyword">int</span> numclients;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    robj *dstkey, *dstobj;</span><br><span class="line">    <span class="comment">//c-&gt;db-&gt;blocking_keys中没有记录，说明当前列表没有被任何客户端所等待</span></span><br><span class="line">    de = dictFind(c-&gt;db-&gt;blocking_keys,key);</span><br><span class="line">    <span class="keyword">if</span> (de == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取当前列表关联的所有阻塞客户端</span></span><br><span class="line">    clients = dictGetEntryVal(de);</span><br><span class="line">    numclients = listLength(clients);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to handle the push as long as there are clients waiting for a push.</span></span><br><span class="line"><span class="comment">     * Note that "numclients" is used because the list of clients waiting for a</span></span><br><span class="line"><span class="comment">     * push on "key" is deleted by unblockClient() when empty.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This loop will have more than 1 iteration when there is a BRPOPLPUSH</span></span><br><span class="line"><span class="comment">     * that cannot push the target list because it does not contain a list. If</span></span><br><span class="line"><span class="comment">     * this happens, it simply tries the next client waiting for a push. */</span></span><br><span class="line">    <span class="keyword">while</span> (numclients--) &#123;</span><br><span class="line">        ln = listFirst(clients);</span><br><span class="line">        redisAssert(ln != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//receiver是等待执行pop的客户端</span></span><br><span class="line">        receiver = ln-&gt;value;</span><br><span class="line">        <span class="comment">//如果pop出的元素要立即被push到另一个列表中，dstkey是被执行push的列表的key</span></span><br><span class="line">        dstkey = receiver-&gt;bpop.target;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Protect receiver-&gt;bpop.target, that will be freed by</span></span><br><span class="line"><span class="comment">         * the next unblockClientWaitingData() call. */</span></span><br><span class="line">        <span class="keyword">if</span> (dstkey) incrRefCount(dstkey);</span><br><span class="line">        <span class="comment">/* This should remove the first element of the "clients" list. */</span></span><br><span class="line">        <span class="comment">//执行push前先解除客户端的阻塞</span></span><br><span class="line">        unblockClientWaitingData(receiver);</span><br><span class="line">        <span class="comment">//如果没指定push的列表，说明当前的命令就是单纯的blocking pop，因为此前pop已经执行，函数直接在此退出</span></span><br><span class="line">        <span class="keyword">if</span> (dstkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* BRPOP/BLPOP */</span></span><br><span class="line">            addReplyMultiBulkLen(receiver,<span class="number">2</span>);</span><br><span class="line">            addReplyBulk(receiver,key);</span><br><span class="line">            addReplyBulk(receiver,ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Serve just the first client as in B[RL]POP semantics */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* BRPOPLPUSH, note that receiver-&gt;db is always equal to c-&gt;db. */</span></span><br><span class="line">            dstobj = lookupKeyWrite(receiver-&gt;db,dstkey);</span><br><span class="line">            <span class="keyword">if</span> (!(dstobj &amp;&amp; checkType(receiver,dstobj,REDIS_LIST))) &#123;</span><br><span class="line">                rpoplpushHandlePush(c,receiver,dstkey,dstobj,ele);</span><br><span class="line">                decrRefCount(dstkey);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            decrRefCount(dstkey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析出对象object的过期时间，结果保存在timeout中，其实只是调用getLongFromObjectOrReply</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTimeoutFromObjectOrReply</span><span class="params">(redisClient *c, robj *object, <span class="keyword">time_t</span> *timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,object,&amp;tval,</span><br><span class="line">        <span class="string">"timeout is not an integer or out of range"</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"timeout is negative"</span>);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tval &gt; <span class="number">0</span>) tval += time(<span class="literal">NULL</span>);</span><br><span class="line">    *timeout = tval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Blocking RPOP/LPOP */</span></span><br><span class="line"><span class="comment">//处理客户端发来的blpop和brpop命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockingPopGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">time_t</span> timeout;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[c-&gt;argc<span class="number">-1</span>],&amp;timeout) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序遍历命令参数里的所有列表，找到第一个非空列表后，执行pop并返回</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">//获取列表</span></span><br><span class="line">        o = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//不是列表对象就退出</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type != REDIS_LIST) &#123;</span><br><span class="line">                addReply(c,shared.wrongtypeerr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果列表不为空就可以执行pop</span></span><br><span class="line">                <span class="keyword">if</span> (listTypeLength(o) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* If the list contains elements fall back to the usual</span></span><br><span class="line"><span class="comment">                     * non-blocking POP operation */</span></span><br><span class="line">                    struct redisCommand *orig_cmd;</span><br><span class="line">                    robj *argv[<span class="number">2</span>], **orig_argv;</span><br><span class="line">                    <span class="keyword">int</span> orig_argc;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* We need to alter the command arguments before to call</span></span><br><span class="line"><span class="comment">                     * popGenericCommand() as the command takes a single key. */</span></span><br><span class="line">                    <span class="comment">//因为要切换到执行pop命令的popGenericCommand函数，所以需要调整一下命令参数</span></span><br><span class="line">                    orig_argv = c-&gt;argv;</span><br><span class="line">                    orig_argc = c-&gt;argc;</span><br><span class="line">                    orig_cmd = c-&gt;cmd;</span><br><span class="line">                    argv[<span class="number">1</span>] = c-&gt;argv[j];</span><br><span class="line">                    c-&gt;argv = argv;</span><br><span class="line">                    c-&gt;argc = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Also the return value is different, we need to output</span></span><br><span class="line"><span class="comment">                     * the multi bulk reply header and the key name. The</span></span><br><span class="line"><span class="comment">                     * "real" command will add the last element (the value)</span></span><br><span class="line"><span class="comment">                     * for us. If this souds like an hack to you it's just</span></span><br><span class="line"><span class="comment">                     * because it is... */</span></span><br><span class="line">                    addReplyMultiBulkLen(c,<span class="number">2</span>);</span><br><span class="line">                    addReplyBulk(c,argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                    popGenericCommand(c,where);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Fix the client structure with the original stuff */</span></span><br><span class="line">                    c-&gt;argv = orig_argv;</span><br><span class="line">                    c-&gt;argc = orig_argc;</span><br><span class="line">                    c-&gt;cmd = orig_cmd;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are inside a MULTI/EXEC and the list is empty the only thing</span></span><br><span class="line"><span class="comment">     * we can do is treating it as a timeout (even with timeout 0). */</span></span><br><span class="line">    <span class="comment">//没看懂？？？</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</span><br><span class="line">        addReply(c,shared.nullmultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the list is empty or the key does not exists we must block */</span></span><br><span class="line">    <span class="comment">//如果执行到这里，说明命令里的所有列表都是空的，pop执行失败，需要把当前客户端设置为阻塞并且关联上命令里的所有列表</span></span><br><span class="line">    blockForKeys(c, c-&gt;argv + <span class="number">1</span>, c-&gt;argc - <span class="number">2</span>, timeout, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现blpop命令</span></span><br><span class="line"><span class="comment">//BLPOP LIST1 LIST2 .. LISTN TIMEOUT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blpopCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    blockingPopGenericCommand(c,REDIS_HEAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现brpop命令</span></span><br><span class="line"><span class="comment">//BLPOP LIST1 LIST2 .. LISTN TIMEOUT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpopCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    blockingPopGenericCommand(c,REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现brpoplpush命令</span></span><br><span class="line"><span class="comment">//BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT </span></span><br><span class="line"><span class="comment">//rpoplpush里如果列表为空就退出，brpoplpush里如果列表为空就阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpoplpushCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;timeout) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    robj *key = lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//如果要执行pop的列表为空，就调用blockForKeys</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Blocking against an empty list in a multi state</span></span><br><span class="line"><span class="comment">             * returns immediately. */</span></span><br><span class="line">            addReply(c, shared.nullbulk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The list is empty and the client blocks. */</span></span><br><span class="line">            blockForKeys(c, c-&gt;argv + <span class="number">1</span>, <span class="number">1</span>, timeout, c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果要执行pop的列表不为空，就调用rpoplpushCommand</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key-&gt;type != REDIS_LIST) &#123;</span><br><span class="line">            addReply(c, shared.wrongtypeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The list exists and has elements, so</span></span><br><span class="line"><span class="comment">             * the regular rpoplpushCommand is executed. */</span></span><br><span class="line">            redisAssert(listTypeLength(key) &gt; <span class="number">0</span>);</span><br><span class="line">            rpoplpushCommand(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-哈希"><a href="#4-4-哈希" class="headerlink" title="4.4 哈希"></a>4.4 哈希</h2><h3 id="t-hash-c"><a href="#t-hash-c" class="headerlink" title="t_hash.c"></a>t_hash.c</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-单机数据库相关"><a href="#5-单机数据库相关" class="headerlink" title="5 单机数据库相关"></a>5 单机数据库相关</h1><h1 id="6-客户端和服务器端相关"><a href="#6-客户端和服务器端相关" class="headerlink" title="6 客户端和服务器端相关"></a>6 客户端和服务器端相关</h1><h1 id="7-多机数据库相关"><a href="#7-多机数据库相关" class="headerlink" title="7 多机数据库相关"></a>7 多机数据库相关</h1><h1 id="8-测试类文件"><a href="#8-测试类文件" class="headerlink" title="8 测试类文件"></a>8 测试类文件</h1><h3 id="testhelp-h"><a href="#testhelp-h" class="headerlink" title="testhelp.h"></a>testhelp.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a really minimal testing framework for C.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * test_cond("Check if 1 == 1", 1==1)</span></span><br><span class="line"><span class="comment"> * test_cond("Check if 5 &gt; 10", 5 &gt; 10)</span></span><br><span class="line"><span class="comment"> * test_report()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TESTHELP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TESTHELP_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试失败次数</span></span><br><span class="line"><span class="keyword">int</span> __failed_tests = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//测试总次数</span></span><br><span class="line"><span class="keyword">int</span> __test_num = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_cond(descr,_c) do &#123; \</span></span><br><span class="line">    <span class="comment">//测试次数加一，先输出描述信息</span></span><br><span class="line">    __test_num++; <span class="built_in">printf</span>(<span class="string">"%d - %s: "</span>, __test_num, descr); \</span><br><span class="line">    <span class="comment">//执行_c表示的表达式，输出成功或失败提示</span></span><br><span class="line">    <span class="keyword">if</span>(_c) <span class="built_in">printf</span>(<span class="string">"PASSED\n"</span>); <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">"FAILED\n"</span>); __failed_tests++;&#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试报告</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_report() do &#123; \</span></span><br><span class="line">    <span class="comment">//输出测试总次数，成功次数和失败次数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d tests, %d passed, %d failed\n"</span>, __test_num, \</span><br><span class="line">                    __test_num-__failed_tests, __failed_tests); \</span><br><span class="line">    <span class="comment">//如果有失败的样例就报warning</span></span><br><span class="line">    <span class="keyword">if</span> (__failed_tests) &#123; \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"=== WARNING === We have failed tests here...\n"</span>); \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="9-工具类文件"><a href="#9-工具类文件" class="headerlink" title="9 工具类文件"></a>9 工具类文件</h1><h1 id="10-封装类文件"><a href="#10-封装类文件" class="headerlink" title="10 封装类文件"></a>10 封装类文件</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="https://shivakasu.cn/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="redis" scheme="https://shivakasu.cn/tags/redis/"/>
    
      <category term="数据库" scheme="https://shivakasu.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Haskell Programming From First Principles notes (更新中)</title>
    <link href="https://shivakasu.cn/2020/06/14/haskell0/"/>
    <id>https://shivakasu.cn/2020/06/14/haskell0/</id>
    <published>2020-06-13T16:45:20.000Z</published>
    <updated>2020-06-15T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-All-You-Need-is-Lambda"><a href="#1-All-You-Need-is-Lambda" class="headerlink" title="1 All You Need is Lambda"></a>1 All You Need is Lambda</h1><ul><li>A calculus is a method of calculation or reasoning. The <strong>lambda calculus</strong> is one process for formalizing a method. Lambda calculus is your foundation, because Haskell is a lambda calculus.</li><li>The essence of Functional Programming(FP) is that programs are a combination of <strong>expressions</strong>. Expressions include concrete values, variables and functions. In FP, functions are <strong>first-class</strong>: they can be used as values or passed as arguments, or inputs, to yet more functions.</li><li>FP languages are all based on the lambda calculus. Haskell is a pure FP language, while some other FP languages incorporate features that aren’t translatable into lambda expressions. </li><li>The purity of FP languages is also called <strong>referential transparency</strong>(引用透明性). Referential transparency means that the same function, given the same values to evaluate, will always return the same result in pure FP. 和数学的函数一样，一个 x 只对应一个 y ，一个 y 可以对应多个 x .</li><li>Lambda calculus has three basic components: <strong>expressions</strong>, <strong>variables</strong>, and <strong>abstractions</strong>. An expression can be a variable name, an abstraction, or a combination of those things. An abstraction is a function that consist of two parts: the head and the body.The head is a $\lambda$ followed by a variable name(parameter). The body is another expression. So, a simple function might look like this: $\lambda x.x$ (the dot is just a separator)</li><li>Lambda abstraction has no name(like $f$ ). It is an anonymous function, so it cannot be called by name by another function. The name “abstraction” means generalization, because parameters in the head have no concrete type. Once we replace the parameters with values, we making the abstraction concrete.</li><li>Variable names in an abstraction’s head have no semantically meaning, so $\lambda x.x$ and $\lambda d.d$ are totally the same thing. This is called <strong>alpha equivalence</strong> ( $\alpha$-等价，又称重命名等价，是 Lambda 表达式之间的最小二元关系). <script type="math/tex; mode=display">\lambda x.x= _\alpha\lambda d.d</script></li><li><strong>Beta reduction</strong> ( $\beta$-规约，是非 $\alpha$-等价的 Lambda 表达式之间的最小二元关系) is this process of applying a lambda term to an argument, replacing the bound variables with the value of the argument, and eliminating the head. The process of beta reduction stops when there are either no more heads, or lambdas, left to apply or no more arguments to apply functions to.<script type="math/tex; mode=display">(\lambda x.P)Q\vartriangleright _\beta P[Q/x]</script>其实就是赋值，在 body 中用取值 $Q$ 取代参数 $x$，再去掉 head。例如：<script type="math/tex; mode=display">(\lambda x.x+1)2\vartriangleright _\beta 3</script><script type="math/tex; mode=display">(\lambda x.x)(\lambda y.y)\vartriangleright _\beta (\lambda y.y)</script><script type="math/tex; mode=display">(\lambda x.x)(\lambda y.y)z\vartriangleright _\beta (\lambda y.y)z\vartriangleright _\beta z</script></li><li>Sometimes the body expression has variables that are not named in the head. We call those variables <strong>free variables</strong>, like $\lambda x.xy$ . Free variables are irreducible, so:<script type="math/tex; mode=display">(\lambda x.xy)z\vartriangleright _\beta zy</script>alpha equivalence does not apply to free variables, so:<script type="math/tex; mode=display">\lambda x.xy\neq _\alpha\lambda x.xz</script></li><li>Functions that require multiple arguments have nested heads. When you apply it once and eliminate the first (leftmost) head, the next one is applied and so on. This formulation was originally discovered by Moses Schönfinkel in the 1920s but was later rediscovered and named after Haskell Curry and is commonly called <strong>currying</strong> (柯里化，指的是把接受多个参数的函数变换成接受一个单一参数的函数，返回值是接受余下的参数的新函数). 例如：<script type="math/tex; mode=display">(\lambda xy.xy)2\ 3=(\lambda x.(\lambda y.xy))2\ 3\vartriangleright _\beta (\lambda y.2y)3\vartriangleright _\beta 6</script><script type="math/tex; mode=display">(\lambda xy.xy)(\lambda z.z+1)\ 3=(\lambda x.(\lambda y.xy))(\lambda z.z+1)\ 3\vartriangleright _\beta (\lambda y.(\lambda z.z+1)y)3\vartriangleright _\beta (\lambda z.z+1)3\vartriangleright _\beta 4</script><script type="math/tex; mode=display">(\lambda xyz.xy)(\lambda z.z+1)\ 3=(\lambda x.(\lambda y.xy))(\lambda z.z+1)\ 3\vartriangleright _\beta (\lambda y.(\lambda z.z+1)y)3\vartriangleright _\beta (\lambda z.z+1)3\vartriangleright _\beta 4</script></li><li>$\beta$-规约的顺序不是唯一的，可以从左到右，也可以先规约括号里的。例如：<script type="math/tex; mode=display">(\lambda x.(\lambda y.x))((\lambda x.x)(\lambda x.x))\vartriangleright _\beta (\lambda x.(\lambda y.x))(\lambda x.x)\vartriangleright _\beta (\lambda y.(\lambda x.x))</script><script type="math/tex; mode=display">(\lambda x.(\lambda y.x))((\lambda x.x)(\lambda x.x))\vartriangleright _\beta (\lambda y.((\lambda x.x)(\lambda x.x)))\vartriangleright _\beta (\lambda y.(\lambda x.x))</script></li><li><strong>Beta normal form</strong> is when you cannot beta reduce the terms any further.</li><li>A <strong>combinator</strong> is a lambda term with no free variables. “Combinators” means only to serve to combine the arguments they are given.</li><li>Some reducible lambda terms cannot reduce neatly to a beta normal form because they diverge. <strong>Divergence</strong> means that the reduction process never terminates or ends. Divergence(发散) is the opposite of convergence(收敛). For example:<script type="math/tex; mode=display">(\lambda x.xx)(\lambda x.xx)\vartriangleright _\beta (\lambda x.xx)(\lambda x.xx)</script></li><li>Beta reduce exercises<script type="math/tex; mode=display">(\lambda abc.cba)zz(\lambda wv.w)\vartriangleright _\beta (\lambda wv.w)zz\vartriangleright _\beta z</script><script type="math/tex; mode=display">(\lambda x.\lambda y.xyy)(\lambda a.a)b\vartriangleright _\beta (\lambda a.a)bb\vartriangleright _\beta bb</script><script type="math/tex; mode=display">(\lambda y.y)(\lambda x.xx)(\lambda z.zq)\vartriangleright _\beta (\lambda x.xx)(\lambda z.zq)\vartriangleright _\beta (\lambda z.zq)(\lambda z.zq)\vartriangleright _\beta (\lambda z.zq)q\vartriangleright _\beta qq</script><script type="math/tex; mode=display">(\lambda z.z)(\lambda z.zz)(\lambda z.zy)\vartriangleright _\beta (\lambda z.zz)(\lambda z.zy)\vartriangleright _\beta (\lambda z.zy)(\lambda z.zy)\vartriangleright _\beta (\lambda z.zy)y\vartriangleright _\beta yy</script><script type="math/tex; mode=display">(\lambda x.\lambda y.xyy)(\lambda y.y)y\vartriangleright _\beta (\lambda y.y)yy\vartriangleright _\beta yy</script><script type="math/tex; mode=display">(\lambda a.aa)(\lambda b.ba)c\vartriangleright _\beta (\lambda b.ba)(\lambda b.ba)c\vartriangleright _\beta (\lambda b.ba)ac\vartriangleright _\beta aac</script><script type="math/tex; mode=display">(\lambda xyz.xz(yz))(\lambda x.z)(\lambda x.a)\vartriangleright _\beta (\lambda z.(\lambda x.z)z((\lambda x.a)z))\vartriangleright _\beta (\lambda z.(\lambda x.z)za)\vartriangleright _\beta (\lambda z.za)</script></li></ul><h1 id="2-Hello-Haskell"><a href="#2-Hello-Haskell" class="headerlink" title="2 Hello, Haskell"></a>2 Hello, Haskell</h1><ul><li>A expressions is in <strong>normal form</strong> when it has reached an irreducible form. Reducible expressions are also called <strong>redexes</strong>. The process of evaluation or reduction is called “normalizing” or “executing”.</li><li>Functions in Haskell take one argument and return one result. If we pass multiple arguments to a function, each step of <strong>currying</strong> can be considered as calling a new function with one input and one output.</li><li>Function names must start with lowercase letters.</li><li>Haskell uses a nonstrict evaluation (also called “<strong>lazy evaluation</strong>”) strategy which defers evaluation of terms until they’re forced by other terms referring to them.</li><li>Calling functions in Haskell default to prefix syntax, but not all functions are prefix. <strong>Operators</strong>, such as arithmetic operators, are functions which can be used in infix style. All operators are functions, while not all functions are operators. We can use infix operators in prefix fashion by wrapping them in parentheses, so <code>100 + 100</code> is the same as <code>(+) 100 100</code> .</li><li>The <strong>order of declarations</strong> in a source code file doesn’t matter because GHCi loads the entire file at once, so it knows all the values that have been defined. On the other hand, when you enter them one by one into the REPL, the order does matter.</li><li><strong>Indentation</strong> of Haskell code is significant. Use spaces, not tabs, to indent your source code.</li><li><strong>Whitespace</strong> is often the only mark of a function call, unless parentheses are necessary due to conflicting precedence. Trailing whitespace, that is, extraneous whitespace at the end of lines of code, is considered bad style.</li><li>some arithmetic functions：<ul><li>/ : fractional division. <code>3 / 2 == 1.5</code></li><li>div : integral division, round down(向下取整), <code>div 4 3 == 1</code>, <code>div (-4) 3 == -2</code></li><li>quot : integral division, round towards zero(向0取整), <code>quot 4 3 == 1</code>, <code>quot (-4) 3 == -1</code></li><li>mod : 整除模量, <code>mod 5 3 == 2</code>, <code>mod 5 (-3) == -1</code>, <code>mod (-5) 3 == 1</code>, <code>mod (-5) (-3) == -2</code></li><li>rem : 整除余数, <code>rem 5 3 == 2</code>, <code>rem 5 (-3) == 2</code>, <code>rem (-5) 3 == -2</code>, <code>rem (-5) (-3) == -2</code></li><li><code>(quot x y)*y + (rem x y) == x</code></li><li><code>(div x y)*y + (mod x y) == x</code></li><li><code>mod</code> 结果的符号与第二个参数相同, <code>rem</code> 的结果符号与第一个参数相同。</li><li>无论参数的正负，<code>rem</code> 结果的绝对值都与正数整除的余数相同，因此计算的时候可以先不考虑符号。而 <code>mod</code> 的计算过程可以想象成转时钟，第一个参数代表转的方向和刻度数，第二个参数代表表盘的排列方向和正负号，比如 15 表示正向转 15 下，-15 表示反向转 15 下，12 表示表盘顺时针排列为 0~11，-12 表示表盘逆时针排列为 0~-11，那么有 <code>mod 15 12 == 3</code>, <code>mod (-15) 12 == 9</code>, <code>mod 15 (-12) == -9</code>, <code>mod (-15) (-12) == -3</code></li></ul></li><li>Negation numbers in Haskell use a kind of <strong>syntactic sugar</strong>. When syntactic sugar is processed by compiler, the shorter(“sweeter”) form will be transformed to the origin representation. For example, <code>(-1)</code> will be transformed to <code>(negate 1)</code> .</li><li><code>$</code> is a infix operator with the lowest possible precedence. It will allow everything to the right of it to be evaluated first and can be used to delay function application(优先级最低，先算右边). For example, <code>(2^)$(2+)$3*2==(2^)$(2+)$6==(2^)$(2+6)==(2^)$8==2^8==256</code> .</li><li><strong>Sectioning</strong> is special syntax for partial application on infix operators.<ul><li><code>(^2)</code> is left section, the same as <code>\x -&gt; x ^ 2</code></li><li><code>(2^)</code> is right section, the same as <code>\x -&gt; 2 ^ x</code></li><li><code>-</code> operator cannot do a right section, because that would be interpreted as negation instead of subtraction.</li></ul></li></ul><h1 id="3-Strings"><a href="#3-Strings" class="headerlink" title="3 Strings"></a>3 Strings</h1><p>- </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="https://shivakasu.cn/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="编程语言" scheme="https://shivakasu.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>leetcode (更新中)</title>
    <link href="https://shivakasu.cn/2020/06/03/leetcode/"/>
    <id>https://shivakasu.cn/2020/06/03/leetcode/</id>
    <published>2020-06-03T09:30:20.000Z</published>
    <updated>2020-06-15T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        for i in range(len(nums)-1):</span><br><span class="line">            for j in range(i+1,len(nums)):</span><br><span class="line">                if nums[i]+nums[j]&#x3D;&#x3D;target:</span><br><span class="line">                    return [i,j]</span><br></pre></td></tr></table></figure><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2 两数相加"></a>2 两数相加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1, l2):</span><br><span class="line">        a&#x3D;&quot;&quot;</span><br><span class="line">        b&#x3D;&quot;&quot;</span><br><span class="line">        while True:</span><br><span class="line">            a+&#x3D;str(l1.val)</span><br><span class="line">            if l1.next:</span><br><span class="line">                l1&#x3D;l1.next</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        while True:</span><br><span class="line">            b+&#x3D;str(l2.val)</span><br><span class="line">            if l2.next:</span><br><span class="line">                l2&#x3D;l2.next</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        a&#x3D;&#39;&#39;.join(list(reversed(list(a))))</span><br><span class="line">        b&#x3D;&#39;&#39;.join(list(reversed(list(b))))</span><br><span class="line">        c&#x3D;str(int(a)+int(b))</span><br><span class="line">        l&#x3D;ListNode(c[0])</span><br><span class="line">        l3&#x3D;ListNode(0)</span><br><span class="line">        for i in range(1,len(c)):</span><br><span class="line">            l3&#x3D;ListNode(c[i])</span><br><span class="line">            l3.next&#x3D;l</span><br><span class="line">            l&#x3D;l3</span><br><span class="line">        return l</span><br></pre></td></tr></table></figure><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3 无重复字符的最长子串"></a>3 无重复字符的最长子串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        if len(s)&lt;&#x3D;1:</span><br><span class="line">            return len(s)</span><br><span class="line">        max&#x3D;0</span><br><span class="line">        a&#x3D;[s[0]]</span><br><span class="line">        for i in range(1,len(s)):</span><br><span class="line">            if s[i] in a:</span><br><span class="line">                if max&lt;len(a):</span><br><span class="line">                    max&#x3D;len(a)</span><br><span class="line">                b&#x3D;a.index(s[i])</span><br><span class="line">                a&#x3D;a[b+1:]</span><br><span class="line">                a.append(s[i])</span><br><span class="line">            else:</span><br><span class="line">                a.append(s[i])</span><br><span class="line">        if max&lt;len(a):</span><br><span class="line">            max&#x3D;len(a)</span><br><span class="line">        return max</span><br></pre></td></tr></table></figure><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4 寻找两个正序数组的中位数"></a>4 寻找两个正序数组的中位数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findMedianSortedArrays(self, nums1, nums2):</span><br><span class="line">        nums1.extend(nums2)</span><br><span class="line">        nums1.sort()</span><br><span class="line">        a&#x3D;len(nums1)</span><br><span class="line">        if a%2&#x3D;&#x3D;0:</span><br><span class="line">            return (nums1[a&#x2F;&#x2F;2]+nums1[a&#x2F;&#x2F;2-1])&#x2F;2</span><br><span class="line">        else:</span><br><span class="line">            return nums1[a&#x2F;&#x2F;2]</span><br></pre></td></tr></table></figure><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        def check(a,b):</span><br><span class="line">            while a&gt;&#x3D;0 and b&lt;len(s) and s[a]&#x3D;&#x3D;s[b]:</span><br><span class="line">                a-&#x3D;1</span><br><span class="line">                b+&#x3D;1</span><br><span class="line">            return s[a+1:b]</span><br><span class="line">        max&#x3D;&quot;&quot;</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            tmp &#x3D; check(i,i)</span><br><span class="line">            if len(max)&lt;len(tmp):</span><br><span class="line">                max&#x3D;tmp</span><br><span class="line">            tmp &#x3D; check(i,i+1)</span><br><span class="line">            if len(max)&lt;len(tmp):</span><br><span class="line">                max&#x3D;tmp</span><br><span class="line">        return max</span><br></pre></td></tr></table></figure><h3 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6 Z 字形变换"></a>6 Z 字形变换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convert(self, s, numRows):</span><br><span class="line">        a &#x3D; [[] for i in range(numRows)]</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        j&#x3D;0</span><br><span class="line">        index&#x3D;1</span><br><span class="line">        while j&lt;len(s):</span><br><span class="line">            a[i].append(s[j])</span><br><span class="line">            if index&#x3D;&#x3D;1:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                if i&#x3D;&#x3D;numRows:</span><br><span class="line">                    i&#x3D;max(numRows-2,0)</span><br><span class="line">                    index&#x3D;-1</span><br><span class="line">            else:</span><br><span class="line">                i-&#x3D;1</span><br><span class="line">                if i&#x3D;&#x3D;-1:</span><br><span class="line">                    i&#x3D;min(1,numRows-1)</span><br><span class="line">                    index&#x3D;1</span><br><span class="line">            j+&#x3D;1</span><br><span class="line">        r&#x3D;&quot;&quot;</span><br><span class="line">        for i in range(len(a)):</span><br><span class="line">            for j in range(len(a[i])):</span><br><span class="line">                r+&#x3D;a[i][j]</span><br><span class="line">        return r</span><br></pre></td></tr></table></figure><h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7 整数反转"></a>7 整数反转</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        neg &#x3D; -1</span><br><span class="line">        s &#x3D; str(x)</span><br><span class="line">        if s[0]&#x3D;&#x3D;&#39;-&#39;:</span><br><span class="line">            s &#x3D; s[1:]</span><br><span class="line">            neg &#x3D; 1</span><br><span class="line">        a &#x3D; int(s[::-1])*neg*(-1)</span><br><span class="line">        if a&gt;2**31-1 or a&lt;2**31*-1:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            return a</span><br></pre></td></tr></table></figure><h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8 字符串转换整数 (atoi)"></a>8 字符串转换整数 (atoi)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, s):</span><br><span class="line">        s &#x3D; s.lstrip()</span><br><span class="line">        if s&#x3D;&#x3D;&#39;&#39;:</span><br><span class="line">            return 0</span><br><span class="line">        if s[0]&#x3D;&#x3D;&#39;+&#39; and len(s)&gt;1:</span><br><span class="line">            if s[1]&lt;&#39;0&#39; or s[1]&gt;&#39;9&#39;:</span><br><span class="line">                return 0</span><br><span class="line">            else:</span><br><span class="line">                s&#x3D;s[1:]</span><br><span class="line">        if s[0]&#x3D;&#x3D;&#39;-&#39; or (s[0]&gt;&#x3D;&#39;0&#39; and s[0]&lt;&#x3D;&#39;9&#39;):</span><br><span class="line">            i&#x3D;1</span><br><span class="line">            while i&lt;len(s) and s[i]&gt;&#x3D;&#39;0&#39; and s[i]&lt;&#x3D;&#39;9&#39;:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">            s&#x3D;s[:i]</span><br><span class="line">            if s&#x3D;&#x3D;&#39;-&#39;:</span><br><span class="line">                return 0</span><br><span class="line">            s&#x3D;int(s[:i])</span><br><span class="line">            if s&gt;2**31-1:</span><br><span class="line">                return 2**31-1</span><br><span class="line">            if s&lt;2**31*(-1):</span><br><span class="line">                return 2**31*(-1)</span><br><span class="line">            return s</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure><h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9 回文数"></a>9 回文数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x):</span><br><span class="line">        s&#x3D;str(x)</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        j&#x3D;len(s)-1</span><br><span class="line">        while i&lt;&#x3D;j:</span><br><span class="line">            if s[i]!&#x3D;s[j]:</span><br><span class="line">                return False</span><br><span class="line">            i+&#x3D;1</span><br><span class="line">            j-&#x3D;1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10 正则表达式匹配"></a>10 正则表达式匹配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isMatch(self, s: str, p: str) -&gt; bool:</span><br><span class="line">        if (s!&#x3D;&#39;&#39; and p&#x3D;&#x3D;&#39;&#39;) or (p!&#x3D;&#39;&#39; and p[0]&#x3D;&#x3D;&#39;*&#39;):</span><br><span class="line">            return False</span><br><span class="line">        res &#x3D; [(0,0)]</span><br><span class="line">        only &#x3D; []</span><br><span class="line">        while res:</span><br><span class="line">            si,pi&#x3D;res.pop(0)</span><br><span class="line">            if (si,pi) in only:</span><br><span class="line">                continue</span><br><span class="line">            only.append((si,pi))</span><br><span class="line">            if pi&#x3D;&#x3D;len(p):</span><br><span class="line">                if si&#x3D;&#x3D;len(s):</span><br><span class="line">                    return True</span><br><span class="line">                continue</span><br><span class="line">            if si&#x3D;&#x3D;len(s):</span><br><span class="line">                if pi&lt;len(p)-1 and p[pi+1]&#x3D;&#x3D;&#39;*&#39;:</span><br><span class="line">                    res.append((si,pi+2))</span><br><span class="line">                elif p[pi]&#x3D;&#x3D;&#39;*&#39;:</span><br><span class="line">                    res.append((si,pi+1))</span><br><span class="line">                continue</span><br><span class="line">            if p[pi]&#x3D;&#x3D;&#39;.&#39;:</span><br><span class="line">                res.append((si+1,pi+1))</span><br><span class="line">                if pi&lt;len(p)-2 and p[pi+1]&#x3D;&#x3D;&#39;*&#39;:</span><br><span class="line">                    res.append((si,pi+2))</span><br><span class="line">            elif p[pi]&#x3D;&#x3D;&#39;*&#39;:</span><br><span class="line">                if p[pi-1]&#x3D;&#x3D;&#39;*&#39;:</span><br><span class="line">                    continue</span><br><span class="line">                if p[pi-1]&#x3D;&#x3D;&#39;.&#39; or s[si-1]&#x3D;&#x3D;p[pi-1]:</span><br><span class="line">                    if p[pi-1]&#x3D;&#x3D;&#39;.&#39; or s[si-1]&#x3D;&#x3D;s[si]:</span><br><span class="line">                        res.append((si+1,pi))</span><br><span class="line">                        res.append((si+1,pi+1))</span><br><span class="line">                    res.append((si,pi+1))</span><br><span class="line">                res.append((si-1,pi+1))</span><br><span class="line">            else:</span><br><span class="line">                if s[si]&#x3D;&#x3D;p[pi]:</span><br><span class="line">                    res.append((si+1,pi+1))</span><br><span class="line">                if pi&lt;len(p)-2 and p[pi+1]&#x3D;&#x3D;&#39;*&#39;:</span><br><span class="line">                    res.append((si,pi+2))</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 盛最多水的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, h):</span><br><span class="line">        m&#x3D;[]</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        j&#x3D;len(h)-1</span><br><span class="line">        while i&lt;j:</span><br><span class="line">            m.append((j-i)*min(h[i],h[j]))</span><br><span class="line">            if h[i]&lt;h[j]:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                j-&#x3D;1</span><br><span class="line">        return max(m)</span><br></pre></td></tr></table></figure><h3 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12 整数转罗马数字"></a>12 整数转罗马数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intToRoman(self, num: int) -&gt; str:</span><br><span class="line">        res &#x3D; &#39;&#39;</span><br><span class="line">        a&#x3D;[1000,900,500,400,100,90,50,40,10,9,5,4,1]</span><br><span class="line">        b&#x3D;[&#39;M&#39;,&#39;CM&#39;,&#39;D&#39;,&quot;CD&quot;,&#39;C&#39;,&#39;XC&#39;,&#39;L&#39;,&#39;XL&#39;,&#39;X&#39;,&#39;IX&#39;,&#39;V&#39;,&#39;IV&#39;,&#39;I&#39;]</span><br><span class="line">        while num&gt;0:</span><br><span class="line">            for i in range(len(a)):</span><br><span class="line">                if num&gt;&#x3D;a[i]:</span><br><span class="line">                    num-&#x3D;a[i]</span><br><span class="line">                    res+&#x3D;b[i]</span><br><span class="line">                    break</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13 罗马数字转整数"></a>13 罗马数字转整数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s: str) -&gt; int:</span><br><span class="line">        res &#x3D; 0</span><br><span class="line">        a&#x3D;[1000,900,500,400,100,90,50,40,10,9,5,4,1]</span><br><span class="line">        b&#x3D;[&#39;M&#39;,&#39;CM&#39;,&#39;D&#39;,&quot;CD&quot;,&#39;C&#39;,&#39;XC&#39;,&#39;L&#39;,&#39;XL&#39;,&#39;X&#39;,&#39;IX&#39;,&#39;V&#39;,&#39;IV&#39;,&#39;I&#39;]</span><br><span class="line">        while s:</span><br><span class="line">            for i in range(len(a)):</span><br><span class="line">                if s.startswith(b[i]):</span><br><span class="line">                    res+&#x3D;a[i]</span><br><span class="line">                    s&#x3D;s[len(b[i]):]</span><br><span class="line">                    break</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14 最长公共前缀"></a>14 最长公共前缀</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        k &#x3D; &quot;&quot;</span><br><span class="line">        try:</span><br><span class="line">            for i in range(len(strs[0])):</span><br><span class="line">                for j in range(len(strs)-1):</span><br><span class="line">                    if strs[j][i]!&#x3D;strs[j+1][i]:</span><br><span class="line">                        return k</span><br><span class="line">                k &#x3D; k+strs[0][i]</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">        return k</span><br></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15 三数之和"></a>15 三数之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        if len(nums)&#x3D;&#x3D;0 or nums[-1]&lt;0:</span><br><span class="line">            return []</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        for i in range(len(nums)-2):</span><br><span class="line">            if nums[i]&gt;0:</span><br><span class="line">                break</span><br><span class="line">            if i&gt;0 and nums[i]&#x3D;&#x3D;nums[i-1]:</span><br><span class="line">                continue</span><br><span class="line">            m,n&#x3D;i+1,len(nums)-1</span><br><span class="line">            while m&lt;n:</span><br><span class="line">                if nums[n]&lt;0:</span><br><span class="line">                    break</span><br><span class="line">                elif nums[m]+nums[n]+nums[i]&#x3D;&#x3D;0:</span><br><span class="line">                    res.append([nums[i],nums[m],nums[n]])</span><br><span class="line">                    while m&lt;len(nums)-1 and nums[m]&#x3D;&#x3D;nums[m+1]:</span><br><span class="line">                        m+&#x3D;1</span><br><span class="line">                    while n&gt;i and nums[n]&#x3D;&#x3D;nums[n-1]:</span><br><span class="line">                        n-&#x3D;1</span><br><span class="line">                    m+&#x3D;1</span><br><span class="line">                    n-&#x3D;1</span><br><span class="line">                elif nums[m]+nums[n]+nums[i]&gt;0:</span><br><span class="line">                    n-&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    m+&#x3D;1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16 最接近的三数之和"></a>16 最接近的三数之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        nums.sort()</span><br><span class="line">        dis &#x3D; target-nums[0]-nums[1]-nums[2]</span><br><span class="line">        k &#x3D; len(nums)-1</span><br><span class="line">        for i in range(k-1):</span><br><span class="line">            m, n &#x3D; i+1, k</span><br><span class="line">            while m&lt;n:</span><br><span class="line">                s &#x3D; nums[i]+nums[m]+nums[n]</span><br><span class="line">                if s&#x3D;&#x3D;target:</span><br><span class="line">                    return target</span><br><span class="line">                elif s&gt;target:</span><br><span class="line">                    if s-target&lt;abs(dis):</span><br><span class="line">                        dis &#x3D; target-s</span><br><span class="line">                    n-&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    if target-s&lt;abs(dis):</span><br><span class="line">                        dis &#x3D; target-s</span><br><span class="line">                    m+&#x3D;1</span><br><span class="line">        return target-dis</span><br></pre></td></tr></table></figure><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17 电话号码的字母组合"></a>17 电话号码的字母组合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from functools import reduce </span><br><span class="line">class Solution:</span><br><span class="line">    def letterCombinations(self, digits: str) -&gt; List[str]:</span><br><span class="line">        if len(digits)&#x3D;&#x3D;0:</span><br><span class="line">            return []</span><br><span class="line">        d &#x3D; [[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],[&#39;d&#39;,&#39;e&#39;,&#39;f&#39;],[&#39;g&#39;,&#39;h&#39;,&#39;i&#39;],[&#39;j&#39;,&#39;k&#39;,&#39;l&#39;],[&#39;m&#39;,&#39;n&#39;,&#39;o&#39;],</span><br><span class="line">            [&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;],[&#39;t&#39;,&#39;u&#39;,&#39;v&#39;],[&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]]</span><br><span class="line">        r &#x3D; []</span><br><span class="line">        for i in digits:</span><br><span class="line">            r.append(d[int(i)-2])</span><br><span class="line">        def fn(list1,list2):</span><br><span class="line">            return [i+j for i in list1 for j in list2]</span><br><span class="line">        return reduce(fn,r)</span><br></pre></td></tr></table></figure><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18 四数之和"></a>18 四数之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        if len(nums)&#x3D;&#x3D;0 or (target&lt;0 and nums[-1]&lt;target) or (target&gt;&#x3D;0 and nums[0]&gt;target):</span><br><span class="line">            return []</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        k &#x3D; len(nums)-1</span><br><span class="line">        for i in range(k-2):</span><br><span class="line">            if target&gt;&#x3D;0 and nums[i]&gt;target:</span><br><span class="line">                break</span><br><span class="line">            if i&gt;0 and nums[i]&#x3D;&#x3D;nums[i-1]:</span><br><span class="line">                continue</span><br><span class="line">            for j in range(i+1,k-1):</span><br><span class="line">                if target&gt;&#x3D;0 and nums[i]+nums[j]&gt;target:</span><br><span class="line">                    break</span><br><span class="line">                if j&gt;i+1 and nums[j]&#x3D;&#x3D;nums[j-1]:</span><br><span class="line">                    continue</span><br><span class="line">                m, n &#x3D; j+1, k</span><br><span class="line">                while m&lt;n:</span><br><span class="line">                    s &#x3D; nums[i]+nums[j]+nums[m]</span><br><span class="line">                    if target&gt;&#x3D;0 and s&gt;target:</span><br><span class="line">                        break</span><br><span class="line">                    elif s+nums[n]&#x3D;&#x3D;target:</span><br><span class="line">                        res.append([nums[i],nums[j],nums[m],nums[n]])</span><br><span class="line">                        while m&lt;k and nums[m]&#x3D;&#x3D;nums[m+1]:</span><br><span class="line">                            m+&#x3D;1</span><br><span class="line">                        while n&gt;j and nums[n]&#x3D;&#x3D;nums[n-1]:</span><br><span class="line">                            n-&#x3D;1</span><br><span class="line">                        m+&#x3D;1</span><br><span class="line">                        n-&#x3D;1</span><br><span class="line">                    elif s+nums[n]&gt;target:</span><br><span class="line">                        n-&#x3D;1</span><br><span class="line">                    else:</span><br><span class="line">                        m+&#x3D;1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19 删除链表的倒数第N个节点"></a>19 删除链表的倒数第N个节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span><br><span class="line">        a &#x3D; head</span><br><span class="line">        b &#x3D; head</span><br><span class="line">        for i in range(n):</span><br><span class="line">            a &#x3D; a.next</span><br><span class="line">        if not a:</span><br><span class="line">            return head.next</span><br><span class="line">        while a.next:</span><br><span class="line">            a &#x3D; a.next</span><br><span class="line">            b &#x3D; b.next</span><br><span class="line">        b.next &#x3D; b.next.next</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, s: str) -&gt; bool:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for i in s:</span><br><span class="line">            if len(a)&#x3D;&#x3D;0:</span><br><span class="line">                a.append(i)</span><br><span class="line">            elif i&#x3D;&#x3D;&#39;)&#39; and a[-1]&#x3D;&#x3D;&#39;(&#39;:</span><br><span class="line">                a.pop()</span><br><span class="line">            elif i&#x3D;&#x3D;&#39;]&#39; and a[-1]&#x3D;&#x3D;&#39;[&#39;:</span><br><span class="line">                a.pop()</span><br><span class="line">            elif i&#x3D;&#x3D;&#39;&#125;&#39; and a[-1]&#x3D;&#x3D;&#39;&#123;&#39;:</span><br><span class="line">                a.pop()</span><br><span class="line">            else:</span><br><span class="line">                a.append(i)</span><br><span class="line">        return len(a)&#x3D;&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if not l1:</span><br><span class="line">            return l2</span><br><span class="line">        if not l2:</span><br><span class="line">            return l1</span><br><span class="line">        k &#x3D; p &#x3D; ListNode()</span><br><span class="line">        m, n &#x3D; l1, l2</span><br><span class="line">        while m and n:</span><br><span class="line">            if m.val&lt;&#x3D;n.val:</span><br><span class="line">                k.next &#x3D; m</span><br><span class="line">                k &#x3D; k.next</span><br><span class="line">                m &#x3D; m.next</span><br><span class="line">            else:</span><br><span class="line">                k.next &#x3D; n</span><br><span class="line">                k &#x3D; k.next</span><br><span class="line">                n &#x3D; n.next</span><br><span class="line">        if m:</span><br><span class="line">            k.next &#x3D; m</span><br><span class="line">        elif n:</span><br><span class="line">            k.next &#x3D; n</span><br><span class="line">        return p.next</span><br></pre></td></tr></table></figure><h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22 括号生成"></a>22 括号生成</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        def onestep(s,left,right):</span><br><span class="line">            if len(s)&#x3D;&#x3D;n*2:</span><br><span class="line">                if left&#x3D;&#x3D;right:</span><br><span class="line">                    res.append(s)</span><br><span class="line">            elif left&gt;right:</span><br><span class="line">                onestep(s+&#39;(&#39;,left+1,right)</span><br><span class="line">                onestep(s+&#39;)&#39;,left,right+1)</span><br><span class="line">            elif left&#x3D;&#x3D;right:</span><br><span class="line">                onestep(s+&#39;(&#39;,left+1,right)</span><br><span class="line">        onestep(&#39;(&#39;,1,0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26 删除排序数组中的重复项"></a>26 删除排序数组中的重复项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if len(nums)&lt;2:</span><br><span class="line">            return len(nums)</span><br><span class="line">        i &#x3D; 1</span><br><span class="line">        while i&lt;len(nums):</span><br><span class="line">            if nums[i]&#x3D;&#x3D;nums[i-1]:</span><br><span class="line">                del nums[i]</span><br><span class="line">            else:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">        return len(nums)</span><br></pre></td></tr></table></figure><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27 移除元素"></a>27 移除元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElement(self, nums, val):</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        while i&lt;len(nums):</span><br><span class="line">            if nums[i]&#x3D;&#x3D;val:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">            else:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">        return len(nums)</span><br></pre></td></tr></table></figure><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35 搜索插入位置"></a>35 搜索插入位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchInsert(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[i]&gt;&#x3D;target:</span><br><span class="line">                return i</span><br><span class="line">        return len(nums)</span><br></pre></td></tr></table></figure><h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38 外观数列"></a>38 外观数列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countAndSay(self, n: int) -&gt; str:</span><br><span class="line">        a&#x3D;&#39;1 &#39;</span><br><span class="line">        if n&#x3D;&#x3D;1:</span><br><span class="line">            return a[:-1]</span><br><span class="line">        for i in range(n-1):</span><br><span class="line">            b&#x3D;m&#x3D;n&#x3D;&#39;&#39;</span><br><span class="line">            for k in a:</span><br><span class="line">                if m&#x3D;&#x3D;&#39;&#39; and n&#x3D;&#x3D;&#39;&#39;:</span><br><span class="line">                    m&#x3D;k</span><br><span class="line">                    n&#x3D;1</span><br><span class="line">                elif k&#x3D;&#x3D;m:</span><br><span class="line">                    n+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    b&#x3D;b+str(n)+m</span><br><span class="line">                    m&#x3D;k</span><br><span class="line">                    n&#x3D;1</span><br><span class="line">            a&#x3D;b+&#39; &#39;</span><br><span class="line">        return a[:-1]</span><br></pre></td></tr></table></figure><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            if nums[i-1]&gt;0:</span><br><span class="line">                nums[i]+&#x3D;nums[i-1]</span><br><span class="line">        return max(nums)</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54 螺旋矩阵"></a>54 螺旋矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def spiralOrder(self, m):</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        j&#x3D;-1</span><br><span class="line">        t&#x3D;&#39;L&#39;</span><br><span class="line">        a&#x3D;[]</span><br><span class="line">        if m&#x3D;&#x3D;[]:</span><br><span class="line">            return []</span><br><span class="line">        while len(a)!&#x3D;len(m)*len(m[0]):</span><br><span class="line">            if t&#x3D;&#x3D;&#39;L&#39;:</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            elif t&#x3D;&#x3D;&#39;R&#39;:</span><br><span class="line">                j-&#x3D;1</span><br><span class="line">            elif t&#x3D;&#x3D;&#39;U&#39;:</span><br><span class="line">                i-&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">            a.append(m[i][j])</span><br><span class="line">            m[i][j]&#x3D;&#39;$&#39;</span><br><span class="line">            if t&#x3D;&#x3D;&#39;L&#39; and (j&#x3D;&#x3D;len(m[0])-1 or m[i][j+1]&#x3D;&#x3D;&#39;$&#39;):</span><br><span class="line">                t&#x3D;&#39;D&#39;</span><br><span class="line">            elif t&#x3D;&#x3D;&#39;D&#39; and (i&#x3D;&#x3D;len(m)-1 or m[i+1][j]&#x3D;&#x3D;&#39;$&#39;):</span><br><span class="line">                t&#x3D;&#39;R&#39;</span><br><span class="line">            elif t&#x3D;&#x3D;&#39;R&#39; and (j&#x3D;&#x3D;0 or m[i][j-1]&#x3D;&#x3D;&#39;$&#39;):</span><br><span class="line">                t&#x3D;&#39;U&#39;</span><br><span class="line">            elif t&#x3D;&#x3D;&#39;U&#39; and (i&#x3D;&#x3D;0 or m[i-1][j]&#x3D;&#x3D;&#39;$&#39;):</span><br><span class="line">                t&#x3D;&#39;L&#39;</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canJump(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        if len(nums)&lt;2:</span><br><span class="line">            return True</span><br><span class="line">        end &#x3D; len(nums)-1</span><br><span class="line">        for i in range(len(nums)-1,-1,-1):</span><br><span class="line">            if nums[i]&gt;&#x3D;end-i:</span><br><span class="line">                end &#x3D; i</span><br><span class="line">        return end&#x3D;&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58 最后一个单词的长度"></a>58 最后一个单词的长度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLastWord(self, s: str) -&gt; int:</span><br><span class="line">        return len(s.strip().split(&#39; &#39;)[-1])</span><br></pre></td></tr></table></figure><h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62 不同路径"></a>62 不同路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniquePaths(self, m: int, n: int) -&gt; int:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for i in range(m):</span><br><span class="line">            a.append([0]*n)</span><br><span class="line">        for i in range(m):</span><br><span class="line">            a[i][0] &#x3D; 1</span><br><span class="line">        for i in range(n):</span><br><span class="line">            a[0][i] &#x3D; 1</span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                a[i][j] &#x3D; a[i][j-1]+a[i-1][j]</span><br><span class="line">        return a[m-1][n-1]</span><br></pre></td></tr></table></figure><h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63 不同路径 II"></a>63 不同路径 II</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:</span><br><span class="line">        m &#x3D; len(obstacleGrid)</span><br><span class="line">        n &#x3D; len(obstacleGrid[0])</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for i in range(m):</span><br><span class="line">            a.append([0]*n)</span><br><span class="line">        a[0][0] &#x3D; 1 if obstacleGrid[0][0]&#x3D;&#x3D;0 else 0</span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            if obstacleGrid[i][0]&#x3D;&#x3D;1:</span><br><span class="line">                a[i][0] &#x3D; 0</span><br><span class="line">            else:</span><br><span class="line">                a[i][0] &#x3D; a[i-1][0]</span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            if obstacleGrid[0][i]&#x3D;&#x3D;1:</span><br><span class="line">                a[0][i] &#x3D; 0</span><br><span class="line">            else:</span><br><span class="line">                a[0][i] &#x3D; a[0][i-1]</span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                if obstacleGrid[i][j]&#x3D;&#x3D;1:</span><br><span class="line">                    a[i][j] &#x3D; 0</span><br><span class="line">                else:</span><br><span class="line">                    a[i][j] &#x3D; a[i][j-1]+a[i-1][j]</span><br><span class="line">        return a[m-1][n-1]</span><br></pre></td></tr></table></figure><h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66 加一"></a>66 加一</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits: List[int]) -&gt; List[int]:</span><br><span class="line">        for i in range(len(digits)-1,-1,-1):</span><br><span class="line">            if digits[i]&lt;9:</span><br><span class="line">                digits[i]+&#x3D;1</span><br><span class="line">                return digits</span><br><span class="line">            else:</span><br><span class="line">                digits[i]&#x3D;0</span><br><span class="line">                if i&#x3D;&#x3D;0:</span><br><span class="line">                    digits.insert(0,1)</span><br><span class="line">                    return digits</span><br></pre></td></tr></table></figure><h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67 二进制求和"></a>67 二进制求和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a: str, b: str) -&gt; str:</span><br><span class="line">        c &#x3D; 0</span><br><span class="line">        d &#x3D; &quot;&quot;</span><br><span class="line">        if len(a)&gt;len(b):</span><br><span class="line">            while len(b)&lt;len(a):</span><br><span class="line">                b &#x3D; &#39;0&#39;+b</span><br><span class="line">        else:</span><br><span class="line">            while len(b)&gt;len(a):</span><br><span class="line">                a &#x3D; &#39;0&#39;+a</span><br><span class="line">        for i in range(len(a)-1,-1,-1):</span><br><span class="line">            t &#x3D; int(a[i])+int(b[i])+c</span><br><span class="line">            if t&#x3D;&#x3D;0:</span><br><span class="line">                d &#x3D; &quot;0&quot;+d</span><br><span class="line">                c &#x3D; 0</span><br><span class="line">            elif t&#x3D;&#x3D;1:</span><br><span class="line">                d &#x3D; &quot;1&quot;+d</span><br><span class="line">                c &#x3D; 0</span><br><span class="line">            elif t&#x3D;&#x3D;2:</span><br><span class="line">                d &#x3D; &quot;0&quot;+d</span><br><span class="line">                c &#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                d &#x3D; &quot;1&quot;+d</span><br><span class="line">                c &#x3D; 1</span><br><span class="line">        if c&#x3D;&#x3D;1:</span><br><span class="line">            d &#x3D; &quot;1&quot;+d</span><br><span class="line">        return d</span><br></pre></td></tr></table></figure><h3 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69 x 的平方根"></a>69 x 的平方根</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mySqrt(self, x):</span><br><span class="line">        if x&lt;2:</span><br><span class="line">            return x</span><br><span class="line">        start &#x3D; 0</span><br><span class="line">        end &#x3D; x</span><br><span class="line">        middle &#x3D; x&#x2F;&#x2F;2</span><br><span class="line">        while start&lt;end-1:</span><br><span class="line">            if middle**2&gt;x:</span><br><span class="line">                end &#x3D; middle</span><br><span class="line">                middle &#x3D; (start+end)&#x2F;&#x2F;2</span><br><span class="line">            elif middle**2&lt;x:</span><br><span class="line">                start &#x3D; middle</span><br><span class="line">                middle &#x3D; (start+end)&#x2F;&#x2F;2</span><br><span class="line">            else:</span><br><span class="line">                return middle</span><br><span class="line">        return start</span><br></pre></td></tr></table></figure><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def climbStairs(self, n):</span><br><span class="line">        a&#x3D;[0]*(n+1)</span><br><span class="line">        a[0]&#x3D;1</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if i+2&lt;n+1:</span><br><span class="line">                a[i+2]+&#x3D;a[i]</span><br><span class="line">            if i+1&lt;n+1:</span><br><span class="line">                a[i+1]+&#x3D;a[i]</span><br><span class="line">        return a[n]</span><br></pre></td></tr></table></figure><h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73 矩阵置零"></a>73 矩阵置零</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def setZeroes(self, m):</span><br><span class="line">        a&#x3D;len(m)</span><br><span class="line">        b&#x3D;len(m[0])</span><br><span class="line">        for i in range(a):</span><br><span class="line">            for j in range(b):</span><br><span class="line">                if m[i][j]&#x3D;&#x3D;0:</span><br><span class="line">                    for k in range(a):</span><br><span class="line">                        if m[k][j]!&#x3D;0:</span><br><span class="line">                            m[k][j]&#x3D;&#39;$&#39;</span><br><span class="line">                    for k in range(b):</span><br><span class="line">                        if m[i][k]!&#x3D;0:</span><br><span class="line">                            m[i][k]&#x3D;&#39;$&#39;</span><br><span class="line">        for i in range(a):</span><br><span class="line">            for j in range(b):</span><br><span class="line">                if m[i][j]&#x3D;&#x3D;&#39;$&#39;:</span><br><span class="line">                    m[i][j]&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74 搜索二维矩阵"></a>74 搜索二维矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchMatrix(self, m, t):</span><br><span class="line">        if len(m)&#x3D;&#x3D;0 or len(m[0])&#x3D;&#x3D;0:</span><br><span class="line">            return False</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        while i&lt;len(m):</span><br><span class="line">            if m[i][0]&gt;t:</span><br><span class="line">                break</span><br><span class="line">            i+&#x3D;1</span><br><span class="line">        if i&#x3D;&#x3D;0:</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            return (t in m[i-1])</span><br></pre></td></tr></table></figure><h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83 删除排序链表中的重复元素"></a>83 删除排序链表中的重复元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        a &#x3D; head</span><br><span class="line">        t &#x3D; head</span><br><span class="line">        while head and head.next:</span><br><span class="line">            head &#x3D; head.next</span><br><span class="line">            if head.val&#x3D;&#x3D;t.val:</span><br><span class="line">                t.next &#x3D; head.next</span><br><span class="line">            else:</span><br><span class="line">                t &#x3D; t.next</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88 合并两个有序数组"></a>88 合并两个有序数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:</span><br><span class="line">        for i in range(n):</span><br><span class="line">            nums1[m+i]&#x3D;nums2[i]</span><br><span class="line">        nums1[0:m+n]&#x3D;sorted(nums1[0:m+n])</span><br></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94 二叉树的中序遍历"></a>94 二叉树的中序遍历</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        stack &#x3D; []</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        t &#x3D; root</span><br><span class="line">        while stack or t:</span><br><span class="line">            if t:</span><br><span class="line">                stack.append(t)</span><br><span class="line">                t &#x3D; t.left</span><br><span class="line">            else:</span><br><span class="line">                t &#x3D; stack.pop()</span><br><span class="line">                res.append(t.val)</span><br><span class="line">                t &#x3D; t.right</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100 相同的树"></a>100 相同的树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isSameTree(self, p, q):</span><br><span class="line">        a&#x3D;[]</span><br><span class="line">        b&#x3D;[]</span><br><span class="line">        def s(m,r):</span><br><span class="line">            if r:</span><br><span class="line">                m.append(r.val)</span><br><span class="line">                s(m,r.left)</span><br><span class="line">                s(m,r.right)</span><br><span class="line">            else:</span><br><span class="line">                m.append(&#39;$&#39;)</span><br><span class="line">        s(a,p)</span><br><span class="line">        s(b,q)</span><br><span class="line">        if len(a)!&#x3D;len(b):</span><br><span class="line">            return False</span><br><span class="line">        for i in range(len(a)):</span><br><span class="line">            if a[i]!&#x3D;b[i]:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isSymmetric(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        a&#x3D;[]</span><br><span class="line">        b&#x3D;[]</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        node&#x3D;root</span><br><span class="line">        while stack or node:</span><br><span class="line">            while True:</span><br><span class="line">                if not node:</span><br><span class="line">                    a.append(&#39;null&#39;)</span><br><span class="line">                    break</span><br><span class="line">                a.append(node.val)</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node&#x3D;node.left</span><br><span class="line">            node&#x3D;stack.pop()</span><br><span class="line">            node&#x3D;node.right</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        node&#x3D;root</span><br><span class="line">        while stack or node:</span><br><span class="line">            while True:</span><br><span class="line">                if not node:</span><br><span class="line">                    b.append(&#39;null&#39;)</span><br><span class="line">                    break</span><br><span class="line">                b.append(node.val)</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node&#x3D;node.right</span><br><span class="line">            node&#x3D;stack.pop()</span><br><span class="line">            node&#x3D;node.left</span><br><span class="line">        for i in range(len(a)):</span><br><span class="line">            if a[i]!&#x3D;b[i]:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104 二叉树的最大深度"></a>104 二叉树的最大深度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDepth(self, root):</span><br><span class="line">        def se(a,r):</span><br><span class="line">            if r:</span><br><span class="line">                return max(se(a+1,r.left),se(a+1,r.right),1)</span><br><span class="line">            else:</span><br><span class="line">                return a</span><br><span class="line">        return se(0,root)</span><br></pre></td></tr></table></figure><h3 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107 二叉树的层次遍历 II"></a>107 二叉树的层次遍历 II</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        if not root:</span><br><span class="line">            return []</span><br><span class="line">        a&#x3D;[root]</span><br><span class="line">        b&#x3D;[]</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        while a:</span><br><span class="line">            res.append([])</span><br><span class="line">            for i in a:</span><br><span class="line">                res[-1].append(i.val)</span><br><span class="line">                if i.left:</span><br><span class="line">                    b.append(i.left)</span><br><span class="line">                if i.right:</span><br><span class="line">                    b.append(i.right)</span><br><span class="line">            a,b&#x3D;b,[]</span><br><span class="line">        res.reverse()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111 二叉树的最小深度"></a>111 二叉树的最小深度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minDepth(self, root: TreeNode) -&gt; int:</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        t1 &#x3D; [root]</span><br><span class="line">        t2 &#x3D; []</span><br><span class="line">        c &#x3D; 1</span><br><span class="line">        while True:</span><br><span class="line">            for t in t1:</span><br><span class="line">                if t.left:</span><br><span class="line">                    t2.append(t.left)</span><br><span class="line">                if t.right:</span><br><span class="line">                    t2.append(t.right)</span><br><span class="line">                if t.left&#x3D;&#x3D;None and t.right&#x3D;&#x3D;None:</span><br><span class="line">                    return c</span><br><span class="line">            c+&#x3D;1</span><br><span class="line">            t1&#x3D;t2</span><br><span class="line">            t2&#x3D;[]</span><br></pre></td></tr></table></figure><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:</span><br><span class="line">        if not root:</span><br><span class="line">            return False</span><br><span class="line">        a,b&#x3D;[root],[]</span><br><span class="line">        while a:</span><br><span class="line">            for i in a:</span><br><span class="line">                if not i.left and not i.right and i.val&#x3D;&#x3D;sum:</span><br><span class="line">                    return True</span><br><span class="line">            for i in a:</span><br><span class="line">                if i.left:</span><br><span class="line">                    i.left.val&#x3D;i.left.val+i.val</span><br><span class="line">                    b.append(i.left)</span><br><span class="line">                if i.right:</span><br><span class="line">                    i.right.val&#x3D;i.right.val+i.val</span><br><span class="line">                    b.append(i.right)</span><br><span class="line">            a,b&#x3D;b,[]</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118 杨辉三角"></a>118 杨辉三角</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generate(self, numRows: int) -&gt; List[List[int]]:</span><br><span class="line">        a &#x3D; [[1],[1,1]]</span><br><span class="line">        if numRows&lt;3:</span><br><span class="line">            return a[:numRows]</span><br><span class="line">        for i in range(2,numRows):</span><br><span class="line">            a.append([1])</span><br><span class="line">            for j in range(1,len(a[-2])):</span><br><span class="line">                a[-1].append(a[-2][j]+a[-2][j-1])</span><br><span class="line">            a[-1].append(1)</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119 杨辉三角 II"></a>119 杨辉三角 II</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getRow(self, rowIndex: int) -&gt; List[int]:</span><br><span class="line">        a&#x3D;[1]</span><br><span class="line">        b&#x3D;[]</span><br><span class="line">        for i in range(rowIndex):</span><br><span class="line">            b.append(1)</span><br><span class="line">            for k in range(len(a)-1):</span><br><span class="line">                b.append(a[k]+a[k+1])</span><br><span class="line">            b.append(1)</span><br><span class="line">            a,b&#x3D;b,[]</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120 三角形最小路径和"></a>120 三角形最小路径和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minimumTotal(self, t):</span><br><span class="line">        if len(t)&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        if len(t)&#x3D;&#x3D;1:</span><br><span class="line">            return t[0][0]</span><br><span class="line">        for i in range(len(t)-2,-1,-1):</span><br><span class="line">            for j in range(len(t[i])):</span><br><span class="line">                t[i][j]+&#x3D;min(t[i+1][j],t[i+1][j+1])</span><br><span class="line">        return t[0][0]</span><br></pre></td></tr></table></figure><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121 买卖股票的最佳时机"></a>121 买卖股票的最佳时机</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxProfit(self, prices: List[int]) -&gt; int:</span><br><span class="line">        if len(prices)&lt;2:</span><br><span class="line">            return 0</span><br><span class="line">        lmin&#x3D;prices[0]</span><br><span class="line">        best&#x3D;0</span><br><span class="line">        for i in range(1,len(prices)):</span><br><span class="line">            if best&lt;prices[i]-lmin:</span><br><span class="line">                best&#x3D;prices[i]-lmin</span><br><span class="line">            if lmin&gt;prices[i]:</span><br><span class="line">                lmin&#x3D;prices[i]</span><br><span class="line">        return best</span><br></pre></td></tr></table></figure><h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122 买卖股票的最佳时机 II"></a>122 买卖股票的最佳时机 II</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxProfit(self, prices):</span><br><span class="line">        a&#x3D;0</span><br><span class="line">        for i in range(len(prices)-1):</span><br><span class="line">            if prices[i]&lt;prices[i+1]:</span><br><span class="line">                a+&#x3D;prices[i+1]-prices[i]</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136 只出现一次的数字"></a>136 只出现一次的数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums):</span><br><span class="line">        a&#x3D;sum(nums)</span><br><span class="line">        b&#x3D;sum(set(nums))</span><br><span class="line">        return b*2-a</span><br></pre></td></tr></table></figure><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151 翻转字符串里的单词"></a>151 翻转字符串里的单词</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def reverseWords(self, s):</span><br><span class="line">        a&#x3D;s.split(&#39; &#39;)</span><br><span class="line">        a&#x3D;[i for i in a if len(i)&gt;0]</span><br><span class="line">        if len(a)&#x3D;&#x3D;0:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        a.reverse()</span><br><span class="line">        return &#39; &#39;.join(a)</span><br></pre></td></tr></table></figure><h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152 乘积最大子数组"></a>152 乘积最大子数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxProduct(self, nums: List[int]) -&gt; int:</span><br><span class="line">        m &#x3D; nums[0]</span><br><span class="line">        nums[0] &#x3D; [nums[0]]</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            t &#x3D; [nums[i]]</span><br><span class="line">            for j in nums[i-1]:</span><br><span class="line">                t.append(nums[i]*j)</span><br><span class="line">            nums[i] &#x3D; [max(t),min(t)]</span><br><span class="line">            if max(t)&gt;m:</span><br><span class="line">                m &#x3D; max(t)</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165 比较版本号"></a>165 比较版本号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def compareVersion(self, version1: str, version2: str) -&gt; int:</span><br><span class="line">        v1 &#x3D; version1.split(&#39;.&#39;)</span><br><span class="line">        v2 &#x3D; version2.split(&#39;.&#39;)</span><br><span class="line">        k &#x3D; min(len(v1),len(v2))</span><br><span class="line">        for i in range(k):</span><br><span class="line">            if int(v1[i])&gt;int(v2[i]):</span><br><span class="line">                return 1</span><br><span class="line">            elif int(v1[i])&lt;int(v2[i]):</span><br><span class="line">                return -1</span><br><span class="line">        if len(v1)&gt;len(v2):</span><br><span class="line">            for i in v1[k:]:</span><br><span class="line">                if int(i)&gt;0:</span><br><span class="line">                    return 1</span><br><span class="line">        elif len(v1)&lt;len(v2):</span><br><span class="line">            for i in v2[k:]:</span><br><span class="line">                if int(i)&gt;0:</span><br><span class="line">                    return -1</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure><h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167 两数之和 II - 输入有序数组"></a>167 两数之和 II - 输入有序数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        a &#x3D; &#123;&#125;</span><br><span class="line">        for i in range(len(numbers)):</span><br><span class="line">            if target-numbers[i] in a:</span><br><span class="line">                return [a[target-numbers[i]],i+1]</span><br><span class="line">            elif numbers[i] not in a:</span><br><span class="line">                a[numbers[i]] &#x3D; i+1</span><br></pre></td></tr></table></figure><h3 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168 Excel表列名称"></a>168 Excel表列名称</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convertToTitle(self, n: int) -&gt; str:</span><br><span class="line">        s &#x3D; &#39;&#39;</span><br><span class="line">        while n&gt;0:</span><br><span class="line">            m &#x3D; n%26</span><br><span class="line">            if m&#x3D;&#x3D;0:</span><br><span class="line">                n &#x3D; n&#x2F;&#x2F;26-1</span><br><span class="line">                s &#x3D; &#39;Z&#39;+s</span><br><span class="line">            else:</span><br><span class="line">                n &#x3D; n&#x2F;&#x2F;26</span><br><span class="line">                s &#x3D; chr(m+64)+s</span><br><span class="line">        return s</span><br></pre></td></tr></table></figure><h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169 多数元素"></a>169 多数元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def majorityElement(self, nums: List[int]) -&gt; int:</span><br><span class="line">        nums.sort()</span><br><span class="line">        return nums[len(nums)&#x2F;&#x2F;2]</span><br></pre></td></tr></table></figure><h3 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171 Excel表列序号"></a>171 Excel表列序号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def titleToNumber(self, s):</span><br><span class="line">        a&#x3D;list(s)</span><br><span class="line">        m&#x3D;0</span><br><span class="line">        for i in a:</span><br><span class="line">            m&#x3D;m*26+ord(i)-64</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172 阶乘后的零"></a>172 阶乘后的零</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def trailingZeroes(self, n: int) -&gt; int:</span><br><span class="line">        c &#x3D; 0</span><br><span class="line">        k &#x3D; 5</span><br><span class="line">        while k&lt;&#x3D;n:</span><br><span class="line">            c+&#x3D;n&#x2F;&#x2F;k</span><br><span class="line">            k*&#x3D;5</span><br><span class="line">        return c</span><br></pre></td></tr></table></figure><h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189 旋转数组"></a>189 旋转数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, nums, k):</span><br><span class="line">        for i in range(k):</span><br><span class="line">            nums.insert(0,nums[-1])</span><br><span class="line">            nums.pop()</span><br></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198 打家劫舍"></a>198 打家劫舍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rob(self, nums: List[int]) -&gt; int:</span><br><span class="line">        include &#x3D; 0</span><br><span class="line">        exclude &#x3D; 0</span><br><span class="line">        for i in nums:</span><br><span class="line">            include,exclude &#x3D; max(exclude+i,include),include</span><br><span class="line">        return include</span><br></pre></td></tr></table></figure><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200 岛屿数量"></a>200 岛屿数量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numIslands(self, grid: List[List[str]]) -&gt; int:</span><br><span class="line">        c &#x3D; 0</span><br><span class="line">        for i in range(len(grid)):</span><br><span class="line">            for j in range(len(grid[0])):</span><br><span class="line">                if grid[i][j]&#x3D;&#x3D;&quot;1&quot;:</span><br><span class="line">                    grid[i][j] &#x3D; &quot;0&quot;</span><br><span class="line">                    c+&#x3D;1</span><br><span class="line">                    t1 &#x3D; [(i,j)]</span><br><span class="line">                    t2 &#x3D; []</span><br><span class="line">                    while len(t1)&gt;0:</span><br><span class="line">                        for k in t1:</span><br><span class="line">                            if k[0]&gt;0 and grid[k[0]-1][k[1]]&#x3D;&#x3D;&quot;1&quot;:</span><br><span class="line">                                grid[k[0]-1][k[1]] &#x3D; &quot;0&quot;</span><br><span class="line">                                t2.append((k[0]-1,k[1]))</span><br><span class="line">                            if k[1]&gt;0 and grid[k[0]][k[1]-1]&#x3D;&#x3D;&quot;1&quot;:</span><br><span class="line">                                grid[k[0]][k[1]-1] &#x3D; &quot;0&quot;</span><br><span class="line">                                t2.append((k[0],k[1]-1))</span><br><span class="line">                            if k[0]&lt;len(grid)-1 and grid[k[0]+1][k[1]]&#x3D;&#x3D;&quot;1&quot;:</span><br><span class="line">                                grid[k[0]+1][k[1]] &#x3D; &quot;0&quot;</span><br><span class="line">                                t2.append((k[0]+1,k[1]))</span><br><span class="line">                            if k[1]&lt;len(grid[0])-1 and grid[k[0]][k[1]+1]&#x3D;&#x3D;&quot;1&quot;:</span><br><span class="line">                                grid[k[0]][k[1]+1] &#x3D; &quot;0&quot;</span><br><span class="line">                                t2.append((k[0],k[1]+1))</span><br><span class="line">                        t1 &#x3D; t2</span><br><span class="line">                        t2 &#x3D; []</span><br><span class="line">        return c</span><br></pre></td></tr></table></figure><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isHappy(self, n: int) -&gt; bool:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        while n not in a:</span><br><span class="line">            if n&#x3D;&#x3D;1:</span><br><span class="line">                return True</span><br><span class="line">            a.append(n)</span><br><span class="line">            t &#x3D; list(str(n))</span><br><span class="line">            n &#x3D; 0</span><br><span class="line">            for i in t:</span><br><span class="line">                n+&#x3D;int(i)**2</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203 移除链表元素"></a>203 移除链表元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        while head and head.val&#x3D;&#x3D;val:</span><br><span class="line">            head &#x3D; head.next</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        a &#x3D; head</span><br><span class="line">        while head.next:</span><br><span class="line">            if head.next.val&#x3D;&#x3D;val:</span><br><span class="line">                head.next &#x3D; head.next.next</span><br><span class="line">            else:</span><br><span class="line">                head &#x3D; head.next</span><br><span class="line">            if not head:</span><br><span class="line">                break</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205 同构字符串"></a>205 同构字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isIsomorphic(self, s: str, t: str) -&gt; bool:</span><br><span class="line">        d &#x3D; &#123;&#125;</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i] not in d:</span><br><span class="line">                if t[i] in d.values():</span><br><span class="line">                    return False</span><br><span class="line">                d[s[i]] &#x3D; t[i]</span><br><span class="line">            elif t[i]!&#x3D;d[s[i]]:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213 打家劫舍 II"></a>213 打家劫舍 II</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rob(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        if len(nums)&lt;4:</span><br><span class="line">            return max(nums)</span><br><span class="line">        dp1 &#x3D; [0]*(len(nums)-1)</span><br><span class="line">        dp1[0] &#x3D; nums[0]</span><br><span class="line">        dp1[1] &#x3D; max(nums[0],nums[1])</span><br><span class="line">        for i in range(2,len(nums)-1):</span><br><span class="line">            dp1[i] &#x3D; max(dp1[i-1],nums[i]+dp1[i-2])</span><br><span class="line">        dp2 &#x3D; [0]*(len(nums)-1)</span><br><span class="line">        dp2[0] &#x3D; nums[1]</span><br><span class="line">        dp2[1] &#x3D; max(nums[1],nums[2])</span><br><span class="line">        for i in range(3,len(nums)):</span><br><span class="line">            dp2[i-1] &#x3D; max(dp2[i-2],nums[i]+dp2[i-3])</span><br><span class="line">        return max(dp1[-1],dp2[-1])</span><br></pre></td></tr></table></figure><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217 存在重复元素"></a>217 存在重复元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def containsDuplicate(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        return len(nums)!&#x3D;len(set(nums))</span><br></pre></td></tr></table></figure><h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225 用队列实现栈"></a>225 用队列实现栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyStack:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Initialize your data structure here.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.a &#x3D; []</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def push(self, x: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Push element x onto stack.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        b&#x3D;[]</span><br><span class="line">        while len(self.a)&gt;0:</span><br><span class="line">            b.insert(0,self.a.pop())</span><br><span class="line">        self.a.insert(0,x)</span><br><span class="line">        while len(b)&gt;0:</span><br><span class="line">            self.a.insert(0,b.pop())</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def pop(self) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Removes the element on top of the stack and returns that element.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.a.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def top(self) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Get the top element.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.a[-1]</span><br><span class="line"></span><br><span class="line">    def empty(self) -&gt; bool:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns whether the stack is empty.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return len(self.a)&#x3D;&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227 基本计算器 II"></a>227 基本计算器 II</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def calculate(self, s: str) -&gt; int:</span><br><span class="line">        op &#x3D; []</span><br><span class="line">        num &#x3D; []</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        s &#x3D; s.replace(&#39; &#39;,&#39;&#39;)</span><br><span class="line">        while i&lt;len(s):</span><br><span class="line">            if s[i]&gt;&#x3D;&#39;0&#39; and s[i]&lt;&#x3D;&#39;9&#39;:</span><br><span class="line">                j&#x3D;i</span><br><span class="line">                while j&lt;len(s) and s[j]&gt;&#x3D;&#39;0&#39; and s[j]&lt;&#x3D;&#39;9&#39;:</span><br><span class="line">                    j+&#x3D;1</span><br><span class="line">                num.append(int(s[i:j]))</span><br><span class="line">                i &#x3D; j-1</span><br><span class="line">            elif s[i]&#x3D;&#x3D;&#39;-&#39; or s[i]&#x3D;&#x3D;&#39;+&#39;:</span><br><span class="line">                op.append(s[i])</span><br><span class="line">            elif s[i]&#x3D;&#x3D;&#39;*&#39;:</span><br><span class="line">                j &#x3D; i+1</span><br><span class="line">                while j&lt;len(s) and s[j]&gt;&#x3D;&#39;0&#39; and s[j]&lt;&#x3D;&#39;9&#39;:</span><br><span class="line">                    j+&#x3D;1</span><br><span class="line">                num.append(num.pop()*int(s[i+1:j]))</span><br><span class="line">                i &#x3D; j-1</span><br><span class="line">            elif s[i]&#x3D;&#x3D;&#39;&#x2F;&#39;:</span><br><span class="line">                j &#x3D; i+1</span><br><span class="line">                while j&lt;len(s) and s[j]&gt;&#x3D;&#39;0&#39; and s[j]&lt;&#x3D;&#39;9&#39;:</span><br><span class="line">                    j+&#x3D;1</span><br><span class="line">                num.append(num.pop()&#x2F;&#x2F;int(s[i+1:j]))</span><br><span class="line">                i &#x3D; j-1</span><br><span class="line">            i+&#x3D;1</span><br><span class="line">        while len(op)&gt;0:</span><br><span class="line">            if op.pop(0)&#x3D;&#x3D;&#39;-&#39;:</span><br><span class="line">                num.insert(0,num.pop(0)-num.pop(0))</span><br><span class="line">            else:</span><br><span class="line">                num.insert(0,num.pop(0)+num.pop(0))</span><br><span class="line">        return num[0]</span><br></pre></td></tr></table></figure><h3 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228 汇总区间"></a>228 汇总区间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def summaryRanges(self, nums: List[int]) -&gt; List[str]:</span><br><span class="line">        if len(nums)&#x3D;&#x3D;0:</span><br><span class="line">            return nums</span><br><span class="line">        a &#x3D; [str(nums[0])]</span><br><span class="line">        last &#x3D; nums[0]</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            if nums[i]&gt;nums[i-1]+1:</span><br><span class="line">                if last!&#x3D;nums[i-1]:</span><br><span class="line">                    a[-1] &#x3D; a[-1]+&quot;-&gt;&quot;+str(nums[i-1])</span><br><span class="line">                last &#x3D; nums[i]</span><br><span class="line">                a.append(str(nums[i]))</span><br><span class="line">        if last&lt;nums[-1]:</span><br><span class="line">            a[-1] &#x3D; a[-1]+&quot;-&gt;&quot;+str(nums[-1])</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238 除自身以外数组的乘积"></a>238 除自身以外数组的乘积</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        res &#x3D; [nums[0]]</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            res.append(res[-1]*nums[i])</span><br><span class="line">        tmp &#x3D; 1</span><br><span class="line">        for i in range(len(nums)-1,0,-1):</span><br><span class="line">            res[i] &#x3D; res[i-1]*tmp</span><br><span class="line">            tmp*&#x3D;nums[i]</span><br><span class="line">        res[0] &#x3D; tmp</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242 有效的字母异位词"></a>242 有效的字母异位词</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isAnagram(self, s: str, t: str) -&gt; bool:</span><br><span class="line">        return sorted(list(s))&#x3D;&#x3D;sorted(list(t))</span><br></pre></td></tr></table></figure><h3 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258 各位相加"></a>258 各位相加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addDigits(self, num: int) -&gt; int:</span><br><span class="line">        if num&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        return (num-1)%9+1</span><br></pre></td></tr></table></figure><h3 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263 丑数"></a>263 丑数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isUgly(self, num: int) -&gt; bool:</span><br><span class="line">        while num&gt;0:</span><br><span class="line">            if num%2&#x3D;&#x3D;0:</span><br><span class="line">                num&#x2F;&#x3D;2</span><br><span class="line">            elif num%3&#x3D;&#x3D;0:</span><br><span class="line">                num&#x2F;&#x3D;3</span><br><span class="line">            elif num%5&#x3D;&#x3D;0:</span><br><span class="line">                num&#x2F;&#x3D;5</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return num&#x3D;&#x3D;1</span><br></pre></td></tr></table></figure><h3 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268 缺失数字"></a>268 缺失数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def missingNumber(self, nums):</span><br><span class="line">        n&#x3D;len(nums)</span><br><span class="line">        return (n*n+n)&#x2F;&#x2F;2-sum(nums)</span><br></pre></td></tr></table></figure><h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278 第一个错误的版本"></a>278 第一个错误的版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstBadVersion(self, n):</span><br><span class="line">        start &#x3D; 1</span><br><span class="line">        end &#x3D; n</span><br><span class="line">        if isBadVersion(start):</span><br><span class="line">            return 1</span><br><span class="line">        middle &#x3D; (start+end)&#x2F;&#x2F;2</span><br><span class="line">        while start&lt;end-1:</span><br><span class="line">            if isBadVersion(middle):</span><br><span class="line">                end &#x3D; middle</span><br><span class="line">            else:</span><br><span class="line">                start &#x3D; middle</span><br><span class="line">            middle &#x3D; (start+end)&#x2F;&#x2F;2</span><br><span class="line">        if isBadVersion(start):</span><br><span class="line">            return start</span><br><span class="line">        return end</span><br></pre></td></tr></table></figure><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283 移动零"></a>283 移动零</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def moveZeroes(self, nums: List[int]) -&gt; None:</span><br><span class="line">        i &#x3D; len(nums)-1</span><br><span class="line">        while i&gt;&#x3D;0:</span><br><span class="line">            if nums[i]&#x3D;&#x3D;0:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">                nums.append(0)</span><br><span class="line">            i-&#x3D;1</span><br></pre></td></tr></table></figure><h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290 单词规律"></a>290 单词规律</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def wordPattern(self, p, s):</span><br><span class="line">        a&#x3D;list(p)</span><br><span class="line">        b&#x3D;s.split(&#39; &#39;)</span><br><span class="line">        if len(a)!&#x3D;len(b):</span><br><span class="line">            return False</span><br><span class="line">        d&#x3D;&#123;&#125;</span><br><span class="line">        f&#x3D;&#123;&#125;</span><br><span class="line">        for i in range(len(a)):</span><br><span class="line">            d[a[i]]&#x3D;b[i]</span><br><span class="line">            f[b[i]]&#x3D;a[i]</span><br><span class="line">        c&#x3D;[d[i] for i in a]</span><br><span class="line">        w&#x3D;[f[i] for i in b]</span><br><span class="line">        if &#39; &#39;.join(c)!&#x3D;s or &#39;&#39;.join(w)!&#x3D;p:</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292 Nim 游戏"></a>292 Nim 游戏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canWinNim(self, n):</span><br><span class="line">        if n%4&#x3D;&#x3D;0:</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299 猜数字游戏"></a>299 猜数字游戏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getHint(self, secret: str, guess: str) -&gt; str:</span><br><span class="line">        a &#x3D; 0</span><br><span class="line">        b &#x3D; 0</span><br><span class="line">        d1 &#x3D; &#123;&#125;</span><br><span class="line">        d2 &#x3D; &#123;&#125;</span><br><span class="line">        for i in range(len(secret)):</span><br><span class="line">            if secret[i] not in d1:</span><br><span class="line">                d1[secret[i]] &#x3D; [i]</span><br><span class="line">            else:</span><br><span class="line">                d1[secret[i]].append(i)</span><br><span class="line">            if guess[i] not in d2:</span><br><span class="line">                d2[guess[i]] &#x3D; [i]</span><br><span class="line">            else:</span><br><span class="line">                d2[guess[i]].append(i)</span><br><span class="line">        x &#x3D; set(d1.keys()) &amp; set(d2.keys())</span><br><span class="line">        for i in list(x):</span><br><span class="line">            a+&#x3D;len(set(d1[i])&amp;set(d2[i]))</span><br><span class="line">            if len(d1[i])&lt;len(d2[i]):</span><br><span class="line">                b+&#x3D;len(set(d1[i])-set(d2[i]))</span><br><span class="line">            else:</span><br><span class="line">                b+&#x3D;len(set(d2[i])-set(d1[i]))</span><br><span class="line">        return str(a)+&quot;A&quot;+str(b)+&quot;B&quot;</span><br></pre></td></tr></table></figure><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303 区域和检索 - 数组不可变"></a>303 区域和检索 - 数组不可变</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NumArray:</span><br><span class="line"></span><br><span class="line">    def __init__(self, nums: List[int]):</span><br><span class="line">        self.n &#x3D; nums</span><br><span class="line"></span><br><span class="line">    def sumRange(self, i: int, j: int) -&gt; int:</span><br><span class="line">        return sum(self.n[i:j+1])</span><br></pre></td></tr></table></figure><h3 id="307-区域和检索-数组可修改"><a href="#307-区域和检索-数组可修改" class="headerlink" title="307 区域和检索 - 数组可修改"></a>307 区域和检索 - 数组可修改</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NumArray:</span><br><span class="line"></span><br><span class="line">    def __init__(self, nums: List[int]):</span><br><span class="line">        self.n &#x3D; nums</span><br><span class="line"></span><br><span class="line">    def update(self, i: int, val: int) -&gt; None:</span><br><span class="line">        self.n[i] &#x3D; val</span><br><span class="line"></span><br><span class="line">    def sumRange(self, i: int, j: int) -&gt; int:</span><br><span class="line">        return sum(self.n[i:j+1])</span><br></pre></td></tr></table></figure><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344 反转字符串"></a>344 反转字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        j &#x3D; len(s)-1</span><br><span class="line">        while i&lt;j:</span><br><span class="line">            s[i],s[j] &#x3D; s[j],s[i]</span><br><span class="line">            i+&#x3D;1</span><br><span class="line">            j-&#x3D;1</span><br></pre></td></tr></table></figure><h3 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345 反转字符串中的元音字母"></a>345 反转字符串中的元音字母</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseVowels(self, s: str) -&gt; str:</span><br><span class="line">        a &#x3D; [&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;,&quot;A&quot;,&quot;E&quot;,&quot;I&quot;,&quot;O&quot;,&quot;U&quot;]</span><br><span class="line">        s &#x3D; list(s)</span><br><span class="line">        i,j &#x3D; 0,len(s)-1</span><br><span class="line">        while i&lt;j:</span><br><span class="line">            while i&lt;len(s) and s[i] not in a:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">            while j&gt;0 and s[j] not in a:</span><br><span class="line">                j-&#x3D;1</span><br><span class="line">            if i&lt;j:</span><br><span class="line">                s[i],s[j] &#x3D; s[j],s[i]</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                j-&#x3D;1</span><br><span class="line">        return &#39;&#39;.join(s)</span><br></pre></td></tr></table></figure><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349 两个数组的交集"></a>349 两个数组的交集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:</span><br><span class="line">        return list(set(nums1) &amp; set(nums2))</span><br></pre></td></tr></table></figure><h3 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367 有效的完全平方数"></a>367 有效的完全平方数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPerfectSquare(self, num: int) -&gt; bool:</span><br><span class="line">        if num&#x3D;&#x3D;1:</span><br><span class="line">            return True</span><br><span class="line">        left &#x3D; 2</span><br><span class="line">        right &#x3D; num&#x2F;&#x2F;2</span><br><span class="line">        while left&lt;&#x3D;right:</span><br><span class="line">            mid &#x3D; (left+right)&#x2F;&#x2F;2</span><br><span class="line">            s &#x3D; mid*mid</span><br><span class="line">            if mid&#x3D;&#x3D;left or mid&#x3D;&#x3D;right:</span><br><span class="line">                return s&#x3D;&#x3D;num</span><br><span class="line">            if s&#x3D;&#x3D;num:</span><br><span class="line">                return True</span><br><span class="line">            elif s&gt;num:</span><br><span class="line">                right &#x3D; mid</span><br><span class="line">            else:</span><br><span class="line">                left &#x3D; mid</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371 两整数之和"></a>371 两整数之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getSum(self, a: int, b: int) -&gt; int:</span><br><span class="line">        return sum((a,b))</span><br></pre></td></tr></table></figure><h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376 摆动序列"></a>376 摆动序列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def wiggleMaxLength(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if len(nums)&lt;2:</span><br><span class="line">            return len(nums)</span><br><span class="line">        flag &#x3D; [0,0]</span><br><span class="line">        wmax &#x3D; 1</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            if nums[i]&gt;nums[i-1]:</span><br><span class="line">                flag.append(1)</span><br><span class="line">                if flag[-1]!&#x3D;flag[-2]:</span><br><span class="line">                    wmax+&#x3D;1</span><br><span class="line">            elif nums[i]&lt;nums[i-1]:</span><br><span class="line">                flag.append(-1)</span><br><span class="line">                if flag[-1]!&#x3D;flag[-2]:</span><br><span class="line">                    wmax+&#x3D;1</span><br><span class="line">        return wmax</span><br></pre></td></tr></table></figure><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383 赎金信"></a>383 赎金信</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:</span><br><span class="line">        if not ransomNote:</span><br><span class="line">            return True</span><br><span class="line">        a &#x3D; list(ransomNote)</span><br><span class="line">        b &#x3D; list(magazine)</span><br><span class="line">        for i in a:</span><br><span class="line">            if i not in b:</span><br><span class="line">                return False</span><br><span class="line">            b.pop(b.index(i))</span><br><span class="line">        return bool(a)</span><br></pre></td></tr></table></figure><h3 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389 找不同"></a>389 找不同</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findTheDifference(self, s: str, t: str) -&gt; str:</span><br><span class="line">        s &#x3D; sorted(s)</span><br><span class="line">        t &#x3D; sorted(t)</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i]!&#x3D;t[i]:</span><br><span class="line">                return t[i]</span><br><span class="line">        return t[-1]</span><br></pre></td></tr></table></figure><h3 id="391-完美矩形"><a href="#391-完美矩形" class="headerlink" title="391 完美矩形"></a>391 完美矩形</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isRectangleCover(self, rectangles):</span><br><span class="line">        m&#x3D;set()</span><br><span class="line">        size&#x3D;0</span><br><span class="line">        for a,b,c,d in rectangles:</span><br><span class="line">            size+&#x3D;(d-b)*(c-a)</span><br><span class="line">            for r in [(a,b),(a,d),(c,d),(c,b)]:</span><br><span class="line">                if r not in m:</span><br><span class="line">                    m.add(r)</span><br><span class="line">                else:</span><br><span class="line">                    m.remove(r)</span><br><span class="line">        if len(m)!&#x3D;4:</span><br><span class="line">            return False</span><br><span class="line">        m&#x3D;list(m)</span><br><span class="line">        xs&#x3D;min(m[0][0],m[1][0],m[2][0],m[3][0])</span><br><span class="line">        xm&#x3D;max(m[0][0],m[1][0],m[2][0],m[3][0])</span><br><span class="line">        ys&#x3D;min(m[0][1],m[1][1],m[2][1],m[3][1])</span><br><span class="line">        ym&#x3D;max(m[0][1],m[1][1],m[2][1],m[3][1])</span><br><span class="line">        if size!&#x3D;(xm-xs)*(ym-ys):</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412 Fizz Buzz"></a>412 Fizz Buzz</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def fizzBuzz(self, n: int) -&gt; List[str]:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for i in range(1,n+1):</span><br><span class="line">            if i%15&#x3D;&#x3D;0:</span><br><span class="line">                a.append(&quot;FizzBuzz&quot;)</span><br><span class="line">            elif i%5&#x3D;&#x3D;0:</span><br><span class="line">                a.append(&quot;Buzz&quot;)</span><br><span class="line">            elif i%3&#x3D;&#x3D;0:</span><br><span class="line">                a.append(&quot;Fizz&quot;)</span><br><span class="line">            else:</span><br><span class="line">                a.append(str(i))</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415 字符串相加"></a>415 字符串相加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addStrings(self, num1: str, num2: str) -&gt; str:</span><br><span class="line">        if len(num1)&gt;len(num2):</span><br><span class="line">            num2 &#x3D; &quot;0&quot;*(len(num1)-len(num2))+num2</span><br><span class="line">        else:</span><br><span class="line">            num1 &#x3D; &quot;0&quot;*(len(num2)-len(num1))+num1</span><br><span class="line">        a &#x3D; &quot;&quot;</span><br><span class="line">        c &#x3D; 0</span><br><span class="line">        for i in range(len(num1)-1,-1,-1):</span><br><span class="line">            t &#x3D; int(num1[i])+int(num2[i])</span><br><span class="line">            if c:</span><br><span class="line">                t+&#x3D;1</span><br><span class="line">                c &#x3D; 0</span><br><span class="line">            if t&gt;9:</span><br><span class="line">                c &#x3D; 1</span><br><span class="line">                a &#x3D; str(t-10)+a</span><br><span class="line">            else:</span><br><span class="line">                a &#x3D; str(t)+a</span><br><span class="line">        if c:</span><br><span class="line">            a &#x3D; &quot;1&quot;+a</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429 N叉树的层序遍历"></a>429 N叉树的层序遍历</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:</span><br><span class="line">        if not root:</span><br><span class="line">            return []</span><br><span class="line">        s &#x3D; [root]</span><br><span class="line">        last &#x3D; 0</span><br><span class="line">        p &#x3D; n &#x3D; 0</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while s:</span><br><span class="line">            res.append([])</span><br><span class="line">            while p&lt;&#x3D;last:</span><br><span class="line">                k &#x3D; s.pop(0)</span><br><span class="line">                res[-1].append(k.val)</span><br><span class="line">                p+&#x3D;1</span><br><span class="line">                for j in k.children:</span><br><span class="line">                    s.append(j)</span><br><span class="line">                    n+&#x3D;1</span><br><span class="line">            last &#x3D; n</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434 字符串中的单词数"></a>434 字符串中的单词数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countSegments(self, s: str) -&gt; int:</span><br><span class="line">        return len([i for i in s.split(&quot; &quot;) if len(i)&gt;0])</span><br></pre></td></tr></table></figure><h3 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="441 排列硬币"></a>441 排列硬币</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def arrangeCoins(self, n: int) -&gt; int:</span><br><span class="line">        L &#x3D; 0</span><br><span class="line">        R &#x3D; 99999999</span><br><span class="line">        while L&lt;&#x3D;R:</span><br><span class="line">            M &#x3D; (L+R)&#x2F;&#x2F;2</span><br><span class="line">            if L&#x3D;&#x3D;R-1:</span><br><span class="line">                break</span><br><span class="line">            if (M*M+M)&#x2F;&#x2F;2&gt;n:</span><br><span class="line">                R &#x3D; M</span><br><span class="line">            else:</span><br><span class="line">                L &#x3D; M</span><br><span class="line">        if (L*L+L)&#x2F;&#x2F;2&lt;&#x3D;n:</span><br><span class="line">            return L</span><br><span class="line">        return R</span><br></pre></td></tr></table></figure><h3 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442 数组中重复的数据"></a>442 数组中重复的数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findDuplicates(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            while nums[i]!&#x3D;i+1 and nums[i]&gt;0:</span><br><span class="line">                if nums[nums[i]-1]&#x3D;&#x3D;nums[i]:</span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    nums[i] &#x3D; 0</span><br><span class="line">                else:</span><br><span class="line">                    t &#x3D; nums[i]</span><br><span class="line">                    nums[i] &#x3D; nums[t-1]</span><br><span class="line">                    nums[t-1] &#x3D; t</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452 用最少数量的箭引爆气球"></a>452 用最少数量的箭引爆气球</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:</span><br><span class="line">        if len(points)&lt;2:</span><br><span class="line">            return len(points)</span><br><span class="line">        p &#x3D; sorted(points,key&#x3D;lambda x:x[1])</span><br><span class="line">        last &#x3D; -1</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        for i in p:</span><br><span class="line">            if i[0]&gt;last:</span><br><span class="line">                last &#x3D; i[1]</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure><h3 id="453-最小移动次数使数组元素相等"><a href="#453-最小移动次数使数组元素相等" class="headerlink" title="453 最小移动次数使数组元素相等"></a>453 最小移动次数使数组元素相等</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minMoves(self, nums: List[int]) -&gt; int:</span><br><span class="line">        return sum(nums)-min(nums)*len(nums)</span><br></pre></td></tr></table></figure><h3 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455 分发饼干"></a>455 分发饼干</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findContentChildren(self, g: List[int], s: List[int]) -&gt; int:</span><br><span class="line">        g &#x3D; sorted(g)</span><br><span class="line">        s &#x3D; sorted(s)</span><br><span class="line">        i,j,k &#x3D; 0,0,0 </span><br><span class="line">        while i&lt;len(s) and j&lt;len(g):</span><br><span class="line">            if s[i]&gt;&#x3D;g[j]:</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">                k+&#x3D;1</span><br><span class="line">            i+&#x3D;1</span><br><span class="line">        return k</span><br></pre></td></tr></table></figure><h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494 目标和"></a>494 目标和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findTargetSumWays(self, nums: List[int], S: int) -&gt; int:</span><br><span class="line">        d1 &#x3D; &#123;&#125;</span><br><span class="line">        d2 &#x3D; &#123;&#125;</span><br><span class="line">        if nums[0]&#x3D;&#x3D;0:</span><br><span class="line">            d1[0] &#x3D; 2</span><br><span class="line">        else:</span><br><span class="line">            d1[nums[0]] &#x3D; 1</span><br><span class="line">            d1[-nums[0]] &#x3D; 1</span><br><span class="line">        for i in nums[1:]:</span><br><span class="line">            k &#x3D; list(d1.keys())</span><br><span class="line">            for j in k:</span><br><span class="line">                if j+i in d2:</span><br><span class="line">                    d2[j+i]+&#x3D;d1[j]</span><br><span class="line">                else:</span><br><span class="line">                    d2[j+i] &#x3D; d1[j]</span><br><span class="line">                if j-i in d2:</span><br><span class="line">                    d2[j-i]+&#x3D;d1[j]</span><br><span class="line">                else:</span><br><span class="line">                    d2[j-i] &#x3D; d1[j]</span><br><span class="line">            d1 &#x3D; d2</span><br><span class="line">            d2 &#x3D; &#123;&#125;</span><br><span class="line">        if S in d1:</span><br><span class="line">            return d1[S]</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure><h3 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495 提莫攻击"></a>495 提莫攻击</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findPoisonedDuration(self, timeSeries, duration):</span><br><span class="line">        m&#x3D;0</span><br><span class="line">        end&#x3D;-1</span><br><span class="line">        for t in timeSeries:</span><br><span class="line">            if t&gt;&#x3D;end:</span><br><span class="line">                m+&#x3D;duration</span><br><span class="line">                end &#x3D; t+duration</span><br><span class="line">            elif t+duration&lt;&#x3D;end:</span><br><span class="line">                continue</span><br><span class="line">            else:</span><br><span class="line">                m+&#x3D;duration-end+t</span><br><span class="line">                end &#x3D; t+duration</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500 键盘行"></a>500 键盘行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findWords(self, words: List[str]) -&gt; List[str]:</span><br><span class="line">        a &#x3D; [[&#39;q&#39;,&#39;w&#39;,&#39;e&#39;,&#39;r&#39;,&#39;t&#39;,&#39;y&#39;,&#39;u&#39;,&#39;i&#39;,&#39;o&#39;,&#39;p&#39;],</span><br><span class="line">            [&#39;a&#39;,&#39;s&#39;,&#39;d&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;],</span><br><span class="line">            [&#39;z&#39;,&#39;x&#39;,&#39;c&#39;,&#39;v&#39;,&#39;b&#39;,&#39;n&#39;,&#39;m&#39;]]</span><br><span class="line">        r &#x3D; []</span><br><span class="line">        for w in words:</span><br><span class="line">            s &#x3D; set(w.lower())</span><br><span class="line">            for i in a:</span><br><span class="line">                if s.issubset(i):</span><br><span class="line">                    r.append(w)</span><br><span class="line">                    break</span><br><span class="line">        return r</span><br></pre></td></tr></table></figure><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509 斐波那契数"></a>509 斐波那契数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def fib(self, N: int) -&gt; int:</span><br><span class="line">        if N&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        a&#x3D;b&#x3D;1</span><br><span class="line">        for i in range(N-2):</span><br><span class="line">            a,b &#x3D; b,a+b</span><br><span class="line">        return b</span><br></pre></td></tr></table></figure><h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515 在每个树行中找最大值"></a>515 在每个树行中找最大值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largestValues(self, root):</span><br><span class="line">        m&#x3D;[]</span><br><span class="line">        mm&#x3D;[]</span><br><span class="line">        tmp1&#x3D;[]</span><br><span class="line">        if root:</span><br><span class="line">            tmp1.append(root)</span><br><span class="line">        tmp2&#x3D;[]</span><br><span class="line">        while len(tmp1)&gt;0:</span><br><span class="line">            for r in tmp1:</span><br><span class="line">                mm.append(r.val)</span><br><span class="line">                if r.left:</span><br><span class="line">                    tmp2.append(r.left)</span><br><span class="line">                if r.right:</span><br><span class="line">                    tmp2.append(r.right)</span><br><span class="line">            m.append(max(mm))</span><br><span class="line">            mm&#x3D;[]</span><br><span class="line">            tmp1&#x3D;tmp2</span><br><span class="line">            tmp2&#x3D;[]</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530 二叉搜索树的最小绝对差"></a>530 二叉搜索树的最小绝对差</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getMinimumDifference(self, root: TreeNode) -&gt; int:</span><br><span class="line">        a &#x3D; [root]</span><br><span class="line">        b &#x3D; []</span><br><span class="line">        while a:</span><br><span class="line">            k &#x3D; a.pop()</span><br><span class="line">            if not k:</span><br><span class="line">                continue</span><br><span class="line">            b.append(k.val)</span><br><span class="line">            a.append(k.left)</span><br><span class="line">            a.append(k.right)</span><br><span class="line">        b.sort()</span><br><span class="line">        m &#x3D; -1</span><br><span class="line">        for i in range(1,len(b)):</span><br><span class="line">            if b[i]-b[i-1]&lt;m or m&lt;0:</span><br><span class="line">                m &#x3D; b[i]-b[i-1]</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="540 有序数组中的单一元素"></a>540 有序数组中的单一元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNonDuplicate(self, n):</span><br><span class="line">        if len(n)&#x3D;&#x3D;1:</span><br><span class="line">            return n[0]</span><br><span class="line">        a&#x3D;len(n)&#x2F;&#x2F;2</span><br><span class="line">        if n[a]&#x3D;&#x3D;n[a+1]:</span><br><span class="line">            if a%2&#x3D;&#x3D;1:</span><br><span class="line">                return self.singleNonDuplicate(n[:a])</span><br><span class="line">            else:</span><br><span class="line">                return self.singleNonDuplicate(n[a+2:])</span><br><span class="line">        elif n[a]&#x3D;&#x3D;n[a-1]:</span><br><span class="line">            if a%2&#x3D;&#x3D;0:</span><br><span class="line">                return self.singleNonDuplicate(n[:a-1])</span><br><span class="line">            else:</span><br><span class="line">                return self.singleNonDuplicate(n[a+1:])</span><br><span class="line">        else:</span><br><span class="line">            return n[a]</span><br></pre></td></tr></table></figure><h3 id="554-砖墙"><a href="#554-砖墙" class="headerlink" title="554 砖墙"></a>554 砖墙</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def leastBricks(self, wall: List[List[int]]) -&gt; int:</span><br><span class="line">        d &#x3D; &#123;&#125;</span><br><span class="line">        for w in wall:</span><br><span class="line">            c &#x3D; 0</span><br><span class="line">            for i in range(len(w)-1):</span><br><span class="line">                c+&#x3D;w[i]</span><br><span class="line">                if c in d:</span><br><span class="line">                    d[c]+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    d[c] &#x3D; 1</span><br><span class="line">        if not d:</span><br><span class="line">            return len(wall)</span><br><span class="line">        m &#x3D; max(d.values())</span><br><span class="line">        return len(wall)-m</span><br></pre></td></tr></table></figure><h3 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="559 N叉树的最大深度"></a>559 N叉树的最大深度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDepth(self, root: &#39;Node&#39;) -&gt; int:</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        a &#x3D; [root]</span><br><span class="line">        b &#x3D; []</span><br><span class="line">        d &#x3D; 1</span><br><span class="line">        while a:</span><br><span class="line">            for i in a:</span><br><span class="line">                if i and i.children:</span><br><span class="line">                    b.extend(i.children)</span><br><span class="line">            if b:</span><br><span class="line">                d+&#x3D;1</span><br><span class="line">                a,b &#x3D; b,[]</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return d</span><br></pre></td></tr></table></figure><h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583 两个字符串的删除操作"></a>583 两个字符串的删除操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        dp &#x3D; [[0 for i in range(len(word1)+1)] for j in range(len(word2)+1)]</span><br><span class="line">        for i in range(len(word1)):</span><br><span class="line">            for j in range(len(word2)):</span><br><span class="line">                if word1[i]&#x3D;&#x3D;word2[j]:</span><br><span class="line">                    dp[j+1][i+1] &#x3D; dp[j][i]+1</span><br><span class="line">                else:</span><br><span class="line">                    dp[j+1][i+1] &#x3D; max(dp[j][i+1],dp[j+1][i])</span><br><span class="line">        return len(word1)+len(word2)-2*dp[len(word2)][len(word1)]</span><br></pre></td></tr></table></figure><h3 id="593-有效的正方形"><a href="#593-有效的正方形" class="headerlink" title="593 有效的正方形"></a>593 有效的正方形</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -&gt; bool:</span><br><span class="line">        d &#x3D; [(p1[0]-p2[0])**2+(p1[1]-p2[1])**2,</span><br><span class="line">            (p1[0]-p3[0])**2+(p1[1]-p3[1])**2,</span><br><span class="line">            (p1[0]-p4[0])**2+(p1[1]-p4[1])**2,</span><br><span class="line">            (p2[0]-p3[0])**2+(p2[1]-p3[1])**2,</span><br><span class="line">            (p2[0]-p4[0])**2+(p2[1]-p4[1])**2,</span><br><span class="line">            (p3[0]-p4[0])**2+(p3[1]-p4[1])**2]</span><br><span class="line">        print(d)</span><br><span class="line">        if len(set(d))!&#x3D;2 or (d.count(d[0])!&#x3D;2 and d.count(d[0])!&#x3D;4):</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633 平方数之和"></a>633 平方数之和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def judgeSquareSum(self, c: int) -&gt; bool:</span><br><span class="line">        L &#x3D; 0</span><br><span class="line">        R &#x3D; int(math.sqrt(c))</span><br><span class="line">        while L&lt;&#x3D;R:</span><br><span class="line">            m &#x3D; L**2+R**2</span><br><span class="line">            if m&#x3D;&#x3D;c:</span><br><span class="line">                return True</span><br><span class="line">            elif m&lt;c:</span><br><span class="line">                L+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                R-&#x3D;1</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641 设计循环双端队列"></a>641 设计循环双端队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyCircularDeque:</span><br><span class="line"></span><br><span class="line">    def __init__(self, k: int):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Initialize your data structure here. Set the size of the deque to be k.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.nums &#x3D; []</span><br><span class="line">        self.limit &#x3D; k</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def insertFront(self, value: int) -&gt; bool:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Adds an item at the front of Deque. Return true if the operation is successful.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(self.nums)&#x3D;&#x3D;self.limit:</span><br><span class="line">            return False</span><br><span class="line">        self.nums.insert(0,value)</span><br><span class="line">        return True</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def insertLast(self, value: int) -&gt; bool:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Adds an item at the rear of Deque. Return true if the operation is successful.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(self.nums)&#x3D;&#x3D;self.limit:</span><br><span class="line">            return False</span><br><span class="line">        self.nums.append(value)</span><br><span class="line">        return True</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def deleteFront(self) -&gt; bool:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Deletes an item from the front of Deque. Return true if the operation is successful.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(self.nums)&#x3D;&#x3D;0:</span><br><span class="line">            return False</span><br><span class="line">        del self.nums[0]</span><br><span class="line">        return True</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def deleteLast(self) -&gt; bool:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Deletes an item from the rear of Deque. Return true if the operation is successful.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(self.nums)&#x3D;&#x3D;0:</span><br><span class="line">            return False</span><br><span class="line">        del self.nums[-1]</span><br><span class="line">        return True</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def getFront(self) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Get the front item from the deque.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(self.nums)&#x3D;&#x3D;0:</span><br><span class="line">            return -1</span><br><span class="line">        return self.nums[0]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def getRear(self) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Get the last item from the deque.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(self.nums)&#x3D;&#x3D;0:</span><br><span class="line">            return -1</span><br><span class="line">        return self.nums[-1]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def isEmpty(self) -&gt; bool:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Checks whether the circular deque is empty or not.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(self.nums)&#x3D;&#x3D;0:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def isFull(self) -&gt; bool:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Checks whether the circular deque is full or not.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(self.nums)&#x3D;&#x3D;self.limit:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="657-机器人能否返回原点"><a href="#657-机器人能否返回原点" class="headerlink" title="657 机器人能否返回原点"></a>657 机器人能否返回原点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def judgeCircle(self, moves):</span><br><span class="line">        x&#x3D;0</span><br><span class="line">        y&#x3D;0</span><br><span class="line">        for i in moves:</span><br><span class="line">            if i&#x3D;&#x3D;&#39;L&#39;:</span><br><span class="line">                x+&#x3D;1</span><br><span class="line">            elif i&#x3D;&#x3D;&#39;R&#39;:</span><br><span class="line">                x-&#x3D;1</span><br><span class="line">            elif i&#x3D;&#x3D;&#39;U&#39;:</span><br><span class="line">                y+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                y-&#x3D;1</span><br><span class="line">        if x&#x3D;&#x3D;0 and y&#x3D;&#x3D;0:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="670 最大交换"></a>670 最大交换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maximumSwap(self, num: int) -&gt; int:</span><br><span class="line">        if num&lt;10:</span><br><span class="line">            return num</span><br><span class="line">        s &#x3D; list(str(num))</span><br><span class="line">        m &#x3D; []</span><br><span class="line">        k &#x3D; s[-1]</span><br><span class="line">        for i in range(len(s)-1,0,-1):</span><br><span class="line">            k &#x3D; max(k,s[i])</span><br><span class="line">            m.insert(0,k)</span><br><span class="line">        for i in range(len(s)-1):</span><br><span class="line">            if s[i]&lt;m[i]:</span><br><span class="line">                for j in range(len(s)-1,i,-1):</span><br><span class="line">                    if s[j]&#x3D;&#x3D;m[i]:</span><br><span class="line">                        break</span><br><span class="line">                s[i], s[j] &#x3D; s[j], s[i]</span><br><span class="line">                break</span><br><span class="line">        return int(&#39;&#39;.join(s))</span><br></pre></td></tr></table></figure><h3 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678 有效的括号字符串"></a>678 有效的括号字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def checkValidString(self, s: str) -&gt; bool:</span><br><span class="line">        a &#x3D; set()</span><br><span class="line">        b &#x3D; set()</span><br><span class="line">        a.add(0)</span><br><span class="line">        for i in s:</span><br><span class="line">            if i&#x3D;&#x3D;&#39;(&#39;:</span><br><span class="line">                for j in a:</span><br><span class="line">                    b.add(j+1)</span><br><span class="line">            elif i&#x3D;&#x3D;&#39;)&#39;:</span><br><span class="line">                for j in a:</span><br><span class="line">                    if j&gt;0:</span><br><span class="line">                        b.add(j-1)</span><br><span class="line">            else:</span><br><span class="line">                for j in a:</span><br><span class="line">                    b.add(j)</span><br><span class="line">                    b.add(j+1)</span><br><span class="line">                    if j&gt;0:</span><br><span class="line">                        b.add(j-1)</span><br><span class="line">            a &#x3D; b</span><br><span class="line">            b &#x3D; set()</span><br><span class="line">        return (0 in a)</span><br></pre></td></tr></table></figure><h3 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680 验证回文字符串 Ⅱ"></a>680 验证回文字符串 Ⅱ</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def validPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        i,j &#x3D; 0,len(s)-1</span><br><span class="line">        c &#x3D; True</span><br><span class="line">        f &#x3D; False</span><br><span class="line">        while i&lt;j:</span><br><span class="line">            if s[i]!&#x3D;s[j]:</span><br><span class="line">                if c:</span><br><span class="line">                    c &#x3D; False</span><br><span class="line">                    i+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    f &#x3D; True</span><br><span class="line">                    break</span><br><span class="line">            else:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                j-&#x3D;1</span><br><span class="line">        if f:</span><br><span class="line">            i,j &#x3D; 0,len(s)-1</span><br><span class="line">            while i&lt;j:</span><br><span class="line">                if s[i]!&#x3D;s[j]:</span><br><span class="line">                    if not c:</span><br><span class="line">                        c &#x3D; True</span><br><span class="line">                        j-&#x3D;1</span><br><span class="line">                    else:</span><br><span class="line">                        return False</span><br><span class="line">                else:</span><br><span class="line">                    i+&#x3D;1</span><br><span class="line">                    j-&#x3D;1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695 岛屿的最大面积"></a>695 岛屿的最大面积</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        m &#x3D; 0</span><br><span class="line">        for i in range(len(grid)):</span><br><span class="line">            for j in range(len(grid[0])):</span><br><span class="line">                if grid[i][j]&#x3D;&#x3D;1:</span><br><span class="line">                    s &#x3D; [(i,j)]</span><br><span class="line">                    area &#x3D; 0</span><br><span class="line">                    while s:</span><br><span class="line">                        p,q &#x3D; s.pop()</span><br><span class="line">                        if grid[p][q]&#x3D;&#x3D;0:</span><br><span class="line">                            continue</span><br><span class="line">                        area+&#x3D;1</span><br><span class="line">                        grid[p][q] &#x3D; 0</span><br><span class="line">                        if p&gt;0 and grid[p-1][q]&#x3D;&#x3D;1:</span><br><span class="line">                            s.append((p-1,q))</span><br><span class="line">                        if p&lt;len(grid)-1 and grid[p+1][q]&#x3D;&#x3D;1:</span><br><span class="line">                            s.append((p+1,q))</span><br><span class="line">                        if q&gt;0 and grid[p][q-1]&#x3D;&#x3D;1:</span><br><span class="line">                            s.append((p,q-1))</span><br><span class="line">                        if q&lt;len(grid[0])-1 and grid[p][q+1]&#x3D;&#x3D;1:</span><br><span class="line">                            s.append((p,q+1))</span><br><span class="line">                    m &#x3D; max(m,area)</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704 二分查找"></a>704 二分查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def search(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        start &#x3D; 0</span><br><span class="line">        end &#x3D; len(nums)-1</span><br><span class="line">        middle &#x3D; (start+end)&#x2F;&#x2F;2</span><br><span class="line">        while start&lt;end-1:</span><br><span class="line">            if nums[middle]&#x3D;&#x3D;target:</span><br><span class="line">                return middle</span><br><span class="line">            elif nums[middle]&gt;target:</span><br><span class="line">                end &#x3D; middle</span><br><span class="line">                middle &#x3D; (start+end)&#x2F;&#x2F;2</span><br><span class="line">            else:</span><br><span class="line">                start &#x3D; middle</span><br><span class="line">                middle &#x3D; (start+end)&#x2F;&#x2F;2</span><br><span class="line">        if nums[start]&#x3D;&#x3D;target:</span><br><span class="line">            return start</span><br><span class="line">        elif nums[end]&#x3D;&#x3D;target:</span><br><span class="line">            return end</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure><h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739 每日温度"></a>739 每日温度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def dailyTemperatures(self, t):</span><br><span class="line">        a&#x3D;[33333]*101</span><br><span class="line">        m&#x3D;[]</span><br><span class="line">        for i in range(len(t)-1,-1,-1):</span><br><span class="line">            if i&lt;a[t[i]]:</span><br><span class="line">                a[t[i]]&#x3D;i</span><br><span class="line">            if t[i]&#x3D;&#x3D;100:</span><br><span class="line">                m.append(0)</span><br><span class="line">            else:</span><br><span class="line">                k&#x3D;min(a[t[i]+1:])</span><br><span class="line">                if k&#x3D;&#x3D;33333:</span><br><span class="line">                    m.append(0)</span><br><span class="line">                else:</span><br><span class="line">                    m.append(k-i)</span><br><span class="line">        m.reverse()</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="744-寻找比目标字母大的最小字母"><a href="#744-寻找比目标字母大的最小字母" class="headerlink" title="744 寻找比目标字母大的最小字母"></a>744 寻找比目标字母大的最小字母</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def nextGreatestLetter(self, letters, target):</span><br><span class="line">        a &#x3D; list(set(letters))</span><br><span class="line">        a.sort()</span><br><span class="line">        for i in a:</span><br><span class="line">            if i&gt;target:</span><br><span class="line">                return i</span><br><span class="line">        return a[0]</span><br></pre></td></tr></table></figure><h3 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766 托普利茨矩阵"></a>766 托普利茨矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isToeplitzMatrix(self, m):</span><br><span class="line">        for i in range(len(m[0])):</span><br><span class="line">            s&#x3D;m[0][i]</span><br><span class="line">            p&#x3D;0</span><br><span class="line">            q&#x3D;i</span><br><span class="line">            while p&lt;len(m) and q&lt;len(m[0]):</span><br><span class="line">                if m[p][q]!&#x3D;s:</span><br><span class="line">                    return False</span><br><span class="line">                p+&#x3D;1</span><br><span class="line">                q+&#x3D;1</span><br><span class="line">        for i in range(len(m)):</span><br><span class="line">            s&#x3D;m[i][0]</span><br><span class="line">            p&#x3D;i</span><br><span class="line">            q&#x3D;0</span><br><span class="line">            while p&lt;len(m) and q&lt;len(m[0]):</span><br><span class="line">                if m[p][q]!&#x3D;s:</span><br><span class="line">                    return False</span><br><span class="line">                p+&#x3D;1</span><br><span class="line">                q+&#x3D;1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="781-森林中的兔子"><a href="#781-森林中的兔子" class="headerlink" title="781 森林中的兔子"></a>781 森林中的兔子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numRabbits(self, answers: List[int]) -&gt; int:</span><br><span class="line">        a &#x3D; &#123;&#125;</span><br><span class="line">        for i in answers:</span><br><span class="line">            if i+1 in a:</span><br><span class="line">                a[i+1]+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                a[i+1] &#x3D; 1</span><br><span class="line">        res &#x3D; 0</span><br><span class="line">        for i in a:</span><br><span class="line">            if a[i]&lt;&#x3D;i:</span><br><span class="line">                res+&#x3D;i</span><br><span class="line">            else:</span><br><span class="line">                res+&#x3D;a[i]&#x2F;&#x2F;i*i</span><br><span class="line">                if a[i]%i&gt;0:</span><br><span class="line">                    res+&#x3D;i</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="783-二叉搜索树节点最小距离"><a href="#783-二叉搜索树节点最小距离" class="headerlink" title="783 二叉搜索树节点最小距离"></a>783 二叉搜索树节点最小距离</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minDiffInBST(self, root: TreeNode) -&gt; int:</span><br><span class="line">        a &#x3D; [root]</span><br><span class="line">        b &#x3D; []</span><br><span class="line">        while a:</span><br><span class="line">            k &#x3D; a.pop()</span><br><span class="line">            if not k:</span><br><span class="line">                continue</span><br><span class="line">            b.append(k.val)</span><br><span class="line">            a.append(k.left)</span><br><span class="line">            a.append(k.right)</span><br><span class="line">        b.sort()</span><br><span class="line">        m &#x3D; -1</span><br><span class="line">        for i in range(1,len(b)):</span><br><span class="line">            if b[i]-b[i-1]&lt;m or m&lt;0:</span><br><span class="line">                m &#x3D; b[i]-b[i-1]</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="794-有效的井字游戏"><a href="#794-有效的井字游戏" class="headerlink" title="794 有效的井字游戏"></a>794 有效的井字游戏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def validTicTacToe(self, board: List[str]) -&gt; bool:</span><br><span class="line">        cx &#x3D; co &#x3D; 0</span><br><span class="line">        xwin &#x3D; owin &#x3D; False</span><br><span class="line">        for i in range(3):</span><br><span class="line">            for j in board[i]:</span><br><span class="line">                if j&#x3D;&#x3D;&#39;X&#39;:</span><br><span class="line">                    cx+&#x3D;1</span><br><span class="line">                elif j&#x3D;&#x3D;&#39;O&#39;:</span><br><span class="line">                    co+&#x3D;1</span><br><span class="line">        if co&gt;cx or cx&gt;co+1:</span><br><span class="line">            return False</span><br><span class="line">        for i in range(3):</span><br><span class="line">            if board[i][0]&#x3D;&#x3D;board[i][1]&#x3D;&#x3D;board[i][2]:</span><br><span class="line">                if board[i][0]&#x3D;&#x3D;&#39;X&#39;:</span><br><span class="line">                    xwin &#x3D; True</span><br><span class="line">                elif board[i][0]&#x3D;&#x3D;&#39;O&#39;:</span><br><span class="line">                    owin &#x3D; True</span><br><span class="line">            if board[0][i]&#x3D;&#x3D;board[1][i]&#x3D;&#x3D;board[2][i]:</span><br><span class="line">                if board[0][i]&#x3D;&#x3D;&#39;X&#39;:</span><br><span class="line">                    xwin &#x3D; True</span><br><span class="line">                elif board[0][i]&#x3D;&#x3D;&#39;O&#39;:</span><br><span class="line">                    owin &#x3D; True</span><br><span class="line">        if board[0][0]&#x3D;&#x3D;board[1][1]&#x3D;&#x3D;board[2][2]:</span><br><span class="line">                if board[0][0]&#x3D;&#x3D;&#39;X&#39;:</span><br><span class="line">                    xwin &#x3D; True</span><br><span class="line">                elif board[0][0]&#x3D;&#x3D;&#39;O&#39;:</span><br><span class="line">                    owin &#x3D; True</span><br><span class="line">        if board[0][2]&#x3D;&#x3D;board[1][1]&#x3D;&#x3D;board[2][0]:</span><br><span class="line">                if board[1][1]&#x3D;&#x3D;&#39;X&#39;:</span><br><span class="line">                    xwin &#x3D; True</span><br><span class="line">                elif board[1][1]&#x3D;&#x3D;&#39;O&#39;:</span><br><span class="line">                    owin &#x3D; True</span><br><span class="line">        if xwin and owin:</span><br><span class="line">            return False</span><br><span class="line">        if (xwin and cx&#x3D;&#x3D;co+1) or (owin and cx&#x3D;&#x3D;co):</span><br><span class="line">            return True</span><br><span class="line">        if not xwin and not owin:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="804-唯一摩尔斯密码词"><a href="#804-唯一摩尔斯密码词" class="headerlink" title="804 唯一摩尔斯密码词"></a>804 唯一摩尔斯密码词</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniqueMorseRepresentations(self, words):</span><br><span class="line">        a&#x3D;[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br><span class="line">        m&#x3D;[]</span><br><span class="line">        for i in words:</span><br><span class="line">            k&#x3D;list(i)</span><br><span class="line">            p&#x3D;&quot;&quot;</span><br><span class="line">            for j in k:</span><br><span class="line">                p+&#x3D;a[ord(j)-97]</span><br><span class="line">            m.append(p)</span><br><span class="line">        return len(set(m))</span><br></pre></td></tr></table></figure><h3 id="807-保持城市天际线"><a href="#807-保持城市天际线" class="headerlink" title="807 保持城市天际线"></a>807 保持城市天际线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        m &#x3D; [0]*len(grid)</span><br><span class="line">        n &#x3D; [0]*len(grid[0])</span><br><span class="line">        res &#x3D; 0</span><br><span class="line">        for i in range(len(grid)):</span><br><span class="line">            for j in range(len(grid[0])):</span><br><span class="line">                if grid[i][j]&gt;m[i]:</span><br><span class="line">                    m[i] &#x3D; grid[i][j]</span><br><span class="line">                if grid[i][j]&gt;n[j]:</span><br><span class="line">                    n[j] &#x3D; grid[i][j]</span><br><span class="line">        for i in range(len(grid)):</span><br><span class="line">            for j in range(len(grid[0])):</span><br><span class="line">                res+&#x3D;min(m[i],n[j])-grid[i][j]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="817-链表组件"><a href="#817-链表组件" class="headerlink" title="817 链表组件"></a>817 链表组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numComponents(self, head, G):</span><br><span class="line">        a&#x3D;[0]*10000</span><br><span class="line">        for i in G:</span><br><span class="line">            a[i]&#x3D;1</span><br><span class="line">        flag&#x3D;0</span><br><span class="line">        count&#x3D;0</span><br><span class="line">        while head:</span><br><span class="line">            if a[head.val]&#x3D;&#x3D;1 and flag&#x3D;&#x3D;0:</span><br><span class="line">                flag&#x3D;1</span><br><span class="line">            elif a[head.val]&#x3D;&#x3D;0 and flag&#x3D;&#x3D;1:</span><br><span class="line">                flag&#x3D;0</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        if flag&#x3D;&#x3D;1:</span><br><span class="line">            count+&#x3D;1</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure><h3 id="830-较大分组的位置"><a href="#830-较大分组的位置" class="headerlink" title="830 较大分组的位置"></a>830 较大分组的位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largeGroupPositions(self, S: str) -&gt; List[List[int]]:</span><br><span class="line">        if len(S)&lt;3:</span><br><span class="line">            return []</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        n &#x3D; S[0]</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        for i in range(len(S)):</span><br><span class="line">            if S[i]!&#x3D;n:</span><br><span class="line">                if count&gt;&#x3D;3:</span><br><span class="line">                    res.append([i-count,i-1])</span><br><span class="line">                n &#x3D; S[i]</span><br><span class="line">                count &#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">        if count&gt;&#x3D;3:</span><br><span class="line">            res.append([len(S)-count,len(S)-1])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832 翻转图像"></a>832 翻转图像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def flipAndInvertImage(self, A):</span><br><span class="line">        a&#x3D;[]</span><br><span class="line">        for k in A:</span><br><span class="line">            k.reverse()</span><br><span class="line">            a.append([0 if i&#x3D;&#x3D;1 else 1 for i in k])</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844 比较含退格的字符串"></a>844 比较含退格的字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def backspaceCompare(self, S: str, T: str) -&gt; bool:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        b &#x3D; []</span><br><span class="line">        for i in S:</span><br><span class="line">            if i&#x3D;&#x3D;&#39;#&#39;:</span><br><span class="line">                if len(a)&gt;0:</span><br><span class="line">                    a.pop()</span><br><span class="line">            else:</span><br><span class="line">                a.append(i)</span><br><span class="line">        for i in T:</span><br><span class="line">            if i&#x3D;&#x3D;&#39;#&#39;:</span><br><span class="line">                if len(b)&gt;0:</span><br><span class="line">                    b.pop()</span><br><span class="line">            else:</span><br><span class="line">                b.append(i)</span><br><span class="line">        return a&#x3D;&#x3D;b</span><br></pre></td></tr></table></figure><h3 id="852-山脉数组的峰顶索引"><a href="#852-山脉数组的峰顶索引" class="headerlink" title="852 山脉数组的峰顶索引"></a>852 山脉数组的峰顶索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def peakIndexInMountainArray(self, A: List[int]) -&gt; int:</span><br><span class="line">        for i in range(1,len(A)):</span><br><span class="line">            if A[i]&lt;A[i-1]:</span><br><span class="line">                return i-1</span><br></pre></td></tr></table></figure><h3 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856 括号的分数"></a>856 括号的分数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def scoreOfParentheses(self, S: str) -&gt; int:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for i in S:</span><br><span class="line">            if i&#x3D;&#x3D;&#39;(&#39;:</span><br><span class="line">                a.append(i)</span><br><span class="line">            elif i&#x3D;&#x3D;&#39;)&#39;:</span><br><span class="line">                if a[-1]&#x3D;&#x3D;&#39;(&#39;:</span><br><span class="line">                    a.pop()</span><br><span class="line">                    a.append(1)</span><br><span class="line">                    while len(a)&gt;1 and type(a[-1])&#x3D;&#x3D;type(a[-2])&#x3D;&#x3D;int:</span><br><span class="line">                        a[-2] +&#x3D; a[-1]</span><br><span class="line">                        a.pop()</span><br><span class="line">                else:</span><br><span class="line">                    t &#x3D; a[-1]</span><br><span class="line">                    a.pop()</span><br><span class="line">                    a.pop()</span><br><span class="line">                    a.append(2*t)</span><br><span class="line">                    while len(a)&gt;1 and type(a[-1])&#x3D;&#x3D;type(a[-2])&#x3D;&#x3D;int:</span><br><span class="line">                        a[-2] +&#x3D; a[-1]</span><br><span class="line">                        a.pop()</span><br><span class="line">        return a[0]</span><br></pre></td></tr></table></figure><h3 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lemonadeChange(self, bills: List[int]) -&gt; bool:</span><br><span class="line">        d&#x3D;&#123;5:0,10:0&#125;</span><br><span class="line">        for i in bills:</span><br><span class="line">            if i&#x3D;&#x3D;5:</span><br><span class="line">                d[5]+&#x3D;1</span><br><span class="line">            elif i&#x3D;&#x3D;10:</span><br><span class="line">                if d[5]&#x3D;&#x3D;0:</span><br><span class="line">                    return False</span><br><span class="line">                d[10]+&#x3D;1</span><br><span class="line">                d[5]-&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                if d[5]&#x3D;&#x3D;0:</span><br><span class="line">                    return False</span><br><span class="line">                if d[10]&#x3D;&#x3D;0:</span><br><span class="line">                    if d[5]&lt;3:</span><br><span class="line">                        return False</span><br><span class="line">                    else:</span><br><span class="line">                        d[5]-&#x3D;3</span><br><span class="line">                else:</span><br><span class="line">                    d[10]-&#x3D;1</span><br><span class="line">                    d[5]-&#x3D;1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867 转置矩阵"></a>867 转置矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def transpose(self, A: List[List[int]]) -&gt; List[List[int]]:</span><br><span class="line">        return [[k[i] for k in A] for i in range(len(A[0]))]</span><br></pre></td></tr></table></figure><h3 id="868-二进制间距"><a href="#868-二进制间距" class="headerlink" title="868 二进制间距"></a>868 二进制间距</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def binaryGap(self, N: int) -&gt; int:</span><br><span class="line">        s &#x3D; bin(N)</span><br><span class="line">        m&#x3D;start&#x3D;0</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">                start&#x3D;i</span><br><span class="line">                break</span><br><span class="line">        for j in range(i+1,len(s)):</span><br><span class="line">            if s[j]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">                m&#x3D;max(m,j-start)</span><br><span class="line">                start&#x3D;j</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="869-重新排序得到-2-的幂"><a href="#869-重新排序得到-2-的幂" class="headerlink" title="869 重新排序得到 2 的幂"></a>869 重新排序得到 2 的幂</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reorderedPowerOf2(self, N: int) -&gt; bool:</span><br><span class="line">        if N&#x3D;&#x3D;1:</span><br><span class="line">            return True</span><br><span class="line">        a &#x3D; int(&#39;&#39;.join(sorted(list(str(N)))))</span><br><span class="line">        for i in range(2,30):</span><br><span class="line">            b &#x3D; int(&#39;&#39;.join(sorted(list(str(2**i)))))</span><br><span class="line">            if a&#x3D;&#x3D;b and len(str(N))&#x3D;&#x3D;len(str(2**i)):</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="872-叶子相似的树"><a href="#872-叶子相似的树" class="headerlink" title="872 叶子相似的树"></a>872 叶子相似的树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def leafSimilar(self, root1, root2):</span><br><span class="line">        a&#x3D;[]</span><br><span class="line">        b&#x3D;[]</span><br><span class="line">        def scan(r,k):</span><br><span class="line">            if r:</span><br><span class="line">                if r.left:</span><br><span class="line">                    scan(r.left,k)</span><br><span class="line">                if r.right:</span><br><span class="line">                    scan(r.right,k)</span><br><span class="line">                if r.left&#x3D;&#x3D;None and r.right&#x3D;&#x3D;None:</span><br><span class="line">                    k.append(r.val)</span><br><span class="line">        scan(root1,a)</span><br><span class="line">        scan(root2,b)</span><br><span class="line">        if len(a)!&#x3D;len(b):</span><br><span class="line">            return False</span><br><span class="line">        for i in range(len(a)):</span><br><span class="line">            if a[i]!&#x3D;b[i]:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877 石子游戏"></a>877 石子游戏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def stoneGame(self, piles: List[int]) -&gt; bool:</span><br><span class="line">        # piles.length是偶数，所以先手必赢</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="896-单调数列"><a href="#896-单调数列" class="headerlink" title="896 单调数列"></a>896 单调数列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isMonotonic(self, A: List[int]) -&gt; bool:</span><br><span class="line">        c &#x3D; 0</span><br><span class="line">        for i in range(1,len(A)):</span><br><span class="line">            if A[i]&gt;A[i-1]:</span><br><span class="line">                if c&#x3D;&#x3D;0:</span><br><span class="line">                    c &#x3D; 1</span><br><span class="line">                elif c&#x3D;&#x3D;-1:</span><br><span class="line">                    return False</span><br><span class="line">            elif A[i]&lt;A[i-1]:</span><br><span class="line">                if c&#x3D;&#x3D;0:</span><br><span class="line">                    c &#x3D; -1</span><br><span class="line">                elif c&#x3D;&#x3D;1:</span><br><span class="line">                    return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h3 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912 排序数组"></a>912 排序数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def sortArray(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        return sorted(nums)</span><br></pre></td></tr></table></figure><h3 id="925-长按键入"><a href="#925-长按键入" class="headerlink" title="925 长按键入"></a>925 长按键入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isLongPressedName(self, name: str, typed: str) -&gt; bool:</span><br><span class="line">        i,j &#x3D; 0,0</span><br><span class="line">        while j&lt;len(typed):</span><br><span class="line">            if name[i]&#x3D;&#x3D;typed[j]:</span><br><span class="line">                if i&#x3D;&#x3D;len(name)-1:</span><br><span class="line">                    return True</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h3 id="930-和相同的二元子数组"><a href="#930-和相同的二元子数组" class="headerlink" title="930 和相同的二元子数组"></a>930 和相同的二元子数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numSubarraysWithSum(self, A: List[int], S: int) -&gt; int:</span><br><span class="line">        start &#x3D; 0</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        ans &#x3D; 0</span><br><span class="line">        for i in range(len(A)):</span><br><span class="line">            count +&#x3D; A[i]</span><br><span class="line">            if count&lt;S:</span><br><span class="line">                continue</span><br><span class="line">            else:</span><br><span class="line">                while count&gt;S and start&lt;i:</span><br><span class="line">                    count -&#x3D; A[start]</span><br><span class="line">                    start +&#x3D; 1</span><br><span class="line">                if count&#x3D;&#x3D;S:</span><br><span class="line">                    ans +&#x3D; 1</span><br><span class="line">                    for j in range(start,i):</span><br><span class="line">                        if A[j]&#x3D;&#x3D;1:</span><br><span class="line">                            break</span><br><span class="line">                        ans +&#x3D; 1</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure><h3 id="935-骑士拨号器"><a href="#935-骑士拨号器" class="headerlink" title="935 骑士拨号器"></a>935 骑士拨号器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def knightDialer(self, N: int) -&gt; int:</span><br><span class="line">        a &#x3D; [1,1,1,1,1,1,1,1,1,1]</span><br><span class="line">        b &#x3D; [0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">        for i in range(N-1):</span><br><span class="line">            b[0] &#x3D; a[4]+a[6]</span><br><span class="line">            b[1] &#x3D; a[6]+a[8]</span><br><span class="line">            b[2] &#x3D; a[7]+a[9]</span><br><span class="line">            b[3] &#x3D; a[4]+a[8]</span><br><span class="line">            b[4] &#x3D; a[0]+a[3]+a[9]</span><br><span class="line">            b[6] &#x3D; a[0]+a[1]+a[7]</span><br><span class="line">            b[7] &#x3D; a[2]+a[6]</span><br><span class="line">            b[8] &#x3D; a[1]+a[3]</span><br><span class="line">            b[9] &#x3D; a[2]+a[4]</span><br><span class="line">            a &#x3D; b</span><br><span class="line">            b &#x3D; [0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">        return sum(a)%(10**9+7)</span><br></pre></td></tr></table></figure><h3 id="941-有效的山脉数组"><a href="#941-有效的山脉数组" class="headerlink" title="941 有效的山脉数组"></a>941 有效的山脉数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def validMountainArray(self, A: List[int]) -&gt; bool:</span><br><span class="line">        if len(A)&lt;2:</span><br><span class="line">            return False</span><br><span class="line">        stage &#x3D; 0</span><br><span class="line">        up &#x3D; False</span><br><span class="line">        for i in range(1,len(A)):</span><br><span class="line">            if stage&#x3D;&#x3D;0 and A[i]&gt;A[i-1]:</span><br><span class="line">                up &#x3D; True</span><br><span class="line">                continue</span><br><span class="line">            elif stage&#x3D;&#x3D;0 and A[i]&lt;A[i-1] and up:</span><br><span class="line">                stage &#x3D; 1</span><br><span class="line">                continue</span><br><span class="line">            elif stage&#x3D;&#x3D;1 and A[i]&lt;A[i-1]:</span><br><span class="line">                continue</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br><span class="line">        return stage&#x3D;&#x3D;1</span><br></pre></td></tr></table></figure><h3 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946 验证栈序列"></a>946 验证栈序列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def validateStackSequences(self, pushed: List[int], popped: List[int]) -&gt; bool:</span><br><span class="line">        if len(pushed)&#x3D;&#x3D;0:</span><br><span class="line">            return len(popped)&#x3D;&#x3D;0</span><br><span class="line">        a &#x3D; [pushed[0]]</span><br><span class="line">        i &#x3D; 1</span><br><span class="line">        j &#x3D; 0</span><br><span class="line">        while True:</span><br><span class="line">            if len(a)&#x3D;&#x3D;0:</span><br><span class="line">                if i&#x3D;&#x3D;len(pushed):</span><br><span class="line">                    break</span><br><span class="line">                a.append(pushed[i])</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">            elif a[-1]&#x3D;&#x3D;popped[j]:</span><br><span class="line">                a.pop()</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                if i&#x3D;&#x3D;len(pushed):</span><br><span class="line">                    break</span><br><span class="line">                a.append(pushed[i])</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">        return len(a)&#x3D;&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="1003-检查替换后的词是否有效"><a href="#1003-检查替换后的词是否有效" class="headerlink" title="1003 检查替换后的词是否有效"></a>1003 检查替换后的词是否有效</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, S: str) -&gt; bool:</span><br><span class="line">        if not S:</span><br><span class="line">            return False</span><br><span class="line">        m &#x3D; 0</span><br><span class="line">        while len(S)!&#x3D;m:</span><br><span class="line">            m &#x3D; len(S)</span><br><span class="line">            S &#x3D; S.replace(&#39;abc&#39;,&#39;&#39;)</span><br><span class="line">        return len(S)&#x3D;&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014 最佳观光组合"></a>1014 最佳观光组合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxScoreSightseeingPair(self, A: List[int]) -&gt; int:</span><br><span class="line">        m &#x3D; A[0]</span><br><span class="line">        r &#x3D; 0</span><br><span class="line">        for i in range(1,len(A)):</span><br><span class="line">            r &#x3D; max(r,m+A[i]-i)</span><br><span class="line">            m &#x3D; max(m,A[i]+i)</span><br><span class="line">        return r</span><br></pre></td></tr></table></figure><h3 id="1021-删除最外层的括号"><a href="#1021-删除最外层的括号" class="headerlink" title="1021 删除最外层的括号"></a>1021 删除最外层的括号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeOuterParentheses(self, S: str) -&gt; str:</span><br><span class="line">        res &#x3D; &quot;&quot;</span><br><span class="line">        start &#x3D; 0</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        for i in range(len(S)):</span><br><span class="line">            if S[i]&#x3D;&#x3D;&#39;(&#39;:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                count-&#x3D;1</span><br><span class="line">            if count&#x3D;&#x3D;0:</span><br><span class="line">                if start+1&lt;&#x3D;i:</span><br><span class="line">                    res+&#x3D;S[start+1:i]</span><br><span class="line">                start&#x3D;i+1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="1023-驼峰式匹配"><a href="#1023-驼峰式匹配" class="headerlink" title="1023 驼峰式匹配"></a>1023 驼峰式匹配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def camelMatch(self, queries: List[str], pattern: str) -&gt; List[bool]:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for i in queries:</span><br><span class="line">            m,n,fa,fb &#x3D; 0,0,0,0</span><br><span class="line">            while True:</span><br><span class="line">                if fb&#x3D;&#x3D;0 and i[m]&#x3D;&#x3D;pattern[n]:</span><br><span class="line">                    if m&#x3D;&#x3D;len(i)-1 and n&#x3D;&#x3D;len(pattern)-1:</span><br><span class="line">                        a.append(True)</span><br><span class="line">                        break</span><br><span class="line">                    if n&#x3D;&#x3D;len(pattern)-1:</span><br><span class="line">                        fb&#x3D;1</span><br><span class="line">                        m+&#x3D;1</span><br><span class="line">                    else:</span><br><span class="line">                        m+&#x3D;1</span><br><span class="line">                        n+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    if m&lt;len(i) and i[m]&gt;&#x3D;&#39;A&#39; and i[m]&lt;&#x3D;&#39;Z&#39;:</span><br><span class="line">                        a.append(False)</span><br><span class="line">                        break</span><br><span class="line">                    if m&#x3D;&#x3D;len(i)-1:</span><br><span class="line">                        fa&#x3D;1</span><br><span class="line">                    if fa and fb:</span><br><span class="line">                        a.append(True)</span><br><span class="line">                        break</span><br><span class="line">                    if fa and not fb:</span><br><span class="line">                        a.append(False)</span><br><span class="line">                        break</span><br><span class="line">                    m+&#x3D;1</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249 移除无效的括号"></a>1249 移除无效的括号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minRemoveToMakeValid(self, s: str) -&gt; str:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        b &#x3D; []</span><br><span class="line">        pos &#x3D; 0</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i]&#x3D;&#x3D;&#39;(&#39;:</span><br><span class="line">                pos+&#x3D;1</span><br><span class="line">                a.append(s[i])</span><br><span class="line">                b.append(i)</span><br><span class="line">            elif s[i]&#x3D;&#x3D;&#39;)&#39;:</span><br><span class="line">                if len(a)&gt;0 and pos&gt;0:</span><br><span class="line">                    a.pop()</span><br><span class="line">                    b.pop()</span><br><span class="line">                    pos-&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    a.append(s[i])</span><br><span class="line">                    b.append(i)</span><br><span class="line">        res &#x3D; &#39;&#39;</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if i not in b:</span><br><span class="line">                res+&#x3D;s[i]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="1291-顺次数"><a href="#1291-顺次数" class="headerlink" title="1291 顺次数"></a>1291 顺次数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def sequentialDigits(self, low: int, high: int) -&gt; List[int]:</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        for i in range(len(str(low)),len(str(high))+1):</span><br><span class="line">            base &#x3D; int(&#39;&#39;.join([str(i) for i in range(1,i+1)]))</span><br><span class="line">            agg &#x3D; int(&#39;1&#39;*i)</span><br><span class="line">            if low&lt;&#x3D;base&lt;&#x3D;high:</span><br><span class="line">                res.append(base)</span><br><span class="line">            for j in range(9-i):</span><br><span class="line">                base+&#x3D;agg</span><br><span class="line">                if low&lt;&#x3D;base&lt;&#x3D;high:</span><br><span class="line">                    res.append(base)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="1299-将每个元素替换为右侧最大元素"><a href="#1299-将每个元素替换为右侧最大元素" class="headerlink" title="1299 将每个元素替换为右侧最大元素"></a>1299 将每个元素替换为右侧最大元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def replaceElements(self, arr: List[int]) -&gt; List[int]:</span><br><span class="line">        if len(arr)&#x3D;&#x3D;0:</span><br><span class="line">            return []</span><br><span class="line">        if len(arr)&#x3D;&#x3D;1:</span><br><span class="line">            return [-1]</span><br><span class="line">        a &#x3D; [-1]</span><br><span class="line">        m &#x3D; arr[-1]</span><br><span class="line">        for i in range(len(arr)-2,-1,-1):</span><br><span class="line">            a.insert(0,m)</span><br><span class="line">            if m&lt;arr[i]:</span><br><span class="line">                m &#x3D; arr[i]</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="1304-和为零的N个唯一整数"><a href="#1304-和为零的N个唯一整数" class="headerlink" title="1304 和为零的N个唯一整数"></a>1304 和为零的N个唯一整数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def sumZero(self, n: int) -&gt; List[int]:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for i in range(n-1):</span><br><span class="line">            a.append(i)</span><br><span class="line">        a.append(sum(a)*(-1))</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="1313-解压缩编码列表"><a href="#1313-解压缩编码列表" class="headerlink" title="1313 解压缩编码列表"></a>1313 解压缩编码列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def decompressRLElist(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while nums:</span><br><span class="line">            a &#x3D; nums.pop(0)</span><br><span class="line">            b &#x3D; nums.pop(0)</span><br><span class="line">            for i in range(a):</span><br><span class="line">                res.append(b)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="1337-方阵中战斗力最弱的-K-行"><a href="#1337-方阵中战斗力最弱的-K-行" class="headerlink" title="1337 方阵中战斗力最弱的 K 行"></a>1337 方阵中战斗力最弱的 K 行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def kWeakestRows(self, mat: List[List[int]], k: int) -&gt; List[int]:</span><br><span class="line">        s &#x3D; [sum(i) for i in mat]</span><br><span class="line">        res &#x3D; [0]</span><br><span class="line">        for i in range(1,len(s)):</span><br><span class="line">            for j in range(len(res)):</span><br><span class="line">                if s[res[j]]&gt;s[i]:</span><br><span class="line">                    res.insert(j,i)</span><br><span class="line">                    break</span><br><span class="line">                elif j&#x3D;&#x3D;len(res)-1:</span><br><span class="line">                    res.append(i)</span><br><span class="line">        return res[:k]</span><br></pre></td></tr></table></figure><h3 id="1380-矩阵中的幸运数"><a href="#1380-矩阵中的幸运数" class="headerlink" title="1380 矩阵中的幸运数"></a>1380 矩阵中的幸运数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def luckyNumbers (self, matrix: List[List[int]]) -&gt; List[int]:</span><br><span class="line">        m &#x3D; [999999]*len(matrix)</span><br><span class="line">        n &#x3D; [0]*len(matrix[0])</span><br><span class="line">        for i in range(len(matrix)):</span><br><span class="line">            for j in range(len(matrix[0])):</span><br><span class="line">                if matrix[i][j]&lt;m[i]:</span><br><span class="line">                    m[i] &#x3D; matrix[i][j]</span><br><span class="line">                if matrix[i][j]&gt;n[j]:</span><br><span class="line">                    n[j] &#x3D; matrix[i][j]</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        for i in range(len(matrix)):</span><br><span class="line">            for j in range(len(matrix[0])):</span><br><span class="line">                if matrix[i][j]&#x3D;&#x3D;m[i]&#x3D;&#x3D;n[j]:</span><br><span class="line">                    res.append(matrix[i][j])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="1385-两个数组间的距离值"><a href="#1385-两个数组间的距离值" class="headerlink" title="1385 两个数组间的距离值"></a>1385 两个数组间的距离值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -&gt; int:</span><br><span class="line">        m &#x3D; 0</span><br><span class="line">        for i in arr1:</span><br><span class="line">            acc &#x3D; True</span><br><span class="line">            for j in arr2:</span><br><span class="line">                if abs(i-j)&lt;&#x3D;d:</span><br><span class="line">                    acc &#x3D; False</span><br><span class="line">            if acc:</span><br><span class="line">                m+&#x3D;1</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure><h3 id="1394-找出数组中的幸运数"><a href="#1394-找出数组中的幸运数" class="headerlink" title="1394 找出数组中的幸运数"></a>1394 找出数组中的幸运数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findLucky(self, arr: List[int]) -&gt; int:</span><br><span class="line">        d &#x3D; &#123;&#125;</span><br><span class="line">        for i in arr:</span><br><span class="line">            d[i] &#x3D; d[i]+1 if i in d else 1</span><br><span class="line">        res &#x3D; -1</span><br><span class="line">        for i in d:</span><br><span class="line">            if d[i]&#x3D;&#x3D;i and i&gt;res:</span><br><span class="line">                res &#x3D; i</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02 返回倒数第 k 个节点"></a>面试题 02.02 返回倒数第 k 个节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def kthToLast(self, head: ListNode, k: int) -&gt; int:</span><br><span class="line">        c &#x3D; 1</span><br><span class="line">        p &#x3D; head</span><br><span class="line">        while p.next:</span><br><span class="line">            p &#x3D; p.next</span><br><span class="line">            c+&#x3D;1</span><br><span class="line">        c &#x3D; c-k</span><br><span class="line">        while c:</span><br><span class="line">            head &#x3D; head.next</span><br><span class="line">            c-&#x3D;1</span><br><span class="line">        return head.val</span><br></pre></td></tr></table></figure><h3 id="面试题17-打印从1到最大的n位数"><a href="#面试题17-打印从1到最大的n位数" class="headerlink" title="面试题17 打印从1到最大的n位数"></a>面试题17 打印从1到最大的n位数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def printNumbers(self, n: int) -&gt; List[int]:</span><br><span class="line">        a &#x3D; []</span><br><span class="line">        for i in range(1,int(&#39;9&#39;*n)+1):</span><br><span class="line">            a.append(i)</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure><h3 id="面试题-17-04-消失的数字"><a href="#面试题-17-04-消失的数字" class="headerlink" title="面试题 17.04 消失的数字"></a>面试题 17.04 消失的数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def missingNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        nums.append(-1)</span><br><span class="line">        for k in range(len(nums)):</span><br><span class="line">            while nums[k]!&#x3D;k and nums[k]!&#x3D;-1:</span><br><span class="line">                t &#x3D; nums[k]</span><br><span class="line">                nums[k] &#x3D; nums[t]</span><br><span class="line">                nums[t] &#x3D; t</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[i]&#x3D;&#x3D;-1:</span><br><span class="line">                return i</span><br></pre></td></tr></table></figure><h3 id="面试题46-把数字翻译成字符串"><a href="#面试题46-把数字翻译成字符串" class="headerlink" title="面试题46 把数字翻译成字符串"></a>面试题46 把数字翻译成字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def translateNum(self, num: int) -&gt; int:</span><br><span class="line">        a &#x3D; [1,1]</span><br><span class="line">        s &#x3D; str(num)</span><br><span class="line">        for i in range(1,len(s)):</span><br><span class="line">            if 9&lt;int(s[i-1:i+1])&lt;26:</span><br><span class="line">                a.append(a[-1]+a[-2])</span><br><span class="line">            else:</span><br><span class="line">                a.append(a[-1])</span><br><span class="line">        return a[-1]</span><br></pre></td></tr></table></figure><h3 id="面试题55-I-二叉树的深度"><a href="#面试题55-I-二叉树的深度" class="headerlink" title="面试题55 - I 二叉树的深度"></a>面试题55 - I 二叉树的深度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDepth(self, root):</span><br><span class="line">        def se(a,r):</span><br><span class="line">            if r:</span><br><span class="line">                return max(se(a+1,r.left),se(a+1,r.right),1)</span><br><span class="line">            else:</span><br><span class="line">                return a</span><br><span class="line">        return se(0,root)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="https://shivakasu.cn/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://shivakasu.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术与应用笔记</title>
    <link href="https://shivakasu.cn/2020/05/28/blockchain0/"/>
    <id>https://shivakasu.cn/2020/05/28/blockchain0/</id>
    <published>2020-05-28T13:55:20.000Z</published>
    <updated>2020-06-15T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-比特币"><a href="#1-比特币" class="headerlink" title="1 比特币"></a>1 比特币</h1><h2 id="1-1-密码学原理"><a href="#1-1-密码学原理" class="headerlink" title="1.1 密码学原理"></a>1.1 密码学原理</h2><ul><li>加密货币(crypto-currency)用到的密码学技术是哈希和签名。</li><li>加密货币用到的哈希函数叫做加密哈希函数(cryptographic hash function), 它有三个特性：<ul><li>collision resistance：抗碰撞性，即输入空间足够大时，给定一个 $x$ ，没有一种比穷举更高效的方法使我们找到一个 $y\neq x$ 满足 $hash(x)=hash(y)$ 。有此性质可以防篡改，因为几乎不可能人为篡改信息后仍保持哈希值不变。抗碰撞性是不可证明的，只能通过经验大概判断。</li><li>hiding：藏匿性，即输入空间足够大时，给定一个哈希值 $hash(x)$ ，没有一种比穷举更高效的方法使我们反推出对应的 $x$ 。结合抗碰撞性与藏匿性可以实现数字承诺(digital commitment)，即 seal a value in an envelope and open the envelope later。</li><li>puzzle friendly：任何人无法得知哈希函数的映射规则，无法根据给定的哈希值要求构造输入。这是比特币对哈希函数的要求，比特币是一块指定的哈希值空间，如果要寻找对应这一块空间的输入，除了穷举挖矿没有捷径，因此挖矿的过程能够比较公正地作为工作量证明(proof of work)。由于哈希函数的单向性，寻找输入只能穷举，但验证输入的合法性很简单，因此挖出的比特币能够被所有人验证。</li></ul></li><li>比特币的哈希函数是SHA-256，SHA是 Secure Hash Algorithm，满足上述三个性质。</li><li>比特币用到的第二个密码学技术是数字签名，涉及到比特币的账户管理。比特币采用去中心化的账户管理，没有类似银行的中心机构，每个用户都能自主开户，开户过程就是在本地创建一个公钥私钥对，一个公钥私钥对就代表了一个账户。</li><li>公钥私钥是非对称加密算法中的概念。对称加密算法中，加密和解密过程使用的是同一个密钥，能加密的人必然也能解密，所以需要保证密钥分发的安全性。而非对称加密算法不需要考虑这一点，加密用公钥，解密用私钥，每个用户只公开自己的公钥，使得所有人都能用自己的公钥加密，但只有用户自己能用私钥解密，从而防止了信息泄露。</li><li>比特币系统本身是不加密的，所有信息都是公开的，公钥私钥主要是用来实现数字签名。每个用户的公钥分发给所有人，私钥保存在本地，进行比特币交易时，用自己的私钥进行加密，其他用户使用该用户的公钥进行解密即可验证交易人的身份。在此过程中，所有人都能解密，而只有签名用户能加密，同样保证了数字签名的安全性和可靠性，也就防止了假冒身份进行交易。</li></ul><h2 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h2><ul><li>比特币使用的一个数据结构是区块链，区块链是一个个区块构成的链表，与一般链表的区别是使用哈希指针进行链接。哈希指针(hash pointer)同时保存了下一个区块的地址和下一个区块的哈希值。</li><li>区块链中，最初的区块(next=null)称为创世纪块(genesis block)，头节点区块称为最近区块(most recent block)。每个区块包含指向前一个区块的哈希指针，系统中存储着一个独立的哈希指针指向最近区块。</li><li>使用哈希指针可以实现防篡改日志(tamper-evident-log)，当一个区块内容被篡改后，哈希值改变，导致原本指向该区块的哈希指针无法匹配，系统为了保持链接会自动修改指向该区块的那个区块中的哈希指针，由于计算哈希值时也包含了区块中的哈希指针，所以会导致传递地逆着区块链接的方向修改所有区块中指针的哈希值，最终修改到指向最近区块的指针，因此任一区块的改变都会导致指向最近区块的指针的改变，所以只看一个指针就可以方便地判断有无篡改。此外，当用户不小心删除了本地的一个区块，需要别人重新发送一份时，可以根据指向丢失区块的哈希指针的哈希值判断收到的区块是否是正确的。</li><li>比特币使用的另一个数据结构是梅克尔树(Merkle tree)，梅克尔树的叶节点是存储数据的数据块，非叶节点存储的是其所有子节点的哈希值，把当前节点的所有子节点的哈希值拼接后再算一次哈希，将这个哈希值保存在当前节点的父节点中，如此自底向上计算哈希，最后归结到根节点，根节点中的所有哈希值拼接后再算一次哈希，得到的就是最终的根哈希值。与区块链类似，梅克尔树也具有防篡改日志的特性，对任一数据块的篡改最终都会导致根哈希值的变化。</li><li>由于区块链的冗余备份，要求所有节点都保存全部的数据文件，而随着区块链上的交易越来越多，数据同步的代价越来越高，只有少数大存储节点有能力保存全部数据，为了不让区块链演变成中心化结构，出现了全节点(full node)和轻节点(light node)的概念，全节点区块包含块头(header)和块身(body)，轻节点只有块头。梅克尔树的每个数据块都代表一个交易(transaction)，梅克尔树的根哈希值存储在块头，其余结构存储在块身，因此全节点存储了整个梅克尔树，而轻节点只存储了根哈希值。</li><li>梅克尔树提供了梅克尔证明(Merkle proofs)的机制，使轻节点用户能够验证一个交易是否被写入了区块链中。梅克尔树一个叶节点到根节点的路径叫做一个梅克尔证明，用户根据已有的交易，向全节点请求该交易对应的梅克尔证明路径中自己无法求出的哈希值(因为非叶节点中的哈希值还涉及了其他交易，发送路径中用到的哈希值比发送所有叶节点的数据量小多了)，用户结合交易信息的哈希值和全节点提供的哈希值，就能逐层计算出最终的根哈希值，将计算得到的根哈希值和自己轻节点中存储的根哈希值对比，就能验证交易是否已经写入区块链。</li><li>由于哈希函数的抗碰撞性，全节点几乎不可能恶意提供一个错误的梅克尔证明，使得轻节点用户根据一个被篡改的交易能够算出正确的根哈希值，所以梅克尔证明的机制是安全的。</li><li>哈希指针只能用在无环的结构中，因为在环上会导致无穷尽的哈希值的循环影响。</li></ul><h2 id="1-3-协议"><a href="#1-3-协议" class="headerlink" title="1.3 协议"></a>1.3 协议</h2><ul><li>公钥私钥的加密只能保证数字货币交易的安全性，但容易实施双花攻击(double spending attack)，因为数字货币的本质就是签了名的文件，不能即时标记使用次数，所以用户可以把数字货币复制多份重复使用。一种可行的解决方案是设立一个中央银行，数字货币的发行和交易必须经过央行的认证，央行给每个数字货币一个唯一的编号，验证交易时就可以根据编号查询该货币是否被使用过。但是这是中心化结构的实现方案，比特币系统的初衷是要去中心化的。</li><li>去中心化的比特币系统要解决两个问题。一个是由谁发行比特币，这个问题与挖矿有关，后面再讲。另一个是防止双花攻击，解决方法就是全体用户维护一个区块链，用于记录和跟踪交易日志，所以区块链也被叫做公共账本。比特币的交易一方面要根据签名验证交易人的身份，同时也要验证比特币的来源，因为双花攻击就相当于发行货币、凭空创造货币，只要确定比特币来源可靠就能保证交易的有效性。</li><li>假设A向B转账，在转账之前，A需要知道B的比特币账户地址，用户地址虽然不是保密的，但由于比特币系统没有查询用户地址的方法，所以需要通过别的渠道获得。同时，B要知道A的公钥，来验证比特币中A的签名，B收到一个带签名的交易和一个公钥，结合二者来验证交易的有效性，如果没有区块链的交易日志，就能允许一个第三者C同时篡改签名和公钥，让B成功验证交易后以为在和A交易但实际上走的别人的账户，一旦有了交易日志，就能知道比特币的当前持有人，甚至能追溯到发行该比特币的用户，所以对交易人公钥的篡改不会被区块链接受。(好像是这个意思，没太看懂)</li><li>区块身中记录的是交易列表(transaction list)。区块头中记录的是一些宏观信息，如比特币的协议版本(Bitcoin version)，指向前一区块的指针(hash of previous block header)，梅克尔树的根哈希值(Merkle root hash)，挖矿的难度目标阈值(difficulty target)，时间戳(timestamp)，以及随机数(nonce)。哈希指针是在区块头之间链接的，指针中的哈希值也只是计算整个区块头的哈希值，不计算区块身，因为梅克尔树已经能保证交易的可靠性了，区块身就不用管了。</li><li>区块链要满足分布式共识(distributed comsensus)，也就是每个用户本地的区块链数据要保持一致性，涉及到分布式系统的一些理论，如FLP、CAP。共识机制解决并保证每一笔交易在所有记帐节点上的一致性和正确性问题。区块链的共识机制不能依靠用户投票，因为区块链不能确定谁有投票权，也就是不能知道哪些用户是值得信任的，在区块链系统上创建账户太简单了，只需要生成公钥私钥对就够了，如果给所有用户同样的投票权，就可能会有某个用户恶意生成大量账户来操纵投票结果，这种攻击称为女巫攻击(sybil attack，水军攻击~)。</li><li>区块链的共识机制是依据算力进行投票。挖矿的过程就是创建区块的过程，有效的哈希值只是哈希函数输出空间上很小的一个区域，矿工先构造一个区块头，然后穷举随机数nonce使得 $hash(block\ header)\leq difficulty\ target$ ，找到满足条件的随机数时，该矿工就有了记账权，也就是能往区块链中添加该区块。但仅仅是新区块内容有效也不一定被区块链接受，因为区块链的共识最终目的是保证比特币不停的在工作量最大(通常也是难度最多区块数最多)的区块链上运转，保证工作量最大的区块链成为唯一权威的公共总帐本，如果新区块不是添加在最长有效链的末尾，而是额外插在最长有效链的某个节点上导致产生了无效分支链，那么就不会被区块链接受。</li><li>51%攻击就是利用新分支来篡改区块链，当攻击者掌握了全网超过50%的算力时，自己私下不断创建新区块却不发布到最长有效链上，当这条隐身的区块链长度超过了最长有效链时，攻击者将整条链发布，就能直接替代掉原来的最长有效链，抹除掉原来主链上的记录。</li><li>正常情况下也会出现分支，当两个矿工几乎同时发布了新区块到主链末尾，就会产生两个分支。对于这种等长的临时分支，系统会同时保留并认可，直到有用户在某个分支下添加新的区块造成两个分支不等长，此时系统就会放弃短的分支，意味着短分支的计算工作全都白干了。</li><li>因此共识机制就是有记账权的矿工们在区块链上添加区块，维护最长有效链，所谓的投票就是矿工选择分支进行扩展，只有有记账权的矿工才能投票，所以女巫攻击就不可行了，因为普通用户只有验证权没有记账权。之所以要拼算力竞争记账权，是因为添加新区块后添加者有权力在新区块内发行一定数量的比特币，作为挖矿的报酬，这种特殊交易称为铸币交易(coinbase transaction)，铸币交易是发行新比特币的唯一途径。比特币数量上限是2100万个，最初的新区块内可发行50个比特币，而后每创建21万个区块后，新区块内可发行的比特币数量减半，大概是每四年减半一次(通过调整挖矿难度，比特币协议规定了系统平均出块时间是10分钟左右)，目前已经减到12.5个，这种规则是为了抑制比特币的产出，但是随着比特币的升值，发布新区块的收益其实是越来越高的(不考虑挖矿的支出)。</li></ul><h2 id="1-4-实现"><a href="#1-4-实现" class="headerlink" title="1.4 实现"></a>1.4 实现</h2><ul><li>比特币系统采用基于交易的账本模式(transaction-based ledger)，区块里记录着铸币交易和转账交易，但不显式记录每个账户的余额，查询余额需要根据交易日志推算。</li><li>区块链的全节点维护着一个名为UTXO(Unspent Transaction Output)的数据结构，记录尚未花费的所有交易的输出，一个交易可以有多个输出，即同时转账给多人，也可以有多个输入，即多人同时转账给同一人。UTXO中的索引是交易的哈希值和输出的序号，根据这两个值可以检索具体某个交易的某个输出。交易完成前查询UTXO可以防止双花攻击，因为已花费的比特币记录会从UTXO中删除，确保只会花一次。一个交易既消耗UTXO中的记录，又会产生新的UTXO记录。</li><li>通常交易的总输入等于总输出，但有时总输入会大于总输出，因为把自己的交易存储在别人的区块中要付给区块发布者少许交易费(transaction fee)。这是为了高效利用区块，激励区块发布者把别人的交易记录存储在自己的区块中。但相比于微薄的交易费，目前挖矿的动力主要还是为了十几个币的出块奖励，等到出块奖励衰减到微乎其微时，挖矿的动力就转为了交易费。</li><li>与基于交易的账本模式对应的是基于账户的账本模式(account-based ledger)，系统会显式记录每个账户的余额，以太坊用的就是这种模式。</li><li>由于当前挖矿人数太多，竞争激烈，挖矿难度已经被调整得非常高。区块头的nonce只是32位的无符号整数，有时穷举完32位的所有整数也无法找到满足难度要求的数，这时就需要调整区块头中其他可改字段的值，扩大搜索空间。通常修改的是梅克尔树的根哈希值，这个字段可改是因为铸币交易记录中的coinbase字段是自定义的，铸币用户写什么都无所谓，修改这个字段会导致梅克尔树根哈希值的改变。所以挖矿过程其实是两层循环，先遍历coinbase字段，再遍历nonce字段，搜索空间大大增加。</li><li>挖矿过程中，每一次试数都是一次伯努利试验(Bernoulli trial: a random experiment with binary outcome)，两种结果是成功和失败，成功的概率远远小于失败的概率。多次试数就构成了一个伯努利过程(Bernoulli process: a sequence of independent Bernoulli trials)，伯努利过程的一个性质是无记忆性(memoryless)，意味着每次试数都是独立的、不受之前结果影响的。这个伯努利过程可以用泊松过程(Poisson process)来近似，因为泊松过程就是无记忆性的，就算已经有10分钟没有挖出新的区块，接下来挖到新区块的概率也不会因此而上升。无记忆性能够保证挖矿的公平性，因为防止了算力强的矿工滚雪球。</li><li>由于四年减半，比特币的增量是一个等比数列，比特币的总量就是 $21万\times 50\times (1+1/2+1/4…)=2100万$ 。</li><li>挖矿一定程度上保证了比特币的安全，他不假定所有用户是诚实的，而是假定所有算力掌握在诚实的矿工手中。但这种安全性只是概率上的保证，体现了投票的可靠性，表明所有用户能够大概率地维护正确的最长有效链。此外，如果一个区块节点拒绝记录某个合法的交易，也总能等到有一个诚实的节点愿意记录该交易。</li><li>基于这种信任，有一种六次确认的防篡改判断。当用户A向B发起交易后，可以利用自己的算力立即创建一条略长的新分支，暂时取代当前的主链来欺骗B，而B可以选择等待一段时间，由于A无法对抗全体用户的算力，一段时间后原来的主链会自然而然地被重新维护起来，通常是在交易所在的区块后边被扩展了六个新区块后，可以认为该交易是可靠的，代表有六个其他用户认可了该交易，10分钟创建一个新区块，所以等待时间大约是一个小时。</li><li>虽然有了六次确认，零次确认还是比较普遍的。一方面因为创建新分支的节点会迟于在主链上添加节点，根据时间的先后，新分支有很大概率不会被区块链接受。另一方面交易的完成本身就需要一段时间，这就相当于六次确认的等待时间了。</li></ul><h2 id="1-5-网络"><a href="#1-5-网络" class="headerlink" title="1.5 网络"></a>1.5 网络</h2><ul><li>比特币系统的区块链运行在应用层，下面的网络层是一个P2P覆盖网络(P2P Overlay Network)，网络中所有的节点都是平等的，没有所谓的super node或master node。节点之间使用TCP通信，有利于穿透防火墙。</li><li>比特币的设计原则是简单鲁棒而非高效，网络中的信息采用flooding的方式传播，每个节点收到信息后传播给所有邻居节点，邻居节点的选择是随机的，不会考虑拓扑结构上的远近，比如中国的一个节点邻居可能在美国，这样提高了鲁棒性但牺牲了效率。</li><li>每个节点要维护一个等待上链的交易的集合，通过查询集合可以保证相同的交易信息只对邻居发送一次。</li><li>比特币系统限制了区块的大小是1MB，之所以设计得这么小是因为比特币网络这种低效的信息传播方式非常耗带宽。</li><li>比特币网络的信息传播属于best effort(尽力而为)，由于网络传输存在延迟，同时有些节点转发信息可能不合规范，最后可能会导致有的节点收不到信息，收到信息的顺序不一样，或者收到不合法的信息。这也是去中心化系统普遍面临的问题。</li></ul><h2 id="1-6-挖矿难度"><a href="#1-6-挖矿难度" class="headerlink" title="1.6 挖矿难度"></a>1.6 挖矿难度</h2><ul><li>挖矿难度 difficulty 和目标阈值 target成反比。随着挖矿人数的增加和硬件算力的提升，出块时间会越来越小，出块速度远远小于新区块信息在节点间的传播和同步。用户们不能及时扩展新区块结尾的主链，依然以旧节点为链尾进行扩展，会更容易造成区块链分叉，也更容易受到51% attack，因为不能保持大部分诚实的矿工维护同一条主链。因此，出块时间不是越短越好，相反，挖矿变得容易就表示人们挖矿的热情下降了，比特币的处境反而变得艰难了。</li><li>但是比特币协议把出块时间规定成10分钟也没有被证明是最优的，比如以太坊就把出块时间定为15秒，并设计了一个额外的ghost协议来解决区块链分叉的问题。</li><li>比特币协议规定每隔2016个区块(大概两个星期)调整一次目标阈值(挖矿难度)，更新 target 的公式是：<script type="math/tex; mode=display">target=target\times\frac{actual\ time}{expected\ time}</script>expected time就是2016X10分钟，actual time是最近的2016个区块的产生时间。可见，实际出块时间越短，target变得越小，挖矿难度也就越高。但是为了控制target的变动幅度，actual time最小是半个星期，最大是8个星期，也就是把target的变动限制在4倍，实际出块时间太大或太小都会按照4倍的边界值计算，这大概是考虑到区块链可能出意外。</li></ul><h2 id="1-7-挖矿"><a href="#1-7-挖矿" class="headerlink" title="1.7 挖矿"></a>1.7 挖矿</h2><ul><li>全节点：<ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存里维护UTXO集合，以便快速检验交易的正确性</li><li>监听比特币网络上的交易信息，验证每个交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块，验证其合法性</li><li>选择分叉，决定主链</li></ul></li><li>轻节点：<ul><li>不是一直在线</li><li>不保存整个区块链，只保存每个区块的区块头</li><li>不保存全部交易，只保存与自己相关的交易</li><li>无法检验大多数交易的合法性，只能检验与自己相关的交易的合法性</li><li>无法检测网上发布的区块的正确性，因为无法检验其包含的交易的合法性</li><li>可以验证挖矿的难度</li><li>只能检测哪个是最长链，不能检测哪个是最长合法链，合法性需要验证全部交易</li></ul></li><li>比特币的安全性是由密码学原理和共识机制两方面所保证的。</li><li>cpu挖矿浪费资源，因为只会用到很少的内存和指令部件。gpu挖矿同样闲置了浮点计算的部件，因为挖矿只涉及整数运算，而且目前的挖矿难度已经超过了gpu的算力范围。目前都用ASIC(Application Specific Integrated Circuit)芯片挖矿，是一种专门为挖矿设计的芯片，除了挖矿什么也干不了。可见，挖矿设备的演化是一个通用到专用的过程。但是因为ASIC芯片更新换代很快，过时以后也干不了别的事只能废弃，有人认为这违背了比特币去中心化的初衷，所以有的数字货币会设计成抗ASIC芯片，限制ASIC芯片的使用，鼓励人们用通用芯片挖矿。</li><li>比特币的发展导致了矿池的出现，矿主招揽多个矿工共同挖矿，矿工只负责用芯片计算哈希，节点的维护由矿主负责，得到的收益在整个矿池内按劳分配。矿工在矿池挖矿，降低了维护和管理设备的成本，收益相比于自己单干也更加稳定，是从小概率赚大钱变成了大概率赚小钱。但是矿池的出现也导致了矿主的算力垄断，使得51% attack更容易实施，因为记账权不再由全体矿工掌握，而是掌握在少数矿主的手里。</li></ul><h2 id="1-8-比特币脚本"><a href="#1-8-比特币脚本" class="headerlink" title="1.8 比特币脚本"></a>1.8 比特币脚本</h2><ul><li>略</li></ul><h2 id="1-9-分叉"><a href="#1-9-分叉" class="headerlink" title="1.9 分叉"></a>1.9 分叉</h2><ul><li>区块链分叉包括两种情况。第一种是 state fork，是指用户对当前主链的确定产生分歧，比如两人几乎同时发布新区块，再如51% attack，由于这种分叉是人为的，所以也叫 deliberate fork。第二种是 protocol fork，当比特币协议改变时需要进行软件升级，但在去中心化的系统中无法保证所有节点都能及时完成升级，就会导致产生分叉。根据协议修改内容的不同，又分为硬分叉(hard fork)和软分叉(soft fork)。</li><li>硬分叉是指在比特币协议中增加了新特性，没有及时更新协议的节点就会拒绝接受符合新特性的区块。比如对区块大小限制的修改，尽管区块不是越大越好，但另一方面因为出块时间是固定的，单个区块越大越能承载更多的交易，也就提升了系统处理新交易的速度。当把区块大小上限从1MB调整到4MB后，没有更新协议的节点就会拒绝大于1MB的新区块，仍然接着扩展上一个1MB大小的区块，从而产生了分叉。无论主链有多长，旧协议的节点始终认为它是非法的，所以只要这些节点不更新协议，分叉就会一直保留。如果这些节点一直保守地不更新协议，就会导致社区分裂，两拨用户分道扬镳，独立运营，为了在分开后不混淆两条链上交易，防止重放攻击，要给每条链一个 chainID，但是原来的一个账户会复制成每个分支上都有一个独立的账户，不知道会怎么处理。</li><li>软分叉是指在比特币协议中增加了限制，某些原来合法的区块现在变得不合法了。比如把区块大小上限从1MB调整到0.5MB后，按照新协议挖出的所有区块会被旧协议接受，但按照旧协议挖出的大于0.5MB的区块不会被新协议接受，从而产生分叉。由于旧协议对两条链都能接受，所以只要大部分算力的用户使用了新协议，软分叉上的用户最终都会回到主链上，分叉上的区块就等于白挖了。所以软分叉是一种临时的分叉，只要挖出大于0.5MB的区块就会产生分叉，随着主链变得更长，分叉就会被放弃。</li><li>简单来说，硬分叉就是新协议(多数)向前兼容，少数不认可多数，多数认可少数，结果就是两拨人各自独立运营，分叉上的工作都保留了下来。软分叉是新协议(多数)不向前兼容，少数认可多数，但多数不认可少数，结果就是分分合合，分叉上的工作都白干了。</li></ul><h2 id="1-10-课堂问答"><a href="#1-10-课堂问答" class="headerlink" title="1.10 课堂问答"></a>1.10 课堂问答</h2><ul><li>转账只是在区块链上记录交易信息，转账对象没必要保持在线。</li><li>交易的接收账户可能是全节点也不知道的，因为开通新账户只是在本地创建公钥私钥，不需要通知任何节点，新账户第一次收到钱后才会被节点记录。</li><li>私钥丢失了以后，账户就成了死户，钱就找不回了，因为没有一个中心化的交易所替用户管理，但是即使有交易所也未必是可信的。</li><li>私钥泄露了或发现有可疑交易，应该创建一个新账户，尽快把钱转走。私钥是账户的全部凭证，创建了就不能做修改，所有知道私钥的人都能合法操作账户的钱。</li><li>转账写错了地址，只能自认倒霉，因为用户不能修改已发布的交易。如果认识对方，可以联系对方能不能退回。如果转给了一个不存在的账户，钱就等于丢了，直到有人创建了该账户，他就直接白捡了这些钱。</li><li>交易费不需要指定接收的矿工，任何挖到区块的矿工，只要愿意打包某个交易，就能得到交易的交易费，所以设置交易费的时候不需要也不能够指定接收人。</li></ul><h2 id="1-11-比特币的匿名性"><a href="#1-11-比特币的匿名性" class="headerlink" title="1.11 比特币的匿名性"></a>1.11 比特币的匿名性</h2><ul><li>比特币系统中的匿名不是真正的匿名，而是一种伪匿名(Pseudo-anonymity)，因为交易信息中心记录了使用者的数字签名，可以根据交易日志追踪某个账户的历史活动，但是用户的比特币账户和现实身份是无关的，一个用户也可以创建多个独立不相干的比特币账户。真正匿名的货币是现实中的纸币，货币的使用与使用者的身份毫无关系，只不过相比于数字货币，不便于管理。</li><li>一旦比特币账户与现实世界发生交互，比如用比特币购买现实中的商品，就会导致账户与显示身份的关联，破坏匿名性，因为大数据分析可以在现实交易和比特币交易之间寻找联系。</li><li>比特币系统运行在应用层，底层的网络层可以通过保护ip的方式来实现匿名性，比如洋葱网络的多路径转发，每一个转发节点都只能知道上一个节点的位置，但无法知道整个发送路径以及原发送者的地址，如此就保护了发送者的ip。应用层实现匿名性的一种方法是 coin mixing，把多个用户的比特币混在一起，一个账户每次操作的比特币不再是原来保存的币，而是从多个用户的币池里随机抽取得到的，但是 coin mixing 实现起来比较复杂，风险也比较大，因为这样一个去中心化的系统中很难建立一个绝对可信的 coin mixing 服务。</li><li>零知识证明(zero knowledge proof)是指证明者向验证者证明一个陈述是正确的，而无需透露除该陈述是正确的外的任何信息。零知识证明的数学基础是同态隐藏，同态隐藏有三个性质：<ul><li>如果 x，y 不同，那么它们的加密函数值 E(x) 和 E(y) 也不相同。(和哈希函数不同，是完全无碰撞的)</li><li>给定 E(x) 的值，很难反推出 x 的值。</li><li>给定 E(x) 和 E(y) 的值，很容易计算出某些关于 x，y 的加密函数值。可以通过 E(x) 和 E(y) 计算出 同态加法 E(x+y) 和 同态乘法 E(xy) 的值，进而可以扩展到任意多项式。</li></ul></li><li>比如A要向B证明他知道一组 x 和 y 的值使得 x+y=7 ，且不能让B知道 x 和 y 的具体数值。方法是，A向B发送 E(x) 和 E(y) 的值，B使用 E(x) 和 E(y) 计算出 E(x+y) 的值，然后B计算 E(7) 的值，如果 E(x+y) 和 E(7) 相等，说明A确实知道这样一组 x 和 y 。</li><li>零知识证明的一个应用是盲签。在 1.3 一节中提到过，防止双花攻击的一种中心化实现方法是建立央行，央行给每个比特币唯一的编号，通过编号记录交易和持有人，但这里的央行对交易和用户进行了关联，可以检索出用户的交易日志，匿名性比较差。而在盲签的实现方法中，给比特币提供编号的是用户而不是央行，交易发送方 A 设定一个编号 x ，然后将 E(x) 发送给央行，央行用自己的私钥对 E(x) 加密得到 C(E(x)) 再返回给 A 。之后 A 把 x 和 C(E(x)) 发送给交易接收方 B ，B 基于 x 计算出 E(x) ，同时使用央行的公钥解密出另一个 E(x) ，如果两个 E(x) 相等，说明交易的比特币是可靠的，因为既验证了 A 设置的编号，又验证了央行的签名。盲签的匿名性在于，央行在签名时不知道具体的比特币编号，也就无法追踪交易双方的账户。</li><li>比特币系统提供了伪匿名性，但无法消除关联性(交易日志)。由此，零币和零钞的设计动机就是在协议层基于密码学原理实现完全的匿名性。<ul><li>零币(zerocoin)系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联，因为已经混淆了币的来源，原理类似于上面提到的 coin mixing。</li><li>零钞(zerocash)系统使用 zk-SNARKs 协议，不依赖基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要的关键属性的证明，区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行。</li></ul></li><li>像零币和零钞这种强匿名性的加密货币并没有成为主流，原因有三：一是因为系统为了实现强匿名性而牺牲了效率，二是对强匿名性有需求的用户并不是很多，三是因为系统只实现了区块链内部的强匿名性，在与现实世界交互时依然存在隐患。</li></ul><h2 id="1-12-反思"><a href="#1-12-反思" class="headerlink" title="1.12 反思"></a>1.12 反思</h2><ul><li>哈希指针在具体的实现中是只有哈希没有指针，哈希与区块的对应关系存储在一个 key-value 数据库中，常用的是 levelDB，区块链所谓的链表结构实际上是一个 key-value 数据表。</li><li>如果多人共用一个账户，把私钥截断成几段分开保存是不安全的。首先只要一个人丢失了他的那部分，所有人的钱都没了。再者，只有部分私钥也能降低暴力破解的难度，比特币账户的私钥有256位，假设有一半的私钥，穷举空间就从 $2^{256}$ 减少到了 $2^{128}$ ，所以知道一半私钥，破解难度就降低了 $2^{128}$ 倍，而不是简单地降低一半。更安全的方法是使用多重签名，对账户的每个使用者都生成独立的256位私钥。</li><li>分布式共识已经被科学家证明是不可能的了，所以比特币系统实际上并没有取得真正的分布式共识。真正的共识一旦形成就不能再修改，而区块链中可以通过分叉攻击实现回滚，否定当前的主链。</li><li>比特币的总量是一定的，所以比特币本身是稀缺品。稀缺品不适合作为货币，因为随着社会财富的增加，比特币会越来越值钱，拥有比特币的人会越来越富，没有比特币的人越来越难追上别人，贫富差距会失衡。目前比特币的涨幅已经超过了房价。</li><li>不需要担心量子计算对加密货币的破坏。首先，量子计算机距离投入使用还有很长的时间。其次，一旦量子计算得到应用，传统金融业的加密体系会比比特币系统更脆弱，比特币系统应用了非对称加密和不可逆的哈希函数，即使是量子计算机也很难短时间内暴力破解，所以该担心的应该是网银支付宝这类平台。</li></ul><h1 id="2-以太坊"><a href="#2-以太坊" class="headerlink" title="2 以太坊"></a>2 以太坊</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li>比特币简称 BTC，货币的最小单位是 satoshi(中本聪的“聪”)。以太坊简称 ETH，其中的货币称为以太(Ether)，货币的最小单位是 wei(戴伟的“伟”)。</li><li>比特币被称为区块链1.0，以太坊被称为区块链2.0，以太坊针对比特币系统设计中的一些问题进行了改善，例如：<ul><li>出块时间降到十几秒，为适应新的出块时间采用了基于ghost协议的共识机制。</li><li>采用了新的 mining puzzle ，比特币的 mining puzzle 比拼的是穷举哈希值的算力，导致的结果就是挖矿设备的专业化，很多人认为这违背了去中心化的理念，而以太坊的 mining puzzle 对内存(或显存)的需求很大，称为 memory hard mining puzzle ，一定程度上限制了 ASIC 芯片的使用。</li><li>用权益证明(proof of stake, POS)取代工作量证明(proof of work, POW)，新区块不再通过耗费资源挖矿产生，而是有币的人共同投票选举产生。POW是竞争思维，而POS是合作思维。</li><li>支持智能合约(smart contract)。比特币是去中心化的货币系统(decentralized currency)，使货币摆脱了政府司法的管制，完全由密码学原理和共识机制维护运行。以太坊受其启发设计了去中心化的合约(decentralized contract)，使合约的实现和判定也摆脱政府管制，用技术手段取代司法手段。去中心化的好处是完全统一规则，不同的国家、地域都遵循同一套共识机制，使得跨国活动更方便。</li></ul></li></ul><h2 id="2-2-账户"><a href="#2-2-账户" class="headerlink" title="2.2 账户"></a>2.2 账户</h2><ul><li>比特币采用基于交易的账本，不显式记录账户余额，余额只能通过UTXO推算得到，这种模式的好处是隐私性比较好，但是使用不方便，比如 A 有10个比特币，向 B 转账3个比特币，就需要显式地把多出来的7个币转回给自己，不然就成了交易费，这是因为不记录账户余额，所有的比特币流动都需要显式地用交易来记录，没有指定去向的币就会被当做交易输入输出的差额，也就是交易费。</li><li>以太坊采用基于账户的记账模式，更接近现实中银行账户的概念，没有参与交易以太币会被当做余额存在原账户。交易中的每个以太币只需要知道来自哪个账户就够了，不需要像比特币一样支持回溯币的来源。</li><li>以太坊的好处是能够天然防御双花攻击，因为交易可以回滚，但账户扣了钱是不能回滚的，花两次就是扣两次钱。然而以太坊可能会受到重放攻击(replay attack)。双花攻击是花钱的人不诚实，通过回滚交易使一份钱可以花两次，而重放攻击是收钱的人不诚实，通过重复广播交易使得花钱的人被扣两次钱。比特币不需要专门防御重放攻击，因为比特币系统是可以追溯币的来源的，UTXO的记录已经能够保证一份钱不会花两次，可以同时防御双花攻击和重放攻击。以太坊防止重放攻击的方法是在交易信息中记录该账户交易的次数(nonce，比特币里的nonce指的是随机数，这里则相当于计数器)，nonce 每次加一，当做交易的ID，因为交易有签名保护，所以交易ID是无法篡改的。</li><li>以太坊账户分为外部账户(externally owned account)和合约账户(smart contract account)。外部账户像比特币账户一样通过公钥私钥控制，状态包括余额(balance)和交易次数(nonce)。合约账户不是用公钥私钥控制，状态包括 balance、nonce、code 和 storage，外部账户发起交易时可以调用合约账户，合约账户也可以调用另一个合约账户，但合约账户不能主动发起交易。</li></ul><h2 id="2-3-状态树"><a href="#2-3-状态树" class="headerlink" title="2.3 状态树"></a>2.3 状态树</h2><ul><li>以太坊使用的账户地址是160bits，一般表示成40位16进制的数。虽然地址格式和比特币账户不一样，但原理都是对公钥取哈希。</li><li>比特币系统的每个区块中都会构建一个 Merkle tree，叶节点仅包含本区块内的交易， Merkle tree 生成后就不可更改了。所以每新增一个区块都会构建一个 Merkle tree，但是叶节点不会超过4000个交易。</li><li>而以太坊是基于账户的记账，Merkle tree 的叶节点是账户而不是交易，为了确保所有全节点对根哈希值达成共识，也为了提供 Merkle proof，所有账户必须全部参与 Merkle tree 的构建，无论它们的余额有没有发生变动。但是实际上发生改变的账户只有很少一部分，所以这种方案又费时间，效率又低，所以不可能每新增一个区块就重新构建一次 Merkle tree。</li><li>实际上，用和比特币系统里一样的 Merkle tree 本身就是不行的，因为每个账户作为一个叶节点的话，叶节点会非常多，查找和更新的效率很低。叶节点也必须进行排序，因为如果不排序，每个全节点构建出的 Merkle tree 就很可能是不同的。比特币系统中不用考虑排序是因为 Merkle tree 是由有当前区块记账权的用户决定的，其他用户只需要认同就够了，而全体账户状态不可能打包进单独一个区块，所以全体账户的 Merkle tree 不能由一个人决定，需要全体的共识。即使对叶节点进行排序也是不可行的，因为如果有人创建了新账户，插入新节点的代价非常高，可能大部分 Merkle tree 的非叶节点都要改变，跟重新构建 Merkle tree 几乎没区别。</li><li>以太坊使用的数据结构是 MPT(Merkle Patricia Tree)，是一种融合Merkle tree 和 trie tree 得到的结构。前缀树的特性会带来以下优点：<ul><li>由于账户是十六进制的，所以树中一个节点最多只有17个子节点(0~f，外加一个结束标志符)。</li><li>以太坊账户地址都是40位的，在前缀树中的查找效率比较平均。</li><li>原始的 Merkle tree 使用哈希值索引，有很小的概率出现哈希碰撞，但前缀树永远不可能出现索引碰撞。</li><li>只要给定的输入(全体账户集合)相同，即使顺序打乱，得到的树也是相同的。</li><li>插入和更新是局部性的，不会影响无关节点。</li></ul></li><li>patricia tree 是对 trie tree 的改进，进行了路径压缩，因此又叫做压缩前缀树。如果一颗子树是一条链，也就是每个节点只有一个子节点，就把它压缩成一个节点，节点内容就是这条链代表的字符串(将一串 branch node 替换为一个 extension node)。不过当插入新节点时，压缩的节点可能需要展开。在键值分布稀疏的情况下，压缩的效果比较好，也就是路径很长但分支很少，以太坊账户160bits，现存的账户数量与整个状态空间 $2^{160}$ 相比是相当稀疏的，所以理论上 MPT 的压缩效率非常高。实际上，以太坊地址设定成160位就是为了稀疏性，使用长地址是这样一个去中心化系统防止地址碰撞的唯一方法。</li><li>MPT 的根哈希值可以防止账户篡改，提供的 Merkle proof 可以让轻节点验证账户余额。此外 Merkle proof 也可以证明某个账户是不存在的，因为 MPT 和 sorted Merkle tree 都是有序树，都可以定位到不存在的账户应该在的位置，然后把对应的 Merkle proof 发给轻节点，轻节点验证失败从而得知账户不存在。</li><li>因此以太坊中也是每新增一个区块就构建一次 MPT，但区别在于树中的大部分节点都是共享自前一区块的 MPT，只修改新区块影响到的账户的分支。之所以要对每个区块保存一个 MPT，而不是只维护一个 MPT，是为了保留历史记录，当区块链出现分叉时会重新选择主链，被淘汰的分叉就需要根据历史的 MPT 将账户数据进行回滚，回滚到分叉点后再沿着主链更新主链的 MPT。虽然交易可以通过推算交易信息来回滚，不太需要历史状态，但以太坊的智能合约很复杂，必须依赖历史状态才能回滚。</li><li>MPT的非叶节点存储的是账户地址的前缀，也就是账户的索引，而 MPT 的叶节点存储的是账户完整地址和账户状态的 key-value 对，这里的账户状态 value 是基于 RLP 编码规则进行序列化后的结果，因为账户的状态最终都能表示成可嵌套的字节数组，所以用 RLP 编码比较方便。</li></ul><h2 id="2-4-交易树和收据树"><a href="#2-4-交易树和收据树" class="headerlink" title="2.4 交易树和收据树"></a>2.4 交易树和收据树</h2><ul><li>除了状态树，以太坊还采用了交易树和收据树，这三个树的根哈希值都保存在块头中，它们的结构都是 MPT，可能是因为三种树用同一个结构便于管理代码。区别在于：<ul><li>状态树的索引是账户地址，交易树和收据树的索引是交易在区块中的序号，该序号由发布区块的节点决定。</li><li>状态树包含了系统中所有账户的信息，而交易树和收据树只包含当前区块的交易信息。</li><li>状态树共享了前一区块 MPT 的节点，但每个区块的交易树和收据树都是独立的。</li></ul></li><li>交易树和收据树可以提供 Merkle proof。交易树的 Merkle proof 用来证明交易在区块中的存在性和合法性。收据树的 Merkle proof 用来验证交易的结果。</li><li>以太坊采用了布隆过滤器，布隆过滤器是把一个大的集合映射到一个稠密的向量上，将元素是否存在于集合中的查询操作的时间复杂度，从线性降低到常数，但缺陷在于可能出现 false positive ，而且布隆过滤器只支持添加元素和查找元素，不支持删除元素的操作。</li><li>以太坊的区块在块头里存储了其内部所有交易归结成的布隆过滤器，当要在整个区块链中查找某个交易时，先用各个块头里的布隆过滤器判断，判断存在后再从对应区块的交易树和收据树中再次查找，因为布隆过滤器是不准的。这种使用了布隆过滤器的二次查找的机制的好处在于，提高了查找效率，布隆过滤器只有 false positive 而没有 false negative ，所以能够帮助过滤大部分无关的区块。此外，这使得只存储了块头的轻节点也能进行初步查询，缩小区块范围后再向全节点请求 Merkle proof ，大大提高了查找效率。 </li><li>以太坊的运行过程是一个交易驱动的状态机(transaction-driven state machine)，状态机的每一个状态都是一棵状态树，存储了全部账户的状态，通过进行交易，使得状态机转移到下一个状态。比特币也可以看作是一个交易驱动的状态机，只不过其中的状态是 UTXO 。以太坊和比特币的状态机都是确定性状态机，因为发生交易时，每个节点都要进行状态转移，所以状态转移必须是确定性的，从而保证各个节点的一致性。</li><li>以太坊和比特币一样，交易的收款账户可能是全节点没记录的，因为创建新账户不需要通知任何节点，只有新账户第一次收到钱时才需要作为新节点插入到状态树中。</li><li>以太坊的状态树之所以要包含全部账户，是为了方便查找。假如只包含与当前区块内交易相关的账户，要查找不在其中的账户的信息，就需要回溯到前面的区块去查找，如果一个账户很久没有进行过交易，查询余额就需要回溯非常长的距离。如果查询的账户是新建的没有进行过交易的账户，就要一直查到创世纪块，而在存储了全部账户的状态树中查询就很方便，只要这一棵树上查不到就说明是没进行过交易的账户。</li></ul><h2 id="2-5-GHOST"><a href="#2-5-GHOST" class="headerlink" title="2.5 GHOST"></a>2.5 GHOST</h2><ul><li>区块链底层的 P2P 网络采用拓扑结构无关的无脑 flooding 来传播信息，新发布的区块传到各个节点可能需要十几秒，比特币的出块时间设成10分钟是绰绰有余的，只有几乎同时发布的两个新区块才可能造成临时性的分叉。然而，以太坊的出块时间降低到了十几秒，发布间隔长达数秒的两个区块也有可能导致临时分叉，所以以太坊中这种临时性分叉成为了常态。比特币中分叉概率比较低，所以规定竞争失败的分叉中的区块和铸币奖励直接作废是可以接受的，但如果以太坊也这么规定对矿工就太不友好了。</li><li>以太坊采用了GHOST协议解决该问题，给予竞争失败的分叉一定的安慰奖励。比特币中竞争失败的分叉中的区块都叫做 orphan block 或 stale block ，以太坊换了一个不那么悲观的名字，叫做 uncle block 。发布区块的人事先不知道自己的区块是否会成为 uncle block ，当再有新区块选定了某个分支进行扩展时，其余分支的区块才确定是 uncle block 。主链上的侄子区块(和 uncle block 同层次的下一个区块)可以选择包含至多两个叔叔区块，每包含一个叔叔区块就额外获得 $\frac{1}{32}$ 的出块奖励，同时被包含的叔叔区块的发布者获得 $\frac{7}{8}$ 的出块奖励，所以这是个双赢的协议，能够鼓励区块链中出现分叉时及时合并。</li><li>由于网络传输的延迟，侄子区块发布时可能不知道叔叔区块的存在，或者侄子区块仅仅出于自私，选择牺牲自己的 $\frac{1}{32}$ 来不让对方得到 $\frac{7}{8}$ ，结果都是侄子区块不选择包含叔叔区块。此时，协议规定侄子区块后续的区块还可以选择是否包含叔叔区块，因为以太坊不考虑论资排辈，所以分叉后的叔叔区块对于后续主链上的区块来说都是叔叔区块，只不过每隔了一代，叔叔区块的收益就减少 $\frac{1}{8}$ ，直到减少到 $\frac{2}{8}$ ，再远的叔叔区块就没有奖励了，而侄子区块的 $\frac{1}{32}$ 的奖励是恒定的，所以七代以内的叔侄都是双赢的。这个机制抑制了侄子区块损人不利己的自私行为，就算当前的侄子区块不想双赢，剩下的六个侄子里也总会有愿意包含叔叔区块的(没有绝对垄断的情况下)，损人不利己就变成单纯的不利己了。同时，收益递减也鼓励了分叉后叔叔区块尽早同意被包含，因为越晚被包含奖励越少。所以该协议对叔侄两方都有尽早合并的鼓励效果。</li><li>这种机制只适用于临时性分叉，同时侄子愿意包含，叔叔愿意被包含。而对于协议冲突导致的硬分叉和软分叉是不适用的，因为会有一方认为另一方的区块不合法，因此拒绝合并。</li><li>以太坊的以太币数量没有上限，所以不需要像比特币一样，每隔一段时间就把出块奖励减半，人为制造稀缺性，所以比特币会不断升值，而以太币是必定会通胀的。</li><li>让侄子区块包含叔叔区块，仅仅是为了安慰其竞争失败，所以不执行叔叔区块内的交易，因为其中的交易可能与主链上的交易冲突。所以侄子区块只检查叔叔区块的区块头是否合法，不会检查其中的交易是否合法。因此，叔叔区块只有安慰奖励和增加主链比重的作用，block body里存不了任何有用的信息。</li><li>只有分叉的第一个区块才叫做叔叔区块，才能被奖励，而叔叔区块后面扩展的所有区块都会被直接丢弃。如果接收分叉的全部区块，就会降低分叉攻击的代价，因为就算分叉攻击失败了，整条分叉也会被主链全部接收，攻击者能得到不少的奖励。</li></ul><h2 id="2-6-挖矿算法"><a href="#2-6-挖矿算法" class="headerlink" title="2.6 挖矿算法"></a>2.6 挖矿算法</h2><ul><li>比特币 POW 的挖矿算法很成功，至今没有被曝出严重的漏洞，但是令人诟病的一点是导致了挖矿设备的专业化。如果挖矿设备没有专业化，用 CPU、GPU、ASIC 挖矿的效率没有如此悬殊，那么挖矿会更加普及，51% attack 也会更加困难。所以以太坊挖矿算法的目标就是 ASIC resistance ，主要思路是增加挖矿算法对内存的需求，要求保留计算的中间结果，也就是 memory hard mining puzzle ，因为 ASIC 使用内存的效率与其他芯片差距不大。</li><li>Litecoin 就是使用了 memory hard mining puzzle ，但是缺点在于求解 puzzle 和验证 puzzle 所需的内存都是相当大的。设计 mining puzzle 的原则是 “ difficule to solve, but easy to verify ” ，所以对内存的消耗应该仅在求解阶段。</li><li>以太坊的 mining puzzle 基于两个数据集，一个 16MB 的 cache 和一个 1GB 的 dataset(也叫DAG)，dataset 是基于 cache 生成的，但是随着计算机内存的不断变大，两个数据集的大小也在不断增加。之所以使用一大一小两个数据集是为了便于验证，轻节点只需要存储 cache ，只有挖矿的矿工才会使用到大的 dataset 。</li><li>cache 的构造方法是先确定一个随机数 seed ，取哈希后加入 cache ，之后每一个新元素都是 cache 中的元素再次取哈希得到的结果。每隔30000个区块重新生成一个 seed ，根据新的 seed 重新生成新的 cache 。cache初始大小 16MB，每隔30000个区块后，新的 cache 比旧的 cache 要大初始大小的 $\frac{1}{128}$ ，也就是 128KB 。</li><li>dataset 中的每个元素也是通过基于哈希的方法从 cache 中取值计算出的结果，初始大小 1GB ，同样每隔30000个区块后重新生成一次，新的 dataset 比旧的 dataset 要大初始大小的 $\frac{1}{128}$ ，也就是 8MB 。</li><li>矿工挖矿的过程就是使用区块头、nonce 和 dataset 计算出一个值，再与 target 比较，因为 dataset 要放在内存中便于访问，所以内存消耗比较大。而轻节点的验证过程，是使用区块头、nonce 和基于 cache 临时计算出的 dataset 中的元素计算出一个值，再与 target 比较，因为验证不赶时间，所以也就不需要存储以直接访问 dataset ，所以内存消耗比较小。</li><li>以太坊为了实现 ASIC resistance ，一方面采用 memory hard mining puzzle ，另一方面一直声称要从 POW 转向 POS ，对 ASIC 厂商也起到了威慑作用。但是 ASIC resistance 也不是没有缺点的，一旦挖矿设备通用化，发动攻击的成本会变低，因为囤积大量 ASIC 芯片除了发动攻击什么也干不了，但囤积 CPU 和 GPU 除了挖矿还能干别的工作，虽然攻击难度不好说，但是攻击的风险和成本确实下降了。</li></ul><h2 id="2-7-难度调整"><a href="#2-7-难度调整" class="headerlink" title="2.7 难度调整"></a>2.7 难度调整</h2><ul><li>比特币每隔2016个区块调整一次挖矿难度，而以太坊每个区块都有可能调整难度，难度调整公式是：<script type="math/tex; mode=display">D(H)=\begin{cases}D_0 & H_i=0 \\max(D_0,P(H)_{H_d}+x\times\zeta_2)+\epsilon & otherwise\end{cases}</script><ul><li>$D(H)$ 是本区块的难度，$H_i$ 是本区块的序号。难度的更新包括基础部分(max)和难度炸弹 $\epsilon$ 两部分。</li><li>$P(H)_{H_d}$ 是本区块的父区块(前一区块)的难度，$x\times\zeta_2$ 用于自调节出块难度，维持稳定的出块速度。</li><li>通过使用 max 函数给难度设定了一个下届 $D_0=131072$ ，挖矿难度永远不会低于这个值。</li></ul></li><li>在自调节的部分中，<script type="math/tex; mode=display">x=\lfloor\frac{P(H)_{H_d}}{2048}\rfloor</script><script type="math/tex; mode=display">\zeta_2=max(y-\lfloor\frac{H_s-P(H)_{H_s}}{9}\rfloor,-99)</script><ul><li>$x$ 是调整的单位，所以难度调整的最小单位是父区块难度的 $\frac{1}{2048}$。</li><li>$\zeta_2$ 是调整的系数，$y$ 和父区块的叔叔区块有关，如果父区块包含了他的叔叔区块，$y$ 就等于2，否则 $y$ 就等于1。之所以考虑叔块是因为当父块包含了叔块时，父块和叔块的发布者都会得到奖励，以太币的供应量会比单个区块多，所以需要适当提高难度以保持货币发行量稳定。</li><li>难度系数的下界定为-99，主要是为了应对黑客攻击或其他意想不到的黑天鹅事件。</li><li>$H <em>s$ 是本区块的时间戳，$P(H) </em>{H_s}$ 是父区块的时间戳，单位都是秒，二者相减就是本区块的出块时间。因为调整的目标是把出块时间稳定在15秒左右，所以以 $y=1$ 为例，假如本区块出块时间是1~8秒，结果是 $\zeta _2=1$ ，表示难度要增加一个单位，假如本区块出块时间是9~17秒，结果是 $\zeta _2=0$ ，表示难度不变，假如本区块出块时间是18~26秒，结果是 $\zeta _2=-1$ ，表示难度要下调一个单位。以此类推。</li></ul></li><li>难度炸弹的定义是：<script type="math/tex; mode=display">\epsilon=\lfloor 2^{\lfloor H'_i\div 100000 \rfloor -2} \rfloor</script><script type="math/tex; mode=display">H'_i=max(H_i-3000000,0)</script><ul><li>因为以太坊计划从 POW 转向 POS ，然而将来采用 POS 的共识机制后挖矿难度会急剧下降，之前矿工花高价购买的矿机就没用了，所以一部分矿工可能会联合起来抵制，拒绝转向 POS 。因此为了不让社区分裂，需要设置难度炸弹，让难度高到矿机也无能为力，那些矿工就不得不接受 POS 了。</li><li>难度炸弹是一个让难度呈指数型增长的因子，指数增长的特点是开始增长缓慢，到了后期增长越来越剧烈。最初设置难度炸弹时没有第二个公式，之所以把参数设置成100000，是为了让将来开始转向 POS 时，难度炸弹恰好开始显露威力。然而人算不如天算，转向 POS 的时间被一再延后，此时绝对不能让难度炸弹提前爆炸，否则出块时间会远远低于十几秒，所以就出现了用 $H’_i$ 取代 $H_i$ 的做法，把 $H_i$ 回调30万个区块，相当于强行把难度炸弹爆炸的时间点延后30万个区块。</li><li>以太坊的发展分成四个阶段：Frontier、Homestead、Metropolis 和 Serenity。 Metropolis 又分成 Byzantium 和 Constantinople 两个阶段。我们现在正处于 Byzantium 阶段，难度炸弹的回调也是发生在这个阶段。</li></ul></li></ul><h2 id="2-8-权益证明"><a href="#2-8-权益证明" class="headerlink" title="2.8 权益证明"></a>2.8 权益证明</h2><ul><li>目前比特币和以太坊采用的共识机制是 POW ，缺点是费电，比如比特币系统平均处理一个交易要费大约1000度电，以太坊平均处理一个交易要费大约67度电，以太坊因为挖矿时间短，所以平均下来的能耗比比特币要低，但是仍然远远高于现实中银行的能耗。</li><li>POW 烧钱主要是因为矿工一方面要买设备竞争算力，另一方面设备运行要耗费电力，但这一过程本质上就是经济实力的比拼。POS 的主要思想是，既然从头到尾都是在拼钱，不如省去烧钱的阶段，直接比较钱多钱少当做竞争结果，从间接拼钱变成了直接拼钱，省下来的钱还可以投入以太坊的建设中，何乐而不为。</li><li>采用 POS 的加密货币，一般要在发行前预留一部分货币给开发者，或者出售一部分货币换取开发资金。货币发行后，每个用户的投票权比重就取决于他持有的货币数量。</li><li>对于采用 POW 的加密货币，维护其安全的资源不是一个闭环，例如比特币的用户可以使用比特币系统外的资产来购入挖矿设备，当算力超过全体用户的50%时就可以发动攻击，虽然比特币的抗攻击性比较好，但对于一些用户不多的小币种就很容易被扼杀在摇篮里。相反，在采用 POS 的加密货币系统里，用户在系统外的资产不会直接影响到系统内的投票权，如果想要发动51% attack，必须要在系统内获得50%以上的该货币资产，这与在系统外购买挖矿设备不同，在系统内大量购入货币会导致货币剧烈升值，一定程度上起到了抵制恶意收购的作用，所以相当于系统内部自发地维护安全，所以对于采用 POS 的加密货币，维护其安全的资源是一个闭环。</li><li>POW 和 POS 不是互斥的，有的货币就采用了混合策略，使用户挖矿的难度与用户持有的资产相关，但是难点在于防止用户贫富差距越来越大。</li><li>早期 POS 的设计面临的一个问题是 nothing at stake，也就是两边下注。在挖矿过程中同时扩展两个分叉是费力不讨好的，所以一般只选择一个分叉扩展，而在 POS 中，给两个分叉都投票是很容易的。</li><li>以太坊准备采用的 POS 协议称为 Casper the Friendly Finality Gadget(FFG)，在过渡阶段也是要和 POW 混合使用的，为 POW 提供 finality 。finality 是一种状态，该状态下的交易不会被回滚取消，就算是分叉攻击也不能将其回滚，相比之下，单纯的 POW 是缺乏这种 finality 状态的保证的。</li><li>为了实现 finality 状态，Casper 协议引入了验证者(validator)的角色，成为验证者需要投入一定数量的以太币作为保证金。验证者的作用是投票决定最长合法链(主链)，投票比重取决于保证金的比重。每挖出100个区块就作为一个 epoch ，由验证者投票决定是否成为 finality ，投票过程类似于数据库的 two-phase commit ，投票分成两轮，每一轮都有超过 $\frac{2}{3}$ 的验证者同意才能通过。但是实际应用时会对原始协议进行优化，比如精简到只有一轮投票， epoch 的大小也会减小到50个区块。验证者履行职责会得到奖励，反之被发现有不良行为就会被扣除一部分保证金，扣除保证金是直接销毁，相当于减少系统总资产。</li><li>因此，只有验证者有权利投票决定主链，两边下注会被视为不良行为，所以也就解决的 nothing at stake 的问题。</li><li>目前之所以还没有采用 POS 是因为还不成熟，而 POW 则是经过时间检验的成熟机制，所以目前的主流还是采用 POW 。EOS(柚子币)就是一种采用 POS 的加密货币，不过目前仍然处于不断调试改 bug 的过程中。</li></ul><h2 id="2-9-智能合约"><a href="#2-9-智能合约" class="headerlink" title="2.9 智能合约"></a>2.9 智能合约</h2><ul><li>智能合约是运行在区块链上的一段代码，代码的逻辑定义了合约的内容。智能合约的账户保存了合约当前的运行状态，包括余额(balance)、交易次数(nonce)、合约代码(code)和存储(storage，数据结构是一棵 MPT)。智能合约代码最常用的语言是 Solidity，语法和 JavaScript 接近。</li><li>智能合约的代码写完后，要编译成 bytecode 。</li><li>智能合约的创建是由一个外部账户向0x0地址发起交易，转账金额是0，但是要支付汽油费(交易费)，合约的代码放在交易的 data 域里。</li><li>智能合约运行在 EVM(Ethereum Virtual Machine) 上，目的是提供可移植性或平台无关性。EVM 的寻址空间是256位，比当前通用PC的64位要高很多倍。</li><li>智能合约是一种 Truing-complete Programming Model ，可以实现很多比特币系统无法实现的功能。但也衍生出很多问题，比如交易可能引发死循环，系统对死循环束手无策，因为死循环属于停机问题(Halting Problem)，是不可解的，不像 NPC 一样虽然很难但是可解。这类停机问题的处理方法是把问题推给发起交易的用户，系统会向发起交易的用户收取汽油费，在执行合约的过程中动态计算汽油费，执行合约需要的指令越多越复杂，汽油费就越贵，所以死循环的交易会让发起者承担巨额费用。</li><li>以太坊中的交易具有原子性，一旦遇到异常，整个交易全部回滚，不会只执行部分交易，所以也就不需要 try-catch 这种处理异常的语句，直接无脑回滚就完事了。</li><li>比特币系统对区块占用资源的限制方法是限制区块大小，区块大小的上限是写死在协议里的，因为比特币的交易很简单，交易信息的字节数越多消耗的资源就越多。而以太坊不能这么限制，因为以太坊的交易很复杂，字节数很少的交易可能会消耗大量的资源。以太坊通过限制整个区块的汽油费上限(gaslimit)来限制资源，因为交易执行过程中的任何操作都会耗费汽油费，设置 gaslimit 就是限制了操作的数量和复杂度上限，而且与比特币不同的是，每个区块的发布者都可以根据前一个区块的 gaslimit 来微调本区块的 gaslimit ，调整幅度是 $\frac{1}{1024}$ ，幅度这么小是因为以太坊出块速度太快，要防止 gaslimit 滚雪球速度过高。</li><li>对于一个区块，是先执行交易内容再挖矿，因为交易内容决定了 block header 中的三棵树的根哈希值，只有先算出三个根哈希值，才能对 block header 取哈希，尝试 nonce 值来挖矿。</li><li>执行失败的交易也可能会发布到区块中，因为矿工只有发布才能收到汽油费。判断交易是否成功就靠三棵树中的收据树，每个交易执行完后都生成一个收据，收据中包含了交易的状态。</li><li>以太坊不支持并行和并发，因为交易驱动的状态机必须是确定性的。同理，以太坊也不能生成真正的随机数，只能生成伪随机数，否则每个节点执行的结果就会不一样。</li><li>智能合约的代码是不能更改的，所以只要最初的代码有 bug，就会成为永久的漏洞，最后只能弃用该合约。可见，不可篡改性是一把双刃剑，一方面保证了合约的公信力，另一方面也给漏洞处理增添了困难。</li><li>Solidity 语言的内容略~</li></ul><h2 id="2-10-TheDAO"><a href="#2-10-TheDAO" class="headerlink" title="2.10 TheDAO"></a>2.10 TheDAO</h2><ul><li>略</li></ul><h2 id="2-11-反思"><a href="#2-11-反思" class="headerlink" title="2.11 反思"></a>2.11 反思</h2><ul><li>智能合约并不智能，只是一种按照写死的代码执行的自动化合同。</li><li>区块链的不可篡改性不是绝对的，写死在链上的东西至少还可以被硬分叉软分叉取消，只不过修改意见很难被通过罢了，所以没有什么是真正不可篡改的，不能盲目迷信。</li><li>比特币的脚本语言表达能力简陋，所以支持的功能很少。智能合约的 Solidity 语言图灵完备、表达能力很强，但是容易出现安全漏洞。所以应该寻找一种表达能力适中的编程语言。</li><li>智能合约不会因为公开性而有多安全，因为有时间读代码检查安全性的人就不多，其中有能力检查出漏洞的人就更少了。</li><li>去中心化的理念在于用户自己拥有决定权，只有用户决定做什么或支持什么，而不能是社区强迫用户做什么。所以用户可以选择分叉单干，也可以拒绝更新新协议，只不过后果要自己承担。</li><li>区块链不适合分布式计算，因为区块链的设计都是为了保证去中心化和共识机制，系统整体的运行效率其实是相当低的，想做分布式计算还是要用主流的云计算平台。</li><li>去中心化不一定比中心化更好。去中心化系统中的决策都是靠公投决定的，少数服从多数，多数人的决定不一定是最好的。其次，技术手段不一定比司法手段更安全、更公平，现实世界的法治体系是经过时间检验一路完善下来的结果，相比之下，区块链技术并不十分成熟。</li></ul><h2 id="2-12-美链"><a href="#2-12-美链" class="headerlink" title="2.12 美链"></a>2.12 美链</h2><ul><li>略</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="https://shivakasu.cn/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://shivakasu.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="区块链" scheme="https://shivakasu.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>美语连读规则</title>
    <link href="https://shivakasu.cn/2020/05/15/english2/"/>
    <id>https://shivakasu.cn/2020/05/15/english2/</id>
    <published>2020-05-15T07:31:20.000Z</published>
    <updated>2020-05-15T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-linking-consonant-to-vowel"><a href="#1-linking-consonant-to-vowel" class="headerlink" title="1 linking consonant to vowel"></a>1 linking consonant to vowel</h3><ul><li>when a word ends with a consonant and its next word starts with a vowel, let this consonant be the start of the second word.</li><li>“hold on” pronounced as “hol don”(/hoʊl dɑːn/)</li><li>“like it” pronounced as “li kit”(/laɪ kɪt/), “e” is swallowed</li><li>“deep end” pronounced as “dee pend”(/di pend/)</li><li>“get up late” pronounced as “ge tu plate”(/ɡe tʌ pleɪt/)</li><li>“picked out” pronounced as “pick dout”(/pɪk taʊt/), “ed” pronounced as “/t/“, “e” is swallowed</li><li>“this guy” pronounced as “thi sguy”(/ðɪ sɡaɪ/)</li><li>“come on in” pronounced as “co mo nin”(/kʌ mɑː nɪn/)</li><li>“turn it off” pronounced as “tur ni toff”(/tɜːr nɪ tɔːf/)</li><li>“time is it” pronounced as “ti mi sit”(/taɪ mɪ zɪt/)</li><li>“leave it on” pronounced as “lea vi ton”(/li vɪ tɑːn/)</li><li>“this is a” pronounced as “thi si sa”(/ðɪ sɪ zə/)</li><li>“have an apple” pronounced as “ha va napple”(/hæ və næpl/)</li><li>“we’ve already” pronounced as “we veal ready”(/wi vɔːl redi/)</li></ul><h3 id="2-linking-consonant-to-same-consonant"><a href="#2-linking-consonant-to-same-consonant" class="headerlink" title="2 linking consonant to same consonant"></a>2 linking consonant to same consonant</h3><ul><li>when a word ends with a consonant and its next word starts with the same consonant, pronounce only once but a litttle bit longer or stronger. It seemed little different when pronounced as the first end or the second start.</li><li>“turned down” pronounced as “turn down”</li><li>“speaks Spanish” pronounced as “speak Spanish”</li><li>“black cat” pronounced as “bla cat”</li><li>“help Paul” pronounced as “help all”</li></ul><h3 id="3-final-stop-between-consonants"><a href="#3-final-stop-between-consonants" class="headerlink" title="3 final stop between consonants"></a>3 final stop between consonants</h3><ul><li>when a stop(爆破音, bpdtkg六个音) is followed by another consonant, do not release the stop. 只做出即将发爆破音的嘴型，形成短暂停顿，但不发音</li><li>pop music</li><li>that man</li><li>good book</li><li>drop down</li><li>can’t go</li><li>keep trying</li></ul><h3 id="4-linking-vowel-to-vowel"><a href="#4-linking-vowel-to-vowel" class="headerlink" title="4 linking vowel to vowel"></a>4 linking vowel to vowel</h3><ul><li>when a word ends with a vowel and its next word starts with a vowel, do not pause between the words(不要停止声带振动). To pronounce both of the vowel completely and smoothly, we insert a “y” (/j/) after a front vowel (i, ɪ, ɛ, æ) and insert a “w” (/w/) after a back vowel (ɑ, u, ʌ, ɔ, ʊ).</li><li>“go out” pronounced as “go-wout”</li><li>“how are you” pronounced as “how-ware you”</li><li>“I am” pronounced as “I-yam”</li><li>“they are” pronounced as “they-yare”</li></ul><h3 id="5-linking-vowels-within-a-word"><a href="#5-linking-vowels-within-a-word" class="headerlink" title="5 linking vowels within a word"></a>5 linking vowels within a word</h3><ul><li>ditto add a “y” (/j/) or “w” (/w/) sound between the two vowels.</li><li>“client” into “cliyent”</li><li>“science” into “sciyence”</li><li>“serious” into “seriyous”</li><li>“quiet” into “quiyet”</li><li>“appreciate” into “appreciyate”</li><li>“museum” into “museyum”</li><li>“cooperate” into “cowoperate”</li><li>“experience” into “experiyence”</li><li>“diet” into “diyet”</li><li>“negotiate” into “negotiyate”</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="英语笔记" scheme="https://shivakasu.cn/categories/%E8%8B%B1%E8%AF%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="英语" scheme="https://shivakasu.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="口语" scheme="https://shivakasu.cn/tags/%E5%8F%A3%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>English with Lucy note（更新中）</title>
    <link href="https://shivakasu.cn/2020/05/14/english1/"/>
    <id>https://shivakasu.cn/2020/05/14/english1/</id>
    <published>2020-05-13T18:05:20.000Z</published>
    <updated>2020-06-02T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="160106-make-or-do"><a href="#160106-make-or-do" class="headerlink" title="160106 make or do"></a>160106 make or do</h3><ul><li>“make” usually means to create sth. didn’t exist before. “do” usually means to complete tasks that already exist.</li><li>make：coffee, tea, offer, suggestion, promise, mistake, complaint, sound, noise, discovery, money, profit, loss, investment, bet, fortune</li><li>do：homework, test, experiment, interview, course, shopping, dishes, ironing, well, badly, good, bad, sb’s best/worst</li><li>exceptions：do business, make my bed(整理床铺), do drawing, do hair(梳头), do make-up(化妆)</li></ul><h3 id="160119-ed-pronunciation"><a href="#160119-ed-pronunciation" class="headerlink" title="160119 -ed pronunciation"></a>160119 -ed pronunciation</h3><ul><li>/id/：t+ed (wanted), d+ed (needed)</li><li>/t/：p+ed (helped), k+ed (asked), f+ed (sniffed), gh+ed (laughed), sh+ed (washed), ch+ed (watched), ss+ed (kissed), c+ed (danced), x+ed (fixed), ed前一个音都是声带不振动的音</li><li>/d/：l+ed (called), n+ed (cleaned), r+ed (offered), g+ed (damaged), v+ed (loved), th+ed (breathed), s+ed (used), w+ed (followed), y+ed (enjoyed), z+ed (amazed), ed前一个音都是声带振动的音，对比 laughed 和 loved 可以感受到声带振动的区别</li></ul><h3 id="160128-in-or-on-or-at-preps-of-time"><a href="#160128-in-or-on-or-at-preps-of-time" class="headerlink" title="160128 in or on or at - preps of time"></a>160128 in or on or at - preps of time</h3><ul><li>at + specific time：at 3 o’clock, at sunrise, at noon, at bedtime, at night, at present, at the same time, at the moment, at the weekend(UK), at Christmas(没有 Day)</li><li>in + longer peroids of time：in July, in 1990, in summar, in the future, in the past, in the morning, in the afternoon(night 和 noon 要用 at，算是例外)</li><li>on + specific dates/days：on Monday, on birthday, on Christmas Day, on the 10th of June</li><li>in/on can be replaced by this/next/last/every：this Sunday, last month</li></ul><h3 id="160201-much-or-many-or-lots-of-a-lot-of"><a href="#160201-much-or-many-or-lots-of-a-lot-of" class="headerlink" title="160201 much or many or lots of(a lot of)"></a>160201 much or many or lots of(a lot of)</h3><ul><li>“much” is followed by uncountable nouns, usually used in negative form and interrogative form. e.g. “I don’t have much water. / Do you have much homework?”</li><li>“many” is followed by countable nouns. e.g. “I have two apples.”</li><li>“lots of” is followed by both uncountable and countable nouns. Because “much” is too formal, “lots of” is more frequently used in affirmative form. e.g. “I have lots of water.”</li></ul><h3 id="160218-5-common-British-Expression"><a href="#160218-5-common-British-Expression" class="headerlink" title="160218 5 common British Expression"></a>160218 5 common British Expression</h3><ul><li>“all right” is used to greet someone at the same time as asking if they are well. e.g. “All right, John?””Not bad thanks, and you?”</li><li>“I’m easy” is used to say that you do not mind which choice is made. e.g. “Shall we go to the Indian restaurant, or would you prefer Chinese food?””I’m easy.”</li><li>“be on about”, If you ask someone what they are on about, you are asking that person, often in a slightly annoyed way, what they mean. e.g. “what’s he on about?”</li><li>“Bob’s your uncle” is used to mean that something will happen very quickly and simply. e.g. “Just tell them you’re a friend of mine and, Bob’s your uncle, you’ll get the job.”</li><li>“easy-peasy” means very easy, is an informal or child’s word. 朋友之间吹牛开玩笑时可以用</li></ul><h3 id="160601-a-vlog"><a href="#160601-a-vlog" class="headerlink" title="160601 a vlog"></a>160601 a vlog</h3><ul><li>“swallow sb’s pride” means to decide to do something although it will make sb feel embarrassed or ashamed. e.g. “He was forced to swallow his pride and ask if he could have his old job back.”</li><li>“bank holiday” is an official holiday when banks and most businesses are closed for a day.</li></ul><h3 id="160604-cloud-idioms"><a href="#160604-cloud-idioms" class="headerlink" title="160604 cloud idioms"></a>160604 cloud idioms</h3><ul><li>“rain cats and dogs” means to rain very heavily. e.g. “Don’t forget to take your umbrella. It’s raining cats and dogs out there.”</li><li>“every cloud has a silver lining” used to emphasize that every difficult or unpleasant situation has some advantage. 塞翁失马焉知非福</li><li>“every silver lining has a cloud” has the opposite, negative meaning.</li><li>“have sb’s head in the clouds” means 异想天开，有不切实际的想法，想屁吃</li><li>“be on cloud nine” means to be extremely happy and excited.</li></ul><h3 id="160616-some-definitions-of-get"><a href="#160616-some-definitions-of-get" class="headerlink" title="160616 some definitions of get"></a>160616 some definitions of get</h3><ul><li>means to obtain. e.g. He climbed over the fence to get his ball back.</li><li>means to become. e.g. Your coffee is getting cold.</li><li>means to be ill. e.g. Everyone seems to be getting the flu.</li><li>means to cause. e.g. I can’t get this printer to work!</li><li>means to move. e.g. Get out of here!</li><li>means to arrive. e.g. What time does he normally get home from work?</li><li>means to understand. e.g. I think I got the general idea of the chapter.</li></ul><h3 id="160617-5-common-British-Expression"><a href="#160617-5-common-British-Expression" class="headerlink" title="160617 5 common British Expression"></a>160617 5 common British Expression</h3><ul><li>“bits and bobs” means small things or jobs of different types. e.g. “what did you get fot Christmas?” “oh, just bits and bobs really.”</li><li>“gobsmacked” means so surprised that you cannot speak. 目瞪口呆，没有特定的情绪，可以是惊喜也可以是惊吓 e.g. He was completely gobsmacked when he won the award.</li><li>“lose the plot” means to no longer be able to act normally. 行为怪异莫名其妙 e.g. I can’t believe Stuart did that, he must be losing the plot.</li><li>“take the piss (out of) sb” means to make a joke about someone. e.g. They’re always taking the piss out of him.</li><li>“pass sth with flying colors” means to be very successful in a test. e.g. Lucy passed her university exams with flying colors.</li></ul><h3 id="160623-to-vs-for"><a href="#160623-to-vs-for" class="headerlink" title="160623 to vs. for"></a>160623 to vs. for</h3><ul><li>“to” followed by verb, “for” followed by noun. 配合 to 使用的动词往往动作性、方向性比较强，如 give、go、sell，配合 for 使用的动词目的性相对更强，如 wait、ask、work</li></ul><h3 id="160625-5-common-British-Expression"><a href="#160625-5-common-British-Expression" class="headerlink" title="160625 5 common British Expression"></a>160625 5 common British Expression</h3><ul><li>“a piece of cake” means sth that is very easy to do. e.g. The exam was a piece of cake.</li><li>“break a leg” used for wishing someone good luck, especially before a performance.</li><li>“cost an arm and a leg” means to be extremely expensive. e.g. I’d love to buy a Porsche, but they cost an arm and a leg.</li><li>“pop sb’s clogs” means to die. 委婉的说法 e.g. I think I’ll leave all my money to charity when I pop my clogs.</li><li>“call it a day” means to stop what you are doing because you do not want to do any more or think you have done enough. e.g. You’ve been studying hard. I think you should call it a day.</li></ul><h3 id="160729-5-idioms"><a href="#160729-5-idioms" class="headerlink" title="160729 5 idioms"></a>160729 5 idioms</h3><ul><li>“not be sb’s cup of tea” means not the type of thing of that sb like. e.g. Thanks for inviting me, but ballet isn’t really my cup of tea.</li><li>“beat around the bush” means to avoid talking about what is important. e.g. Don’t beat around the bush - get to the point!</li><li>“move the goalposts” means to change the rules while someone is trying to do something in order to make it more difficult for them. e.g. We’d almost signed the contract when the other guys moved the goalposts and said they wanted more money.</li><li>“be (as) good as gold” means to behave very well. e.g. She’s been as good as gold all morning.</li></ul><h3 id="160924-how-to-ask-for-a-favour"><a href="#160924-how-to-ask-for-a-favour" class="headerlink" title="160924 how to ask for a favour"></a>160924 how to ask for a favour</h3><ul><li>can I ask a favour?</li><li>could you do me a favour?</li><li>could you possibly do me a favour?</li><li>could I ask you to do me a favour?</li><li>I was wondering if I could ask you to do me a favour?</li><li>could you do me a really big favour?</li><li>could you do me a massive favour?</li><li>could you do me a huge favour?</li><li>how to thank them :<ul><li>you’re a lifesaver!</li><li>I really owe you one!</li><li>I owe you big time!</li><li>I owe you a drink!</li></ul></li></ul><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><h3 id="no-gain"><a href="#no-gain" class="headerlink" title="no gain"></a>no gain</h3><p>160109, 160114, 160315, 160630, 160707, 160710, 160711, 160713, 160725, 160802, 160804, 160810, 160916, 160917, 160927, 161010, 161014, 161017, 161019, 161022, 161024, 161027, </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="英语笔记" scheme="https://shivakasu.cn/categories/%E8%8B%B1%E8%AF%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="英语" scheme="https://shivakasu.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="口语" scheme="https://shivakasu.cn/tags/%E5%8F%A3%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>美语弱读规则</title>
    <link href="https://shivakasu.cn/2020/05/02/english0/"/>
    <id>https://shivakasu.cn/2020/05/02/english0/</id>
    <published>2020-05-02T13:29:20.000Z</published>
    <updated>2020-05-02T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>“your/you’re” weakened into “yer”(/jɪr/, sounds like “year”)</li><li>“yours” weakened into “yers”(/jɪrs/)</li><li>“for” weakened into “fer”(/fər/)</li><li>“of” weakened into “a”(/ə/)</li><li>“you” weakened into “ya”(/jə/)</li><li>“-ing” weakened into “-in”, usually used in verb’s continuous form, $\color{red}{informal}$</li><li>“what do you/what are you” weakened into “whaddaya”(/wɑːdəjə/)</li><li>“what are you” weakened into “whacha”(/wɑːtʃə/), $\color{red}{informal}$ than “whaddaya”</li><li>“what do we/they” weakened into “whadda we/they”</li><li>“want to” weakened into “wanna”(/wənə/)</li><li>“going to + verb” weakened into “gonna”(/gənə/)</li><li>“can” weakened into “kin”(/kən/)，weak than below</li><li>“can’t” weakened into “kan”(/kæn/), swallow “t”, stress “can”</li><li>“get” weakened into “git”(/gɪ/), t is weakened</li><li>“to” weakened into “ta”(/tə/)</li><li>“(vowel) + to” weakened into “da”(/də/) e.g. “go to” weakened into “go da”</li><li>“got to” weakened into “gotta”</li><li>“have to” weakened into “hafta”</li><li>“has to” weakened into “hasta”</li><li>“used to” weakened into “useta”</li><li>“supposed to” weakened into “supposta”</li><li>“he” weakened into linked “e”(/i/) e.g. “did he” weakened into “dide”(/dɪdi/)</li><li>“his” weakened into linked “is”(/ɪz/) e.g. “sent his” weakened into “seniz”(/senɪz/)</li><li>“him” weakened into linked “im”(/ɪm/) e.g. “sent him” weakened into “senim”(/senɪm/)</li><li>“her” weakened into linked “er”(/ər/) e.g. “took her” weakened into “tooker”(/tʊkər/)</li><li>“em” weakened into linked “em”(/əm/) e.g. “want them” weakened into “wantem”(/wɑːntəm/)</li><li>“and” weakened into bilinked “n”(/n/) e.g. “room and a room” weakened into “roomn na room”(/ruːmən nə ruːm/)</li><li>“or” weakened into “er”(/ər/)</li><li>“don’t know” weakened into “donno”(/doʊnoʊ/)</li><li>“t + you” weakened into “cha”(/tʃə/) e.g. “not you” weakened into “nocha”(/nɑːtʃə/)</li><li>“t + your/you’re” weakened into “cher”(/tʃər/) e.g. “want your” weakened into “wancher”(/wɑːntʃər/)</li><li>“d + you” weakened into “ja”(/dʒə/) e.g. “could you” weakened into “coulja”(/kʊdʒə/)</li><li>“d + your/you’re” weakened into “jer”(/dʒər/) e.g. “did your” weakened into “dijer”(/dɪdʒər/)</li><li>“(wh- question word) + have” weakened into linked “ave”(/æv/), “ave” can further weakened into “of”(/əv/) e.g. “what have” weakened into “whadof”</li><li>“(wh- question word) + has” weakened into linked “as”(/əz/) e.g. “what has” weakened into “whadas”</li><li>“(wh- question word) + had” weakened into linked “ad”(/əd/) e.g. “what had” weakened into “whadad”</li><li>“(subject) + have/has/had/haven’t/hasn’t/hadn’t” weakened into “ave/as/ad/aven’t/asn’t/adn’t” e.g. “I have” weakened into “I ave”(/aɪ æv/) </li><li>“(modal verbs) + have + (perfect tenses)” weakened into linked “a”(/ə/), $\color{red}{informal}$ <ul><li>“should have” weakened into “shoulda”</li><li>“could have” weakened into “coulda”</li><li>“would have” weakened into “woulda”</li><li>“must have” weakened into “musta”</li><li>“may have” weakened into “maya”</li><li>“might have” weakened into “mighta”</li></ul></li><li>“(negtive modal verbs) + have + (perfect tenses)” weakened into linked “a”(/ə/), $\color{red}{informal}$ <ul><li>“shouldn’t have” weakened into “shoulna”, “d” is swallowed, the same below</li><li>“couldn’t have” weakened into “coulna”</li><li>“wouldn’t have” weakened into “woulna”</li></ul></li><li>“let me” weakened into “lemme”(/lemi/), $\color{red}{informal}$</li><li>“give me” weakened into “gimme”(/ɡɪmi/), $\color{red}{informal}$</li><li>“about” weakened into linked “bout”(/baʊ/), $\color{red}{informal}$</li><li>“because” weakened into “cause”(/kɔːz/), $\color{red}{informal}$</li><li>“come on” weakened into “c’mon”(/kmɑːn/), $\color{red}{informal}$</li><li>delete question words, can also further delete subject, $\color{red}{informal}$, e.g.:<ul><li>“do you want some…?” into “(you) want some…?”</li><li>“are you going to see…?” into “(you) gonna see…?”</li><li>“would you like to…?” into “(you) like to…?”</li><li>“have you seen the…?” into “(you) seen the…?”</li></ul></li><li>unusual contractions<ul><li>“what are” into “what’re”</li><li>“what will” into “what’ll”</li><li>“where are” into “where’re”</li><li>“where will” into “where’ll”</li><li>“why are” into “why’re”</li><li>“why will” into “why’ll”</li><li>“who are” into “who’re”</li><li>“who will” into “who’ll”</li><li>“when are” into “when’re”</li><li>“when will” into “when’ll”</li><li>“how are” into “how’re”</li><li>“how will” into “how’ll”</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="英语笔记" scheme="https://shivakasu.cn/categories/%E8%8B%B1%E8%AF%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="英语" scheme="https://shivakasu.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="口语" scheme="https://shivakasu.cn/tags/%E5%8F%A3%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Easy English Expression note（更新中）</title>
    <link href="https://shivakasu.cn/2020/05/01/ecube0/"/>
    <id>https://shivakasu.cn/2020/05/01/ecube0/</id>
    <published>2020-05-01T06:00:20.000Z</published>
    <updated>2020-06-06T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-How-are-you-doing"><a href="#1-How-are-you-doing" class="headerlink" title="1 How are you doing?"></a>1 How are you doing?</h3><ul><li>“how” pronounced as “ha”, “are” not pronounced, “you” pronounced as “you” or “yah” or “yuh”(ɪə), “ing” in “doing” pronounced as “ing” or “in” or “(ən)”  </li><li>A：how are you doing?<br>B：great!<br>A：how are you (stressed “you” when ask back) doing?<br>B：not too bad,thanks!<br>A：take it easy~</li></ul><h3 id="2-What-do-you-do-for-a-living"><a href="#2-What-do-you-do-for-a-living" class="headerlink" title="2 What do you do for a living?"></a>2 What do you do for a living?</h3><ul><li>the most common way to ask others’job. the same as “what is your job? / how do you make money? / do you have a job? / where do you work? / how do you earn money?”  </li><li>“what” pronounced as “wha”, “do” pronounced as “də”. “you” pronounced as “you” or “yah” or “yuh”(ɪə), the second “do” is stressed, “for” pronounced as “fər”</li></ul><h3 id="3-I”m-into-sth"><a href="#3-I”m-into-sth" class="headerlink" title="3 I”m into sth."></a>3 I”m into sth.</h3><ul><li>the same as “I’m interested in sth.”</li><li>e.g. “I’m into sports / I”m into music”</li></ul><h3 id="4-My-knee-went-out"><a href="#4-My-knee-went-out" class="headerlink" title="4 My knee went out"></a>4 My knee went out</h3><ul><li>“go out” means hurt like 扭伤拉伤，usually used with knee, elbow, shoulder, neck and back. </li><li>In English words, stressd sounds usually fall on “s”, “n” and “l”, while unstressd sounds usually fall on “d”, “t” and “h”. So “went out” pronounced as “wen nout”</li></ul><h3 id="5-what”s-up-this-weekend"><a href="#5-what”s-up-this-weekend" class="headerlink" title="5 what”s up this weekend?"></a>5 what”s up this weekend?</h3><ul><li>the same as “what kind of plan do you have for the weekend?”  </li><li>the first two words are linked, the last two words are linked. “s” is stressd. “t”, “h” and “d” are unstressd, so it pronounced as “wassup thissweeken”</li></ul><h3 id="6-I”m-gonna-kick-back"><a href="#6-I”m-gonna-kick-back" class="headerlink" title="6 I”m gonna kick back"></a>6 I”m gonna kick back</h3><ul><li>the original meaning of “kick back” is 报复, but it has a meaning like “relax” in spoken English. “gonna” is the same as “going to”</li><li>A：you wanna go do something?<br>B：no, I’m gonna kick back.<br>A：you’re so lazy!</li><li>“gonna” pronounced as “gənuh(nə)”. “I’m gonna” pronounced as “Ahm mənuh” when spoken quickly, “Ah ənuh” when more quickly，不用发闭嘴唇的 m，但是要舌根抵住上腭发一个鼻音来打断 Ah 和 ə</li></ul><h3 id="7-I-slept-in"><a href="#7-I-slept-in" class="headerlink" title="7 I slept in"></a>7 I slept in</h3><ul><li>“sleep in” means waking up naturally, pronounced as “slee pin”. The past tense “slept in” pronounced as “slep din”, with “t” weakened into “d”.</li><li>A：you look so refreshed.<br>B：yes, I slept in. I woke up at 10!</li></ul><h3 id="8-I-overslept"><a href="#8-I-overslept" class="headerlink" title="8 I overslept"></a>8 I overslept</h3><ul><li>“oversleep” means waking up late</li></ul><h3 id="9-I”m-gonna-stock-up-on-sth"><a href="#9-I”m-gonna-stock-up-on-sth" class="headerlink" title="9 I”m gonna stock up on sth."></a>9 I”m gonna stock up on sth.</h3><ul><li>the same as “I’m gonna buy a lot of sth.”</li><li>“stock up on” pronounced as “stockʌ pon”</li><li>A：what are you getting at the store?<br>B：I’m gonna stock up on water.</li></ul><h3 id="10-I”m-counting-on-you"><a href="#10-I”m-counting-on-you" class="headerlink" title="10 I”m counting on you"></a>10 I”m counting on you</h3><ul><li>我就指望你了, the same as “rely on you”, 可能对方先承诺了什么</li><li>“I’m” usually pronounced as “Ahm” instead of “/aɪm/“. stressed “n” and weakened “t”, so it pronounced as “counning on nyou(sounds like ‘new’)”</li><li>A：will you help me move this Sunday?<br>B：sure!<br>A：I”m counting on you~</li></ul><h3 id="11-I-had-a-long-week"><a href="#11-I-had-a-long-week" class="headerlink" title="11 I had a long week"></a>11 I had a long week</h3><ul><li>the same as “I had a difficult/tiring/stressful week.”</li><li>the opposite wording is “good/easy/stress free/nice week”, not “short week”. </li><li>“h” is unstressed, “I had a” pronounced as “I ada”，”I” and “a” both pronounced like “/aɪ/“. “long” pronounced like “law” with a nasal sound.</li><li>A：you look stressed?<br>B：well, I had a long week.</li></ul><h3 id="12-TGIF"><a href="#12-TGIF" class="headerlink" title="12 TGIF"></a>12 TGIF</h3><ul><li>TGIF = Thank god, it”s Friday! Both “god” and “God” are ok.</li><li>FNL = Friday night life</li></ul><h3 id="13-That”s-pure-nonsense"><a href="#13-That”s-pure-nonsense" class="headerlink" title="13 That”s pure nonsense!"></a>13 That”s pure nonsense!</h3><ul><li>主观上觉得离谱, the same as “That”s not true! / That”s a crazy lie! / That”s bullshit”</li><li>“pure(pjʊ r)” has two syllables, when speaking quickly, it pronounced only one syllable like “peer(pɪr)”.</li></ul><h3 id="14-Did-you-get-out…"><a href="#14-Did-you-get-out…" class="headerlink" title="14 Did you get out…"></a>14 Did you get out…</h3><ul><li>e.g. Did you get out dancing last weekend? </li><li>American prefer phrase rather than single word, “doing” is more popular than “to do”. So “get/go out dancing” is better than “go to dance” </li><li>“did you get out” pronounced as “di dyou ge dou (dɪ ʤʊ ge daʊ)”</li></ul><h3 id="15-to-do-away-with-sth"><a href="#15-to-do-away-with-sth" class="headerlink" title="15 (to) do away with sth."></a>15 (to) do away with sth.</h3><ul><li>= get rid of sth.</li><li>e.g.：you need to do away with somking. / I will to do away with the hat.</li></ul><h3 id="16-to-do-sth-up"><a href="#16-to-do-sth-up" class="headerlink" title="16 (to) do sth. up"></a>16 (to) do sth. up</h3><ul><li>means to make sth exciting, usually said “do it up”, “it” refers to things like party and celebration.</li><li>A：are you gonna do it up for you mom’s birthday?<br>B：no, we’re just gonna have a nice dinner at home.<br>A：no party?</li></ul><h3 id="17-to-do-up-clothes"><a href="#17-to-do-up-clothes" class="headerlink" title="17 (to) do up (clothes)"></a>17 (to) do up (clothes)</h3><ul><li>means to fasten clothes, like zip up jacket and put hat up, not just put on them but fasten them. </li><li>A：is it cold outside, mom?<br>B：yes, be sureto do up your jacket!</li></ul><h3 id="18-to-do-it-over"><a href="#18-to-do-it-over" class="headerlink" title="18 (to) do it over"></a>18 (to) do it over</h3><ul><li>means to do it again, over=again. we can also said “do it over again” </li><li>Pronounced as “doi dover”, with “t” weakened into “d”.</li></ul><h3 id="19-because-of"><a href="#19-because-of" class="headerlink" title="19 because of"></a>19 because of</h3><ul><li>usually used as an excuse that make sb can’t do sth</li><li>A：why didn’t you call me last night?<br>B：because of my phone’s battery~</li></ul><h3 id="20-thanks-to"><a href="#20-thanks-to" class="headerlink" title="20 thanks to"></a>20 thanks to</h3><ul><li>usually used as an positive reason that enable sb to do sth</li><li>A：your skin looks healthy!<br>B：it’s all thanks to this lotion.</li></ul><h3 id="21-Check-back-in-a-jiffy"><a href="#21-Check-back-in-a-jiffy" class="headerlink" title="21 Check back in a jiffy!"></a>21 Check back in a jiffy!</h3><ul><li>means sth is not ready or finished yet, but will be finished soon.</li><li>Pronounced as “check /baɪ kɪnə/ jiffy”</li><li>A：hi, are my copies done?<br>B：not yet, check back in a jiffy.</li></ul><h3 id="22-pick-your-poison"><a href="#22-pick-your-poison" class="headerlink" title="22 pick your poison"></a>22 pick your poison</h3><ul><li>means to make a choice between some bad things. Sometimes the choices may not be bad, maybe just unhealthy (food).</li><li>Pronounced as “/pɪ kɪər/ poison”</li><li>A：pick your poison.<br>B：I’ll have the peanut butter cookie. </li></ul><h3 id="23-those-poor-children"><a href="#23-those-poor-children" class="headerlink" title="23 those poor children"></a>23 those poor children</h3><ul><li>“poor” means “helpless”, followed by “children”, “people” or “animal”, refer to victims of tragic things like war.</li><li>“poor” pronounced as “pʊ:r”</li></ul><h3 id="24-sth-is-pathetic"><a href="#24-sth-is-pathetic" class="headerlink" title="24 sth. is pathetic"></a>24 sth. is pathetic</h3><ul><li>means sth. is terrible, bad or sth. sucks. Sometimes it’s not a very angry word, can be used to tease friends, like “傻逼”</li><li>You’re a pathetic loser!</li></ul><h3 id="25-What-purpose-does-it-serve"><a href="#25-What-purpose-does-it-serve" class="headerlink" title="25 What purpose does it serve?"></a>25 What purpose does it serve?</h3><ul><li>the same as “what is it used for?” and “what is it’s function?”</li><li>A：why are you takingvitamin C? what purpose do they serve?<br>B：they help strengthen your immune system.</li></ul><h3 id="26-I-couldn’t-help-it"><a href="#26-I-couldn’t-help-it" class="headerlink" title="26 I couldn’t help it."></a>26 I couldn’t help it.</h3><ul><li>pronounced as “I couldn hel pi”, “couldn” can further weakened into “c’n”(/kn/)</li><li>the same as “I couldn’t control/stop myself.”</li><li>A：why did you laugh at class?<br>B：I couldn’t help it.</li></ul><h3 id="27-to-look-away-from-sb-sth"><a href="#27-to-look-away-from-sb-sth" class="headerlink" title="27 to look away (from sb./sth.)"></a>27 to look away (from sb./sth.)</h3><ul><li>just no looking, used without restrictions on feelings, can out of shyness, anger or fear.</li><li>A：don’t look away from me when I’m talking to you.<br>B：yes, dad.</li></ul><h3 id="28-to-push-it"><a href="#28-to-push-it" class="headerlink" title="28 to push it"></a>28 to push it</h3><ul><li>“it” means “luck”, so “don’t pust it” means “don’t believe your good luck. don’t be so greedy, or you gonna lose everything.” also can say “you are pushing it” as a warning.</li><li>explanation in Cambridge Dictionary: to try too hard to get a particular result and risk losing what you have achieved.</li></ul><h3 id="29-Are-you-done-yet"><a href="#29-Are-you-done-yet" class="headerlink" title="29 Are you done yet?"></a>29 Are you done yet?</h3><ul><li>the same as “are you finish yet?”</li></ul><h3 id="30-knock-on-wood"><a href="#30-knock-on-wood" class="headerlink" title="30 knock on wood"></a>30 knock on wood</h3><ul><li>said in order to avoid bad luck, either when you mention good luck that you have had in the past or when you mention hopes you have for the future. 防止立flag遭报应</li><li>e.g. “I never have trouble with my car, knock on wood.”</li></ul><h3 id="31-count-sb-in-out"><a href="#31-count-sb-in-out" class="headerlink" title="31 count sb. in/out"></a>31 count sb. in/out</h3><ul><li>means “include/exclude sb. in an activity or arrangement”</li><li>A：Do you want to go swimming with us tomorrow?<br>B：Yes, count me in.</li></ul><h3 id="32-to-rain-on-sb-’s-parade"><a href="#32-to-rain-on-sb-’s-parade" class="headerlink" title="32 to rain on sb.’s parade"></a>32 to rain on sb.’s parade</h3><ul><li>means “to do sth. terrible to sb.’s plan”</li><li>e.g. “I’m sorry to rain on your parade but you’re not allowed to have alcohol on the premises.”</li></ul><h3 id="33-I’m-broke"><a href="#33-I’m-broke" class="headerlink" title="33 I’m broke."></a>33 I’m broke.</h3><ul><li>means “I have no money.” 不一定是破产，也可能是没什么钱单纯地哭穷。</li><li>e.g. “I can’t go to the movies – I’m broke.”</li></ul><h3 id="34-to-sell-sb-out"><a href="#34-to-sell-sb-out" class="headerlink" title="34 to sell sb. out"></a>34 to sell sb. out</h3><ul><li>means “betray sb.”</li><li>explanation in Cambridge Dictionary: to not do what you have promised someone you will do or what you should do because you will get more advantages for yourself if you do something else.</li></ul><h3 id="35-It-will-all-come-down-to-sth-doing-sth"><a href="#35-It-will-all-come-down-to-sth-doing-sth" class="headerlink" title="35 It will all come down to sth./doing sth."></a>35 It will all come down to sth./doing sth.</h3><ul><li>the same as “it completely depends on sth.”</li><li>e.g. “Eventually our choice of hotel will come down to how much we can afford.”</li></ul><h3 id="36-I-beg-to-differ"><a href="#36-I-beg-to-differ" class="headerlink" title="36 I beg to differ"></a>36 I beg to differ</h3><ul><li>a way of saying “I do not agree” that is polite, but may sound unfriendly. (Strong but polite)</li></ul><h3 id="37-luck-lock"><a href="#37-luck-lock" class="headerlink" title="37 luck lock"></a>37 luck lock</h3><ul><li>luck是短阿 “/ʌ/“, lock是长阿 “/ɑː/“</li></ul><h3 id="38-Don’t-sweat-it"><a href="#38-Don’t-sweat-it" class="headerlink" title="38 Don’t sweat it!"></a>38 Don’t sweat it!</h3><ul><li>the same as “don’t worry about it! / don’t be too stressed out! / relax!”</li><li>pronounced as “don swea ti”</li></ul><h3 id="39-go-all-out"><a href="#39-go-all-out" class="headerlink" title="39 go all out"></a>39 go all out</h3><ul><li>means “to put all your energy or enthusiasm into what you are doing”</li><li>e.g. The team went all out for a win.</li></ul><h3 id="40-already"><a href="#40-already" class="headerlink" title="40 already"></a>40 already</h3><ul><li>used to show that you are losing patience and want someone to stop doing something or to do something more quickly.</li><li>not a polite expression. can be said to friends, but never to your boss.</li><li>e.g. where are you already! / just ask him already! / it should be done already!</li></ul><h3 id="41-come-down-with-sth"><a href="#41-come-down-with-sth" class="headerlink" title="41 come down with sth."></a>41 come down with sth.</h3><ul><li>means “to suffer from an illness, especially one that is not serious”</li><li>e.g. I think I’m coming down with flu. / Are you coming down with a cold?</li></ul><h3 id="42-go-down"><a href="#42-go-down" class="headerlink" title="42 go down"></a>42 go down</h3><ul><li>means to move down to a lower level or place. e.g. The sun goes down.</li><li>means to move to the south.(上北下南)</li><li>means to move from housing area to the dowentown or urban area.(从住宅区去商业区) e.g. I’m going down to the bar tonight.</li></ul><h3 id="43-steal-sb’s-thunder"><a href="#43-steal-sb’s-thunder" class="headerlink" title="43 steal sb’s thunder"></a>43 steal sb’s thunder</h3><ul><li>means to do what someone else was going to do before they do it, especially if this takes success or praise away from them. (steal sb’s glory)</li><li>e.g. Sandy stole my thunder when she announced that she was pregnant two days before I’d planned to tell people about my pregnancy.</li></ul><h3 id="44-to-be-a-pain-in-the-neck"><a href="#44-to-be-a-pain-in-the-neck" class="headerlink" title="44 to be a pain in the neck"></a>44 to be a pain in the neck</h3><ul><li>means someone or something that is very annoying. 如鲠在喉</li><li>“in the” pronounced as “in nuh(nə)”</li><li>e.g. That child is a real pain in the neck. / This traffic is such a pain in the neck.</li></ul><h3 id="45-to-come-in-on-someday"><a href="#45-to-come-in-on-someday" class="headerlink" title="45 to come in on (someday)"></a>45 to come in on (someday)</h3><ul><li>means to become involved in a situation, story, or plan at sometime.</li><li>A：can you come in on a weekend?<br>B：no. I can only go in on weekdays.</li></ul><h3 id="46-to-turn-in"><a href="#46-to-turn-in" class="headerlink" title="46 to turn in"></a>46 to turn in</h3><ul><li>means to give sth to sb who asked for it. e.g. turn in homework to teacher. / turn in weapon to police.</li><li>means to go to bed. e.g. I usually turn in at about midnight.</li></ul><h3 id="47-to-lack-sth"><a href="#47-to-lack-sth" class="headerlink" title="47 to lack sth"></a>47 to lack sth</h3><ul><li>means to not have or not have enough of sth.</li><li>to lack(verb) sth. = the lack(noun) of sth.</li></ul><h3 id="48-I’m-down"><a href="#48-I’m-down" class="headerlink" title="48 I’m down"></a>48 I’m down</h3><ul><li>the same as “count me in. / I’ll join you.”</li><li>A：you wanna go watch the basketball game tonight?<br>B：cool! I’m down!</li></ul><h3 id="49-to-kick-it-up-a-notch"><a href="#49-to-kick-it-up-a-notch" class="headerlink" title="49 to kick it up a notch"></a>49 to kick it up a notch</h3><ul><li>“kick up” means “increase”, “notch” means a “a V-shaped cut”, 一个圆形旋钮分成几个刻度，每两个刻度之间是一个楔形的 notch. 所以 “kick up a notch” 是指调高某个度量，可以是温度、音量，”a notch” 不一定表示一个刻度，也可以是虚指 “a little”</li><li>e.g. The water is pretty cool in here. Can you kick it up a notch?</li></ul><h3 id="50-holiday-vacation-weekend"><a href="#50-holiday-vacation-weekend" class="headerlink" title="50 holiday vacation weekend"></a>50 holiday vacation weekend</h3><ul><li>“holiday” is usually a red number day in calander. 法定假日，包括双休日，圣诞元旦等节日</li><li>“vacation” is a peroid of time we don’t work or study. 和法定假期没有必然关系，指的是个人休息的一种状态，在工作日休息就能叫 vacation，在假期里工作就不能叫 vacation，同理也可以说 take a vacation during a holiday. </li><li>“weekend” means Saterday and Sunday.</li></ul><h3 id="51-a-stocking-stuffer"><a href="#51-a-stocking-stuffer" class="headerlink" title="51 a stocking stuffer"></a>51 a stocking stuffer</h3><ul><li>means a small, usually cheap Christmas present.</li></ul><h3 id="52-to-keep-sb-on-sb’s-toes"><a href="#52-to-keep-sb-on-sb’s-toes" class="headerlink" title="52 to keep sb on sb’s toes"></a>52 to keep sb on sb’s toes</h3><ul><li>“keep me” pronounced as “kee me”, “keep him on his” pronounced as “kee pim on nis”, “keep her on her” pronounced as “kee per on ner”</li><li>means to force sb. to concentrete, to make sb. be alert.</li><li>A：hey! you wrote “practise”, but it should be “practice”.<br>B：oh! thanks for keeping me on my toes.</li></ul><h3 id="53-keep-it-down"><a href="#53-keep-it-down" class="headerlink" title="53 keep it down"></a>53 keep it down</h3><ul><li>“keep it” pronounced as “kee pi”</li><li>means to be quieter.</li><li>e.g. Hey you guys, keep it down in there – I’m on the phone!</li></ul><h3 id="54-the-apple-of-sb’s-eye"><a href="#54-the-apple-of-sb’s-eye" class="headerlink" title="54 the apple of sb’s eye"></a>54 the apple of sb’s eye</h3><ul><li>means the person who someone loves most and is very proud of.</li><li>e.g. His youngest daughter was the apple of his eye.</li></ul><h3 id="55-picky"><a href="#55-picky" class="headerlink" title="55 picky"></a>55 picky</h3><ul><li>means liking only a few things and therefore difficult to please. 挑剔的</li></ul><h3 id="56-to-turn-out"><a href="#56-to-turn-out" class="headerlink" title="56 to turn out"></a>56 to turn out</h3><ul><li>means to happen or become known to happen in a particular way, is similar to “result”.</li><li>e.g. She assured him that everything would turn out all right. / It turns out that Ray had borrowed the money from one of his students.</li></ul><h3 id="57-Auld-Lang-Syne"><a href="#57-Auld-Lang-Syne" class="headerlink" title="57 Auld Lang Syne"></a>57 Auld Lang Syne</h3><ul><li>is a traditional Scottish song that often sung at New Year to say goodbye to the old year and welcome the new year. Auld lang syne means “the old days” in Scots. Its Chinese translation is 友谊天长地久.</li></ul><h3 id="58-starting-is-half-the-battle"><a href="#58-starting-is-half-the-battle" class="headerlink" title="58 starting is half the battle"></a>58 starting is half the battle</h3><ul><li>开始是整个战役的一半，意思是万事开头难，一句鼓励的话。</li></ul><h3 id="59-sb-sticking-to-sb’s-guns"><a href="#59-sb-sticking-to-sb’s-guns" class="headerlink" title="59 sb sticking to sb’s guns"></a>59 sb sticking to sb’s guns</h3><ul><li>means sb refuse to change his beliefs or actions, even if other people disagree with him. 坚定立场，迎难而上</li><li>e.g. My parents didn’t want me to be an actor, but I stuck to my guns.</li></ul><h3 id="60-taking-forever"><a href="#60-taking-forever" class="headerlink" title="60 taking forever"></a>60 taking forever</h3><ul><li>means taking a long time.</li><li>A：you done yet? come on! you’re taking forever!<br>B：just a minute.</li></ul><h3 id="61-pushover"><a href="#61-pushover" class="headerlink" title="61 pushover"></a>61 pushover</h3><ul><li>means something that is easy to do or to win, or someone who is easily persuaded or influenced or defeated. 容易的事或好说话的人，不算贬义</li><li>e.g. The interview was an absolute pushover. / Krista gets whatever she wants because her parents are real pushovers.</li></ul><h3 id="62-be-on-the-edge-of-sth"><a href="#62-be-on-the-edge-of-sth" class="headerlink" title="62 be on the edge (of sth.)"></a>62 be on the edge (of sth.)</h3><ul><li>means to nearly be in a particular situation, or to be close to achieving something.</li><li>e.g. Scientists hope we are on the edge of a new and greener economy.</li></ul><h3 id="63-cushy"><a href="#63-cushy" class="headerlink" title="63 cushy"></a>63 cushy</h3><ul><li>used to discribe sb’s job. “a cushy job” means a nice, relaxing, pleasant, easy job.</li><li>e.g. You don’t work Monday? What a cushy job!</li></ul><h3 id="64-to-hone"><a href="#64-to-hone" class="headerlink" title="64 to hone"></a>64 to hone</h3><ul><li>means to sharpen, to make something perfect or completely suitable for its purpose.</li><li>e.g. Her debating skills were honed in the students’ union. / He helps performers hone their skills as dancers and singers.</li></ul><h3 id="66-to-put-up-with-sth"><a href="#66-to-put-up-with-sth" class="headerlink" title="66 to put up with sth."></a>66 to put up with sth.</h3><ul><li>means to accept or continue to accept an unpleasant situation or experience, or someone who behaves unpleasantly. In other words, sth you hate but you have to endure.</li><li>e.g. I don’t know how he puts up with their constant complaining.</li></ul><h3 id="67-get-the-nod"><a href="#67-get-the-nod" class="headerlink" title="67 get the nod"></a>67 get the nod</h3><ul><li>means to get permission or approval from sb.</li><li>e.g. I got the nod from my boss.</li></ul><h3 id="68-nuke"><a href="#68-nuke" class="headerlink" title="68 nuke"></a>68 nuke</h3><ul><li>means to heat or cook sth in a microwave oven.</li><li>A：you should heat that sandwich up before you eat it.<br>B：I’ll nuke it.</li></ul><h3 id="69-hoopla"><a href="#69-hoopla" class="headerlink" title="69 hoopla"></a>69 hoopla</h3><ul><li>means exciting noise and activity in celebration of an event.</li><li>e.g. There is a lot of hoopla about that movie. 电影好评如潮</li></ul><h3 id="70-straighten-sth-sb-out"><a href="#70-straighten-sth-sb-out" class="headerlink" title="70 straighten sth/sb out"></a>70 straighten sth/sb out</h3><ul><li>means to correct or improve sth/sb, or resolve a problem.</li><li>e.g. I thought marriage would straighten him out. / It took me a while to straighten out my father’s accounts.</li></ul><h3 id="71-brouhaha"><a href="#71-brouhaha" class="headerlink" title="71 brouhaha"></a>71 brouhaha</h3><ul><li>means a lot of noise or angry complaining about something. (opposite to hoopla)</li><li>e.g. There was a big brouhaha when the town council decided to close the park.</li></ul><h3 id="72-My-hat’s-off-to-you"><a href="#72-My-hat’s-off-to-you" class="headerlink" title="72 My hat’s off to you!"></a>72 My hat’s off to you!</h3><ul><li>means to show my respect or congratulation to you.</li></ul><h3 id="73-on-call"><a href="#73-on-call" class="headerlink" title="73 on call"></a>73 on call</h3><ul><li>means to be available to work when needed. 待命, 随叫随到</li><li>e.g. He is on call round-the-clock two weeks each month.</li></ul><h3 id="74-and-whatnot"><a href="#74-and-whatnot" class="headerlink" title="74 and whatnot"></a>74 and whatnot</h3><ul><li>means other things that are not important and no need to be specific. 其他杂七杂八的东西</li><li>e.g. You can buy snacks and whatnot at the bar.</li></ul><h3 id="75-to-tinker-around-with-sth"><a href="#75-to-tinker-around-with-sth" class="headerlink" title="75 to tinker (around) with sth."></a>75 to tinker (around) with sth.</h3><ul><li>means to make small changes in sth, in order to understand how it works or fix it. 捣鼓摆弄(机械、电器什么的)</li><li>e.g. He spends every weekend tinkering (around) with his car. </li></ul><h3 id="76-kowtow"><a href="#76-kowtow" class="headerlink" title="76 kowtow"></a>76 kowtow</h3><ul><li>means to show too much respect or obedience. “叩头”的音译</li><li>e.g. I remembered watching people kowtow in front of the Potala Palace.</li></ul><h3 id="77-tweak"><a href="#77-tweak" class="headerlink" title="77 tweak"></a>77 tweak</h3><ul><li>means to change something slightly, especially in order to make it more correct, effective, or suitable. 微调</li><li>e.g. The software is pretty much there - it just needs a little tweaking.</li></ul><h3 id="78-when-it-comes-to-sth"><a href="#78-when-it-comes-to-sth" class="headerlink" title="78 when it comes to sth."></a>78 when it comes to sth.</h3><ul><li>means when talking anout sth.</li><li>e.g. When it comes to pizza, pepperoni is my favorite. / When it comes to friends, you’re the best.</li></ul><h3 id="79-take-sth-with-a-grain-of-salt"><a href="#79-take-sth-with-a-grain-of-salt" class="headerlink" title="79 take sth with a grain of salt"></a>79 take sth with a grain of salt</h3><ul><li>means to not completely believe something that you are told, because you think it is unlikely to be true. (原意是难吃的东西加点盐才能勉强下咽)</li><li>e.g. You have to take everything she says with a grain of salt, because she tends to exaggerate.</li></ul><h3 id="81-9-out-of-10-times"><a href="#81-9-out-of-10-times" class="headerlink" title="81 9 out of 10 times"></a>81 9 out of 10 times</h3><ul><li>adv, means always</li></ul><h3 id="82-goof-off"><a href="#82-goof-off" class="headerlink" title="82 goof off"></a>82 goof off</h3><ul><li>means to avoid work or waste time. 理应干正事但是在摸鱼</li><li>e.g. You’d better not let the boss catch you goofing off!</li></ul><h3 id="83-My-dogs-are-barking"><a href="#83-My-dogs-are-barking" class="headerlink" title="83 My dogs are barking!"></a>83 My dogs are barking!</h3><ul><li>the same as “My feet are tired/sore !”</li></ul><h3 id="84-get-carried-away"><a href="#84-get-carried-away" class="headerlink" title="84 get carried away"></a>84 get carried away</h3><ul><li>means to become so excited about sth that you do not control what you say or do. 忘乎所以</li><li>e.g. It is worth looking in at a sale, but do not get carried away.</li></ul><h3 id="86-veggie"><a href="#86-veggie" class="headerlink" title="86 veggie"></a>86 veggie</h3><ul><li>noun, short form of “vegetable”. e.g. Veggies are good for health.</li><li>adj, short form of “vegetarian”, means not eating or including meat. e.g. a veggie food.</li></ul><h3 id="87-ad-hoc"><a href="#87-ad-hoc" class="headerlink" title="87 ad hoc"></a>87 ad hoc</h3><ul><li>adj, means made or happening only for a particular purpose or need, not planned before it happens. 临时且专门的</li><li>e.g. an ad hoc committee/meeting</li></ul><h3 id="88-pig-out"><a href="#88-pig-out" class="headerlink" title="88 pig out"></a>88 pig out</h3><ul><li>means to eat a lot.</li><li>e.g. We pigged out on all the delicious cakes and pastries.</li></ul><h3 id="89-sth-is-it"><a href="#89-sth-is-it" class="headerlink" title="89 sth is it"></a>89 sth is it</h3><ul><li>means sth is the best.</li><li>e.g. When it comes to drink, Coke is it!</li></ul><h3 id="90-what-the-heck-hell-fuck-is-wrong-with-you"><a href="#90-what-the-heck-hell-fuck-is-wrong-with-you" class="headerlink" title="90 what the heck/hell/fuck is wrong with you!"></a>90 what the heck/hell/fuck is wrong with you!</h3><ul><li>the same as “what’s wrong with you!”, with anger or surprise.</li></ul><h3 id="91-in-on-heat"><a href="#91-in-on-heat" class="headerlink" title="91 in/on heat"></a>91 in/on heat</h3><ul><li>means an animal that is in a state of sexual excitement and ready to breed.</li><li>e.g. My cat is in heat.</li></ul><h3 id="92-for-shits-and-giggles"><a href="#92-for-shits-and-giggles" class="headerlink" title="92 for shits and giggles"></a>92 for shits and giggles</h3><ul><li>the same as “for fun”</li><li>A：why the hell did you throw that snowball at me?<br>B：for shits and giggles~</li></ul><h3 id="93-put-some-elbow-into-it"><a href="#93-put-some-elbow-into-it" class="headerlink" title="93 put some elbow into it"></a>93 put some elbow into it</h3><ul><li>means to use more power. 因为手肘比手腕有劲</li><li>A：I can’t push this snow.<br>B：put some elbow into it.</li></ul><h3 id="96-pouting"><a href="#96-pouting" class="headerlink" title="96 pouting"></a>96 pouting</h3><ul><li>means to push the lower lip forward to show you are annoyed. 生气地噘嘴</li><li>e.g. Vanessa always pouts if she doesn’t get what she wants.</li></ul><h3 id="97-get-the-gist-of-sth"><a href="#97-get-the-gist-of-sth" class="headerlink" title="97 get the gist of sth"></a>97 get the gist of sth</h3><ul><li>means to basically understand sth.</li><li>A：Did you understand DD216?<br>B：Not everything, but I got the gist of it.</li></ul><h3 id="98-fit"><a href="#98-fit" class="headerlink" title="98 fit"></a>98 fit</h3><ul><li>noun. means a sudden, uncontrolled period of doing something or feeling something.</li><li>e.g. a coughing fit(不住地咳嗽) / She hit him in a fit of anger.(无法克制的愤怒)</li></ul><h3 id="99-get-the-hang-of-sth"><a href="#99-get-the-hang-of-sth" class="headerlink" title="99 get the hang of sth"></a>99 get the hang of sth</h3><ul><li>means to learn how to do something, especially if it is not obvious or simple.</li><li>A：I’ve never used this program before.<br>B：Don’t worry - you’ll soon get the hang of it.</li></ul><h3 id="100-to-die-for"><a href="#100-to-die-for" class="headerlink" title="100 to die for"></a>100 to die for</h3><ul><li>means excellent or to be strongly wished for. 表示东西太好了，得到之后就死而无憾了</li><li>e.g. That chocolate cake is to die for. / She has a figure to die for.</li></ul><h3 id="101-make-ends-meet"><a href="#101-make-ends-meet" class="headerlink" title="101 make ends meet"></a>101 make ends meet</h3><ul><li>means to have just enough money to pay for the things that you need. Expenses = Income, 收支平衡</li><li>e.g. It’s not easy to make ends meet with a big family, but somehow we manage.</li></ul><h3 id="102-order-take-out"><a href="#102-order-take-out" class="headerlink" title="102 order take-out"></a>102 order take-out</h3><ul><li>to buy food in a restaurant and eat it somewhere else. 点外卖</li></ul><h3 id="103-be-rather-upset-angry"><a href="#103-be-rather-upset-angry" class="headerlink" title="103 be rather upset/angry"></a>103 be rather upset/angry</h3><ul><li>used to politely show your upset/angry even though you are extremly upset/angry. “rather” means a slight degree.</li><li>e.g. I’m rather upset.</li></ul><h3 id="104-perplexed-perplexing"><a href="#104-perplexed-perplexing" class="headerlink" title="104 perplexed / perplexing"></a>104 perplexed / perplexing</h3><ul><li>adj. means confused/confusing, because something is difficult to understand or solve.</li><li>e.g. The students looked perplexed, so the teacher tried to explain once again. / The question is perplexing.</li></ul><h3 id="105-keep-it-PG"><a href="#105-keep-it-PG" class="headerlink" title="105 keep it PG"></a>105 keep it PG</h3><ul><li>不要这么少儿不宜. PG = parental guidance, is a movie rating.</li><li>e.g. Two people are kissing. - oh~ keep it PG.</li></ul><h3 id="106-typo"><a href="#106-typo" class="headerlink" title="106 typo"></a>106 typo</h3><ul><li>means a mistake made in printed material produced by a computer or a typewriter. 电子材料中的拼写、排版等错误</li><li>e.g. The text was full of typos.</li></ul><h3 id="108-Go-figure"><a href="#108-Go-figure" class="headerlink" title="108 Go figure!"></a>108 Go figure!</h3><ul><li>used when you tell someone a fact and you then want to say that the fact is surprising, strange or stupid.</li><li>e.g. It’s a terrible movie and it made $200 million. Go figure!</li><li>可以用在肯定的回答里, “yes, go figure!” 相当于 “是啊，意不意外？”</li></ul><h3 id="109-Is-A-considered-B"><a href="#109-Is-A-considered-B" class="headerlink" title="109 Is A considered B?"></a>109 Is A considered B?</h3><ul><li>the same as “Is A equals B?”</li><li>e.g. Is a tomato considered a fruit?</li></ul><h3 id="110-in-my-book"><a href="#110-in-my-book" class="headerlink" title="110 in my book"></a>110 in my book</h3><ul><li>the same as “in my opinion”</li></ul><h3 id="112-Beats-me"><a href="#112-Beats-me" class="headerlink" title="112 Beats me."></a>112 Beats me.</h3><ul><li>the same as “I do not know.” or “I do not understand.”</li></ul><h3 id="113-bite-the-dust"><a href="#113-bite-the-dust" class="headerlink" title="113 bite the dust"></a>113 bite the dust</h3><ul><li>means sb dies or fails,  or sth stops working. 因为败者食尘</li><li>e.g. His career bit the dust when he lost his job. / I think our car just bit the dust.</li></ul><h3 id="114-Bite-me"><a href="#114-Bite-me" class="headerlink" title="114 Bite me!"></a>114 Bite me!</h3><ul><li>used to say to someone that they have made you feel angry or embarrassed. the same as “go to hell! leave me alone!” 要你管！滚蛋！</li></ul><h3 id="115-No-ifs-ands-or-buts"><a href="#115-No-ifs-ands-or-buts" class="headerlink" title="115 No ifs, ands or buts!"></a>115 No ifs, ands or buts!</h3><ul><li>means to stop sb arguing with you when you want him to do sth. 别找借口</li><li>e.g. I want no ifs or buts, just get on and tidy your room now.</li></ul><h3 id="116-I’m-damned-if"><a href="#116-I’m-damned-if" class="headerlink" title="116 I’m damned if"></a>116 I’m damned if</h3><ul><li>used to say that you will certainly not do sth.</li><li>e.g. I’m polite to his ex-wife when I meet her, but I’m damned if I’m going to invite her over for dinner.</li></ul><h3 id="117-hard-to-beat"><a href="#117-hard-to-beat" class="headerlink" title="117 hard to beat"></a>117 hard to beat</h3><ul><li>means be the best.</li><li>e.g. For an evening stroll the beach at Dieppe is hard to beat. </li></ul><h3 id="118-out-of-the-blue-out-of-the-clear-blue-sky"><a href="#118-out-of-the-blue-out-of-the-clear-blue-sky" class="headerlink" title="118 out of the blue / out of the clear blue sky"></a>118 out of the blue / out of the clear blue sky</h3><ul><li>means unexpectedly and suddenly</li><li>e.g. One day, out of the blue, she announced that she was leaving.</li></ul><h3 id="119-low-key"><a href="#119-low-key" class="headerlink" title="119 low-key"></a>119 low-key</h3><ul><li>means simple and not attracting attention (低调的). the opposite is “high-profile”(高调的)</li><li>e.g. The wedding will be a low-key affair, with fewer than thirty guests.</li></ul><h3 id="120-what-do-you-say-clause"><a href="#120-what-do-you-say-clause" class="headerlink" title="120 what do you say + clause"></a>120 what do you say + clause</h3><ul><li>used for making a suggestion, the same as “how about”</li><li>e.g. What do you say we sell the car?</li></ul><h3 id="121-another-the-final-nail-in-the-coffin"><a href="#121-another-the-final-nail-in-the-coffin" class="headerlink" title="121 another/the final nail in the coffin"></a>121 another/the final nail in the coffin</h3><ul><li>an event that causes the failure of something that had already started to fail. 棺材上的最后一颗钉子，表示雪上加霜的致命一击</li><li>e.g. That report drove the final nail in the company’s coffin.</li></ul><h3 id="123-speak-to-sb"><a href="#123-speak-to-sb" class="headerlink" title="123 speak to sb"></a>123 speak to sb</h3><ul><li>means to have a special meaning, importance or attraction for sb.</li><li>e.g. That painting really speaks to me.</li></ul><h3 id="124-Grow-up"><a href="#124-Grow-up" class="headerlink" title="124 Grow up!"></a>124 Grow up!</h3><ul><li>If you say “grow up” to someone, you are telling the person to stop behaving like a child.</li></ul><h3 id="125"><a href="#125" class="headerlink" title="125"></a>125</h3><h3 id="no-gain"><a href="#no-gain" class="headerlink" title="no gain"></a>no gain</h3><ul><li>65, 80, 85, 94, 95, 107, 111, 122, </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="英语笔记" scheme="https://shivakasu.cn/categories/%E8%8B%B1%E8%AF%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="英语" scheme="https://shivakasu.cn/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="口语" scheme="https://shivakasu.cn/tags/%E5%8F%A3%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>《西方哲学史》4：德国古典哲学</title>
    <link href="https://shivakasu.cn/2020/03/12/phi3/"/>
    <id>https://shivakasu.cn/2020/03/12/phi3/</id>
    <published>2020-03-12T09:46:20.000Z</published>
    <updated>2020-03-20T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为视频课不完整，这一部分摘抄总结自赵林老师的《西方哲学史讲演录》。</p><h1 id="1-康德"><a href="#1-康德" class="headerlink" title="1 康德"></a>1 康德</h1><ul><li>经验论和唯理论各自发展到极端，就成了怀疑论和独断论，在怀疑伦下没有普遍必然的知识，在独断论下得不到新的知识。在康德看来，这两派虽然观点相反，但问题的根源却是相同的，他们都没有正确认识到理性的作用，怀疑论固守经验而抛弃理性，独断论固守理性而抛弃经验，他们都极端地认为经验和理性是非此即彼、不能共存的，所以康德为了明确认识论中经验与理性的关系，做的第一件事就是在进行认识之前先批判地考察理性本身，弄清楚理性的能力、范围、界限。因此康德的哲学通常被叫做批判哲学，主要体现在康德撰写的“三大批判”中，即《纯粹理性批判》、《实践理性批判》和《判断力批判》。</li><li>康德出生在德国一个名叫哥尼斯堡的小城市，一生中除了一次短暂的旅行外，始终没有离开过哥尼斯堡，但他学识广博，当过图书管理员、家庭教师、大学教授，在大学里讲的课几乎涵盖了当时所有的学科领域。</li><li>在康德的时代，学科的分类还没有细化，许多思想家都是百科全书式的人物，康德也是如此。他在自然科学领域最重要的贡献就是在牛顿机械论世界观的基础上提出了一套关于宇宙起源的假说，即“星云假说”。牛顿的机械论世界观没有解释运动最初是如何发生的，他把这个问题推给了上帝，说是上帝作为第一推动者推了世界一把，世界就运动起来了。康德认为牛顿的世界里没有发展的观念，世界最初是怎样的，现在和将来仍然是怎样的，所以他提出了星云假说，认为最初的宇宙是一团混沌的星云，在长期的发展过程中，由于宇宙物质自身所具有的重力作用，不同的物质凝聚在一块，逐渐形成了一个个星体。康德把发展的思想引进了世界观中，认为我们今天的宇宙是长期发展、演化的结果，突破了牛顿一成不变的机械论世界观，这种宇宙进化论的观点在19世纪又得到了达尔文的生物进化论的支持，成为人们普遍接受的基本常识。</li><li>康德在哲学领域大器晚成，57岁才发表了第一部重要著作《纯粹理性批判》，而后十多年又完成了《实践理性批判》和《判断力批判》。“三大批判”是为了解决不同的问题，《纯粹理性批判》主要解决认识论问题(知识)，《实践理性批判》主要解决道德问题(意志)，《判断力批判》主要解决审美问题和目的论问题(情感)。我们的整个主观世界，从结构上来说，无非也就是知、意、情三个方面，而作为一种理性动物，人的知、意、情或多或少都与理性有关，所以康德给前两个批判冠以“理性”之名，《判断力批判》虽然名字里没有“理性”，但判断力被康德看作是理论理性与实践理性之间的联系环节，是两个理性之间的桥梁，因此仍然属于理性的范围。因此，三大批判的内容就符合了康德的初衷，即对理性本身的全面的批判。</li><li>康德要在认识之前批判地考察理性，黑格尔嘲笑这种做法就如同“在学会游泳之前切勿下水”的警告牌一样荒唐。但考虑到康德是基于发现了经验论和唯理论的错误，所以康德的做法多少还是有道理的。</li></ul><h2 id="1-1-康德的知识论"><a href="#1-1-康德的知识论" class="headerlink" title="1.1 康德的知识论"></a>1.1 康德的知识论</h2><h3 id="康德哲学中的两条线索"><a href="#康德哲学中的两条线索" class="headerlink" title="康德哲学中的两条线索"></a>康德哲学中的两条线索</h3><ul><li>在康德的哲学里，不知他本人是否意识到了，始终有两对相互矛盾的东西困扰着他，这两对矛盾也是贯穿于整个德国古典哲学的两条基本线索。</li><li>第一条是明线，即思维与存在的关系，在康德哲学中表现为主体与客体的关系，先验自我就是主体，自在之物就是客体。康德的批判哲学想要说明这二者的关系，但是最终却造成了二者之间的对立。思维与存在的关系问题包括“何者为第一性”以及“是否有同一性”两个子问题，德国古典哲学主要解决的是同一性的问题。思维与存在的同一性问题就是思维能否认识存在，也就是认识论的问题，经验论和唯理论在认识论上走进了死胡同，康德就自然而然地着眼于认识论的问题，康德本想实现思维与存在的同一性，但最终得出的结论是自在之物不可知，即否定了同一性。作为德国古典哲学的开创者，康德的贡献在于第一次明确地提出了同一性的问题，自康德开始，经过费希特、谢林、黑格尔，最终在唯心主义基础上实现了思维与存在的同一，而后再到费尔巴哈、马克思，又站在唯物主义的立场上重新解决了这个问题。</li><li>另一条是暗线，即理性与信仰、科学与宗教的关系问题。思维与存在的问题主要在《纯粹理性批判》中表述，而理性与信仰的问题则贯穿于整个“三大批判”中。在当时的德国，理性和信仰都是不可回避的问题，理性精神是英国法国所代表的普世精神，宗教信仰是德意志民族的文化传统。康德受启蒙运动影响，是个充满理性精神的批判者，但同时他也是有虔诚信仰的教徒，尽管他从不参与形式化的宗教活动。只有完整研究了“三大批判”后，才能明白理性与信仰在康德哲学中是一种什么关系，在康德那里，宗教与科学属于两个完全不同的世界，二者泾渭分明，井水不犯河水，在知识论方面，他始终大谈科学，不谈上帝与灵魂，而在实践理性方面，他谈到了道德问题，从道德中引出了宗教信仰。正如康德用一种严格划界或二元论的方式来处理思维与存在的关系，他也用一种严格划界或二元论的方式来处理理性与信仰的关系。</li><li>三大批判要解决的核心问题是：“人是什么？”。这个问题分成了三个子问题，《纯粹理性批判》解决的是“我们能够认识什么？”，《实践理性批判》解决的是“我们应当做什么？”，《判断力批判》解决的是“我们可以希望什么？”。三大批判最终得到的结论是“人是自由”，因此自由是康德哲学的核心，但康德在《纯粹理性批判》中没有讨论自由，他的认识论主要探讨自然界的必然规律，而在《实践理性批判》中，他的道德哲学涉及了人的自由问题，所以康德的前两大批判表现为必然与自由、理论与实践的分裂，虽然他想在《判断力批判》中将其统一，但最终没有实现。因此，康德哲学最终表现为思维与存在、理性与信仰、理论与实践之间的二元分裂和外在对立，黑格尔认为，康德哲学最后的结论是一系列的矛盾，“人是自由”的观点也因此没有得到充足的论证。</li></ul><h3 id="先天综合判断如何可能"><a href="#先天综合判断如何可能" class="headerlink" title="先天综合判断如何可能"></a>先天综合判断如何可能</h3><ul><li>康德开始哲学批判时，面对的是怀疑论和独断论。怀疑论主要是休谟的怀疑论，只承认感觉经验形成的印象和观念，否定一切的实体、上帝和普遍必然性。独断论分为两派，一派是德国的莱布尼茨-沃尔夫体系，认为只靠天赋观念和理性能力就能推出所有知识，是一种唯心主义的独断论，先验地独断了一个主观精神世界，另一派是法国唯物主义独断论，先验地独断了一个客观物质世界，认为世界从根本上就是物质的，物质世界不以人的意志为转移，甚至认为“人是机器”。</li><li>康德先验地假定了两个东西，一个是思维或主体，康德叫做先验自我，另一个是存在或客体，康德叫做自在之物。首先，先验自我和自在之物都只是逻辑上的假定，二者并不是实在的东西，这一点不同于休谟，休谟不允许有超出经验的假设的东西，但康德认为至少从逻辑上来说必须先假定先验自我和自在之物，否则就无法表述由于它们而产生的那些现象。其次，康德承认我们有一些先天的知识形式，如先天直观形式、先天思维形式等，这种知识形式更接近莱布尼兹的天赋潜能而不是笛卡尔的天赋观念，因为知识形式不是现成的知识，还需要依靠经验获得知识的质料或内容，可以看出康德既接受了唯理论的基本前提，又承认了经验的作用，同时受到了亚里士多德“事物是形式与质料的统一”的观点的影响。</li><li>康德试图把唯理论和经验论调和起来，一方面认为先验自我提供了先天的知识形式，另一方面又认为自在之物提供了经验的知识质料，先天的知识形式与经验的知识质料相结合，才能构成具有普遍必然性的知识，这就是康德认识论的基本框架。承认唯理论是为了保证知识的普遍必然性，经验论者已经证明了通过经验归纳得到的知识不具有普遍必然性，目前看来只有先天的东西才是普遍必然的，而承认经验论是为了允许获得新知识，因为唯理论的形式逻辑只是一种证明的方法，新内容需要通过经验归纳获得，所以先天的东西保证了普遍必然性，经验的东西提供了新内容，这样的知识体系才是可靠又可发展的。</li><li>康德认为知识是两个印象或概念连接起来的判断，比如“玫瑰花”和“红的”是两个单纯的印象或概念，只有用系动词连接起来形成“玫瑰花是红的”这样的判断，才可能构成知识，所以知识的最小单位是判断。一切知识都是判断，但任意的判断不一定是知识，只有既具备普遍必然性又包含新内容的判断才算真正的知识，这种判断被康德称为“先天综合判断”。</li><li>康德把传统的逻辑判断分成两类，分别对应唯理论和经验论的思想。第一类是先天分析判断，具有普遍必然性但没有新内容，比如“三角形有三个角”，谓语已经内在包含于主语中。第二类是后天综合判断，提供新内容但不具有普遍必然性，比如“这件衣服是绿的”，主谓语之间的联系不是逻辑必然的。所以康德取长补短，提出了第三种逻辑判断，即先天综合判断，</li><li>“先天综合判断如何可能”是康德认识论的核心问题。但在追问“如何可能”之前，首先应该想清楚“是否可能”，康德的论证方式是在数学和自然科学中列举确实存在的先天综合判断，存在就证明了可能。比如“两点之间直线最短”就是先天综合判断，因为具有普遍必然性(问题在于普遍必然性不能证明出来，康德还是只能基于经验常识来断言是否普遍必然)，同时主语“两点之间的直线”并不包含谓语“最短”，再比如自然科学里的“作用力与反作用力相等”也是先天综合判断。所以剩下的问题就是“如何可能”，康德把这个大问题一分为四，即“纯粹数学如何可能”、“纯粹自然科学如何可能”、“作为一种自然倾向的形而上学如何可能”，以及“作为科学的形而上学如何可能”，也就是这四类知识如何可能。</li></ul><h3 id="感性"><a href="#感性" class="headerlink" title="感性"></a>感性</h3><ul><li>“先天综合判断如何可能”的问题其实就是“先天的知识形式与经验的知识质料如何构成知识”。构成知识的基本原理是：先验自我提供知识形式，自在之物提供知识质料，二者结合构成知识。康德的整个认识论，就是具体说明二者结合的过程，整个过程分三步，第一步是感性，第二步是知性，第三步是理性。</li><li>在感性阶段，先验自我提供了两个先天的直观形式，即时间和空间，我们通过时间和空间形成了对于现象的感性认识。不同于我们的常识，康德认为时间和空间不是客观事物本身具有的形式，而是我们感受对象的一种主观认识形式，是因人而异的，体现在主观认识能力和习惯上的差异，可见康德是以人为中心思考的。换言之，大家只是把主观感受到的一种东西约定俗成地叫做时间和空间，虽然通过沟通使得每个人对时间和空间的理解都差不多，但多少还是有差别的，所以时空本质上是主观的，客观性是人们对约定俗成的误解。需要注意，先天的东西一定是普遍必然的，这种普遍必然性体现在每个人直观到的世界在时空中是一样的，但这并不妨碍我们会因为主观上的种种原因对时空有不同的理解，这种主观上的普遍必然蕴涵了共性与个性的辩证联系。</li><li>康德认为空间是外感官的形式，即直观一切外部现象的先天形式，时间是内感官的形式，即直观一切内部现象(内心状态)的先天形式。尽管自在之物是客观的，但只要我们试图去认识它，就必定会把它放在空间和时间中来加以直观，也就是依靠主观的形式去认识客观的事物。康德的时空观是对牛顿时空观的批判，牛顿提出了绝对空间和绝对时间，二者就像一个大容器，时空间是事物存在所必需的客观背景或依托，但时空间与时空间中的事物是两码事，所以我们只能说事物占据时空间，而不能说时空间是事物的属性，这也是我们所习惯的一套时空观。牛顿的绝对时空观让我们无法想象一个没有时空间作为背景的事物，但康德也是从这个观点反驳，他认为之所以无法想象没有时空间的事物，正是因为时空间是一种无法摆脱的主观上的形式，一旦我们感知事物，就只能先天地、不由自主地把事物置于主观的时空间上理解。</li><li>康德的时空观一定程度上契合了现代哲学和科学的思想，比如相对论认为我们对时空间的感受与身处的参照系有关，现代派文学艺术认为时空间与心理状态直接相关，现代精神病学发现精神不正常的人感受到的时空间和正常人不同。</li><li>在感性阶段，先验自我提供了先天的直观形式，而自在之物提供了感性质料，感性质料被放到先天直观形式中就形成了感性认识。感性认识也叫“现象”，现象是感性质料与先天直观形式结合的结果，是被先验自我加工过的自在之物，加工后本质已经变了，不再是自在之物而是现象。至于纯粹的自在之物则永远都停留在我们的直观之外，自在之物不具有时空，一旦被经验直观后就产生了现象，从而让现象具有了时空的属性，正如物理中的测不准原理，观察手段会对观察对象产生影响。所以在康德的认识论中，我们认识的对象并不是纯粹的客观世界本身，而是主客观杂糅后的现象，认识的过程就是一边形成现象，一边形成对现象的认识。</li><li>感性阶段使得数学作为一种先天综合判断成为可能，因为几何学是关于空间的科学，代数是关于时间的科学，先天的时空形式和经验的感性质料相结合，使得数学成为了一门先天综合判断的科学。这就解决了“先天综合判断如何可能”的第一个子问题。</li></ul><h3 id="知性"><a href="#知性" class="headerlink" title="知性"></a>知性</h3><ul><li>构成知识的第二个阶段是知性，正如先天直观形式是感性阶段体现的先天知识形式，先天思维形式就是在知性阶段体现的先天知识形式。先天思维形式表现为12个范畴，包括三个量的范畴(单一性、多数性、全体性)、三个质的范畴(实在性、否定性、限制性)、三个关系范畴(实体与偶性、原因与结果、主动与受动)和三个模态范畴(可能性与不可能性、存在与非存在、必然性与偶然性)。在感性阶段，自在之物刺激我们的感官，所以我们是被动接受信息的，虽然在先天直观形式中产生现象的过程是主观的，但这更倾向于一种本能的、不由自主地条件反射。而我们在知性阶段却是完全主动的，这时先验自我运用先天思维形式对在感性中获得的现象进行知性加工，即运用这些范畴对已经处于时空之中的现象进行综合统一。比如“钻木”和“着火”是两个现象，套上了因果关系的范畴，就有了“钻木可以起火”的判断。这种判断是先天综合判断，也就是真正的知识，因为先天思维形式具有普遍必然性，现象包含了经验的内容，二者结合自然就是具有普遍必然性的新知识。在知性阶段，现象与范畴的进一步结合使我们获得了具有普遍必然联系的自然科学知识，所以“先天综合判断如何可能”的第二个子问题得到了解决。</li><li>至此，康德表述了“纯粹的数学和自然科学如何可能”的问题，传统观点认为观念需要去符合对象，知识是主体对客体、人对自然的反映，但在康德的认识论里，认识的对象不是自在之物而是现象，现象在认识过程中被构造出来，所以在这里对象要去符合观念。康德自以为拨乱反正，所以他称自己在知识论上完成了一个“哥白尼式的革命”。换言之，我们的唯物主义反映论是“自然给人立法”，在康德这里则是“人给自然立法”，康德认为，广义的理性在理论方面的重要作用就是给自然界颁布法律，即“自然律”，同理，在他的道德哲学中也提出了我们用理性给行为颁布的法律，即“道德律”，自然律和道德律都是理性运用的结果。</li><li>在知性阶段还蕴含了一种观点，即知性的范畴只能运用于时空中的现象上，不能运用于超验的自在之物，这就再次体现了知识是关于现象的知识，纯粹的自在之物是不可知的。</li></ul><h3 id="理性"><a href="#理性" class="headerlink" title="理性"></a>理性</h3><ul><li>在《纯粹理性批判》中，“理性”具有不同的含义。从最宽泛的意义上来说，感性、知性和理性这三个部分都属于广义的理性范围。其次，相对于感性而言，知性和理性也可以一并被看作是理性。从最狭隘的意义上来说，理性则单指与感性、知性不同的认识第三阶段。这里只谈第三阶段的最狭义的理性。</li><li>除了感性和知性，先验自我还有一个更高的层次叫做“理性”，即狭义的理性。理性对在知性中获得的自然科学知识进一步综合统一，以实现从知性的具体知识向更完备的绝对知识的过渡，比如从具体的心理学知识上升到关于“灵魂”本身的知识，从具体的物理学知识上升到关于“宇宙”本身的知识，从世界的知识上升到关于世界原因(即“上帝”)的知识。相对于先天直观形式和先天思维形式，先验自我在理性阶段所体现的是三个先验的理念，即“灵魂”、“宇宙”和“上帝”，这三个理念的作用就是把具体知识进一步综合统一，先统一到灵魂和宇宙，最终再统一到上帝，就得到了最完备、最系统的知识体系。</li><li>康德认为这三个先验的理念只不过是人们出于对知识综合统一的需要，所假定出来的一种逻辑上的概念或层次，既不是客观存在的实体，也不能作为认识的对象。然而理性天生就具有一种超越的倾向，它总是要把调节性的原则当作一种建构性的原则，从而把“灵魂”、“宇宙”、“上帝”当成了三个客观的对象，当作了超验的自在之物，又因为理性只有先验的理念，为了追求对这三者的认识我们不得不运用知性的范畴，但范畴只能运用于时空中的现象，所以用知性范畴去认识超验的自在之物一定会产生谬误。因此历来的独断论者所犯的共同错误，就是把逻辑的主体理解成了实在的主体，导致了诸如精神实体、关于上帝存在的证明等谬误，从而导致了理性自身的分裂。</li><li>在批判独断论者的理性宇宙论时，康德提出了四个二律背反，也就是把知性的范畴运用到作为自在之物的“宇宙”上时，会使得两个对立的观点都能自圆其说。二律背反的命题如下：<ul><li>世界在时间和空间上是有限的 vs 世界在时间和空间上是无限的。</li><li>世界上的一切都是由单纯的部分复合而成 vs 世界上的一切都是复合的，没有单纯的东西</li><li>世界上除了自然因果性外，还有自由的因果性 vs 世界上只有自然因果性，没有自由</li><li>世界上有绝对必然的存在者作为世界的一部分或者世界的原因 vs 世界之中或世界之外都没有绝对必然的存在者</li></ul></li><li>二律背反体现了理性的分裂，理性出于天生的倾向做了不该做的事，它不满足于知性阶段对知识综合统一的程度，试图认识更高层次的超验的自在之物。这种错误是以往各种独断论或形而上学的共同特征，由此就解答了先天综合判断如何可能的第三个子问题，即作为一种自然倾向的形而上学如何可能，可见，康德对以往的各种形而上学都持批判态度。与此相反，当我们限制了理性去运用知性范畴，只让理性起到调节和范导知识的作用，就避免了独断论的谬误，这就解答了先天综合判断如何可能的第四个子问题，也就是在对作为自然倾向的形而上学的批判中，使作为科学的形而上学成为可能。实际上，康德认为形而上学在自然领域只能是消极的，但在道德领域却可以是积极的，他在《实践理性批判》中提出的道德哲学，就是一种积极的、科学的形而上学。</li><li>康德认识论的结论是关于自在之物的不可知论，他一方面认为自在之物不可知，但另一方面自在之物作为感性质料的来源又必须假定存在。后来的谢林把这种不可知的自在之物发展为信仰的对象，由不可知论转向了宗教神秘主义。黑格尔则认为，承认事物本质的不可知是一种“理性的怯懦”，现象只是联结主体和客体的桥梁，认识的最终目的就是透过现象看本质。康德把现象变成了割裂思维与存在的鸿沟，虽然他率先提出了思维与存在的同一性问题，但却没有很好地解决这个问题，他的最终结论是主体与客体、思维与存在之间的截然对立。</li><li>二律背反是近代辩证法的开端，但康德对二律背反持消极的态度，任由矛盾存在而不思考解决矛盾的方法。后来经过费希特、谢林，最后由黑格尔实现了矛盾的对立统一，黑格尔认为解决矛盾的方法恰恰在于认识矛盾和扬弃矛盾，而不是回避矛盾。康德始终认为矛盾是滥用理性产生的谬误，是可以回避的，所以他主张通过限制理性来避免矛盾，而黑格尔则认为矛盾是客观世界中普遍存在、不可回避的东西，并非理性的谬误，所以他才会积极运用理性去思考矛盾，最终能把矛盾上升到对立统一的自否定过程。</li></ul><h2 id="1-2-康德的道德哲学"><a href="#1-2-康德的道德哲学" class="headerlink" title="1.2 康德的道德哲学"></a>1.2 康德的道德哲学</h2><h3 id="道德律与自由"><a href="#道德律与自由" class="headerlink" title="道德律与自由"></a>道德律与自由</h3><ul><li>在康德的认识论中，上帝、灵魂等被贬低为逻辑假设，但在他的本体论思想中，在自在之物的本体界，上帝被树立为实践理性的信仰对象，这一观点表述在《实践理性批判》中。</li><li>在《纯粹理性批判》中，理性给自然立法，涉及的是理论理性或知识的论域，而在《实践理性批判》中，理性给自身立法，涉及的是实践理性或道德的论域。康德认为，实践理性不同于理论理性，它超越了现象，深人到认识不可达的本体界或自在之物，它的目的就是对自由的确立。正如理论理性是给自然界颁布自然律，实现理性则是给人颁布道德律，但二者不同的是，自然律是自然事物“实际”遵循的，而道德律却是人“应该”遵循的，道德律采取的是应然而不是实然的形式，恰恰体现了人的自由本质。</li><li>实践理性颁布道德律时，采取道德命令的形式。命令分为有条件命令和无条件命令，比如在“你应该xxx，否则xxx”中，后半句就是条件。有条件的命令不是道德命令，充其量只是表现了一种合法性，因为遵从命令可能出于功利权衡而非道德追求。所以道德命令一定是无条件的，遵从道德命令一定是出于对道德的热爱。</li><li>康德的道德律只谈形式不谈内容，道德命令只是形式性的东西而不包括任何具体的质料。他并不直接表述“你不应该杀人”、“不应该偷盗”等具体行为，而是表述为“不论你做什么，你都要看看这种行为的准则能不能同时成为一条普遍的立法原则”。道德律有三个特点：具有普遍性，把人当作目的而非手段来加以尊重，以及是“自己立法、自己遵守”的意志自律原则。意志自律原则凸显了自由，但不是随心所欲式的自由，而是以尊重自己和他人为基础，对某种必然性(普遍立法的道德律)的遵循。道德律是自己对自己颁布的法则，因此自由与必然性就得到了统一，康德认为道德律是自由的认识理由，自由则是道德律的存在理由，也就是说，我们因为本性自由而遵循道德律，自由又可以通过道德律彰显出来。</li><li>目前已经有了三种自由。第一种是随心所欲式的自由，但根本不能加以推广，因为在一个社会中，如果每个人都想干什么就干什么，其结果将是谁也干不了什么。第二种是斯宾诺莎理解的自由，即自由是对必然性的认识和顺应，但是这表现为一种外在的必然性，是他律而非自律，所以我们在这种必然性面前是被动的，不算真正的自由。第三种是康德理解的自由，即“自己立法，自己遵守”的意志自律原则，始终把人当作目的来加以尊重，因此更能体现自由的真正内涵。</li><li>康德与卢梭一样，都是近代动机主义道德观的创立者，他们认为道德的行为不能是出于其他原因被动地遵守，而是一定要出于主观上对道德的追求，所以道德的行为既是客观上的道德又是主观上道德。与此相对的是18世纪法国的爱尔维修、英国的边沁等人的功利主义和效果论，他们认为道德的行为只需要在客观上体现道德，只看结果不看动机。</li></ul><h3 id="纯粹实践理性的信仰"><a href="#纯粹实践理性的信仰" class="headerlink" title="纯粹实践理性的信仰"></a>纯粹实践理性的信仰</h3><ul><li>当时功利主义道德观普遍被人们接受，所以康德不得不让他过于理想化的道德观向世俗做出让步。他提出了“至善”是实践理性的最终目的，至善是道德与幸福的统一，道德就是遵循道德律，实现精神追求，而幸福则是遵循自然律，满足肉体追求。既要实现道德又要追求幸福，往往会出现矛盾，使我们陷入一种“实践理性的二律背反”。</li><li>“实践理性的二律背反”就是指我们到底是从幸福引出道德 ，还是从道德引出幸福。前一种观点以伊壁鸠鲁主义为代表，认为解放人性、满足欲望就是道德，后一种观点以斯多葛主义为代表，认为压制欲望、道德高尚就是幸福。这两种观点的错误在于把幸福和道德的关系当作一种分析关系，试图从幸福中分析出道德，或者从道德中分析出幸福，但是康德认为，幸福和道德之间充其量只具有一种综合关系，不能把幸福和道德等同，也不能用幸福作为原因推出道德，而用道德作为原因推出幸福虽然理论上可能，但现实中有道德的人往往过着不幸的生活，极大地动摇了我们坚持道德的信心和勇气。</li><li>在这样的矛盾下，为了保证至善的可达性，让自己的道德观具有积极意义，康德搬出了上帝，在《实践理性批判》中表述了上帝存在的道德论证明(尽管他本人强调这只是一个悬设而不是证明)。证明分三步：第一，假定道德作为原因可以推出幸福，假定人有自由意志作为实现道德的基础。第二，假定灵魂不死，肉体死亡不会中断追求道德的路程。第三，道德与幸福的因果报应需要有一个全知全能全在的第三者来保障，那么这个第三者只能是上帝。这种因果保障就是康德向功利主义的让步，所以上帝存在的证明只是出于实践理性的需要，也就是康德为了鼓励人们追求道德，宁愿让人们把上帝作为事实去相信和信仰。在康德这里，上帝的存在不再是客观必然的，而是主观必要的，上帝存在的根据不再是理论的逻辑论证，而是实践的道德要求。</li><li>康德在道德领域也进行了一场“哥白尼式的革命”，以往人们总是把信仰当作道德的根基，现在康德却反过来把道德当作信仰的根基，从德福相配的至善理想中引出关于上帝的信仰，而道德的根基从宗教信仰变成了自由意志。因此康德并不是从宗教中引出道德，而是从道德中引出宗教。</li><li>实际上，康德和斯多葛主义者一样，把道德当做幸福，他一生孑然一身却能乐在其中。康德之所以向功利主义让步，是为了让自己的道德观具有普世价值，让思想境界没自己高的普通民众也能积极地去追求道德，即使掺杂着功利心也可以容忍。</li></ul><h2 id="1-3-康德小结"><a href="#1-3-康德小结" class="headerlink" title="1.3 康德小结"></a>1.3 康德小结</h2><ul><li>康德的意义在于他构成了近代哲学与现代哲学的重要桥梁。他虽然用先天综合判断的理论调和了怀疑论和独断论，但最终没有超越二者。一方面，他把知识限制在现象世界里，认为自在之物不可知，因此没有完全摆脱怀疑论和不可知论。另一方面，他的哲学建构在先验自我和自在之物这两个独断的基础之上，而不对二者的原因继续追问，先验自我是唯心主义式的独断，自在之物是唯物主义式的独断，因此他也没有完全摆脱独断论。</li><li>作为德国古典哲学的开端，康德的贡献在于提出问题而不是解决问题。正因为康德提出了许多开放性的问题，可以从中引出各种不同的解决方案，所以康德直到今天仍然成为各派哲学共同回溯的一个出发点。反观黑格尔，他的哲学是一种“黑格尔式”的解决方案，在这个方向上不可能有人超越他，所以很少有人愿意回溯到黑格尔。</li><li>康德提出了思维与存在的同一性问题，想要实现思维与存在、主体与客体、先验自我与自在之物的统一，但最终结论却是二者的完全对立。</li><li>在认识论领域，康德讨论了理论理性是如何通过给自然立法来形成科学知识，在道德哲学中，他又讲了实践理性是如何通过给人自身立法以实现意志自律，最后从至善理想中引出了灵魂不死和上帝存在。但康德的认识论和道德哲学是完全脱节的，他和卢梭的观点一样，认为理论与实践、知识与道德没有关系，知识的量与道德的质之间没有必然联系，意志自律是自由的事情，与一个人对世界的认识也没有任何关系。与此相对的是苏格拉底、斯宾诺莎的观点，苏格拉底认为知识即美德，斯宾诺莎认为自由是对必然性的认识，换言之，理论认识越深刻，实践就越自由。因此，在康德哲学里，理论和实践也是分裂的。</li><li>最后，理性和信仰在康德哲学中也是分裂的。《纯粹理性批判》只解决认识论问题，把灵魂、上帝之类超经验的东西都排除了，而在《实践理性批判》中出于实践理性需要又引出了灵魂与上帝。所以他的认识论和道德哲学就体现为科学理性和宗教信仰的对立，一个针对外在的自然世界，一个针对内在的精神世界，井水不犯河水。</li><li>除了以上三种分裂，康德还提出了二律背反问题，也就是认识从知性阶段上升到理性阶段后会产生矛盾。但康德的局限在于把矛盾看成是不好的东西，只看到了矛盾是思维的本质属性，却没有看到矛盾同时也是存在的本质属性，所以康德会主张限制理性，试图把矛盾扼杀在主观世界，不去污染客观世界。康德哲学中这一系列未解决的问题给后人留下了充足的发挥空间。</li></ul><h1 id="2-费希特"><a href="#2-费希特" class="headerlink" title="2 费希特"></a>2 费希特</h1><h2 id="2-1-对康德哲学的批判"><a href="#2-1-对康德哲学的批判" class="headerlink" title="2.1 对康德哲学的批判"></a>2.1 对康德哲学的批判</h2><ul><li>康德称自己的哲学是批判哲学，他的哲学很难被归属在一个主流的派系或什么主义中。先验自我有唯心主义色彩，自在之物有唯物主义色彩，先验自我和自在之物的预设体现出二元论色彩，认识不能到达自在之物又倾向于不可知论，相比之下，费希特就旗帜鲜明，宣称自己是唯心主义，因为他以“绝对自我”为中心，所以又是主观唯心主义，他的哲学始于对康德的批判</li><li>在康德那里，先验自我提供形式，自在之物提供质料，费希特站在唯心主义的角度，必然会对自在之物发出质疑。康德之所以提出自在之物，可能是因为在他的时代不仅有经验论和唯理论，还有法国唯物主义者哲学，他受到了唯物主义思想的启发。但康德关于自在之物不可知却必须存在的观点，给费希特留下了批判的根据，既然假定不可知，就必须像休谟的怀疑论一样坦诚地表明自己对自在之物的存在与否也是一无所知的，所以康德所谓的自在之物其实是思想的虚构物，并非与“自我”一样是哲学的原始项，而是从“自我”里面派生的。费希特把自在之物称作“非我”，但本质上不是“自我”的对立面，而是“自我”中产生的“为我之物”。</li><li>费希特对康德哲学的批判可以概括为如下几点：第一，康德关于知性的12个范畴都是从质、量、关系、模态四种判断形式中分析出来的，费希特却认为这些范畴是从自我意识中合逻辑地演变出来的。第二，因为费希特认为自在之物本身就是从自我中产生的，所以质料是从形式中产生的，形式和质料都是来自于主观自我。第三，康德把认识与实践相分裂，费希特则认为“自我”在创造“非我”的实践过程中也在认识“非我”，因此认识和实践是不可分割的同一个过程。</li><li>康德试图用先验自我和自在之物统一唯物主义和唯心主义，但最终失败了。针对这种结果，费希特认为康德的方向是错的，唯物主义和唯心主义是不可调和的。他认为唯物和唯心不是单纯的理论分歧，而是自我意识和个体人格境界的差异，当人们没有认识到“非我”是“自我”的产物时，就容易对外在世界产生依赖，从而相信唯物主义，当认识到“非我”的本质后，就会上升到唯心主义。所以费希特认为唯心主义是更高的境界。</li><li>费希特哲学的显著特点就是狂妄，他认为一切外界事物都是“自我”创造出来的。但是在这种狂妄精神的背后，隐藏着一种极大的现实苦恼，这种现实苦恼的根源在于，德意志民族的贫穷、落后、分裂的现实状况与英、法等先进国家在实践领域所取得的杰出成就之间的巨大反差。这种深重的现实苦恼很容易以一种逆反的方式转化为一种精神上的狂妄，表现为一种登峰造极的唯心主义。但费希特也像其他德国哲学家一样，是“思想上的巨人，行动上的侏儒”，他的狂妄精神始终局限在思想领域，没有付诸行动。</li><li>费希特主张一切都是“自我”创造的，但为了与贝克莱的唯我论区别开，费希特强调这个“自我”不是某个人的自我，而是作为世界精神的绝对自我。</li></ul><h2 id="2-2-正题、反题、合题"><a href="#2-2-正题、反题、合题" class="headerlink" title="2.2 正题、反题、合题"></a>2.2 正题、反题、合题</h2><ul><li>费希特通过正题、反题、合题的三段式表述自己的哲学。</li><li>费希特哲学的正题是：“自我设定自身”。换言之，“自我”作为整个世界的原始项或本原，它的背后不容许追问出任何更本原性的东西，因此“自我”必须是自由的和自因的。</li><li>费希特哲学的反题是：“自我设定非我”。“自我”设定了自身后，接着就是设定外物，这个“非我”就是康德的自在之物、唯物主义的客观世界，在本质上属于“自我”，在形式上与“自我”对立。费希特认为，“自我”必须设定一个东西来限制自己、对立自己，才能真正地成为“自我”。但此时的“自我”还没有自我意识，误认为“非我”是不受自己控制的客观存在的自在之物，这就是康德哲学中先验自我和自在之物的对立。因此康德哲学最终只停留在费希特的反题阶段。</li><li>费希特哲学的合题是：“自我设定自身和非我”。虽然表述上是正题和反题的简单合取，但是真正的含义是“自我”意识到了“自我”和“非我”是由同一个原因派生出的东西，因为二者被同一个“自我”设定，所以二者在被设定的过程中会产生相互限制的作用。当“自我”限制“非我”时，即主观作用于客观、思维作用于存在、观念作用于对象，这就是实践活动，当“非我”限制“自我”时，即客观作用于主观、存在作用于思维、对象作用于观念，这就是认识活动。所以“自我”和“非我”相互限制的过程蕴涵了实践活动与认识活动，在这个过程中，实践与认识是对立同一的。费希特把作为原因的有自我意识的“自我”称为“绝对自我”，绝对自我是自我在认识过程中自发展的结果，即绝对自我派生出自我和非我，在绝对自我中，主观与客观、思维与存在、实践与认识这些对立的东西全部达到了同一。</li><li>从费希特开始，德国哲学就具有了一种晦淫而神秘的特点，那就是精神一定要经过艰苦而漫长的磨炼过程才能最终达到真理，也就是自我把自身上升到绝对自我的过程，正是这种自编自演的精神苦肉计，克服了康德在思维与存在、认识与实践之间所造成的对立，因为在绝对自我的视角下，认识和实践归根结底无非是“自我”与自己的影子“非我”之间的障眼术。</li><li>费希特不仅解决了一系列同一性问题，也解决了二律背反问题。康德的二律背反在费希特这里就是正题与反题的矛盾，和同一性问题一样，到了合题阶段，就在绝对自我下实现了矛盾双方的同一。</li><li>辩证法的核心思想就是对立同一，费希特最先提出了对立同一的逻辑形式，正是在费希特正题、反题、合题的基础上，黑格尔才发展出肯定、否定和否定之否定的辩证逻辑三段式。</li><li>费希特哲学的问题在于，把整个世界说成是“绝对自我”的产物，但“绝对自我”本身却是个很玄学的东西，费希特指出“绝得自我”是一种世界精神或全人类的自我意识，旨在提高自我的地位和普遍性，然而这种解释并不能让人信服。</li></ul><h1 id="3-谢林"><a href="#3-谢林" class="headerlink" title="3 谢林"></a>3 谢林</h1><h2 id="3-1-对康德、费希特的批判"><a href="#3-1-对康德、费希特的批判" class="headerlink" title="3.1 对康德、费希特的批判"></a>3.1 对康德、费希特的批判</h2><ul><li>谢林在20岁时因批判费希特而成名，他与黑格尔是同学，相比于谢林的少年天才，黑格尔虽然年长但却是大器晚成，因此黑格尔的思想也受到了谢林的影响。早年谢林与晚年谢林之间存在着很大的差异，早年谢林的哲学思想主要表现为自然哲学、先验哲学以及二者结合而成的同一哲学，而后又开始热衷于艺术哲学，晚年则转向了基督教的神话哲学和启示哲学。当谢林转向宗教神秘主义时，黑格尔的思辨哲学开始在德国崛起，相比于康德和黑格尔一脉相承的理性主义传统，谢林的非理性主义和宗教神秘主义与时代潮流格格不入，使得他被哲学界被边缘化。直到19世纪下半叶，谢林晚年的哲学思想才受到祁克果、尼采、狄尔泰、海德格尔等人的大力传扬。又因为谢林认为艺术比哲学更高，所以他在20世纪受到现代派艺术家和诗人的推崇。</li><li>谢林的哲学始于对费希特的批判。第一，费希特认为最初的自我是没有自我意识的，上升到绝对自我才有了自我意识。而谢林指出自我必须要有自我意志，所以最初那个没有自我意识的东西不能算是自我。第二，费希特把绝对自我说成是一种宇宙的、普遍的自我，这种说法让人难以接受。第三，绝对自我并不是绝对的，因为绝对即无限，绝对自我与最初的自我相比只是多了自我意识，因此最初的自我也是无限的，既然自我是无限的，就没有理由派生出一个非我来与自己形成相互限制。</li><li>费希特的“自我”漏洞百出，于是谢林另辟蹊径，借助了斯宾诺莎的泛神论，把斯宾诺莎的“实体”神秘化，称之为“绝对”或“绝对同一”，将其作为唯一的原始项，从中产生精神与物质、思维与存在、观念与对象的差别和对立。谢林认为哲学的任务就是要说明思维与存在、自我与自在之物之间的关系，他把这种关系称为表象与对象之间的关系，并且把它分解为两个任务，第一个任务是说明表象如何依对象而变化，即对客体的认识问题，第二个任务就是说明对象如何依表象而变化，即主体的实践问题。谢林认为，费希特只解释了对象(非我)如何依表象(自我)而变化，唯物主义只解释了表象(精神)如何依对象(物质)而变化，二者各执一端，陷入了片面性，并没有同时解决两个问题。而康德哲学的结论是表象(先验自我)与对象(自在之物)的完全对立，不存在一方依另一方变化的可能，所以康德连一个问题都没有解决。(为什么费希特的非我限定自我不算是解决第二个问题？是因为非我只是自我的影子？)</li><li>唯心主义(费希特)、唯物主义和二元论(康德)都被谢林否定了，看似没有了第四种可能，但谢林突破性地提出了一个既不是思维也不是存在，又包含了这些对立因素的东西作为出发点，即借鉴自斯宾诺莎“实体”概念的“绝对”(也叫“绝对同一”、“绝对理性”或“宇宙精神”)，因为在斯宾诺莎的哲学里，思维与存在对应了思维与广延这两个实体的属性，而实体本身显然是超越了两者又包含两者的东西。因此，谢林把哲学的起点提高到思维与存在之上，开创了第四种可能。</li><li>谢林认为，主客体的对立是相对的，二者的同一才是绝对的，所以“绝对”既不是主体也不是客体，而是“同一”本身，是一个原始的同一体。在思维与存在的层面，分出了唯物主义和主观唯心主义，但谢林的起点是思维与存在达到同一的更高的层面，所以他称自己的哲学是客观唯心主义。</li><li>谢林认为世界最初就处于一种绝对无差别的同一状态，思维与存在的对立是在世界发展的过程中产生的，而随着世界的发展，所有的对立必然会复归于绝对同一。只有在这个从同一走向对立、再从对立走向同一的过程中，才能解释表象如何依对象变化，以及对象如何依表象变化。</li></ul><h2 id="3-2-同一哲学"><a href="#3-2-同一哲学" class="headerlink" title="3.2 同一哲学"></a>3.2 同一哲学</h2><ul><li>谢林的早期哲学就是说明从同一到对立、再从对立回到同一的过程，这种同一自身发展演变的哲学就是同一哲学，它又可以分为自然哲学和先验哲学，前者通过自然界的演化说明精神是如何从潜能走向现实的，后者通过世界历史的演进说明自我意识是如何创造客观世界的。自然哲学和先验哲学解释了从自然界到人类社会的整个发展历程。</li><li>谢林认为，在最初的同一状态里，思维与存在是和“绝对”融为一体的，但由于“绝对”有一种内在目的性，产生了打破同一的欲望，结果导致了差异、矛盾、对立等关系。黑格尔对此的批判是，这种打破同一的欲望毫无产生的道理，谢林也没有解释清楚。欲望是一种拟人的表达，可见谢林的解释是诗意的解释，黑格尔认为谢林哲学缺乏理性，所以从逻辑根据上批判他。</li><li>“绝对”突破同一后，首先产生了自然界，自然哲学描述的就是从同一中产生出差别、对立、矛盾的过程。最初的自然界是一个纯粹的机械性世界，存在或客体占绝对主导的地位，随着自然界的发展演化，产生了精神或意识，意识发展到人类这里就有了充分的自觉，思维或主体的地位就超过了存在或客体，思维或主体占了主导地位，二者的差别、对立、矛盾关系发生逆转，因此自然哲学也就结束了。</li><li>谢林把“二元对立”或“两极性”当作自然界的一个基本原则，在自然发展进化的过程中，每一个阶段都体现了这种“两极性”。比如引力和斥力、正电和负电、酸和碱，以及生物的感受性和反应性、人的主观与客观。低级世界中的“两极”在较高级世界中达到了合题，实现了同一，但是新的“两极”又产生出来，构成了新的差别、对立、矛盾，如此层层递进，就形成了自然界发展的一般公式，即同一→对立→同一。这个公式揭示了自然界从低级到高级的有目的的发展演化过程，是费希特正反合三题的动态演变，对黑格尔的否定之否定思想产生了重要影响</li><li>到人这里，思维或主体占主导地位，同一哲学的阶段从自然哲学转向了先验哲学。自然哲学说明了表象如何依对象变化，先验哲学则说明了对象如何依表象变化，所以同一哲学在人这里的过渡就是从认识过渡到实践，即人类的社会历史进程。</li><li>费希特只是静态地说明“自我”与“非我”、主体与客体之间的相互作<br>用和相互限制，而谢林的自然哲学和先验哲学带有一种动态的、发展的、有历史感的思想(自我上升到绝对自我为什么不算是动态的发展呢？)。后来谢林说黑格尔剽窃他的思想，也是因为黑格尔把从自然界到人类社会的全部历史看作是“绝对精神”的自我实现和自我认识，显然受到了谢林的影响。</li><li>先验哲学说明了主观的精神或自我意识如何创造客观世界的过程，分三个阶段。<ul><li>第一步是认识，谢林这里的观点和康德、费希特一样，认为认识的对象不是意识之外的自在之物，而是被自我意识赋予了形式的为我之物。</li><li>第二步是实践，谢林论述了人的自由是如何在漫长的世界历史中与必然性相协调的过程，在古代社会，自由与必然性相分裂，人类屈服于命运的必然性，在中世纪，自由屈从于自然必然性，封建关系使得自由成为少数人的特权，到了谢林的时代，随着人类对自然必然性的认识和驾驭，自由与必然性相协调，成为一种自由的必然性。</li><li>第三步是艺术，尽管自由与必然性在实践中产生了协调，但依然不是真正无差别的同一，对此谢林提出了人的理性直观能力。康德虽然也提过理性直观，但他认为人只有感性直观没有理性直观。谢林则认为少数的天才人物是有理性直观的，他们可以超越于现实历史自由地创造客观现实。然而在理智直观中，主体与他创造的客体还不是完全同一，实现同一需要把理性直观上升到艺术直观。谢林认为艺术高于哲学，因为艺术家在艺术创作的过程中往往会达到一种物我两忘、主客不分的至高境界，在这种境界里，一切差别、对立、矛盾都融为一体，主体与客体实现了真正的无差别的同一。</li></ul></li></ul><h2 id="3-3-对谢林哲学的评价"><a href="#3-3-对谢林哲学的评价" class="headerlink" title="3.3 对谢林哲学的评价"></a>3.3 对谢林哲学的评价</h2><ul><li>谢林从绝对无差别的同一出发，最终回到了绝对无差别的同一，正如康德过分地执着于对立，谢林则表现为过分地执著于同一。黑格尔反对康德和谢林观点，他认为任何同一都是具体的、辩证的，是包含着矛盾的同一。黑格尔嘲讽二人的观点是抽象的对立和抽象的同一，因为先验自我与自在之物、主体与客体都是抽象的东西，也因此他把抽象对立和抽象同一都斥为一种形而上学，这里的形而上学就有了马克思哲学里的那种贬义的意思，即孤立地、静止地、片面地看问题的思想方法。康德哲学里已经有了这种倾向，他把形而上学分成作为自然科学的形而上学和科学的形而上学，认为一个消极一个积极，到了黑格尔，形而上学就有了明显的贬义。</li><li>谢林打破绝对同一靠的是一种非理性的欲望，这种欲望充其量是一种诗意的描述，缺乏逻辑和理性。黑格尔对谢林把艺术与哲学相提并论甚至高于哲学的观点很不满，可见黑格尔是重哲学轻艺术的，在艺术与哲学的关系问题上，二人的观点处于两个极端，都是有待商榷的。</li><li>在矛盾问题上，康德表现为正反题，费希特表现为正反题到合题，谢林表现为合题到正反题再回到合题，最后到了黑格尔就是肯定到否定再到否定之否定，对立同一的过程就是同一个东西的自否定过程，这个东西在谢林哲学里叫“绝对”，在黑格尔哲学里就叫“精神”。可见，在这个一脉相承的思想发展过程中，谢林哲学是承上启下、不可缺少的中介。</li></ul><h1 id="4-黑格尔"><a href="#4-黑格尔" class="headerlink" title="4 黑格尔"></a>4 黑格尔</h1><h2 id="4-1-“密涅瓦的猫头鹰”"><a href="#4-1-“密涅瓦的猫头鹰”" class="headerlink" title="4.1 “密涅瓦的猫头鹰”"></a>4.1 “密涅瓦的猫头鹰”</h2><ul><li>1807年黑格尔发表了《精神现象学》，标志着黑格尔哲学的奠立，此时也恰逢谢林开始淡出哲学界，转向宗教神秘主义。而后黑格尔又出版了《逻辑学》、《哲学全书》、《法哲学原理》等巨著，使他的哲学成为了普鲁士官方哲学，还获得了普鲁士政府颁发的荣誉奖章。奖章的两面分别雕着黑格尔的侧面头像和肩头站着一只猫头鹰的智慧女神密涅瓦。黑格尔有一句名言：“密涅瓦的猫头鹰只有在黄昏时分才起飞”，意思是哲学这种人类智慧的最高成就，往往是在一个人的晚年或者一个时代的精神成熟之时才会大放异彩，比喻了自己的大器晚成，与少年成名的谢林形成鲜明对比，暗中贬低了谢林所崇尚的艺术。</li><li>德国古典哲学自康德开始，经过费希特和谢林，到了黑格尔就已经对思维与存在的关系问题以及矛盾的问题形成了一种比较合理的见解，基本挑不出硬伤，因此后来的费尔巴哈和马克思只是换到唯物主义的角度重新解决这些问题。唯心和唯物的立场与文化背景有关，从康德到黑格尔的时代一直是在对思想进行批判，所以他们会站在唯心主义的角度，到了马克思的时代，开始对实践和现实政治进行批判，自然而然会让人站在唯物主义的立场。</li><li>黑格尔的哲学狂妄又霸道，他已经把话说绝了，在他的方向上的哲学不可能再超越他，所以现代哲学比较反感黑格尔。黑格尔的哲学代表着一种英雄主义和宏大叙事主题的时代精神，与现在这个时代显得格格不入。</li><li>黑格尔的哲学始于对康德、费希特和谢林的批判。</li><li>黑格尔认同康德批判考察认识能力的观点，但他反对在认识之前考察认识能力，因为对认识能力的考察本身就是一种认识活动。黑格尔也反对康德的不可知论，认为这是一种消极态度和“理性的怯懦”，黑格尔认为理性和矛盾是世界的本质，不可知论是康德限制理性、逃避矛盾所产生的自欺欺人的结果，所以应该正视矛盾、扬弃矛盾，从矛盾中走向同一。</li><li>黑格尔认同费希特把实践的能动性赋予了思维本身，但他反对以费谢特所理解的“自我”为原始项，因为费希特没有认识到“自我”的本质，“非我”应该是“自我”因内在矛盾而自否定的结果，而不是“自我”仅仅为了限制自己才设定出来的。</li><li>黑格尔认同谢林对立同一的发展观点，但他反对同一是绝对无差别的同一，同一应该是具体的、包含着对立的。黑格尔也反对同一走向对立的动力是无意识的欲望，真正的动力应该是同一本身所包含的内在矛盾。此外，黑格尔认为哲学高于艺术。</li></ul><h2 id="4-2-黑格尔哲学概观"><a href="#4-2-黑格尔哲学概观" class="headerlink" title="4.2 黑格尔哲学概观"></a>4.2 黑格尔哲学概观</h2><ul><li>黑格尔哲学的起点是“精神”，既不是思维也不是存在，这一点深受谢林的影响。对于自我实现、自我认识的全过程而言，这个“精神”又可以叫做“绝对精神”，因为它是自否定过程中将主观和客观辩证同一起来的精神，包含了一切东西，无限即绝对。</li><li>绝对精神是思维与存在的同一，但在绝对精神内部，思维与存在是有差别的，他们是绝对精神发展的不同阶段，思维与存在的辩证同一就像蚕和蛾的辩证同一。这是一种发展的眼光，A是A，同时A也时刻处于向非A转化的过程中，从整个发展过程来看，A既是A也不是A，形成了一种自否定。</li><li>绝对精神既是实体又是主体，实体是独立实在的或不依赖于其他事物而存在的东西，主体是自由的、自因的、具有能动性的东西，具备了这些特点，绝对精神就足以作为一切的起源，创造出万事万物。绝对精神不断走出自身又回到自身，在这个过程中不断否定与扬弃(有保留的抛弃)，形成了从简单到复杂、从抽象到具体的大千世界，在自我实现的同时也在自我认识。</li><li>绝对精神自我实现、自我认识的过程表现为一系列的正题、反题、合题或者肯定、否定、否定之否定的三段式，这些三段式构成了黑格尔哲学的全部内容，其中最大的三段式是逻辑学、自然哲学、精神哲学的三段式。绝对精神经历的第一个阶段是逻辑阶段，自然界和人类社会还没有产生，只有概念本身的纯粹演绎，即逻辑学的内容。逻辑学就像是上帝创世之前头脑中的创世方案，在这个意义上，逻辑学就是黑格尔关于世界本质的学说，是黑格尔哲学的实质与核心，后续的自然哲学和精神哲学则是对这个方案的实施，所以他们又叫“实用逻辑学”。当概念发展到极其丰富、极其具体的圆满程度，达到了它的最高形态“绝对理念”时，逻辑阶段就结束了，绝对精神开始进入自然哲学阶段，绝对理念开始“外化”或“异化”为自然界。自然界逐渐复杂后，人出现了，自然哲学开始以人为枢纽过渡到精神哲学，发展出人类社会。精神哲学表现了绝对精神在扬弃了自然界之后向自身的无限返回。在精神哲学中，又依次经历了主观精神、客观精神和绝对精神三个小阶段，最后终于达到了绝对精神的最高形态——哲学。</li></ul><h2 id="4-3-黑格尔的逻辑学"><a href="#4-3-黑格尔的逻辑学" class="headerlink" title="4.3 黑格尔的逻辑学"></a>4.3 黑格尔的逻辑学</h2><ul><li>逻辑学分为三个阶段：存在论、本质论和概念论。首先是存在，然后从存在深入到本质，最后进人概念。概念作为合题是对前两个环节的扬弃和同一，概念就是在存在中把握本质。</li><li>在存在论中，黑格尔把绝对精神的开端设定为“纯存在”或“纯有”，“纯存在”是最简单、最抽象、最空洞无物的概念，它只表示了一个“要存在”的决心，除此之外没有任何其他内容，也只有这种不能再空洞的东西才能作为一切的开端（道生一）。</li><li>“纯存在”实际上也相当于“非存在”，因为它缺少承担存在的主语或宾语，不能表示任何具体的存在之物，所以最抽象的存在就是非存在。这样就从“纯存在”中合逻辑地演绎出了“非存在”，也就是从同一中产生了对立，如果“纯存在”是第一个肯定的话，那么“非存在”就是第一个否定。重要的是，这个过程不需要谢林哲学里那个神秘的欲望，而是用严密的、理性的逻辑方法演绎出来的。“存在”与“非存在”构成了第一个对立，而后二者又在新的概念“变易”中达到同一，即有变成无、无变成有，矛盾在“变易”中被扬弃了，所以“存在”、“非存在”和“变易”构成了绝对精神自否定运动的第一个三段式。同时，“变易”是一个有着真实内容的“具体概念”，具有了“质”，“质”就是使一物成为该物的那种内在规定性。“质”的规定性通过“量”的规定性而表现出来，“质”与“量”的同一就是“度”。在质、量、度的三段式中，黑格尔表述了量质互变的规律。至此，绝对精神在存在论中的历程就结束了，开始转向本质论。</li><li>从存在论向本质论的转化实际上是存在向自己的根据的深人，存在还停留在表面现象上，无法用直观的方式把握到事物内部的本质，所以必须通过反思即间接性的方式来认识，这种反思就是在对立面中建立起同一。绝对精神在本质论中经历了“本质自身”、“现象”和“现实”三个阶段。“本质自身”阶段，黑格尔辩证地论述了从同一到对立的发展过程，同一是包含着对立的同一 ，对立也经历了从抽象的对立(缺乏同一性)到本质的对立(包含同一性)，再到对立面的同一(自己与自己的对立，即矛盾)的发展过程。矛盾是对立同一的合题，是同一个事物的自我否定和自相矛盾，而这恰恰构成了该事物运动发展的“根据”。黑格尔认为矛盾是事物的“根据”，这就与康德的“理性的谬误”有着明显差别。“本质自身”又能发展到“现象”，现象是本质的表现形态和实存方式，内在本质与外在现象的同一就是“现实”。在“现实”中，又有可能性、偶然性和必然性的三段式，最终实现了本质与存在的同一。至此，本质论结束，开始转向概念论。</li><li>概念是存在与本质的真理，是在存在中揭示出来的本质，或者有本质的存在。概念论包括“主观性”、“客观性”和“理念”等三个发展阶段。主观性阶段经历了从概念到判断、再到推理的发展，客观性阶段经历了机械性、化学性和目的性的发展，而“理念”则是“主观性”与“客观性”的统一，它本身又经历了生命、认识和绝对理念三个发展环节。“绝对理念”就是绝对主体和绝对客观在认识与实践活动中的最终同一。在这里，精神终于认识到那个绝对客体不过就是外化了的主体，而那个绝对主体不过就是实现了自我认识的客体。于是在“绝对理念”中，那个作为绝对主体和绝对客体的同一体的精神就最终实现了自我认识。在这个复杂的过程中，概念论不只是逻辑学，也是本体论和认识论。概念论以抽象的方式表现了逻辑学、本体论和认识论的“三统一”，后来整个黑格尔哲学(逻辑学、自然哲学和精神哲学)又以现实的方式重演了这个“三统一”。</li><li>逻辑学中的精神还不是“绝对精神”，而只是“绝对理念”。精神必须跳出逻辑学，走向广阔的自然界和人类历史，才能真正实现主体与客观、思维与存在的同一，从而成为“绝对精神”。因此，逻辑学阶段的路已经走完，精神开始了外化过程，最初的外化就是“绝对理念”向自然界的“堕落”，于是逻辑学就转化为自然哲学。</li></ul><h2 id="4-4-黑格尔的自然哲学和精神哲学"><a href="#4-4-黑格尔的自然哲学和精神哲学" class="headerlink" title="4.4 黑格尔的自然哲学和精神哲学"></a>4.4 黑格尔的自然哲学和精神哲学</h2><ul><li>黑格尔本人对自然科学远不如康德那样精通，他对待自然界不是一种客观的科学研究，而是一种主观的哲学强制，即强行让自然界的发展过程符合他的哲学观点。黑格尔始终对自然界抱着一种鄙夷的态度，认为自然界的物质是惰性的、没有发展的，物质构成了绝对精神的坚硬外壳和束缚精神的沉重枷锁。所以逻辑学走向自然哲学是一种堕落，自然界的“命运”就是要自我毁灭，从而解放精神。</li><li>自然界从最简单的无机物开始，经历了机械论、物理论和有机论的三段式，内容涉及物理、化学、生物等几乎所有的自然科学门类。自然界发展的顶点就是人，当人出现以后，自然界就完成了自己的使命，自然哲学开始过渡到精神哲学。</li><li>精神哲学经历了“主观精神”、“客观精神”和“绝对精神”的三段式，是精神从自我意识走向世界历史，并最终在人类的精神生活(艺术、宗教、哲学)中自我实现和自我认识的过程。“主观精神”包含人类学、精神现象学和心理学三个阶段，这是自我意识的发展历程，自我意识最终在理性中成为自由意识并向“客观精神”转化。“客观精神”是自由意识的客观存在形式，它体现在法哲学中，法哲学是自由的外部规定，包含抽象法(权利)、道德和伦理，伦理作为自由的外在权利和内心道德的统一体，又体现为三个不同层次的“伦理实体“，即家庭、市民社会和国家。在论述国家与个人的关系时，黑格尔表现出一种整体主义的倾向，他用国家来规定个人，用君主来限制人民。有人认为，这种整体主义思想为20世纪德国的极权主义政治埋下了伏笔。</li><li>通过考察国家与国家之间的关系，黑格尔哲学就进入了世界历史，表现为历史哲学。黑格尔表述了绝对精神在世界历史中的历程，即从东方到西方、从古代到现代、从自由意识水平较低的民族到自由意识水平较高的民族的发展路线。黑格尔有浓重的“西方中心论”思想，他总是把东方、古代、抽象和自由意识水平低联系在一起，而把西方、现代、具体和自由意识水平高联系在一起，于是体现出一种地理、历史与逻辑的“三统一”。</li><li>黑格尔认为，世界历史的发展本质上是自由意识的发展，绝对精神在历史发展的每一个时代都选择了代表自己的民族。中国、印度、波斯、埃及是最早被选择的民族，在这里自由仅仅体现为“一个人的自由”，即专制君主的自由。然后被选择的是希腊和罗马，自由体现为“一部分人的自由”，即少数特权阶层的自由。最后被选择的是日耳曼民族，自由体现为“一切人的自由”，尤其是在“人人自由”的原则得到落实和体现的普鲁士。所以黑格尔认为德意志民族就是绝对精神最后的代表，普鲁士国家制度就是最好的政治制度。黑格尔在这里体现出一种为普鲁士歌功颂德的媚俗色彩。</li><li>绝对精神在普鲁士国家制度中实现了自己在客观精神领域中的最终目的，然后开始返回自身中进行自我认识，进入了“绝对精神”阶段。“绝对精神”阶段是绝对精神实现自我认识的场所，它经历了艺术、宗教和哲学三个环节。艺术在谢林哲学中被当作“绝对同一”的最高场所，但在黑格尔哲学中却处于最低的层次。黑格尔认为，艺术是绝对精神在感性层面上的自我复归阶段，绝对精神在艺术中所反映的内容已经是“绝对理念”(回到了逻辑学)，但仍未脱离感性自然的形式，所以绝对精神还要进一步从艺术提高到宗教。宗教以象征和隐喻的形式取代了艺术的感性直观形式，怛仍然没有达到用概念的形式来认识“绝对理念”的高度，这个最后的高度必须在哲学中才能达到。在表述艺术、宗教、哲学的发展阶段时，黑格尔依然遵循了地理、历史与逻辑的“三统一”思想。</li><li>绝对精神从最简单的“纯存在”开始，经历了逻辑演进、自然演化和精神发展，在这个过程中，绝对精神不断否定着自己，又不断扬弃着对自己的否定，在这种扬弃中一切精华的东西都被保留下来，最终成就了丰富多彩的大千世界。正是在这种意义上，黑格尔强调起点就是终点，真理就是过程，真理就是全体。所以他会认为哲学就是哲学史，一个东西和它的发展历程是分不开的。</li><li>在绝对精神的自否定运动中，思维与存在实现了辩证同一，思维与存在是绝对精神的不同发展阶段，因此对立就是自己与自己的对立，同一也是自己与自己的同一。在黑格尔的哲学里不存在任何外在的对立，所有的对立都是自己否定自己、而后又自己回归自己，表现为“肯定一否定一否定之否定”的三段式。黑格尔的思辨哲学就是自否定中的对立同一，黑格尔本人把它叫做“绝对唯心主义”，这个名称本身就表现了一种狂妄，既不是偏执于自我的主观唯心，也不是乞灵于上帝的客观唯心，而是把主观与客观、主体与实体、理论与实践、天上与地下一网打尽的“绝对”唯心。</li><li>马克思对黑格尔辩证法的评价非常高，但他认为黑格尔辩证法的要害在于以唯心主义为基础，所以马克思的哲学就是把黑格尔辩证法重新建立在唯物主义的基础上。此外，黑格尔辩证法与他的哲学体系之间存在着不可克服的矛盾，他的辩证法是开放的，哲学体系却是封闭的，辩证法强调矛盾运动的不断发展，但是黑格尔却出于建立体系的需要，让绝对精神停留在普鲁士国家制度和黑格尔哲学中不再发展了，所以黑格尔哲学最深刻的矛盾就是革命性的方法与保守的体系之间的矛盾。</li></ul><h2 id="4-5-对黑格尔哲学的超越"><a href="#4-5-对黑格尔哲学的超越" class="headerlink" title="4.5 对黑格尔哲学的超越"></a>4.5 对黑格尔哲学的超越</h2><ul><li>黑格尔哲学似乎已经滴水不漏、天衣无缝，从理性上显然没有办法超越他，因为黑格尔已经把理性用尽了。然而，黑格尔哲学里的人实际上是精神和思辨理性的化身，而不是活生生的、有血有肉的人，所以忽略了人的感性就是黑格尔哲学体系的软肋。费尔巴哈和马克思正是看到了这一点，所以从感性上找到了可突破黑格尔哲学的缺口，费尔巴哈从感性的人开始，马克思则从感性的活动(人的实践活动)开始。</li><li>黑格尔的整个哲学实际上是用思辨理性的语言，重新述说了基督教关于上帝创世、亚当失乐园、基督救赎以及人类在圣灵感召之下重返乐园的故事。费尔巴哈敏锐地看到了这一点，他把黑格尔的思辨哲学称为“思辨神学”，认为黑格尔哲学的奥秘就在于对主词和宾词关系的颠倒，即对思维与存在、主体与客体、精神与物质、尤其是上帝与人的关系的颠倒，因此对黑格尔哲学的批判就是要把这种颠倒了的关系拨乱反正。在黑格尔那里，神就是精神，上帝就是绝对精神，一切止步于绝对精神，但是费尔巴哈进一步认为，精神说到底就是人。精神从来都是人的精神，不是上帝或精神创造了人，而是人创造了上帝或精神，于是费尔巴哈就把黑格尔的绝对唯心主义转化为人本主义的唯物主义了。</li><li>西方人长期以来一直在基督教信仰的影响之下生活，黑格尔第一次明确地表示神就是精神，但是黑格尔的精神却是一种脱离人的、抽象的绝对精神，后来费尔巴哈提出精神就是人，但是费尔巴哈的人却只是一个感性的动物，是一个脱离了社会关系的抽象的人。所以马克思又进一步提出，人是具体的、历史的人，是处在特定的社会条件之中的人，受到生产关系和生活关系的制约。人是一切社会关系的总和。人的实质就在于他的实践活动，人通过实践活动创造了人化的自然和世界的历史。</li><li>在马克思之前已经出现了一些无神论者，马克思的贡献并不是创立了无神论，而是把无神论引向了共产主义。以往的无神论者把批判的锋芒指向上帝和天国，把人间的苦难归咎于宗教的欺骗，马克思则认为宗教是建立在颠倒的现实社会之上的颠倒的意识形态，因此对宗教的批判必须深入它赖以确立的现实基础，才能最终消除颠倒的意识形态。马克思从对精神的批判转向了对物质的批判，从以往哲学家们“解释世界”的活动转向了“改造世界”的活动，从无神论对天国的批判转向了共产主义对现实社会的批判。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="网课笔记" scheme="https://shivakasu.cn/categories/%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哲学" scheme="https://shivakasu.cn/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《现代汉语》(更新中)</title>
    <link href="https://shivakasu.cn/2020/02/24/chinese0/"/>
    <id>https://shivakasu.cn/2020/02/24/chinese0/</id>
    <published>2020-02-23T17:34:20.000Z</published>
    <updated>2020-06-27T08:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>课程地址：<a href="https://www.bilibili.com/video/av48351486" target="_blank" rel="noopener">https://www.bilibili.com/video/av48351486</a></li><li>现代汉语-北京大学-沈阳</li></ul><h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h2 id="1-1-汉语的历史分期和古今差异"><a href="#1-1-汉语的历史分期和古今差异" class="headerlink" title="1.1 汉语的历史分期和古今差异"></a>1.1 汉语的历史分期和古今差异</h2><ul><li>汉语分成古代汉语、近代汉语和现代汉语三个时期。</li><li>古代汉语是先秦到隋唐大约一千多年间的汉语，秦朝之前的算是史前语言，不参与历史分期，古代汉语的前身是夏言，指黄河流域中游一带华夏民族的语言，当时的口头语和书面语是一致的(怎么证明的？)。</li><li>近代汉语是晚唐到清初大约一千多年间的汉语，在语音、词汇、语法方面开始系统性地偏离古代汉语，语音上表现为语音系统的简化(韵母大大减少)，词汇上表现为单音词为主转向双音词为主，语法上表现为出现了代词、助词等新的语法结构，期间出现了两种书面语，一种是模仿先秦时期的文言文，所谓文必秦汉，另一种是以六朝以后北方话口语为基础加工成的书面语，即古白话。</li><li>现代汉语的开端众说纷纭，一种主流的观点是在清中期以后，证据就是清中期以后的文学作品所用的词汇与现在相似，比如红楼梦和儒林外史。而在书面语上直到民国还在以文言文为主，五四运动以后才废除文言文，提倡白话文，所以也有人认为现代汉语是从五四以后开始的。狭义的现代汉语是指现代的普通话，广义的现代汉语是普通话和现代方言。现代方言是古汉语的活化石。</li><li>一个民族的共同语是在自然选择(民众)和人为规范(统治者)两种作用下形成的。共同语分为书面共同语和口语共同语，虽然现在看来这两种共同语已经高度统一了，但二者的发展历程还是有所区别。</li><li>书面语发展历史：在先秦时期，已经以今天的洛阳为中心形成了较大范围的书面共同语，称为“雅言”，雅言也是起源于夏言，论语就是用雅言写的，当时的书面共同语和口语共同语是一致的。到了汉魏时期，文人开始模仿先秦的书面语，书面语与口语逐渐产生了差距，所以在文人圈子里基本以文言文为书面共同语，同时民间也出现了古白话的书面语，比如世说新语是古白话写的。到了唐朝，出现的变文和禅经里也使用了不同于文言文的白话文。到了宋朝，讲学之风盛行，书面语进一步口语化，如《朱熹语录》。宋元时期的话本、杂剧里大量使用了白话。元末明初开始出现白话长篇小说。到了清朝，白话写作在民间盛行，形成白话文与文言文势均力敌的局面。再到五四运动时期，开展白话文运动，同时国民政府在1920年宣布取消文言文教科书，正式确立了白话文的书面语地位。</li><li>口头语发展历史：口语共同语最初的形成时间不明，但一般认为晚于书面共同语出现的时间，且北方话在口语上占主导地位。西汉时期扬雄的《方言》里使用了“通语”，相当于共同语的概念。自金朝定都北京起，北京一直是中国的经济政治文化中心，所以北京话在北方话里又是占主导地位的口语，同时北京话也成为了官话。北方话的影响力逐渐向南扩张，造成文白异读的现象，影响了南方人的口语习惯，但当时的口音都不标准。清朝以后又进一步提出了文字改革、言文一致、口语统一。民国时期蔡元培发明了注音字母来统一读音，还要审定读音，经由教育部向全国推广，这就是国语运动。</li><li>在书面语的白话文运动和口语的国语运动共同作用下，形成了现代汉语。后来汉语拼音取代了注音字母，全国人大决定把现代汉民族共同语命名为普通话。</li></ul><h2 id="1-2-现代汉语方言"><a href="#1-2-现代汉语方言" class="headerlink" title="1.2 现代汉语方言"></a>1.2 现代汉语方言</h2><ul><li>方言具有应用价值(日常沟通需要)和文化价值(非物质文化遗产)。</li><li>方言是一种语言内部的子语言划分，因为汉语的各个方言是同源的，而且在书面语上是统一的，所以是方言而不是语言。相反，欧洲各国的语言虽然在历史上属于同一个语系，但在书面语上不统一，所以英语、意大利语、法语都是语言而不是方言。</li><li>地域方言是指某一个地域的口头语与地域外使用的口头语有差异，通过在语音、词汇、语法上划定某一方言的标准，可以在地图上画出同言线，在命名时可以使用区域名，比如广东话、福建话。在地域方言的差别上，语音最大，词汇次之，语法最小。</li><li>社会方言是指以性别、年龄、职业等社会属性来划分的方言，比如年轻人的时髦用语、黑社会的黑话等。广义的方言也包括社会方言，但这里只探讨地域方言。</li><li>中国目前存在七大方言区：北方方言、吴方言、赣方言、湘方言、闽方言、粤方言、客家方言。每个方言区还分成若干个次方言区。<ul><li>北方方言，也叫北方话(以北京话为代表)。分布在长江以北广大地区，长江以南的镇江以上、九江以下的沿江地带，还有湖北、四川、云南、贵州等地。</li><li>吴方言，也叫江浙话、吴语。分布在江苏的南部和浙江、上海。其中温州话在欧洲势力比较大，可能是因为温州移民比较多。</li><li>赣方言，也叫江西话。分布在江西大部分和湖北的东南角。在历史上，江西是黄河流域中原人南迁的必经通道，所以江西受其他地域方言的影响比较大。</li><li>湘方言，也叫湖南话。分布在湖南一带。</li><li>粤方言，也叫广东话。分布在广东的中西部和广西的一部分，还有香港和澳门地区。早年间在澳洲、北美也盛行广东话，因为广东移民比较多。广东话保留了大量古汉语的痕迹，比如吃说成食、喝说成饮、走说成行、回说成返等，听着就像古人。</li><li>闽方言，也叫福建话。福建、台湾、海南、和广东的潮汕、惠州、汕尾一带。南洋(东南亚)也说的福建话。</li><li>客家方言，也叫客家话。集中分布在两广、江西、福建、台湾等地，湖南和四川等省也有分布(当地称“广东话”)等地。客家人原来都是中原地区的北方人，因为战乱躲到了三省交界的山里，天高皇帝远，与外界的交流也少了，所以客家话保留了自己独特的文化特点。</li></ul></li><li>汉语方言的特点是越往东南越古老，越往轴心(北京)越现代。</li><li>方言的语音差异可以从声母、韵母、声调三方面考虑。在声母上，南方方言有浊声母，北方方言没有浊声母，浊声母就是在读b、d、g的时候声带发力形成浊音，北方人读的时候只有嘴里发力。南方人还不分zcs和zhchsh、h和n等。在韵母上，北方话把元音尾(aoe)和鼻音尾(n)拉长，南方话使用入声韵尾阻止尾音拉长，入声韵在北方话里已经消失了。在声调上，体现在声调的数量不同。</li><li>方言的词汇差异体现在两方面。一是同意不同词，比如玉米、苞米和棒子。二是同词不同意，比如北方馒头没馅，南方馒头有馅。</li><li>方言的语法差异相对较小，主要是使用习惯上的差别。</li><li>方言形成的原因包括生活的社会团体、地域的地理条件、行政区划和人口迁徙。</li></ul><h2 id="1-3-现代汉语的规范化"><a href="#1-3-现代汉语的规范化" class="headerlink" title="1.3 现代汉语的规范化"></a>1.3 现代汉语的规范化</h2><ul><li>以北京音为标准音，以北方方言为基础方言，以典范的现代白话文著作为语法规范。针对的是语音、词汇、语法三个点。汉语规范当初是投票定的，所有是有争议的。</li><li>动态的现代汉语规范包括三点。<ul><li>排除例外：排除方言里奇怪的语言习惯，比如北京话的“剪(jiao)头发”、“知不道”等。</li><li>约定俗成：语言规范要迎合多数人的语言习惯，比如大多数人都读成“给(gei)予”，就要修改规范，而不是强制纠正大众的读音。</li><li>兼容并蓄：乐于接受非北方方言与舶来语，比如瘪三、赤佬，以及咖啡、排队、第一时间等。</li></ul></li></ul><h2 id="1-4-现代汉语的特点"><a href="#1-4-现代汉语的特点" class="headerlink" title="1.4 现代汉语的特点"></a>1.4 现代汉语的特点</h2><ul><li>人类语言在形态上可以分为屈折语、黏着语和孤立语。<ul><li>屈折语以词形变化作为表示语法关系的主要手段，一个词缀经常同时表达多种意思，代表语言是英语、俄语、法语。</li><li>黏着语也以词形变化作为表示语法关系的主要手段，但一个词缀一般倾向于只表达单一种的意思，代表语言是土耳其语、日语。</li><li>孤立语不通过词形变化来表达语法的作用，而是通过独立的虚词和固定的词序来表达语法意义，代表语言是汉语。</li></ul></li><li>汉语在语音上的特点可以概括为声调、音素和音节三部分。<ul><li>汉语有声调，音节不变而单独改变声调，也能改变表达的意思，比如“啊”的四个音。</li><li>在音素上，汉字的元音多，一个音节里可以没有辅音，但必须有元音。辅音很少，要么做声母(bpmf)，要么做韵尾(n)，辅音也不能连续出现，相比之下元音就比较灵活。</li><li>在音节上，相比于英语，汉语的拼读痕迹小，一个汉字读出来就像一个音，也不会像英语一样出现连读吞音节的现象。</li></ul></li><li>汉语在词汇上的特点可以概括为音节和语素两部分。<ul><li>在音节上，汉语有单音节词、双音节词、多音节词，其中双音节词占绝对优势(古汉语里单音节词比较多)。汉语只有几百个音节，增加双音节词可以通过排列组合减少同音词。一个汉字写出来可能有多个意思，增加双音节词还可以分化多义词。此外，双音节词还符合韵律上的习惯，比如我们习惯把四字成语按两个字一组读出来。</li><li>在语素上，汉语的语素、音节、汉字是三位一体的，比如“计算机”是三个语素、是三个音节，也是三个汉字，而英语里字的概念和词的概念差不多，只要中间没有空格，不管写多长都算一个word。英语的构词主要靠派生，在一个单词的基础上加上“un”、“ed”、“con”等前后缀，汉语的构词主要包括附加(比较有限，“画儿”)、复合(“电灯”)、重叠(“干干净净”)、拟声(“哗啦”)和译音(“巧克力”)，现在英语里也开始借鉴汉语的复合构词了，比如“raincoat”、“mailbox”。</li></ul></li><li>汉语在语法上的特点可以概括为语法手段、语法结构和语法成分三方面。<ul><li>在语法手段上，汉语缺乏形态变化，包括性、数、格、时、体、态等变化，汉语通过“着”、“们”、“了”等方式实现语义变化。其次，汉语的词形和语法成分没有必然联系，至少不像英语一样有明显的形态变化，汉语的词可以用同样的形态做主谓宾定状补的成分，比如“做研究”、“研究东西”、“研究完成了”、“语法研究”等。而在英语里，形容词形态(“-ful”)只能做定语，副词形态(“-ly”)只能做状语。最后，因为缺乏形态变化，所以汉语里的语序很重要，比如“不怕辣”、“怕不辣”和“怕辣不”。</li><li>在语法结构上，就是上面提到的语序的重要性，定语状语不管多长都要放在前边，除非另起一个句子，不能像英语一样把太长的成分用介词连在句子后面。</li><li>在语法成分上，汉语的主要特点体现在数词和量词。汉语的所有名词都要加量词，而英语和古汉语里没有名量词，只有用到不可数名词时会用容器计数，比如“a cup of tea”。其次，汉语有动量词，比如“打一拳”、“插一刀”。此外，语气词是汉语独有的，一个句子后面接上不同的语气词可以表达不同的意思，而英语要靠变换句式、加疑问词等方式实现。</li></ul></li></ul><h1 id="2-现代汉语的语音"><a href="#2-现代汉语的语音" class="headerlink" title="2 现代汉语的语音"></a>2 现代汉语的语音</h1><h2 id="2-1-语音概述"><a href="#2-1-语音概述" class="headerlink" title="2.1 语音概述"></a>2.1 语音概述</h2><ul><li>语音是人的发声器官发出的表达一定语言意义的声音，至于文字、手语等都是语音的转换形式，严格来说并不是语言的真正的物质载体，只有语音才是承载语言的物质表现形式。心里默默的自言自语也算是语音，只不过是内部的声音，没有语音就不存在自言自语了。</li><li>语音的研究可以根据语音的传播过程分为发声器官发出语音、语音在介质中传播和接收语音三方面。发声器官方面主要涉及发音语音学，研究针对的是发声器官，即语音的生理属性。语音传播方面主要涉及声学语音学，研究针对的是声波，即语音的物理属性。接收语音方面主要涉及听觉语音学，研究针对的是听觉和心理，即语音的心理属性。此外，还有人研究语音的社会属性，即音位学，也就是语义与语音的关系，当不同人说同一句话时，人们能够根据约定俗成的语音习惯把他们发出的有差异的语音归为一类。</li><li>语音的切分：发声器官发出的一段相对连续的语音叫做音流，音流通常是复句或更多的句子。切分音流主要依靠停顿或语调变化，切分的结果称为音段，一个音段相当于一个句子，但并不能说音段就是句子，因为音段是语音单位，句子是语法单位，不能一概而论。在音段的基础上，根据更小的停顿进一步切分，得到的结果称为节拍群，一个节拍群相当于一个词组。在节拍群的基础上，根据轻重音进一步切分，得到的结果称为轻重音组，一个轻重音组相当于一个词，汉语的一个词里必然有轻重音，不可能所有成分的语音都是等重的，只不过有的轻重音我们难以分辨。轻重音组可以切分成多个音节，一个音节相当于一个字，字在汉语里又叫做语素。音节还可以切分成声母、韵母和声调三种更小的单位。最后，韵母还可以切分成多个音素，声母不能切分是因为声母就是一种音素，音素分为元音和辅音两种，同一个音素根据发音位置的不同，在国际音标里有不同的写法。一般认为，音素是语音里的最小单位。</li><li>把音节切分成声母、韵母和声调是中国传统音韵学的方法，把音节切分成音素是国际标准的方法，但在中国传统音韵学中，音节又可以分成“头胫腹尾神”五部分，头就是声母，胫腹尾就是韵母，神就是声调，这五部分就相当于音素。</li><li>汉语中声母都是辅音，但辅音不都是声母，辅音还可以做韵尾。</li><li>历史上汉字主要有过四种记录语音的方法：<ul><li>直音法：东汉之前主要使用的方法，又可细分为譬况、读若、直音和纽四声。<ul><li>譬况是对语音打比方，表示某个字的读音和一个已知的字差不多，只需要调整一下发音的轻重缓急。</li><li>读若比譬况更具体，表示某个字的读音和一个已知的字完全一样。</li><li>直音，其实和读若一样，只不过用起来更简洁，“A，读若B”是说A和B读音一样，可以仿照B的读音，而“A，音B”是直接用B给A注音，目的性更强。以上三种方法的共同缺点是需要借用简单的同音字来确定复杂或生僻字的读音，但作为基础的简单同音字的读音就很难表示，此外有的字没有同音字(比如糗)，用已知字注音会不太准确。</li><li>纽四声的方法不再局限于同音字注音，而是用声母韵母相同的字注音，同时标注平上去入的音调，比如“蹭，层去”表示“蹭”的发音是“层”读去声，纽四声的方法也有缺陷，因为有的字没有和它声母韵母相同的字，比如“日”。</li></ul></li><li>反切法：基本规则是用两个汉字相拼给一个字注音，切上字取声母，切下字取韵母和声调。但是由于古代是按照各自的方言进行反切，所以语音可能会和现代汉语不同，比如“鸡，古奚切”表示“鸡”的读音是“古”的声母拼上“奚”的韵母，读成gi，和现代汉语的读音不同。反切的产生，标志着汉族语音学的开始——从此懂得了对汉语音节做音理上的分析，把一个音节分成声、韵两个部分。反切法的缺陷在于，依然是用字给字注音，需要掌握几百个甚至上千个用于注音的基础字，其次，字的读音是会变的，经年累月后如果很多字的读音已经变了，反切体系就会混乱不堪，所以一定要用符号注音取代汉字注音。</li><li>注音字母：民国时期推行的一套注音符号，是取代反切法的一个转折点。有39个符号，其中24个表示声母，15个表示韵母。注音字母的优点在于符号少，不需要像反切法一样掌握大量基础字，而且念法固定，不像汉字的读音一样可能发生演变。注音字母的问题有两点，第一是没有彻底音素化，一些符号记录的是韵母而不是音素，比如“ao”是一个注音符号，但是包含两个音素，更科学的方法是每个符号只表示一个音素，第二是过于民族化，注音字母是从汉字中截取的，不便于国际交流。后来的国语罗马字、中国拉丁化字母都是对注音字母的改良。</li><li>汉语拼音：1958年全国人大确定的，制定规则包括：以北京音为标准音，采用音素制，以及采用拉丁字母。26个拉丁字母中，5个用作元音，20个用作辅音，还有一个“v”暂时没用，但是不够用，所以后来有增加了四个双字母zh、ch、sh、ng和一个加符字母ü。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="网课笔记" scheme="https://shivakasu.cn/categories/%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="语言学" scheme="https://shivakasu.cn/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《西方哲学史》3：16-18世纪西欧哲学</title>
    <link href="https://shivakasu.cn/2020/02/22/phi2/"/>
    <id>https://shivakasu.cn/2020/02/22/phi2/</id>
    <published>2020-02-22T10:08:20.000Z</published>
    <updated>2020-03-01T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1 概论"></a>1 概论</h1><ul><li>古希腊时期由于刚刚产生哲学，对自然万物都充满好奇，所以基本都是本体论的哲学思想。到了中世纪，由于历史原因使基督教神学兴起，哲学家把人的主观精神放大、异化为一个客观的、全知全能全善的神，实际上是一种精神哲学，只是中世纪的哲学家缺乏反思，没有意识到神源于主观精神。古希腊聚焦客观世界，中世纪聚焦主观精神，所以到了近代就自然而然地、有意识地开始探讨客观与主观、物质与精神之间的关系，从本体论向认识论转移(上帝也算是本体)。</li><li>中世纪时期哲学氛围比较压抑，由于现实生活充满了战乱、苦难，人们对客观现实感到失望、鄙夷，开始把眼光投向了另一个世界，瓦尔特·本雅明评论说“正是现实中充满了绝望，我们才被赋予了希望”。到了近代，内因外因交加产生了两场思想运动，一个是文艺复兴，发生在南部欧洲的拉丁文化的地域，导致了人性的解放，用人性取代了神性，用人道主义取代了神道主义，用现世的快乐取代了天国的理想，另一个是宗教改革，发生在北部欧洲的日耳曼文化的地域，与文艺复兴殊途同归，也是突破了中世纪沉闷的哲学气氛和天主教一统天下的局面，但不是着眼于人文主义，而是强调一种纯正的信仰和纯朴的道德。</li><li>然而文艺复兴和宗教改革在精神实质上还属于中世纪，还没有体现出近代的时代精神，他们所倡导的人性解放都只是感性层面上的，对理性还是十分排斥的，因为中世纪的经院哲学家用理性论证神学教义的无聊行径让他们感到厌恶，所以文艺复兴就表现为浅显的、感性上的放纵，缺乏反思性，而宗教改革也只是体现在想把基督教还原到早期的状态，回归到纯正、纯朴的信仰，在思想上是保守的、倒退的和缺乏理性的。罗素说“16世纪尽管在文学艺术上琳琅满目，但是在科学和哲学上是一个不毛的时代”。所以尽管15、16世纪是一个重要的分水岭，但西方现代意识的产生是从17世纪开始的，17世纪最主要的特点就是理性，体现为怀疑主义和经验方法。</li><li>17世纪的重点是经验论和唯理论，人们开始关注现实世界，寻找必然性的、放之四海而皆准的知识，企图建立主观与客观、思维与存在的同一性。然而到了18世纪并没有达到这些目的，反而背离了经验论和唯理论的初衷，所以康德哲学才会应运而生，对这两者进行批判。</li><li>经验论和唯理论有不同的出发点、方法和基本原则。经验论的出发点是事实经验，主要方法是归纳，基本原则是“一切知识无不来自于经验”，来自于经验但还是需要理性的加工。唯理论的出发点是天赋观念(即不证自明的公理)，主要方法是演绎，基本原则是认为对感觉经验的归纳不可能达到必然性的知识，因为感觉经验因人而异，其次，归纳方法本身也是无意义的，因为归纳必然是有限的(数学归纳法可以推广到所有整数，但事实经验的归纳是不可能穷尽所有情况的)，所以一切必然性的知识一定来自于天赋观念和演绎推理。</li><li>发展中的经验论并不纯粹，也会掺杂一些唯理论的思想，但经验论推到纯粹、极端后导致的结果是怀疑一切。一方面怀疑客观世界，因为经验是一切知识的来源，而一个刚出生的婴儿显然是没有关于客观世界的知识，所以客观世界在主体有经验之前是否存在就值得怀疑，那么就不能假定客观世界是存在的。另一方面也会怀疑“我”，因为我们只有关于思维与行动的经验，却没有关于承载思维与行动的“我”的经验，所以“我”这个主体的存在性也是不能确定的。所以纯粹的经验论怀疑(倒没有彻底否定)一切主观实在与客观实在，只承认活动、现象、感觉等亲身经验。此外，也会怀疑一切普遍的、必然的关系，因为经验只是一系列的事实，而因果、对立、包容等逻辑关系都是我们在事实的基础上主观联想的结果，不是直接得到的事实经验，所以也是不可靠的。所以纯粹经验论导致的结果是既没有了主客观实体，也没有了普遍性与必然性，康德对这种知识的评价是“连一场梦都比不上”，可笑的是这种怀疑论恰恰违背了近代认识论的最初目标。</li><li>发展中的唯理论也同样并不纯粹，也或多或少承认经验的作用，但唯理论推到纯粹、极端后导致的结果是独断论。这种独断论发展到莱布尼茨-沃尔夫体系时，就表现为一个人只需要提高自己的理性能力，就可以通过逻辑演绎三段式把世界上所有东西的知识建立起来，也就是不需要“看”世界就可以认识世界。如果说极端经验论把知识无限缩小了，那么极端唯理论就相当于把知识无限放大了，结果是一堆脱离实际、空而无物的知识。</li><li>基于经验论和唯理论所导致的哲学困境，康德提出了哲学的一个中心问题，即“先天综合判断如何可能？”，也就是既有普遍必然性又有新内容(即经验内容)的知识如何可能，因为经验论缺的就是普遍必然性，而唯理论缺的就是经验内容，二者兼备的知识就叫做先天综合判断。</li></ul><h1 id="2-文艺复兴与宗教改革"><a href="#2-文艺复兴与宗教改革" class="headerlink" title="2 文艺复兴与宗教改革"></a>2 文艺复兴与宗教改革</h1><ul><li>文艺复兴的主要成就是文学艺术上的，与哲学史的关系相对较小，所谓的人文主义者也不是思想成体系的哲学家。</li><li>宗教改革有三大主流教派，即路德宗、安立甘宗和加尔文宗。</li><li>这部分老师略过了~</li></ul><h1 id="3-早期经验论哲学"><a href="#3-早期经验论哲学" class="headerlink" title="3 早期经验论哲学"></a>3 早期经验论哲学</h1><ul><li>经验论者基本都在英国，所以又被称作英国经验论，英国在17世纪领导者整个欧洲的科学与哲学的潮流，原因是英国是个岛国，在16世纪经历了安立甘宗教改革，在17世纪又经历了资产阶级革命，形成了务实的传统，强调自然科学与经验，不喜欢形而上的东西。唯理论者基本都在欧洲大陆，所以又被称作大陆唯理论，原因是欧洲大陆受宗教经院哲学的影响比较深，人们对形而上的东西感兴趣。</li><li>经验论和唯理论并不是唯物主义和唯心主义的对立，二者的论域不同，经验论和唯理论是认识论上的分歧，唯物主义和唯心主义是本体论上的分歧。本体论探讨的问题是世界的物质性和精神性，认识论探讨的问题是普遍的必然性的知识从哪里来以及如何获得。</li></ul><h2 id="3-1-弗兰西斯·培根"><a href="#3-1-弗兰西斯·培根" class="headerlink" title="3.1 弗兰西斯·培根"></a>3.1 弗兰西斯·培根</h2><ul><li>弗兰西斯·培根被视为近代哲学的开端，他的思想受到了中世纪方济各修会的罗吉尔·培根的很大影响。培根的名言是“知识就是力量”，在当时的英国，科学与自然哲学蓬勃发展，人们关注现实以求活得幸福，当时的普遍观念是只有知识才能使人幸福，掌握了知识就能认识自然、掌握自然规律，进而能够征服自然、改造自然，造福于人类，增进现世的幸福。这种思潮一方面促进了英国在科学、经济等各方面的发展，但另一方面这种务实的知识观已经不同于古希腊人对知识的看法，古希腊人认为知识就是智慧，是为了丰富内在、提高自己，而自培根起就开始有目的性地获得知识，过分强调实用主义，从学以致知变成了学以致用。</li><li>培根在科学与哲学上有很大成就，但在道德上存在着瑕疵与争议，虽然知识就是力量，但知识与道德的关系又是怎样。苏格拉底认为知识即美德，知识越丰富的人道德越高尚，到了基督教反而认为知识让人道德败坏，亚当夏娃是因为吃了知识之果才导致人性堕落，到了培根，又开始主张知识即美德。</li></ul><h3 id="四假象"><a href="#四假象" class="headerlink" title="四假象"></a>四假象</h3><ul><li>怀疑主义是17世纪的思想潮流，所以培根在《新工具》的开篇就提出了四假象(明显受到罗吉尔·培根“四障碍”观点的影响)。他认为哲学的目的就是探求知识，探求知识就是发现自然的“形式”(规律)，所以他鄙视此前中世纪的经院哲学，研究信仰无益于掌握自然。但当时基督教如日中天，虽然培根把矛头指向基督教，却不得不用四假象委婉地表达自己的观点，指出此前的哲学对人们认识自然有四种阻碍或假象：<ul><li>族内的假象：植根于人性之中的一种偏见，人们常常因为理智的偏见而误解自然事物的性质。比如目的论的观点就是人们习惯性地将人的目的性类比到自然界的目的性，但自然界未必是有目的的。</li><li>洞穴的假象：个人受其习性、环境和教育的影响而产生的偏见。比如文化背景和社会环境使人思考世界的方式不同，有人偏保守，有人偏激进。</li><li>市场的假象：由于语词的误用而引起的谬见。思想交流就像语言的市场，如果使用的概念不当，就会造成理解力方面的障碍。</li><li>剧场的假象：人们对权威、教条、传统的哲学体系盲目信仰，导致丧失了批判意识和怀疑精神。比如对亚里士多德、炼金术、柏拉图主义等的盲目崇拜。</li></ul></li><li>先破后立，用四假象批判了当前哲学的弊端后，培根提出了自己的认识论观点。培根虽然奠定了早期经验论的基础，却没有极端地否定理性的作用。他把狭隘的经验论比喻为只采集现成材料的蚂蚁，把理性派比喻为只依靠自身材料的蜘蛛，进而主张人们应该像蜜蜂一样，既采集花粉，又利用自己的理性加工，最终才能形成蜜糖。也就是要协调感觉经验与理性思维，但这只是一种肤浅、朴素的观点，没有深入发展。</li></ul><h3 id="科学归纳法"><a href="#科学归纳法" class="headerlink" title="科学归纳法"></a>科学归纳法</h3><ul><li>培根提出了新的科学研究方法，即科学归纳法。主张以感觉经验作为出发点，尽可能地排除心灵的自由臆断和僵硬的三段式推理。科学归纳法的准备工作是收集三张表，第一个是“本质表”或“具有表”，记录具有某种性质的事物，比如研究“热”的形式就要列举出阳光、火等具有热的事物。第二个是“差异表”或“接近中的缺乏表”，记录与本质表中事物相似但不具有目标性质的事物，比如月光与阳光相似但不具有热。第三个是“程度表”或“比较表”，记录同一条件下按其不同程度而具有共变关系的例证，比如光强、运动等条件对热的影响。归纳的过程就是对三张表的例证进行分析、比较、排除等操作。科学归纳法的意义在于，自亚里士多德开始建立的三段论演绎方法只是一种证明的方法而不是发明的方法，17世纪渴求科学的进步，“知识就是力量”强调的是发明知识而不是证明知识，发明知识只能依靠归纳的方法，所以培根给著作起名《新工具》就是在对标亚里士多德的《工具篇》，嘲讽他的演绎方法。科学归纳法为近代归纳逻辑奠定了基础，19世纪英国逻辑学家穆勒所确立的五个方法就是从培根的方法发展而成的。</li><li>在认识论上，培根确立了经验论的基本原则，也就是一切知识来源于感觉经验。</li></ul><h3 id="朴素唯物主义"><a href="#朴素唯物主义" class="headerlink" title="朴素唯物主义"></a>朴素唯物主义</h3><ul><li>在本体论上，培根持一种朴素的唯物主义观点，他虽然是个基督徒，但却把神学和哲学分得很开，在哲学问题上基本不谈上帝，他的观点可以概括为以下四点。第一，自然万物都是由物质性的分子所构成。第二，自然万物本身具有客观规律性，不以我们的意志为转移(必须这么认为，因为经验就是建立在客观性、普遍性和必然性之上的)。第三，自然界的规律是可以被认识的。第四，物质本身在性质和运动形态上具有多样性，这一点与后来的霍布斯不同，霍布斯把唯物主义推向了机械论，认为物质本身所客观具有的性质只有广延性(占空间)，其他所谓的性质都是人们主观感觉的结果，这种观点会导致对物质实体本身的否定。</li></ul><h2 id="3-2-托马斯·霍布斯"><a href="#3-2-托马斯·霍布斯" class="headerlink" title="3.2 托马斯·霍布斯"></a>3.2 托马斯·霍布斯</h2><h3 id="哲学的定义、目的和对象"><a href="#哲学的定义、目的和对象" class="headerlink" title="哲学的定义、目的和对象"></a>哲学的定义、目的和对象</h3><ul><li>霍布斯提出了哲学的定义、目的和对象。他认为哲学是一门从结果求原因或者从原因求结果的推理的学问。此前的经院哲学虽然也有推理，但却是从形而上(信仰)出发的、忽视经验的、纯粹的形式推理，得到的结果是不能靠事实经验验证的。霍布斯的推理强调立足于经验，结果和原因必须能用经验验证，推理建立在概念和判断之上，所以概念和判断是要以感觉经验为准的，这就比经院哲学实在多了。霍布斯认为哲学的目的是利用已有的知识为人生谋福利，符合17世纪的务实之风。霍布斯认为哲学研究的对象是处于产生过程中和具有某种特性的物体，这就排除了神学领域内的没有产生过程和物理特性的对象，比如上帝、天使，所以霍布斯主义在当时被认为是无神论，但其实霍布斯不是纯粹的无神论者，他只是推崇把哲学和神学分开讨论而已。霍布斯把哲学研究的对象分成两类，自然物体和人造物体(国家)，针对这两类物体，哲学也就分成了自然哲学和公民哲学。</li></ul><h3 id="机械论和功能主义"><a href="#机械论和功能主义" class="headerlink" title="机械论和功能主义"></a>机械论和功能主义</h3><ul><li>在自然哲学上，霍布斯把培根的唯物主义经验论推向了机械论，他把物体当做哲学研究的唯一对象，把物体定义为“不依赖于我们思想的东西，与空间的某个部分相合或具有同样的广袤”，他一方面强调了物体的客观实在性，另一方面认为物体只有广袤性(即占据一定空间)这一种本质属性。这种机械论的观点固然排除了没有长宽高等空间属性的上帝，但同时也排除了信息、思维这些看不见摸不着的对象，让哲学变得狭隘了。此外，他还认为运动就是在外力推动下的简单的位移，后来的牛顿、笛卡尔也持这种机械论的运动观，相比于亚里士多德的运动观就显得狭隘了，亚里士多德认为运动就是潜能向实现的转化过程，包括但不限于外力作用下的位移，比如人的生长过程就不能看做简单的位移。机械论固然狭隘，但它的优点是把哲学限定在了经验上可考察、可操作的范围内。</li><li>霍布斯可能也认识到了机械论的狭隘，所以还把他机械论的世界观表述为功能主义的。他只描述构成自然世界的各个机械部分的实际功能和运行过程，而不去考虑世界背后的、潜在的那些原因和目的，不去思考古代哲学家们津津乐道的形而上的话题。这种功能主义体现了17世纪科学的崛起。</li></ul><h3 id="实体和偶性"><a href="#实体和偶性" class="headerlink" title="实体和偶性"></a>实体和偶性</h3><ul><li>霍布斯提出了实体和偶性这一对范畴。他认为物体本身就是实体，因此很难对实体下定义，这一点到了洛克才明确指出实体是我们无法认识却又必须假定存在的东西。正因为实体无法定义，后来就出现了反实体主义，也叫现象主义，在贝克莱、休谟时期发展成熟，他们否定实体的存在，认为物体就是各种属性的集合。</li><li>早在亚里士多德时期就提出了实体的概念，亚里士多德认为实体有四个特点，其中第四点就是：实体是变中之不变，实体承载的具体属性可以变化，但作为实体本身是不变的。其实提出实体是出于常识的理解，人们能感觉到在具体属性之外还有某种物之为物的不变性，所以有时属性的改变不会改变我们对物体的认识。可以说，实体的观念是从亚里士多德开始一脉相承、一以贯之的。</li><li>偶性就是物体具有的各种属性。霍布斯认为，偶性其实是实体所具有的某种能力刺激我们的感官的结果。也就是说，偶性既是实体本身所具有的，同时又与我们的感官有关系。所以霍布斯认为偶性是“我们认识物体的方式”，这就把偶性与人的主观联系了起来，有一种将偶性主观化的倾向。霍布斯把偶性分为两类，一类是广袤，即物体的本质属性，与物体共存亡，另一类是颜色、气味等属性，它们依附于物体存在而不构成物体。霍布斯认为第二类偶性不具有客观实在性，它们只是对象在我们头脑中造成的一种主观映像，正如每个人对物体的颜色、冷热、软硬等方面的感觉或多或少都有差异，但对于广袤性的感知都是一致的(但是到了现代已经有色彩、温度、硬度的客观指标了，这些属性虽然看不见或摸不着，但是是可以测量的，所谓的差异也就只是主观标准上的差异了)。</li><li>霍布斯对实体采取了一种唯名论的态度，他认为实体就是人们的命名，而不是感觉经验的结果。但他的表述还是有些模糊的，一方面启发了后来的洛克，洛克明确表达了这种唯名论的观点，另一方面这种牵强的假设也导致了贝克莱、休谟等人对实体的否定。</li></ul><h3 id="感觉与推理"><a href="#感觉与推理" class="headerlink" title="感觉与推理"></a>感觉与推理</h3><ul><li>在培根的时代，宗教势力的影响比较大，虽然培根认为一切知识都来源于感觉经验，但他也承认我们有与生俱来的天赋观念。到了霍布斯，就坚定地支持感觉经验，否定一切的天赋观念。因此霍布斯批判了笛卡尔的天赋观念说，从经验论的角度看，根本没有人见过上帝，所以上帝的观念不是经验，而是以讹传讹的一种想象，就像盲人对火的观念一样。</li><li>虽然培根建立了科学归纳法，但也只是刚刚兴起，当时的主流还是从亚里士多德传下来的演绎推理。霍布斯没有轻易继承培根的归纳法，他认为哲学是一门推理的学问，但他的推理也是偏机械性的。他把推理等同于计算，认为推理就是复杂观念的组合和分解过程而已，比如把“物体”、“活的”、“理性的”三个观念组合起来就是“人”的观念，从“人”的观念里减去“理性的”就是“动物”的观念。</li><li>但另一方面，这种推理方法也符合霍布斯的“从原因求结果，从结果求原因”的哲学主张。他把从结果求原因的方法称为分解或分析，把从原因求结果的方法称为组合或综合。分析是一种发明的方法，是从个别到普遍，即经验的归纳。综合是一种证明的方法，是从普遍到个别，即理性的演绎。所以霍布斯的推理其实是兼有归纳法和演绎法，只是相对而言更注重演绎罢了。然而霍布斯没有深入探讨两种方法的关系，他简单粗暴地认为分析与综合、归纳与演绎、经验知识与理性知识是彼此分离和互不相干的，完全是两套并行的认识方法和知识系统。所以他这个人很奇怪，在经验归纳时是经验论的立场，而在演绎推理时又转到唯理论的立场。</li><li>唯理论之所以坚持天赋观念，是因为天赋的东西能够保证知识的普遍性和必然性，而感觉经验却是因人而异的。所以经验论的优势在于，以感觉经验为出发点是符合常识、不证自明的，但对于从经验和归纳中得到的知识，不能保证其普遍性和必然性。相反，唯理论的优势在于，从普遍前提经过演绎推理得到的结果一定具有普遍性和必然性，但把天赋观念作为普遍前提是经不起推敲的。</li></ul><h3 id="利维坦"><a href="#利维坦" class="headerlink" title="利维坦"></a>利维坦</h3><ul><li>《利维坦》主要表述了霍布斯的政治观点，奠定了西方近代政治学的基础。</li><li>霍布斯比较早得提出了自然权利与社会契约的思想，这种思想可以称作社会契约论，而社会契约论正是自然法学派的最基本的理论，自然法学派包括荷兰的格劳秀斯、斯宾诺莎，英国的霍布斯、洛克，法国的孟德斯鸠、卢梭，德国的莱布尼兹等人。自然法学派在解释国家起源时，以一种“自然状态”入手，在自然状态中人们彼此订立契约来产生国家的法律。这一点就和马克思主义不同，马克思认为国家是阶级矛盾不可调和时，一个阶级压制另一个阶级的结果，而自然法学派虽然也承认自然状态中存在矛盾，但社会契约是各个阶级共同决定的一个理性的结果，考虑的是共同利益。换言之，马克思认为国家是暴力的结果，自然法学派认为国家是妥协的结果。</li><li>霍布斯认为自然状态里的第一条原则是“用一切手段寻求和平与自卫”，最终导致一种“一切人对一切人的战争”状态，由此推出第二条原则，“为了和平与自卫，人们宁愿主动放弃对一切事物的权利”，也就是为了结束战争，宁愿把自己的权利转让给一个“第三方”，这个第三方体现这全体订约人的人格，并对他们进行治理，这就形成一种社会契约(契约就是权利的转让)，最终导致了国家和法律的产生。</li><li>霍布斯还表达了一种“绝对君权”的思想，他认为掌握权利的“第三者”没有参与契约订立，所以是不受任何约束的，是可以为所欲为的。但这种“绝对君权”和后来的君主专制不同，霍布斯的观点针对的是中世纪传统的“君权神授”的思想，从这一点看，社会契约下的“绝对君权”包含着一种“君权民授”的思想，虽然君权是绝对的，但是已经打破了它的神圣性，所以是具有进步意义的。</li></ul><h2 id="3-3-约翰·洛克"><a href="#3-3-约翰·洛克" class="headerlink" title="3.3 约翰·洛克"></a>3.3 约翰·洛克</h2><ul><li>洛克的著作都是在1688年光荣革命后发表的，所以马克思评论洛克的思想“充满了妥协”，认为他代表了17世纪后半叶英国人的主流思想，也就是妥协，当时有亡党和人民的妥协，有国王和议会的妥协，有天主教和新教的妥协，集中出现在光荣革命时期。</li><li>培根和霍布斯的经验论思想还不成熟，还有着一切模糊的地方和避而不谈的问题。到了洛克才真正系统化地阐述了经验论的基本问题，包括知识的来源、可靠性、范围等问题。他的认识论观点集中表现在《人类理解论》中。</li></ul><h3 id="天赋观念批判"><a href="#天赋观念批判" class="headerlink" title="天赋观念批判"></a>天赋观念批判</h3><ul><li>在人物时间上，笛卡尔先于洛克，霍布斯就已经批判过笛卡尔，洛克则进一步批判了笛卡尔的天赋观念说。笛卡尔的天赋观念有三方面，包括天赋的思辨原则、天赋的实践原则和天赋的上帝观念。</li><li>天赋的思辨原则是指几何学和逻辑学的基本规律，笛卡尔对此的一个基本论据是“普遍同意”，因为感觉经验因人而异，而思辨原则却是人们普遍同意的。但洛克认为“普遍同意”不能说明是天赋的，因为事实上并不存在普遍同意的东西，比如儿童就不懂这些思辨原则。即使有普遍同意的东西，也可以是人们约定俗成的，或者是因为人们通过同样的方式和步骤导致得到了相同的结果，所以不一定是天赋的。</li><li>天赋的实践原则也就是道德原则。17世纪的英国出现了自然神论的思潮，洛克也是自然神论的思想家，他们强调基督教最重要的意义不在于耶稣身上的死而复活、道成肉身之类的神迹，而是在于耶稣身上体现出的道德性，所以道德原则的来源就成了当时思想家热衷探讨的问题。当时的主流观点认为道德就是上帝刻在人们心中的，笛卡尔的天赋实践原则是对这一观点的支持。但洛克否认道德是与生俱来的，他认为道德是教化和约定俗成的结果，他列举了不同文化背景、社会环境下的道德原则差异来证明根本不存在人类统一的道德原则。</li><li>针对天赋的上帝观念，洛克认为上帝的观念也不是与生俱来的。作为一个基督徒，洛克没有彻底否定上帝的观念，他否定的是上帝观念的先验性。他认为上帝的观念是人们对于自然事物运动的第一原因的一种推测，是推理的结果。他指出许多原始民族以及中国等文明国度中都没有上帝的观念，所以上帝观念不是天赋的。</li></ul><h3 id="观念的两个来源"><a href="#观念的两个来源" class="headerlink" title="观念的两个来源"></a>观念的两个来源</h3><ul><li>在批判了一切天赋观念后，洛克明确表述了经验论的基本原则：凡在理智之中的，无不先在感觉之中。他对此提出了“白板说”，认为人心最初如同一块白板，一切观念都是来自于后天的经验。所以到了洛克就正式确立了自培根发展而来的经验论。</li><li>洛克把经验分为两种，即感觉与反省，也就是观念的两个来源。感觉是通过感官从外在事物获得的经验，是一种外在经验，反省是对内心活动的经验，是一种内在经验。从对经验的系统性分类这一点上看，洛克已经超越了培根和霍布斯。</li></ul><h3 id="两种观念"><a href="#两种观念" class="headerlink" title="两种观念"></a>两种观念</h3><ul><li>经验只是知识的来源，观念才是知识系统，所以对经验进行分类后，洛克又进而把观念分成了两种。通过感觉和反省直接得到的称为“简单观念”，简单观念是心灵被动接受的，心灵对于简单观念既不能制造也不能毁灭。心灵通过对简单观念的组合、比较和抽象能够得到一些“复杂观念”，可以看出洛克的理论中还是保留了一些天赋，因为心灵的这种能动性虽然不是天赋观念，但也算是天赋的能力，可见洛克真正否定的是“天赋观念”而不是“天赋”。</li><li>洛克把复杂观念分为样式、实体和观念三类。样式是指实体的一些状态，或者由同一种简单观念集合而成，如“一打”是多个表示数量的“一”的观念集合而成，或者由不同的简单观念组合而成，如“偷盗”是由“物主”、“所有权”、“变换”等观念组合而成。实体也是简单观念的组合体，但它具有独立存在性，是各种性质赖以依附的基质，实体观念分为两种，一种是简单的实体，如人、羊，一种是集合的实体，如人群、羊群。关系是对简单观念加以比较得到的。</li></ul><h3 id="两种性质-简单观念"><a href="#两种性质-简单观念" class="headerlink" title="两种性质(简单观念)"></a>两种性质(简单观念)</h3><ul><li>简单观念是人通过感觉和反省获得的，洛克把物体中能产生观念的能力称为“性质”。他把性质分成两种，第一性质是在任何情况下不能与物体相分离的性质，如体积、广袤、形相、运动、数目等，反映了物体的客观状态，第二性质是物体借第一性质在我们心中产生观念的能力，如颜色、声音、滋味等，虽然也源于物体的刺激，但是具有因人而异的相对性。这和霍布斯提出的两种偶性基本相同，只不过洛克把广袤扩充了，但体积、形相这些性质本质上还是与广袤有关系的。</li><li>其实性质是主观还是客观本来就说不清，我们对物体性质的理解来源于感官接收到并处理过的信息，既包含外物的刺激，也包含人体接受信息时的主观判断。可以看出洛克在区分第一性质和第二性质时基本是按照空间性与可见性来区分的，具有空间性与可见性就容易被认为是客观的外部存在，看不见摸不着的就容易被认为是主观的感觉。到了晚期经验论时代，贝克莱就发现了洛克的这种局限，于是贝克莱把第一性质也归为主观上的性质了。</li><li>洛克还提出了第三种性质，是物体在变化中才显现的性质，比如蜡烛燃烧时变黄、草药能够治病，其实现在看来就是化学变化导致的性质改变，但当时没有化学的概念，洛克对这种性质讨论得比较少，所以人们主要还是关注他的第一性质和第二性质。</li><li>洛克把第一性质归为客观实在，把第二性质归为主观感觉，这就导致了两种性质的分裂，也让洛克的立场十分尴尬，第一性质成为了经验论者批判的目标，第二性质成为了唯物主义者批判的目标。所以后来的经验论者就开始考虑把两种性质统一起来。</li></ul><h3 id="两种实体-复杂观念"><a href="#两种实体-复杂观念" class="headerlink" title="两种实体(复杂观念)"></a>两种实体(复杂观念)</h3><ul><li>解释完简单观念，洛克转而解释复杂观念。三种复杂观念中，实体是最重要的，因为实体构成了样式和关系赖以存在的基质和前提。洛克把实体分为两种，即物质实体和精神实体，物质实体是从感觉中得到的简单观念所寄托的基质，精神实体是从反省中得到的简单观念所寄托的基质，也就是“我”。</li><li>洛克认为实体是人们不可知但又必须假定存在的东西，因为我们的思维定式使我们难以想象诸多简单观念可以独立存在而不需要依托。同时洛克不否认实体的存在，认为实体不可知并不意味着它们不存在。洛克的观点相比于霍布斯对实体下的简单粗陋的定义显然是有进步的，但对于实体是什么依然很模糊。直到休谟才斩钉截铁地否定了实体，认为实体就是不存在的，简单观念就是可以独立存在。</li><li>洛克的实体观点本身就体现了唯物主义立场和经验论基本原则之间的矛盾。他认为实体不可知，但又假定实体存在。站在经验论的立场上，一切知识必须来源于经验，实体的观念不是通过经验得到的，而是出于某种需要假定存在的，是推理的结果，所以不能承认实体的存在。所以洛克的观点其实是向常识、向思维定式妥协的结果，为此宁愿让自己陷入矛盾。而到了贝克莱和休谟就开始走向纯粹的经验论，坚持经验论原则，不向常识妥协，也不再顾忌唯物主义的立场。</li><li>所以从培根到休谟的经验论的发展过程，就是把经验论基本原则贯彻到底的过程，但经验论的悲剧性在于，贯彻到底后一切都变成主观的了，根本没有什么普遍、必然的知识，这反而背离了经验论的初衷，等于挖坑把自己埋了。</li></ul><h3 id="两种本质"><a href="#两种本质" class="headerlink" title="两种本质"></a>两种本质</h3><ul><li>探求事物的本质是人的习惯，很难说这是个好习惯还是坏习惯，但正是因为人类把世界搞复杂了，所以把人类自己搞得丰富了。世界有没有本质也许并不重要，是人类的这种追问使人类本身变得崇高。就算本质问题是一种荒谬，那也是一种神圣的荒谬。</li><li>自柏拉图以来的主流思想认为人无法把握到本质，人对本质是求而不得的。对本质的把握实际上是认识能力的体现，比如上帝眼中没有现象只有本质，到了人，人能把握现象但只能思考本质，再到更低级的动物，动物就只能把握现象，完全没有了对本质的考虑。</li><li>从认识论的角度看，观念来源于经验，而从本体论的角度看，观念就来自于事物的本质，所以在表述了认识论的观点后，洛克又表述了关于本质的观点。他认为本质分为两种，实在本质和名义本质。实在本质是潜藏在物体的各种可感属性背后、并且支撑着这些属性的实在构造，实在本质是我们无法认识的。名义本质其实就是人们对事物的命名，是人们为了传达知识而制造出来的复杂观念，并不能使我们真正认识物体的实在构造。所以实在本质是无法认识的真本质，名义本质是认识了也没用的假本质。</li><li>洛克的实在本质表现出一种关于实体的不可知论思想，名义本质则表现出洛克受到了中世纪唯名论的影响。</li></ul><h3 id="知识的等级、可靠性与真理"><a href="#知识的等级、可靠性与真理" class="headerlink" title="知识的等级、可靠性与真理"></a>知识的等级、可靠性与真理</h3><ul><li>观念并不等同于知识，从观念到知识还需要心灵的加工过程。洛克认为知识就是人心对两个观念的契合或矛盾所产生的一种知觉。从观念与观念契合的角度，洛克把知识分成三个等级：<ul><li>直觉的知识：心灵直接判断出两个观念是否契合，比如判断红的是红的，而不是白的。洛克认为直觉是最清楚、最可靠的知识，直觉是对观念最直接的把握，不需要感觉、反省和推理。但直觉本身带有一种神秘主义色彩，因为“为什么有直觉”、“直觉为什么不需要根据”这些问题是无法解释的，直觉就是当时的一种普遍的思维定式。</li><li>证明的知识：心灵通过其他观念的媒介而推出两个观念是否契合，比如上帝的知识既不是直觉也不是感觉到的，而是我们把一切美德推到最完满得到的结果，比如A比B知道得多，B比C知道得多，所以A比C知道得多，推到无限就会得到全知，因此上帝是推理出来的。</li><li>感性的知识：也就是关于外物的知识，它判断的不是观念与观念是否契合，而是观念与外物是否契合，因为这完全源于经验，所以不具备普遍性与必然性。而洛克认为前两种知识是普遍和必然的，这就使他陷入了自我矛盾，作为一个经验论者，认为从经验得到的知识不可靠，可靠的反而是通过神秘主义和推理得到的知识。虽然会矛盾，但他又不能对前两种显然可靠的知识视而不见，所以这也是没办法的事。到了休谟就不迷茫了，休谟认为前两种知识局限在观念之间，脱离了现实，所以不算知识。</li></ul></li><li>洛克认为两个观念相符合得到的是“确定的知识”，当这两个观念还与现实中所指称的对象符合时，得到的就是“实在的知识”。这涉及到唯物主义的符合论思想，也就是主观要符合客观。但是由于我们无法认识事物的本质，所以实在的知识通常是不可能达到的，我们只能停留在确定的知识上。对应这两种知识，洛克还提出了“口头的真理”和“实在的真理”，知识和真理是一样的。</li></ul><h3 id="《政府论》的社会政治思想"><a href="#《政府论》的社会政治思想" class="headerlink" title="《政府论》的社会政治思想"></a>《政府论》的社会政治思想</h3><ul><li>洛克在政治学上的成就甚至超过了在哲学上的成就。洛克也是自然法学派，也反对“君权神授”，但在社会契约论观点上与霍布斯分道扬镳。洛克也认为国家建立之前的社会是一种自然状态，他认为自然法赋予了人与生俱来的权利(洛克反对天赋观念，但是承认天赋能力)，如自由、平等、私有财产等，其中私有财产权的重要性是光荣革命以来人们经历了财产转移、流血牺牲等惨痛教训才认识到的。洛克描述的自然状态与霍布斯的不同，霍布斯的自然状态是“一切人与一切人的战争”状态，而洛克的自然状态是一个自由平等和谐的、充满善意的、终极完美的状态。所以霍布斯认为国家是人们调和内部矛盾的一种妥协的结果，而洛克认为国家是人们团结一心防御外敌的结果。同时洛克也否定了霍布斯所谓的“第三者”，洛克认为托管权利的人也参与订立契约，也受到契约的约束，当政府违背契约时理应被人民推翻，所以在洛克的理论中就不会出现为所欲为、不受约束的暴君。从这个角度看，如果说霍布斯从社会契约论中引出了君主专制的结论，那么洛克则是从社会契约论中引出了社会革命和君主立宪的政治主张。</li><li>洛克最早提出了三权分立的思想，即立法权、行政权和外交权，后来18世纪的孟德斯鸠对三权分立进一步完善，形成了立法权、行政权、司法权的分立与制衡。三权分立的好处就是防止集权，防止权力滥用和政治腐败。这也是体现了妥协与制衡的思想。</li><li>洛克在宗教上也持一种妥协的观点，他主张宗教宽容，驱除宗教生活中一切反理性的狂热和迷信，不应该因为宗教观点的不同而互相仇恨或歧视。</li></ul><h1 id="4-唯理论哲学"><a href="#4-唯理论哲学" class="headerlink" title="4 唯理论哲学"></a>4 唯理论哲学</h1><ul><li>唯理论得到的知识虽然具有普遍必然性，但倾向于独断论，因为所有知识都是从天赋观念演绎推理出来的，逃不出预先知道的天赋观念所定义的范围，所以得不到新知识。相对的，经验论的归纳法虽然能得到新知识，但知识没有规律、没有普遍必然性。</li></ul><h2 id="4-1-勒奈·笛卡尔"><a href="#4-1-勒奈·笛卡尔" class="headerlink" title="4.1 勒奈·笛卡尔"></a>4.1 勒奈·笛卡尔</h2><ul><li>笛卡尔出生在法国，毕业后在荷兰从军，在一个无战事的冬天里天天围着火炉进行形而上学的沉思，经过这个冬天后他的思想就基本成型了。笛卡尔几乎所有的著作都在荷兰发表，因为当时荷兰是最宽容、思想最自由的国家。</li><li>培根是经验论的开创者，笛卡尔是唯理论的开创者。他们两个都只是提出了一些基本原则，但他们并没有将这些原则贯彻到底，也没有对一些基本的问题深入思考，所以直到后面的几位哲学家才发现理论内在的矛盾。比如霍布斯和洛克的观点中体现出的唯物主义立场和经验论基本原则的矛盾。</li></ul><h3 id="普遍怀疑"><a href="#普遍怀疑" class="headerlink" title="普遍怀疑"></a>普遍怀疑</h3><ul><li>在《谈谈方法》中，笛卡尔对他早年在学校学习的知识表示了怀疑，比如神学充满了我们不能理解的神秘主义的东西，哲学永远处于不同派别之间的永无休止的争辩，逻辑学只能证明已知的知识而不能用来发明和求知，所以笛卡尔对这些知识深感怀疑和不满。</li><li>笛卡尔的怀疑不同于古希腊的怀疑主义，对于古希腊的怀疑主义者，怀疑本身就是目的，所以他们主张不做判断、顺其自然。但笛卡尔的怀疑不是目的，他的目的是找到那些不可怀疑的东西，正如培根提出四假象是为了确立经验归纳的方法。</li><li>在怀疑了大部分学科后，笛卡尔认为数学是唯一具有牢固基础的学科。在古希腊毕达哥拉斯时期，毕达哥拉斯定理导致了数形分离，数被神秘化，成为了西方形而上学的基础。而笛卡尔的解析几何实现了数形统一，也就是任何几何图形都能用代数方程式表示。虽然数学也算是一种逻辑，但笛卡尔认为数学比亚里士多德的逻辑学更精密、更严格。又因为迄今为止人们还没有在数学上建立起知识的大厦，所以笛卡尔认为当前的所有知识都是垃圾。</li><li>笛卡尔做出怀疑的准则是“清楚明白”，但后世哲学家对此的批判是，“清楚明白”本身就不是清楚明白的，因为“清楚明白”是人的主观判断而不是事物本身具有的性质，每个人的主观标准是不一样的，笛卡尔显然没有认识到这一点。笛卡尔的错误在于把自己主观的标准想当然地上升到全人类认同的普遍标准。</li><li>笛卡尔的怀疑准则属于主观标准，唯物主义者的“实践是检验真理的唯一标准”属于客观标准。我们无法说哪种标准更好，因为虽然实践很重要，但哲学的一些根本问题都是形而上的，是不能实践的。人之为人的本性，就是喜欢争论那些无法通过实践判断是非的问题，总是不满足于经验范围内可以用实践验证的问题，从这一点上看，把实践当做检验真理的唯一标准也显得有些独断。</li><li>笛卡尔像欧洲当时的很多知识分子一样，在思想上敢于革新，在行动上却谨小慎微，正如后来马克思评价德国的哲学家们是“思想上的巨人，行动上的侏儒”。笛卡尔仅仅把怀疑限制在思想的范围内，而在行动上明哲保身、不敢得罪权贵，正如他在《谈谈方法》里所说：“永远只求克服自己，不求克服命运；只求改变自己的愿望，不求改变世间的秩序”</li></ul><h3 id="我思故我在"><a href="#我思故我在" class="headerlink" title="我思故我在"></a>我思故我在</h3><ul><li>在对知识表示怀疑后，笛卡尔进而对人的感觉提出了怀疑。他认为感官本身是会骗人的，我们通过感官接收世界的信息，只要有一次产生了错觉，我们就不应当再相信感觉了。再进而思考，一切事物都是值得怀疑的，比如人无法判断自己是不是在做梦，无法确定自己感知到的东西是不是真实存在，甚至连我们认为确定无疑的数学知识都值得怀疑，因为可能是上帝在创造我们时有意把我们造得每次都犯同样的错误，使得我们相信这些是普遍必然的知识。最终，连上帝都可能是不存在的，因为我们不曾感知到他。</li><li>笛卡尔认为，虽然我们可以对一切存在物进行怀疑，但只有“我在怀疑”这件事本身是不可怀疑的，因为即使对“我在怀疑”提出怀疑，这本身仍然表明了“我在怀疑”。怀疑就是思想，笛卡尔认为思想必然能推出一个思想者“我”的存在，因此他提出了“我思故我在”。后世对这一观点的批判就集中在“我”上，虽然“怀疑”是确定的，但从“怀疑”推出“我”是笛卡尔想当然的结果，既然他把一切知识都怀疑了，就没有理由相信“凡有思想必有思想者”这一条知识。</li><li>笛卡尔的解释是，“我”是一个在思想的东西，“我”的本质属性就是思想，思想了多久，“我”就存在了多久，换言之，“我”和“思”是同生同灭的两个东西，所以从“思”到“我”不是一个推理的过程，而是不证自明的。但这并不具有说服力，甚至有点像诡辩，因为“思”是一个过程，而“我”是一个实体。笛卡尔在“我”和“思”的关系上没想明白或者不太讲道理，相比之下，洛克想得就比较明白，按照洛克的观点，“我”作为一个承载“思”的基质，是不能感知但必须假定存在的东西。又或者像休谟一样，直接否定“我”和“思”是两个东西，休谟认为所谓的“我”其实就是一堆“思”的集合，“思”本身不需要有所依附。</li><li>“我思故我在”是笛卡尔哲学的第一原理。可以看出，笛卡尔虽然是唯理论的开创者，但“我”作为他的哲学基础却不是演绎推理的结果，而是自我反省的结果，是一种内在经验，所以笛卡尔的唯理论是从经验出发的，所以笛卡尔有时也被看作经验论者。</li><li>黑格尔认为笛卡尔哲学的意义在于确立了自我意识。此前的中世纪时期都是信仰至上，所有的哲学都是以上帝为大前提，从上帝推出一系列理论，但笛卡尔第一次用自我取代了上帝</li></ul><h3 id="上帝存在的证明"><a href="#上帝存在的证明" class="headerlink" title="上帝存在的证明"></a>上帝存在的证明</h3><ul><li>把“我”作为哲学出发点的问题在于，“我”是个除了思想什么都没有的狭隘的存在，如果要建构哲学体系就需要走出“我”，推演出万事万物，那么最好的方式就是搬出上帝。在那个宗教氛围浓厚的时代，人人信仰上帝，只要有了上帝作为根基，就可以不证自明地推演出万事万物，一切问题就一劳永逸地解决了。所以在确立了“我”为哲学原点后，笛卡尔要做的第一件事就是证明上帝存在，以上帝为跳板，从“我”向世界过渡。后来的贝克莱、莱布尼兹都是这么干的。</li><li>笛卡尔的论证过程是：“怀疑”本身就体现了“我”的不完满，因为“怀疑”相对于“确定”就是不完满的，所以我们能够感觉到“我”是不完满的。能够感觉到不完满，就说明我们已经有了关于完满的东西的观念。这个完满的观念首先不能来自于“我”，因为不完满的东西不能产生完满的东西，也就是“结果不能大于原因”的原则。其次，完满的观念不能来自于对外在事物的感觉，因为我们从未感觉到有什么东西是完满的。最后，完满也不是来源于我们对不完满的否定，因为必须先有完满作为依据才能衍生出不完满。排除了三种可能性后，说明完满的观念只能是由一个客观存在的完满的东西放进我们头脑中的，通过一种天赋的方式赋予我们。接着笛卡尔又重复了安瑟尔谟的论证，即不所不包的东西必定包含了存在，正如一个三角形的观念中已经包含了内角和180度(后来康德批判了这个比喻)。</li><li>从本体论的角度看，论证出上帝以后，就能够不需解释地推出万事万物，也就把笛卡尔否定的一切重新建立起来。从认识论的角度看，论证出上帝以后，就能自然而然地提出天赋观念，是上帝赋予了人以认识的能力。所以上帝既建立了一个物质的世界，又建立了一个心灵的世界，最终使笛卡尔的哲学从自我走向心物二元论的世界。</li><li>笛卡尔先用怀疑否定一切，再从自我出发，以上帝为跳板又推出了一切，所以后来伽桑狄鄙视笛卡尔论证上帝的做法，认为是装腔作势、故弄玄虚。而且笛卡尔的论证很荒谬，以“我”为前提固然没问题，但是他用了很多他认为“清楚明白”的前提，比如“结果不能大于原因”，在怀疑一切的前提下，这些所谓的“清楚明白”都是经不起推敲的主观臆断。</li></ul><h3 id="天赋观念与理性演绎法"><a href="#天赋观念与理性演绎法" class="headerlink" title="天赋观念与理性演绎法"></a>天赋观念与理性演绎法</h3><ul><li>前面由经验论观点引出的一系列观点都是铺垫，直到天赋观念的提出，才正式确立了笛卡尔的唯理论思想。天赋观念是唯理论者始终坚持的知识来源和前提，唯理论的整个知识论体系就建立在天赋观念和理性演绎法的基础之上。</li><li>笛卡尔把观念分成了三类。第一类是天赋观念，包括几何学公理、逻辑学基本规律、上帝的观念。第二类是由感觉提供的观念，比如声音、色彩等，它们不以人的意志为转移，因为人是在被动地接收这些信息。第三类是关于现实世界并不存在的东西的虚假观念，如牛鬼蛇神。笛卡尔认为感觉提供的观念虽然不能算是虚假的，但也是不可靠的，因为感官会产生错觉。后面两类观念其实就是外在经验和内在经验，既然它们都不可靠，所以只有天赋观念才是真正的知识的来源和前提。</li><li>天赋观念是唯一可靠的前提，而理性演绎法就是唯一能获取真理性知识的途径。理性演绎法是从一些不证自明的公理(也是天赋观念)出发，遵循严格的推理规则(也是天赋观念)，清楚明白地推演出一系列命题或定理，形成完整的知识系统。笛卡尔强调，理性演绎法不同于传统的三段论演绎，它是综合了逻辑学、几何学和代数这三门科学优点的新方法。笛卡尔只是提出了这种方法，真正把它系统化的是斯宾诺莎，比如斯宾诺莎的《伦理学》通篇都是用几何学的方法写的。</li><li>因为天赋观念和理性演绎法都是先验的、脱离经验的，所以会导致得到的知识缺少反思，也就是不需要关于世界的经验就能得到关于世界的知识，像是一个矛盾。进而导致的问题是如何保证推理出来的知识与现实世界是相符的，也就是符合论的问题。唯物主义者的解决方法是通过实践回到现实世界中去检验知识，经验论者则不需要证明，因为所有知识都是从对世界的感觉经验推出来的，而笛卡尔的理论是脱离现实世界的、自封闭的一套知识系统，所以如何证明知识符合现实就成了大难题，这也是后来的唯理论者需要突破的瓶颈。笛卡尔最终的解决方法就是又一次耍无赖地搬出上帝，认为上帝自然能够保证二者相符合。</li></ul><h3 id="心物二元论"><a href="#心物二元论" class="headerlink" title="心物二元论"></a>心物二元论</h3><ul><li>笛卡尔认为，上帝一方面保证了精神世界(观念体系)的清楚明白，另一方面也保证了物质世界的真实可靠，而且他还保证了这两个世界之间的相互独立性。</li><li>笛卡尔对实体的定义是“被别的东西作为主体而直接寓于其中的东西”。实体分为绝对实体和相对实体。绝对实体就是上帝，是自因的和自由的，即自己是自己存在的原因。上帝以自身为原因创造了相对实体，即物质和精神，相对实体只依靠上帝而不依靠其他事物存在，物质实体的唯一本质属性是广延，遵循自然规律而运动，精神实体的唯一本质属性是思维，根据自由意志而活动。</li><li>心物二元论是唯理论必须承认的基本原则，只有断绝物质与精神的联系，才能说明仅仅依靠天赋观念和理性演绎法就能建立起一个知识系统。</li></ul><h3 id="身心交感说"><a href="#身心交感说" class="headerlink" title="身心交感说"></a>身心交感说</h3><ul><li>心物二元论认为物质与精神是相互独立的，但问题在于二者按照各自的路数来走居然可以协调一致，比如人兼具物质与精神，协调性就体现在肉体与心灵的交感，肉体的感受能引发心灵的反应，同时精神能够操控肉体的活动，对这种协调性的解释就成了唯理论者需要解决的一个问题。而对于经验论者就不存在这个问题，经验论认为物质对精神是有影响的，所以协调一致是理所当然的。</li><li>笛卡尔的解决方法比较拙劣，他强行把人当做一个例外，认为物质和精神会在人身上的某个部位发生交感。他在晚年写了一部《论灵魂的感情》阐述了他的生理学和心理学观点，感官受到刺激后，刺激信号通过生精(血液精华)传到松果腺，松果腺中的心灵接收到刺激信号后产生关于外物的观念，所以肉体影响心灵的路径就是：感官→生精→松果腺→心灵，反过来就是心灵影响肉体的路径。</li><li>心物二元论与身心交感说是直接矛盾的，如果人是一个特例，那么心物二元论就不是普遍必然的知识。但是这个问题又不能推给上帝，因为笛卡尔之前已经说了上帝创造了两个相互独立的世界，如果接着说上帝维持着两个世界的协调性，就让上帝自相矛盾了。</li></ul><h3 id="物理学上的机械唯物主义"><a href="#物理学上的机械唯物主义" class="headerlink" title="物理学上的机械唯物主义"></a>物理学上的机械唯物主义</h3><ul><li>笛卡尔是一个二元论者，在精神方面坚持天赋观念这套理论，而在物质方面就按照当时物理学的角度，用自然规律解释物质，因为物质世界与精神世界是相互独立的，所以在这两个领域上的理论也可以使不相干的。换言之，笛卡尔在精神领域是唯理论者，在物质领域就是个物理学家。笛卡尔和牛顿是近代机械唯物主义的奠基者。</li><li>笛卡尔在物理学上的基本观点主要有两个。第一，广延是物质的唯一本质属性，机械运动是运动的唯一形式。第二，用“充实空间”理论反对古代原子论者的“空虚空间”理论。德谟克利特认为除了原子之外还有虚空，虚空提供了原子运动的空间，牛顿经典物理学的“绝对空间”观点也是如此，认为运动和空间是独立的、互不影响的。但是爱因斯坦的现代物理学认为时间、空间和运动三者是相互影响的。所以笛卡尔的观点比牛顿更接近现代物理学的观点。笛卡尔认为空间是被物质堆满的，空间和物质不可分开讨论，而运动也不需要绝对空无一物的空间，正如鱼在充满水的鱼池里也能运动。</li></ul><h2 id="4-2-皮埃尔·伽桑狄"><a href="#4-2-皮埃尔·伽桑狄" class="headerlink" title="4.2 皮埃尔·伽桑狄"></a>4.2 皮埃尔·伽桑狄</h2><ul><li>笛卡尔在《第一哲学沉思集》中提出了六个沉思，而后其他的哲学家针对这六个沉思提出了诘难，最终版本的《第一哲学沉思集》收录了其他哲学家的诘难以及笛卡尔对这些诘难的反驳。对笛卡尔提出诘难的代表人物就是伽桑狄。</li><li>伽桑狄认为笛卡尔的“怀疑一切”是装腔作势、故弄玄虚，但是他的反驳很幼稚，因为他不相信有人会怀疑自己所感知的一切，所以认定笛卡尔就是装逼，其实就是用人们习惯的思维定式去质疑笛卡尔的反思维定式的理论。他还指出笛卡尔根本没有解释清楚“我思故我在”中的“我”到底是什么，笛卡尔说“我”不是形体、不具有广延，但这种不完全的排除法只能有限地论证“我”不是什么，而不能反推出“我”是什么。</li><li>伽桑狄也对天赋观念提出了批判，他认为全部观念都是外来的，通过感觉传达到理性，根本就不存在什么“天赋观念”。他还指出笛卡尔的“清楚明白”是过于主观的标准，是因人而异的。</li><li>伽桑狄虽然信仰上帝，但他并不认为上帝的观念是天赋的，他认为上帝的观念是人们将现实经验里所有高尚的品质进行否定、夸张、渲染得到的结果。可以看出，笛卡尔认为不完满不能推出完满，而伽桑狄则认为对不完满进行心理加工可以得到完满。同时他又认为上帝超出了人的理解力，所以人们有限的理性所能把握到的上帝的观念都是对上帝的渺小化。</li><li>针对身心交感说，伽桑狄认为没有广延的心灵无法与具有广延的肉体发生交感，也就是松果腺作为有广延与无广延发生交感的场所，松果腺本身是否具有广延就成了一个矛盾。伽桑狄从古代原子论和唯物主义的角度否定了精神实体，他认为心灵也是一种物质，所以心物二元论的问题自然就没有了。相反，马勒伯朗士站在唯心主义的立场，通过把物质精神化来解决心物二元论的问题。</li></ul><h2 id="4-3-尼古拉·马勒伯朗士"><a href="#4-3-尼古拉·马勒伯朗士" class="headerlink" title="4.3 尼古拉·马勒伯朗士"></a>4.3 尼古拉·马勒伯朗士</h2><ul><li>马勒伯朗士是神学家，所以他致力于把笛卡尔的形而上学与宗教信仰结合起来。他认为我们的观念既不是对客观事物的反映，也不是心灵制造出来的，而是在信仰上帝时从上帝之中直接获得的。物质在上帝那里是以观念的形式存在的，因为上帝是先有了物质的观念，再根据观念创造物质世界。因此我们只需要从上帝那里获得观念就能获得知识，而不需要去认识具体的物质世界，这里可以看出柏拉图主义的影响，即具体事物只是观念(理念)的摹本，观念(理念)远远高于具体事物。马勒伯朗士认为我们从来没有认识过具体事物，我们的感觉只是精神的“变相”，柏拉图从本体论的角度认为具体事物是对理念的摹仿和分有，类似地，马勒伯朗士是从认识论的角度认为精神的变相是对上帝中的观念的摹仿和分有，因为摹仿和分有是有缺憾的，所以感觉是不可靠的。</li><li>心物二元论的第一个问题就有了解释，也就是物质与精神为什么有对应关系。虽然物质世界与精神世界相互独立，我们也从未认识过物质世界，但因为上帝是物质世界与精神世界的共同源头，我们直接从上帝那里得到了物质的观念，所以是上帝保证了物质与精神的对应关系。</li><li>心物二元论的第二个问题是物质与精神的协调关系，马勒伯朗士借鉴了格林克斯的思想，提出了“偶因论”，也叫“机缘论”。他认为物质与精神没有任何必然的联系，是上帝在安排协调关系，上帝在我们想要做某事的时候控制我们的身体去行动，同时在我们做出某事的时候控制我们的心灵活动。虽然感觉上很荒唐，但是马勒伯朗士已经指出感觉是不可靠的，同时这个观点没有像身心交感说中那样明显的内在矛盾，所以相比于笛卡尔的身心交感说是有进步的。</li><li>费尔巴哈对马勒伯朗士的批判是，马勒伯朗士把物质世界排除在认识之外，所以他讨论的不是物质与精神，而是物质的观念与精神，他所解释的不是心与物的协调一致，而是心与心的协调一致。伽桑狄是把精神物质化，而马勒伯朗士是把物质精神化了，所以他们两人并没有真正解决笛卡尔遗留的的心物关系的问题。</li></ul><h2 id="4-4-别涅狄克特·斯宾诺莎"><a href="#4-4-别涅狄克特·斯宾诺莎" class="headerlink" title="4.4 别涅狄克特·斯宾诺莎"></a>4.4 别涅狄克特·斯宾诺莎</h2><ul><li>斯宾诺莎之所以在哲学史上地位很高，不是因为他的智力超群或者哲学理论博大精深，而是因为他人品高尚，活得像个哲学家。相比之下，莱布尼兹虽然哲学理论高深，但他的道德瑕疵让人反感。</li><li>斯宾诺莎生于犹太家庭，因为广泛阅读了大量哲学家和科学家的著作，使他对犹太教的教义产生了怀疑，导致被逐出教门。而后他隐居乡间靠手工磨镜片过着贫苦的生活，又因为不愿对贵族献媚放弃了当教授和得奖金的机会，最终在贫病交加中英年早逝，年仅45岁。因此他的人品被后世所景仰。</li></ul><h3 id="对笛卡尔认识论的批判"><a href="#对笛卡尔认识论的批判" class="headerlink" title="对笛卡尔认识论的批判"></a>对笛卡尔认识论的批判</h3><ul><li>斯宾诺莎的哲学也是从批判笛卡尔开始的，他在《笛卡尔哲学原理》中对笛卡尔的哲学进行了系统地批判。首先他和笛卡尔一样，认为真理的标准是“清楚明白”，只不过多了个“恰当”。他指出哲学应该从一个自明的东西出发，而笛卡尔的“我”是经过一系列怀疑的过程后得到的东西，所以不是自明的，真正自明的东西不需要过程，通过直觉就能直接把握到。况且“我思故我在”已经包含了对“我”的反思，也就是必然存在另一个知道“我思故我在”的“我”，如此推下去就会出现无限多的“我”。所以斯宾诺莎认为自明的东西不需要被追溯或推出，也就是不需要用“我知道”来保证其清楚明白，如此也就避免了像“我知道我知道”这样推出无限个“我”的问题。</li><li>笛卡尔是从认识论的角度思考的，所以他认为只有先“知道”才能说一个东西是自明的，什么都不知道就无从说起。而斯宾诺莎是从本体论的角度思考的，所以他认为自明的东西本身就是清清楚楚地客观存在着的，跟人知不知道它没有关系。因此两个人只是站在不同角度跨服聊天，无所谓谁对谁错。</li></ul><h3 id="泛神论"><a href="#泛神论" class="headerlink" title="泛神论"></a>泛神论</h3><ul><li>斯宾诺莎既不同意以精神(“我”)为哲学出发点，也不同意以物质(原子论)为哲学出发点，他认为神是哲学的出发点，但他又指出神就是自然。“神即自然”的观点有唯物主义的倾向，所以人们总说斯宾诺莎是唯物主义的唯理论者。正如笛卡尔的哲学基本命题是“我思故我在”，斯宾诺莎的哲学基本命题就是“神即自然”。</li><li>笛卡尔的本体论和认识论是矛盾的。在本体论上，上帝作为绝对实体是一切的起点，而在认识论上，“我”是一切的起点，尽管笛卡尔百般辩解，论证上帝的观念不是“我”推出来的，企图说明上帝高于“我”，但这种辩解是无效的，笛卡尔的上帝就是通过对“我”的否定推出来的。所以“我”和上帝在本体论和认识论中是矛盾的。</li><li>斯宾诺莎认为神是内在于而非超越于自然的唯一实体，神就是自然本身。从神学的角度看，这种泛神论是自然神论到无神论的中介，自然神论认为神创造了世界以后就不管世界了，神超越于世界，存在于世界之外，而泛神论是把这个超越世界的神变成了内在于世界的神，最后到了无神论，既然神和自然是一体的，索性就不要这个神了，只承认自然世界，所以这是神的内化再到消失的一个发展过程。因为这种过渡关系很自然，神内化于自然很容易发展成神消失于自然，所以当时斯宾诺莎的泛神论被等同于无神论。</li><li>“神即自然”里的自然是个抽象的东西，斯宾诺莎又把它叫做实体，所以神、自然、实体是一个东西。斯宾诺莎的实体和前人提出的实体概念不同，他认为神是唯一的实体，这个实体是无限的、永恒的，这就类似与巴门尼德的“存在”，只不过巴门尼德认为“存在”是个球，而斯宾诺莎的“实体”是无边无际的。</li><li>我们之所以难以理解自然的无限，是因为我们所感知到的永远只是自然的局部，当从整体上看时，自然就是整个世界、整个宇宙，这已经超越了我们的理解能力，所以我们只能假设它无边无际、无始无终，不能再去追问它。如果非要追问整个世界的原因，就会陷入康德所谓的二律背反，也就是怎么说都无所谓对错，因为我们无法用经验去验证。</li><li>斯宾诺莎把自然分为“产生自然的自然”和“被自然产生的自然”，前者就是神，是能动的、自因的、作为原因的自然，后者就是我们所感知得到的具体的万事万物，是被动的、他因的、作为结果的自然。这就把斯宾诺莎哲学上的自然和我们常识里的自然统一起来了。</li></ul><h3 id="实体、属性与样式"><a href="#实体、属性与样式" class="headerlink" title="实体、属性与样式"></a>实体、属性与样式</h3><ul><li>实体、属性与样式是斯宾诺莎哲学的三个最基本的概念。</li><li>实体(substantia)是“在自身内并通过自身而被认识的东西”，实体是自因的、无限的、永恒的，唯一的实体就是神或自然。斯宾诺莎的实体不同于亚里士多德和笛卡尔，亚里士多德的实体是具体的、个别的东西，所以是有限的，笛卡尔的绝对实体是无限的，但是他的两个相对实体因为彼此限制所以也是有限的。实际上实体的无限就能推出唯一，因为如果一个实体之外还有另一个实体，就已经说明实体有边界而不是无限的了。因为只有一个实体，所以只有“产生自然的自然”是实体，而“被自然产生的自然”就不是实体，而是样式。</li><li>属性(attributus)是“构成实体的本质的东西”。因为实体是无限的，所以它包含的属性也是无限多的，但是其中能被人所认识的属性只有两种，即思维和广延，这两种属性就构成了我们认知里的物质世界和精神世界。斯宾诺莎把笛卡尔的实体二元论变成了属性二元论，实体对人而言有两种呈现形式，人在物质层面和精神层面认知到的东西其实就是同一个实体的两个方面。</li><li>马克思主义哲学里认为笛卡尔只是表面的二元论，因为物质和精神都源于上帝，同时上帝是一种精神，所以笛卡尔实际上是唯心主义的一元论。但是上帝只是笛卡尔用来跳出“我”的一个跳板，只要从上帝引出物质和精神，就可以过河拆桥不要这个上帝了，所以从这个角度看，笛卡尔的上帝只是虚晃一枪，他是真正的二元论者。而在斯宾诺莎的哲学里，神是最重要的概念，所以在最根本的实体问题上他是一元论者，表现为思维和广延的属性二元论。</li><li>样式(modus)是“实体的分殊”，即“被自然产生的自然”，也就是实体具体的、特殊的存在状态。对比实体的自因性，样式是“在他物内通过他物而被认知的东西”，是他因的。对应实体的两个属性，样式就分为思维的样式和广延的样式，所以笛卡尔的物质世界和精神世界在斯宾诺莎这里就变成了思维样式的世界和广延样式的世界。</li></ul><h3 id="身心平行论"><a href="#身心平行论" class="headerlink" title="身心平行论"></a>身心平行论</h3><ul><li>在身体与心灵的协调问题上，斯宾诺莎否定了身心交感说，他认为思维的样式和广延的样式不会发生交感，虽然属于同一个实体，但是这两种属性是独立的。否定身心交感说，就是承认了心物二元论。伽桑狄的唯物主义一元论脱离了二元论，所以避开了这个问题。马勒伯朗士的偶因论虽然本质上是唯心主义一元论，但表面上还是解释为是上帝在不断调整身体与心灵的协调，这其实是一种后天经验的调整，也就是把本来不协调的二者调整成协调的，这种解释漏洞百出。身心交感说是人自己调整的过程，偶因论是上帝调整的过程，这两种解释都是经验的解释。</li><li>斯宾诺莎用先天具备的协调一致取代了后天调整的协调一致，也就是用先验取代了经验，因为两种样式都源自同一个实体，所以他们必然具有先天的、内在的协调一致。在笛卡尔的体系里，物质和精神是上帝创造的两个独立的世界，上帝可以保证两个世界的对应关系，但不能保证两个世界的协调一致。而在斯宾诺莎的体系里，两个样式的世界统一于实体，是实体的两个不同的角度，角度之间是独立的但都与实体同步，这种同步就是我们所理解的两个世界的协调一致。笛卡尔的观点好比上帝创造了两个人，两个人长得差不多但是相互独立，斯宾诺莎的观点好比一个人创造了两个影子，影子之间互不影响但都同步于主体。在这个问题上，后来的莱布尼兹基本上照搬了斯宾诺莎的观点，只不过解释得更加细致，可见斯宾诺莎的高明。</li><li>思维样式的世界又叫观念的系列，广延样式的世界又叫事物的系列，两个系列各自遵守自己的次序，又是完全同一的。自然万物都以这种一体两面的形式存在，事物的系列遵循机械因果律，观念的系列遵循形式逻辑规律。</li></ul><h3 id="知识分类与真观念"><a href="#知识分类与真观念" class="headerlink" title="知识分类与真观念"></a>知识分类与真观念</h3><ul><li>斯宾诺莎在本体论上的身心平行论必然会导致认识上的唯理论，因为在他的哲学体系中排除了一切经验，所谓的物质世界和精神世界在他这里是独立、平行的两条线，不可能产生经验，只能通过纯粹的逻辑推演得到知识，所以可以说斯宾诺莎把唯理论推向了顶峰。</li><li>斯宾诺莎在《知性改进论》中把知识分成四种：由传闻或任意的名称得来的知识，由泛泛的经验得来的知识，由推理得来的知识，由对一件事物的本质的认识而得来的知识。后来在《伦理学》中，他把前两类知识合并，称为想象或意见，由推理得来的知识称为理性知识，由对事物本质的认识得来的知识称为直观知识。在这三者中，想象或意见不可靠，理性知识可靠但其可靠性最终来源于直观，直观知识才是最可靠的，所以直观知识又叫做“真观念”。</li><li>获得正确知识的流程是：排除想象或意见，把真观念作为推理的不证自明的前提或公理，遵循推理规则得出普遍必然性的结论，也就是理性知识，这就说明了理性知识的可靠是因为有真观念做推理前提，然后以理性知识作为前提继续推理出新的结论，如此就像滚雪球一样，逐渐建立起一套知识体系。几何学就是应用了这种方法，斯宾诺莎十分欣赏这种数学方法，所以他的《伦理学》副标题是“依几何学方式证明”，这种用数学方法建立哲学体系的方法，就是笛卡尔想做但没有做到的。</li></ul><h3 id="真理的标准"><a href="#真理的标准" class="headerlink" title="真理的标准"></a>真理的标准</h3><ul><li>在真理的标准上，斯宾诺莎继承了笛卡尔的“清楚明白”，自己又加了一条“恰当”。他认为“清楚明白恰当”是真理的内在标准，换言之，真理的标准就是真理自身，真观念的标准就是真观念自身，因此真观念既是虚假观念的标准，同时又是真观念自己的标准，正如光明是黑暗的标准也是光明的标准。但是这种标准只是主观的、内在的标准，自己认为“清楚明白恰当”的观念不一定是真观念，真观念还要与观念的对象符合，所以斯宾诺莎又提出了符合论。</li><li>符合论就是“真观念必定符合它的对象”，但斯宾诺莎的符合论不是唯物主义的反映论，因为如果真观念是对事物的反映，就违背了物质世界与精神世界相互独立的二元论原则，同时也从唯理论走向了经验论，二元论和唯理论是捆绑在一起的。斯宾诺莎的符合论其实就是一体两面的观点，一体两面就保证了观念和观念的对象是先天就符合的，和先天的协调一致是一样的道理。</li></ul><h3 id="伦理学和政治观点"><a href="#伦理学和政治观点" class="headerlink" title="伦理学和政治观点"></a>伦理学和政治观点</h3><ul><li>在《神、人及其幸福简论》中，斯宾诺莎指出所有的知识都是为了促进人类的幸福，这一点反倒和培根、霍布斯等英国经验论者的务实态度不谋而合。斯宾诺莎很重视伦理学，因为伦理学就是学术成果对人类福祉、道德、境遇的改变，所以整个学术就是伦理学。</li><li>斯宾诺莎把哲学的目的放在人的自由和解放上，他认为人的不自由是因为过度沉溺于情感和欲望，情欲是自然的东西，只有充分认识到情欲背后的自然本质，才能超越情欲、克服情欲，摆脱情欲才能获得自由。自由不是随心所欲，随心所欲是动物式的任性，真正的自由是对必然性的认识，认识到必然性后顺应必然性来行事。正因为对自由有脱俗的理解，所以斯宾诺莎一生甘于穷困潦倒的生活，那种有钱有势、随心所欲的人生在他看来反而是不自由的。这种观点上承苏格拉底，下启黑格尔，是西方伦理学史上关于自由的一条主线，也就是知识越多、认识越深刻，那么道德水平和人生境界就越高。但是这种观点又容易走向消极的宿命论，也就是人在必然性面前只能逆来顺受，类似于古希腊斯多葛学派的塞涅卡的“顺应自然，服从命运”。</li><li>在政治上，斯宾诺莎也是自然法学派。他认为自然的自由受到情欲的影响，只有人们缔结社会契约，形成一个社会，人们才能遵循一种普遍的必然性，实现社会的自由。社会自由就是对整个自然(神)的本质的认识，人是神的一种样式，所以只有认识神的本质，才能认识到人的本质。政治的目的就是实现社会自由，在这个意义上，斯宾诺莎认为只有民主制才是最好的政体，因为专制政体会践踏人的自由。斯宾诺莎把民主和自由联系起来，是近代第一个把政治学建立在伦理学上的人。</li></ul><h2 id="4-5-哥特弗利德·威廉·莱布尼茨"><a href="#4-5-哥特弗利德·威廉·莱布尼茨" class="headerlink" title="4.5 哥特弗利德·威廉·莱布尼茨"></a>4.5 哥特弗利德·威廉·莱布尼茨</h2><ul><li>莱布尼茨是个百科全书式的人物，在哲学、数学、物理学、逻辑学等一系列领域中都卓有建树。在哲学领域的著作主要有，批判洛克《人类理智论》的《人类理智新论》，表述本体论观点的《单子论》(奠定了莱布尼茨的哲学根基)，带有媚俗色彩的《神正论》，等等。</li><li>斯宾诺莎为了追求自由而放弃了衣食无忧的生活，相反，莱布尼茨等德国的哲学家们普遍表现出一种对当局、权贵的迎合和媚俗的态度。罗素认为莱布尼茨的智力水平高于斯宾诺莎，当人品远远比不上斯宾诺莎。</li><li>当时的德国相对落后，所以莱布尼茨主要关注的不是德国的思想，而是英国、法国的思想，他写作几乎不用德语，而是用的法语和拉丁语。但莱布尼茨也深受德国文化环境的影响，所以他的思辨方式不同于英国、法国的哲学家，而是像后来的德国古典哲学思想一样深奥、晦涩。</li></ul><h3 id="单子论"><a href="#单子论" class="headerlink" title="单子论"></a>单子论</h3><ul><li>在本体论上，莱布尼茨否定了笛卡尔的二元论，在他看来笛卡尔的二元论是荒谬的，因为两个相对实体还要隶属于一个绝对实体，所以两个相对实体不能算是最终的本原。同时他也否定了斯宾诺莎的泛神论思想，因为唯一实体需要具体化到样式上，那么实体本身就太抽象了，而且莱布尼茨认为内化于自然的实体是静止不变的，静止不变的实体无法解释丰富多彩的样式。</li><li>莱布尼茨早年对古希腊的原子论感兴趣，但他认为原子还不是最终的、最小的单元，因为只要原子具有广延性，只要原子占据空间，理论上就能被继续分割，而且是可以无限分割下去的。</li><li>因此莱布尼茨提出，最终的实体(本原)一方面应该是真正单一的、不可分的，另一方面应该是能动的。此前的哲学家提出的实体都没有同时满足这两点，比如斯宾诺莎的实体没有能动性，原子论的原子有能动性但没有不可分性，所以莱布尼茨需要另辟蹊径。</li><li>因为原子论的影响，莱布尼茨早期把满足这两个条件的最终实体称为“形式的实体”或“形式的原子”，也就是具有原子内在的能动性而不具有外在的广延性，后来才称其为“单子”。可以看出，单子其实是一种纯粹的精神性的东西，因为任何物质性的东西都一定具有广延，物质性与广延性的捆绑从笛卡尔时代就已经确立了。</li><li>莱布尼茨的单子体现了德国哲学家玄奥的思辨方式，他认为作为本原的实体必定是一个点，而物理学上的点(物质世界)有实在性但没有精确性(即不可分性)，数学上的点(精神世界)有精确性但没有实在性，所以实际上他既不谈物质也不谈精神，而是上升到形而上学，认为实体是形而上学的点，兼具实在性和精确性。只不过当时普遍认为除了物质就是精神，没有第三种分类，所以才把莱布尼茨的单子划分为精神性的东西，但其实单子也是具有物质的实在性的。</li><li>单子有如下本性：<ul><li>单子不具有广延性，这是基于当时“凡物质必有广延，凡广延必可分”的普遍共识。</li><li>单子具有能动性，单子的本性是一种“原始的力”，是一种固有的、内在的欲望(拟人化的表达)。可以看出德国哲学家的思想与当时主流的英国思想有差异，多了一些神秘主义色彩，少了一些机械主义色彩，比如牛顿只承认外力作用下的机械运动而否认事物有内在的驱动力。这种神秘主义在某种意义上克服了机械主义的缺陷，往哲学和科学中引入了辩证法的思想，可以说这种神秘主义就是近代辩证法的开端。</li><li>单子是自由的、自因的实体，因为他自己就是最基本的单元，同时又具有内在驱动力。笛卡尔的绝对实体和斯宾诺莎的实体其实也暗含了自由、自因的特点。</li></ul></li><li>由单子的本性自然引出的一个问题是，无广延的本原如何能构成有广延的万事万物。莱布尼茨实际上是把本体论的问题还原为认识论的问题，也就是把“世界是什么样的”还原为“人是如何看世界的”。他认为任何事物都是单子的堆积，但这不是物理学意义上的简单的堆积，单子堆积的结果在人的知觉系统下就呈现为我们所理解的万事万物的样子，也就是说事物的本质是单子的堆积，而我们所感知到的事物的样子只是知觉系统把握到的事物的表象。在这个意义上，认识能力决定了对世界的把握，也许认识能力比人低的东西看到的世界就是一团糟，也许认识能力比人高的东西可以看到神。</li><li>单子有如下特点(比本性稍弱)：<ul><li>单子已经是最基本的单元，所以它没有“部分”的概念，意味着单子不能以自然的方式合成或解散。所以单子只能是上帝创造的，上帝是创造一切单子的单子，他凭借“神性的一刹那的连续闪耀”创造出其他单子，单子的产生和消失都是以由于上帝的“奇迹”，这就等于把解决不了的问题推给了神秘主义，是一种非自然的方式。</li><li>“单子没有可供事物出入的窗子”，即单子是自封闭的，单子之间不能发生相互作用。这与牛顿的机械主义观点截然相反，牛顿认为运动的产生是由于事物之间的相互作用，而莱布尼茨则认为事物之间没有相互作用，运动是由于单子内部的驱动力。</li><li>单子是精神性的实体，所以单子之间不存在量的差别(大小轻重等)，只有质的差别，质的差别就是单子“知觉”能力的差别。所谓知觉是指单子反映宇宙全体的一种能力，这就又体现了莱布尼兹用认识论来表述本体论问题，也就是一个东西感知到的世界是什么样的取决于构成他的单子的知觉能力，而世界本身到底是什么样的就相对不重要的(因为我们永远无法解释，索性就不解释了)。莱布尼兹建立了知觉的等级划分，比如构成无机物和植物的单子具有“微知觉”，动物的单子具有“知觉”，人的单子具有“统觉”，上帝的单子具有最高级的知觉。虽然等级是离散的，但是把所有单子按照知觉能力排序，就是一个从无知觉到上帝知觉的无限的、平滑的、趋近于连续的过渡过程。</li></ul></li><li>莱布尼兹认为哲学有两大迷宫，一个是不可分的点和连续性问题，另一个是自由和必然的问题。针对第一个问题，他提出了宇宙中的两个基本规律，一个是“差异律”，即“世界上找不出两片完全相同的树叶”，另一个是“连续律”，即“自然决不做飞跃”。反观原子论和笛卡尔的充实空间，都没有同时满足差异律和连续律。原子论的原子虽然是不可分的，但是原子论已经暗含了原子具有广延的观点，同时原子是机械地、简单地堆积在一起的，因此两个原子之间必定存在缝隙，不然就是一个原子了，所以原子论里压根没考虑连续性。笛卡尔的充实空间则认为空间的任何位置都没有缝隙，所以整个空间就是连续的一大块，显然不存在不可分的点了。</li><li>莱布尼茨对单子的定义都是为了解决不可分的点和连续性问题而做的铺垫。因为单子是不可分的最小单元，且任意两个单子之间存在着知觉能力上的细微差别，所以就满足了差异律。因为单子没有广延，所以任意两个单子之间都能再插入无限个单子，当把这个无限单子序列按照知觉能力排列时，就是无限趋近于连续的。这种离散性与连续性的辩证统一其实算是数学上的微积分问题，所以这里的连续就是微积分里趋近于的那个连续，无限的离散就形成了平滑的、连续的过渡，正如差异律体现在1和2是两个不同的数，连续律则体现在1和2之间有无限个数。莱布尼兹的天才就在于把数学和哲学结合起来。</li></ul><h3 id="前定和谐"><a href="#前定和谐" class="headerlink" title="前定和谐"></a>前定和谐</h3><ul><li>身心相互独立且协调一致的问题是唯理论者共同面临的难题。从实体的角度看，笛卡尔是二元论者，他解释的是物质和精神两个实体间的独立且协调，斯宾诺莎是一元论者，他解释的是同一个实体的两种属性之间的独立且协调，而莱布尼茨的单子就是实体，他是多元论者，所以他需要解释的是无数个实体之间的独立且协调，相比笛卡尔和斯宾诺莎难度更大。</li><li>因为身心独立且协调的问题是从笛卡尔开始遗留下来的问题，所以莱布尼茨最开始也是考虑的身心的协调一致，而不是直接考虑单子的协调一致。他总结了身心关系的三种观点：第一种是身心之间在经验层面上的相互影响，即笛卡尔的身心交感说。第二种是上帝不断调整身心的协调一致，即马勒伯朗士的偶因论，说到底还是经验上的调整。第三种就是莱布尼兹新提出的“前定和谐”。莱布尼茨认为身心交感说是流俗的观点，经不起推敲，正如前人提出的松果腺的矛盾性。而偶因论是把一切琐碎的事情都推给上帝，把上帝当成了“救急神”，是一种拙劣的方法和对上帝的贬低。</li><li>莱布尼茨的“前定和谐”基本上是继承了斯宾诺莎的“身心平行论”，也就是先验的协调一致。他认为上帝最初创造每个单子的时候，就已经把使他们相互协调一致的程序放进了单子里。他认为上帝不需要总是创造奇迹(偶因论)，而是只需要在最初创造一次奇迹就可以了。因为解释成了前定，所以两个单子的协调一致和全体单子的协调一致就没有区别了，反正都是因为上帝牛逼。莱布尼茨本人对斯宾诺莎的哲学是失望的，他在表述“前定和谐”的时候没有提到斯宾诺莎，可能是因为人品差故意隐瞒，装作完全是自己发明的观点，也可能是不自觉地受到了自己看不上的人的影响，相当有讽刺意味。</li><li>莱布尼茨以上帝的奇迹作为最终解释，建立起单子论和前定和谐的理论，然而正是在上帝这里产生了一系列的问题和矛盾，他把解决不了的问题都推给上帝，正如黑格尔所说：“上帝仿佛是一条大阴沟，所有的矛盾都汇集其中”，主要矛盾如下：<ul><li>上帝是创造单子的单子，归根结底它也是单子，而单子的特点是自封闭的，不能与其他单子相互作用，那么就不可能由一个单子产生新的单子，除非上帝是超越单子的存在。</li><li>“自然决不做飞跃”，但单子的产生和消失却是上帝突然的奇迹，在单子的有无转换之中没有体现连续性。</li><li>单子是自因的，但是单子的产生和消失却由上帝决定，那么单子就不是完全自因的。</li><li>单子是自因的、自由的、能动的，但前定和谐理论中是上帝早就决定了单子协调一致，那么单子就不是自由能动的，而是遵从上帝的设定，成了一种宿命论。</li><li>前定和谐论认为上帝决定了世界的秩序和规律，但莱布尼兹在《神正论》里又用世界的秩序和规律来证明上帝的存在，这就陷入了毫无意义的循环论证。可见这样一个大逻辑学家也难免陷入逻辑的错误。</li></ul></li></ul><h3 id="“有纹路的大理石”"><a href="#“有纹路的大理石”" class="headerlink" title="“有纹路的大理石”"></a>“有纹路的大理石”</h3><ul><li>莱布尼茨在认识论上继承发展了唯理论一派的天赋观念说，同时在批判经验论的过程中不可避免地吸收了经验论的一些有价值的思想。</li><li>莱布尼茨认为笛卡尔的天赋观念说并不能应对来自经验论者的反驳，比如洛克指出儿童没有关于几何公理、思辨原则的观念，不信教的人没有上帝的观念。所以莱布尼茨结合笛卡尔的天赋观念说和洛克的白板说，提出了“有纹路的大理石”的学说。人心既不是空无一物的白板，也不是天生被赋予了全部的清楚的观念，人心被天赋的是获得真理和观念的倾向、禀赋、习性或潜能。天赋的潜能加上外部感性加工的“机缘”，二者结合才能形成我们的知识，就像大理石能被雕刻成什么样是由他固有的纹路和工匠的加工共同决定的。这里的“机缘”就是莱布尼茨受经验论影响的结果，他还是承认了感觉经验的作用，只不过站在唯理论的立场上认为对于观念来说，天赋潜能比感觉经验更有决定性。相比于斯宾诺莎纯粹的唯理论，莱布尼茨是对经验论做了一些让步的。</li><li>在《人类理智新论》中，莱布尼茨还歪曲了洛克的观点。洛克认为观念有感觉和反省两个来源，反省是通过反思内心活动产生的经验。而莱布尼茨认为反省的对象是天赋观念(即天赋潜能)，天赋观念最初以微知觉的形式存在于人心中，通过对心中微知觉活动的反省可以升级到知觉、统觉。这就把认识论和单子论联系了起来。</li><li>莱布尼茨指出他和洛克在认识论上的分歧就是柏拉图和亚里士多德的分歧。莱布尼茨的“有纹路的大理石”和柏拉图的回忆说如出一辙，而洛克和亚里士多德都认为认识只能从感觉经验开始。</li><li>康德虽然批判莱布尼茨-沃尔夫体系的独断论，但康德的认识论观点深受莱布尼茨的影响，认为知识是先天的东西和经验的东西相结合的结果。</li><li>莱布尼茨与笛卡尔关于天赋观念的另一点不同是，笛卡尔把观念分成三种，他认为只有最可靠的几何公理、逻辑规律等是天赋观念，其余两种来自于外在经验和内在经验，因而是不可靠的。但莱布尼茨认为所有的观念都是天赋的，也就是都以潜能的形式先天存在于人的心中，这是因为“单子没有可供事物出入的窗子”(自封闭性)，我们不可能从感觉经验中获得新观念，感觉经验只能作为一种刺激让微知觉升级到统觉，而不能作为新知识的来源。</li></ul><h3 id="推理真理与事实真理"><a href="#推理真理与事实真理" class="headerlink" title="推理真理与事实真理"></a>推理真理与事实真理</h3><ul><li>笛卡尔的三种观念里，有两种分别来自外在经验和内在经验，斯宾诺莎的三种观念(知识)里，“想象或意见”是来自于感觉经验。所以受前人的影响，莱布尼茨也承认了能从感觉经验中获得知识。但受限于单子的自封闭性，莱布尼茨必须指出从感觉经验获得的知识其实早就以天赋潜能的形式存在于心中，只不过知觉能力有限。从知觉能力限制的角度看，从感觉经验获得知识是必要的，因为人的知觉能力有限，并不能仅依靠理性的逻辑推理得到所有的知识。但同时，感觉经验获得的知识也是不可靠的，这也是源于单子知觉能力的差异，正如人看到的世界只是构成人的单子所能认知到的表象，而上帝看到的世界就是本质上的一个个的单子，所以从世界的表象里获得的知识固然能应用于现实生活、推动科学发展，但归根结底不是真知灼见。</li><li>莱布尼茨把理性推理出的知识称为“推理真理”，把从感性经验得来的知识称为“事实真理”。人类因为知觉能力的有限，才不得不需要事实真理，所以人们需要提高自己的知觉能力，让自己的知觉能力不断接近上帝，就如《人类理智新论》里所说：“只要有上帝那样能看透一切的眼光，就能在最微末的实体中看出宇宙间事物的整个序列”。提高知觉能力就是所谓的“启蒙”，所以莱布尼茨的认识论可以说是德国启蒙运动的源头。</li><li>莱布尼茨提出了获得知识的两大逻辑原则。一个是矛盾原则，适用于纯粹数学和逻辑学，从不证自明的公理出发，遇到矛盾时可以判断何者为真何者为假，最终得到的就是“推理真理”。另一个是充足理由原则，从经验事实出发，对大量例证进行归纳，最终得到的是“事实真理”。推理真理具有普遍必然性，事实真理是片面地、偶然的，因为事实真理基于因果律，后来休谟指出因果律存在例外，因此不具有普遍必然性。充足理由原则是知觉能力有限的人需要的，对于上帝而言，只需要矛盾原则，上帝就能推出所有的知识。</li><li>从真理的可靠性上看，莱布尼茨又把客观的问题还原到了主观的认识论上，每个人的知觉能力都有差异，真理是否具有普遍必然性就因人而异了。同一个真理，知觉能力强的人直接用理性推出来，此时该真理就表现为普遍必然的，知觉能力弱的人只能从感觉经验中归纳出来，此时该真理就表现为片面偶然的。</li></ul><h3 id="“最好世界”理论"><a href="#“最好世界”理论" class="headerlink" title="“最好世界”理论"></a>“最好世界”理论</h3><ul><li>莱布尼茨继承了德国哲学家传统的对宗教的虔诚态度，相比于英国、法国的哲学家有更浓厚的宗教色彩。上帝在笛卡尔的理论中只是个起到跳板作用的工具，洛克虽然是基督徒，但他依然是站在哲学家的立场上分析关于上帝的问题，而莱布尼茨在上帝的问题上更像个神学家，他把上帝看得很重要，可以说上帝甚至就是莱布尼茨整个哲学的目的。</li><li>“最好世界”理论又叫做“神正论”或“神义论”，它解决的是一个古老的问题，即上帝的正义与世间的罪恶的问题。莱布尼茨提出哲学有两大迷宫，一个是不可分的点和连续性问题，另一个是自由和必然的问题。其中自由和必然的问题就是上帝的正义与世间的罪恶的问题，必然性体现在上帝创造世界并协调世界，但上帝不能对世间的一切负责，因为至善的上帝不会主动创造世间的罪恶，所以人们把世间的罪恶归因于人的自由意志，因此自由和必然的问题其实就是上帝的意志和人的自由意志的问题。</li><li>古往今来很多哲学家和神学家都思考过这个问题。希腊化时期的伊壁鸠鲁最先提出了这个问题，如果上帝愿意消除世间的罪恶而没有能力消除，那么上帝就不是全能的，如果上帝有能力消除罪恶而不愿消除，那么上帝就不是全善的，如果上帝既没有能力消除罪恶又不愿消除，那么上帝就不是全能全善的，所以上帝只能是既有能力消除罪恶又愿意消除，但如此就无法解释我们这个有罪恶的世界从何而来，所以伊壁鸠鲁的思考没有得出结论。再比如中世纪的奥古斯丁，他提出原罪和救赎的理论，认为自由意志是上帝对人的格外恩宠，滥用自由意志的恶果是人类自作自受，人类本不该被拯救，是上帝的全善让他决定拯救一部分人，这和全善并不冲突，如果拯救所有人就成了对作恶的纵容，反倒不是全善了。</li><li>奥古斯丁认为恶没有本质，恶就是对善(上帝)的缺乏和背离，这个定义被后世历代的哲学家所接受。莱布尼茨基于这个定义把恶分成三类：<ul><li>形而上学的恶：任何事物相对于上帝都是不完善、有缺失的，这是一种与生俱来的、必然的恶。</li><li>道德的恶：滥用自由意志所造成的恶，是否滥用自由意志是因人而异的，所以这是一种或然的恶，亚当夏娃的原罪就属于这种恶，所以又叫罪恶。</li><li>形体上的恶：人们被动遭受的恶，比如死亡、天灾、病痛，这是上帝为了保持公正而对人们道德的恶的惩罚，也就是所谓的报应。同时也是上帝为了防止人们继续堕落犯更大的错而做出的警示。</li></ul></li><li>莱布尼茨承认恶的存在，但同时认为有恶的世界比没有恶的世界更完美。首先，形而上学的恶是不可避免的，善恶共存的世界才是一种真正的和谐，纯善或纯恶的世界都是不和谐的，这是一种充满辩证法意味的高明的观点。其次，恶的存在使自由选择成为可能。古希腊人没有考虑过关于自由的问题，中世纪的基督教最先提到自由，但自由是与原罪相关联的一个贬义的概念，直到近现代(尤其是启蒙运动后)才将自由看做是褒义的，人若没有自由和自我就与动物没有区别了。自由最初的表现必定是对上帝的背离，因为一味地顺从上帝的安排是无所谓自由的，只不过从上帝的角度看这种自由就是恶，但正因为人有了自由，所以也能够自由选择弃恶从善，恶所引出的自由和自我意识就是人之为人、超越动物的开端。上帝之所以甘愿以恶为代价赋予人自由意志，是因为上帝觉得自由比恶更有价值。上帝考虑的是整个宇宙的和谐，不会像人类一样只从道德的角度考虑善恶的问题，恶对于整个宇宙的和谐也是不可或缺的一部分，我们在道德上觉得恶应该被消除，但上帝不这么认为。因此，既然上帝是全知全能全善的，那么我们的世界一定是所有可能的世界中最好的世界。</li><li>莱布尼茨的这种观点和所有德国哲学家的观点一样，都有一种媚俗的色彩，总是为我们这个现实世界涂脂抹粉、歌功颂德，不像英法哲学家一样富有批判性。他们对理论的批判比英法哲学家更强烈，但他们对于现实却是唯唯诺诺，所以马克思评价德国的哲学家们是“思想上的巨人，行动上的侏儒”。也许就是因为有这种倾向，才导致了莱布尼茨在上帝存在与最好世界之间的循环论证，成为了一个笑柄。</li><li>伏尔泰专门写了一部喜剧《老实人》来讽刺莱布尼茨对世界的乐观主义。主人公最初信奉乐观主义，经历过天灾人祸和社会弊病后，最终放弃了盲目乐观，向现实低头。</li></ul><h3 id="莱布尼茨-沃尔夫体系"><a href="#莱布尼茨-沃尔夫体系" class="headerlink" title="莱布尼茨-沃尔夫体系"></a>莱布尼茨-沃尔夫体系</h3><ul><li>莱布尼茨的思想被他的追随者沃尔夫推向了极端，沃尔夫把莱布尼茨的唯理论进一步系统化和刻板化，最终发展成一种形而上学的独断论，走向了一种神学目的论。但同时沃尔夫对于德国启蒙运动和理性精神的崛起也有重要的推动作用，他过分弘扬理性的思想反倒帮助德国思想界突破了传统的虔敬主义。此外他最先用德语表述哲学思想，使哲学获得了德语的形式，黑格尔对此很赞赏，因为目前看来德语是最易于表达哲学思想的语言。莱布尼茨-沃尔夫体系统治了德国主流思想达半个世纪之久，直到康德时期才被打破。</li><li>沃尔夫夸大了理性认识的能力，他认为人的知觉能力可以提升到上帝的境界，莱布尼茨认为理论上所有知识都能通过理性推理得到，但以人的知觉水平无法实现，沃尔夫则认为这是可以实现的，于是就成了一种独断论，也就是彻底否定感觉经验的作用，认为人仅仅依靠理性就能得到所有真理。这一点被康德在《纯粹理性批判》中猛烈批判，康德认为理性建立起的知识体系没有新知识，因为结果不能大于原因，纯粹的形式逻辑只是证明的方法，不是发明的方法。沃尔夫哲学包括理论哲学和实践哲学，理论哲学包括形而上学、理性心理学、宇宙学和理性神学，这四部分都受到了康德的批判。</li><li>在形式上，沃尔夫的哲学严格遵循几何学形式，从先验的抽象范畴中直接演绎出整个知识体系，等于把哲学的形式刻板化了。</li><li>沃尔夫把最好世界理论也推向极端，莱布尼茨只是认为世界的和谐是上帝安排的结果，并没有很明显地表达出目的论的色彩，沃尔夫进一步认为世界上所有东西都是合理的，所有东西无不体现着上帝的特殊目的，也就是一种神学目的论，神学目的论包含了太多庸俗化和主观化的东西。</li></ul><h1 id="5-晚期经验论哲学"><a href="#5-晚期经验论哲学" class="headerlink" title="5 晚期经验论哲学"></a>5 晚期经验论哲学</h1><h2 id="5-1-乔治·贝克莱"><a href="#5-1-乔治·贝克莱" class="headerlink" title="5.1 乔治·贝克莱"></a>5.1 乔治·贝克莱</h2><ul><li>洛克虽然把经验论的基本原则和基本问题系统化了，但依然暴露出经验论基本原则与唯物主义立场之间的矛盾。他基于“样式和观念必须寄托于实体”这一思维定式，认为实体是必须假定客观存在的，但我们却从来没有过关于实体的感觉经验。换言之，一方面认为客观世界永远存在，另一方面又认为所有观念都来自于感觉经验，那么在我们有感觉经验之前客观世界是否存在就成了矛盾。实际上，洛克把实体分成了物质实体和精神实体，既有唯物主义色彩也有唯心主义色彩，只不过他把第一性质归为客观实在，把第二性质归为主观感觉，所以更偏向于唯物主义。</li><li>解决这个矛盾有两种方向。一种是唯物主义式的解决，承认有些东西(比如客观世界)是经验的前提，而不是经验作为他们的前提，这是以牺牲经验论原则为代价。另一种是经验论式的解决，把经验论原则贯彻到底，否定经验之外的一切，这是以牺牲唯物主义立场为代价。</li><li>贝克莱选择了经验论式的解决，但他最终也没有把经验论原则贯彻到底，他固然用经验论原则否定了洛克的物质实体，由于种种原因，他依然保留了洛克的精神实体，同时由于宗教信仰，他也保留了上帝这个最大的实体。所以贝克莱算是主观唯心主义者。</li><li>贝克莱的三个主要思想对应他的三部著作，《视觉新论》主要表述“视觉与触觉”，《人类知识原理》主要表述“存在就是被感知”，《哲学对话三篇》主要表述“观念客观化”。</li></ul><h3 id="视觉与触觉"><a href="#视觉与触觉" class="headerlink" title="视觉与触觉"></a>视觉与触觉</h3><ul><li>贝克莱的哲学是从对洛克的继承和发展开始的，他在《视觉新论》里的观点主要针对的就是洛克的第一性质和第二性质。洛克把物体中能产生观念的能力称为“性质”，第一性质是在任何情况下不能与物体相分离的性质，如体积、广袤、形相、运动、数目等，反映了物体的客观状态，第二性质是物体借第一性质在我们心中产生观念的能力，如颜色、声音、滋味等，第二性质并不完全是主观的，而是主客观的一种关系。</li><li>贝克莱把洛克的两种具有客观意义的性质转变成了两种主观意义上的感觉。触觉的对象是广延、形相等，视觉的对象是光和色。触觉对象的广延是客观实在的，所以触觉感知到的广延基本就等于事物的客观广延，视觉的对象只有光和色，但在看东西的时候会根据以往的触觉经验形成一种联想结果，在这个意义上，触觉决定了视觉。所以触觉摸到的是客观的，眼睛看到的除了光和色都是主观联想，视觉广延和触觉广延有差异。</li><li>《视觉新论》的主要观点有三个：<ul><li>第一，把物体的性质转变为感觉的观念，用触觉对象和视觉对象来取代洛克的第一性质和第二性质，由此埋下了把事物的可感性质等同于感觉或观念，从而把实物观念化的伏笔。</li><li>第二，把实在的广延等同于触觉的广延，又把触觉广延说成是视觉广延中回忆的基础，这样就为日后用视觉广延取代触觉广延，进而把广延、形相等第一性质和色声香味等第二性质都说成是纯粹的主观观念奠定了基础。</li><li>第三，对数目的唯名论解释。洛克认为事物的数目是第一性质，贝克莱则认为数目只是人们命名的结果，是人心任意给予一个观念或一群观念的一个名称。这为日后进一步提出“事物是观念的集合”奠定了基础，比如苹果的红、香、硬、甜不过是人们给观念的命名，把这四种观念的集合再起一个名字，就成了苹果。</li></ul></li></ul><h3 id="存在就是被感知"><a href="#存在就是被感知" class="headerlink" title="存在就是被感知"></a>存在就是被感知</h3><ul><li>在《人类知识原理》中，贝克莱主要有两大观点，即“事物是观念的集合”以及“存在就是被感知”。他认为感觉经验的对象是事物的可感性质，而观念就是被感知的可感性质，但贝克莱理论的重点在于混淆了可感性质与感觉的关系，他认为并不是因为事物有可感性质才使得我们产生感觉，而是因为我们有了感觉才能证明事物有可感性质，而这就把客观的可感性质主观化了，从而把实物也主观化了。</li><li>贝克莱的思维方式和唯物主义者完全相反，因为经验论基本原则和唯物主义立场就是截然相反的。唯物主义者先假定客观事物的存在，再从事物的可感性质推出感觉，经验论者从感觉经验出发，所以是由感觉推出可感性质，又因为感觉经验只能推出可感性质，不能进一步推出客观事物的存在，所以贝克莱只能把事物等同于它的可感性质的集合，或者说他不谈事物只谈可感性质。最后，因为观念就是被感知的可感性质，观念等同于可感性质，所以自然就有了“事物是观念的集合”这个结论。</li><li>“事物是观念的集合”也体现了一个观点，即观念决定事物，而不是事物决定观念，由此自然就能得到“存在就是被感知”的结论。同时贝克莱又认为观念必须存在于某个地方，于是他提出了“心”的概念，认为观念必须存在于心中、在心中发生，所以归根结底，事物存不存在取决于对应的观念是否在心中发生，这就是所谓的“存在就是被感知”。</li><li>洛克提出物质实体是出于承载广延、形相等第一性质的需要，但贝克莱认为，首先，第一性质和第二性质是不可分离的，因为我们无法想象一个只有广延没有颜色的东西。其次，第一性质也是因人而异的，感官功能的差异让不同的人感知到的形相和广延也各不相同，所以第一性质和第二性质都是主观的。最后，洛克承认物质实体是不可知的，而不可感知的东西无法承载可感的性质(没什么道理)。因此贝克莱指出，洛克假设物质实体必须存在的理由已经不成立了，洛克也承认物质实体是不可知的，那么物质实体存在与否就对我们的认知没有任何影响，于是贝克莱索性就否定了物质实体的存在。</li><li>出于虔诚的宗教信仰，贝克莱也有必须否定物质实体的理由。唯物主义和无神论是天然的盟友，物质实体是他们的基石，只要把物质实体否定掉，无神论也就完蛋了。</li><li>但是贝克莱又说，他否定的不是“物”，而是物质实体。换言之，他否定的是不以人的意志为转移的那个作为原因的“物”，他仍然承认作为观念的结果的那个“物”。</li><li>可以看出贝克莱的经验论并不彻底，他虽然否定了物质实体的存在，但仍然承认“心”(精神实体)，认为“心”的存在不需要以感觉经验为前提。后来休谟进一步指出，“心”也是一种假设，因为我们只能感觉到心理活动，但不能感觉到承载心理活动的那个主体。也就是说，贝克莱突破了“可感性质必须依附于物质实体”的思维定式，休谟突破了“观念必须依附于精神实体”的思维定式。</li></ul><h3 id="观念客观化"><a href="#观念客观化" class="headerlink" title="观念客观化"></a>观念客观化</h3><ul><li>贝克莱把事物观念化的结果是使自己陷入了唯我论，虽然理论上近乎于天衣无缝，但明显违背了常识，容易受到世俗的指责。因为贝克莱的理论完全以自我为中心，“你不被我所感知，你就是不存在的”，显然背离了常识，所谓常识其实就是一种朴素唯物主义，但凡有点生活经历的人都会觉得世界上有不以人的意志为转移的东西存在。</li><li>人们之所以会指责和误解贝克莱，是因为他没有解释清楚他理论中的自我(心)到底是什么，是贝克莱的自我？所有人的自我？或是上帝的自我？世人容易把自我理解成贝克莱的自我，所以会认为他是个自大的疯子。所以贝克莱后来写了《哲学对话三篇》为自己辩解。</li><li>贝克莱在《人类知识原理》中把实物观念化，而在《哲学对话三篇》中是把观念客观化。他声称自己的本意不是把实物观念化，而是要说明任何观念都是与某个实物对应的，被误解是因为世人都把客观的事物和主观的观念看成两个东西，但贝克莱认为这两个东西其实是一回事。这就有点像唯理论的身心平行论，也就是物质世界和精神世界、客观和主观具有某种同构性，至于这种同构性如何保证，贝克莱和唯理论者不谋而合，都推给了上帝。</li><li>《哲学对话三篇》的核心思想就是，上帝这个宇宙“大心灵”的知觉和意志是一切可感事物存在的原因，这些可感事物则构成了我们观念的原因。有了上帝这个最大的、最终的感知者，贝克莱就不需要具体指明“存在就是被感知”到底是谁在感知，对于一个东西只要有任意一个心灵能感知到，就证明了它存在，反过来说，如果所有的心灵都不能感知到它，乃至上帝这个大心灵也感知不到，那么就说明它不存在。总而言之，狭隘的唯我论是“我→观念→物”，加入上帝就成了“我→观念→物←上帝”，上帝在注视着整个宇宙，一下子豁然开朗。</li><li>但是搬出了上帝以后，好像又回到了最初的起点，人们心灵的感知变得无关紧要了，因为即使所有人放弃了感知，还有上帝的感知决定着万事万物的存在。更致命的是，把上帝当做世界的根本原因恰恰背离了经验论的基本原则，贝克莱绕了个大圈子搬出来上帝这个非经验的东西，再用上帝说明万事万物的存在，反倒不如唯物主义者直接假定万事万物客观存在来得直截了当。</li><li>贝克莱对此的狡辩很无力，他认为人们虽然不能有关于上帝的观念，但是可以有关于上帝的意念，意念就是在自我直觉的基础上进行推理，把自我的优点夸大缺点缩小最后推理出上帝，然而作为理论基石的上帝依然是推理的结果，贝克莱还是没有回到经验论上。尽管他通过否定物质实体消除了唯物主义和经验论的矛盾，但保留精神实体却让他陷入了形而上学(非经验的上帝和心)和经验论的矛盾。</li><li>此外，贝克莱虽然没有表述过知识的分类，但我们能够看出，自我源自直觉，上帝源自意念，事物的观念源自感觉，这其实就是洛克、笛卡尔、斯宾诺莎等人都讨论过的三类知识来源，即直觉、感觉和推理。</li></ul><h2 id="5-2-大卫·休谟"><a href="#5-2-大卫·休谟" class="headerlink" title="5.2 大卫·休谟"></a>5.2 大卫·休谟</h2><ul><li>休谟在26岁写出《人性论》，包含三卷，分别从知(知识)、情(情感)、意(意志或道德)三方面讨论人性，但反响平平。几年后他把第一卷改写成《人类理解研究》，一举成名，后来又把第三卷改写成了《道德原则研究》。其余著作包括《英国史》、《宗教的自然史》、《自然宗教对话录》等。</li><li>休谟的思想有很强的解构性和颠覆性，他把英国的经验论发展成怀疑论和不可知论，而怀疑论和不可知论是古往今来一切形而上学和宗教神学的敌人，因为它们颠覆了一切非经验的、独断的东西，比如心灵、上帝。</li><li>休谟虽然在哲学思想上极具攻击性，但生活中却是个循规蹈矩的人，这也符合了西方思想家学以致知而非学以致用的态度，说难听点就是马克思所谓的“行动上的侏儒”。</li></ul><h3 id="印象与观念"><a href="#印象与观念" class="headerlink" title="印象与观念"></a>印象与观念</h3><ul><li>休谟把经验论的基本原则一以贯之地推到极端，严格遵循经验是一切观念的来源，认为我们的观念超不出我们的经验。休谟把我们通过感觉经验获得的东西叫做知觉，知觉由两部分构成，一个是印象，另一个是观念，印象是比较鲜活和强烈的，而观念是对印象进行加工的结果。休谟的印象和观念分别具有感性认识和理性认识的含义，但休谟把二者的差别仅仅限定在强烈程度上，可见他是把理性认识感性化了。休谟对感性认识和理性认识的态度也与传统观点相反，他认为印象是精确的、可靠的，而观念只是印象的摹本(把理性的加工简单化)，所以观念是不可靠的。这种对理性的简单化理解和轻视态度，是导致他走向不可知论和怀疑论的重要原因。</li></ul><h3 id="对实体的怀疑"><a href="#对实体的怀疑" class="headerlink" title="对实体的怀疑"></a>对实体的怀疑</h3><ul><li>休谟坚持了经验论基本原则，自然也就继承了贝克莱的基本观点，认为“事物是观念的集合”。但休谟有两点不同于贝克莱，第一点是对物质实体的态度。我们对物质实体没有经验，固然不能承认它的存在，但也不能像贝克莱一样断言它的不存在。对于不能感知的东西，我们无法确定存在性。贝克莱认为“存在就是被感知”，于是他又顺理成章地认为“不被感知就是不存在”，但休谟则认为“不被感知就是一无所知”，一无所知就是连存在与否都不能确定。休谟把话说得更聪明和圆满了，为知识的进一步拓展留下了后路，因为对于没有感知到的东西，贝克莱持一种冷漠、否定、不屑一顾的态度，而休谟承认自己的无知，保留了未来能够感知得到的可能性。</li><li>休谟与贝克莱的第二点区别是，贝克莱保留了精神实体，休谟则认为所谓“精神”、“心灵”、“自我”这类东西也是不能被直接经验到的。我们经验到的是一个个具体的感觉、情绪或心理状态，从来没有对精神实体的经验，正如“事物是观念的集合”，精神也应该是心理活动的集合，“心理活动需要承担者”就像“可感性质需要承担者”一样，只是人们的思维定式，没有根据也经不起推敲。</li><li>后来的康德进一步指出，“我”充其量不过是个逻辑主体，而不是一个实在主体，逻辑主体就是并不实在的、必须假定的一个逻辑根据，承载、依托着那些可感对象，当一个人说“我高兴”的时候，他想表达的只是高兴，“我”作为一个承担情绪的主体只是起到一个指向的作用，用来说明这个情绪属于哪一堆心理活动的集合，而人们出于简化的习惯把这一堆东西的集合假想成了单个的实体。虽然到了康德才明确区分逻辑主体和实在主体，但在休谟的怀疑论已经有了这种倾向。</li><li>休谟对上帝也是持不置可否的怀疑态度。之前的哲学家都把上帝当做不可追问的最终原因，束之于不可知的高阁。休谟则认为，我们对真正的上帝正如对实体一样一无所知，因此不能断言上帝存在还是不存在，也不能断言上帝可知还是不可知，只能说截至目前还没有感知到。他又精辟地指出，我们所谓的“上帝”的观念不过是根据有限的观念推演出来的结果，并不是我们以为的真正的上帝。</li><li>休谟把物质实体、精神实体和上帝全都推进了怀疑论的深渊，剩下的就只有那些通过感觉经验而获得的印象和观念。诚如康德后来所嘲讽的，“只剩下一大堆杂乱无章的印象和观念”。这里实际上已经蕴涵着知识论的危机了。</li></ul><h3 id="因果问题"><a href="#因果问题" class="headerlink" title="因果问题"></a>因果问题</h3><ul><li>休谟的另一个理论建树是对因果关系的必然性和客观性的颠覆。休谟认为一切观念来自于经验，知识无非就是对观念及其关系的组合。他把一切观念的关系概括为三种，第一种叫相似关系，即两个观念具有某种外在的相似性，比如人和人之间都是相似的。第二种叫时空接近关系，即两个观念在时间或空间上彼此接近，比如今天早上刷牙明天早上也刷牙。第三种叫因果关系，即一个观念构成了另一个观念的原因或结果。休谟认为，相似关系和时空接近关系都是建立在主观联想的基础上，比如看见一个人就联想到他的家人，今天刷了牙就会想到明天也要刷牙，这两种关系都是主观的联系。但是因果关系却一直被人们当做客观的联系，而且具有某种必然性，因此休谟要质疑和颠覆因果关系。</li><li>休谟的观点是，因果关系既不是客观的，也不具有必然性，它只是一种主观的习惯联想。按照经验论的基本原则，一切知识来自于感觉经验，但我们从来没有对两件事的因果关系产生过直接的感觉经验，我们只能经验到两个事件以及它们发生的先后次序，由于两个事件往往以同样的先后次序发生，使我们产生了一种主观的习惯联想，进而使我们将这种主观联想误以为是某种客观的和必然的联系。在休谟看来，因果关系是主观上的习惯联想，所以不具有客观性，又因为主观联想是对习以为常的事情进行经验归纳，所以也不具有必然性，充其量只是概率很高的或然性。</li><li>休谟否定的不是因果关系本身，而是因果关系的客观性和必然性，他实际上是把因果关系从一种客观世界的规则变成了一种主观思维的规则，因此，这丝毫不影响因果关系在自然科学研究中的重要作用。我认为把因果关系当做主观的大概率事件而非客观必然事件，反而能提高自然科学研究的严谨性，因为这会警醒研究者去考虑概率之外、常识之外的可能情况。</li><li>把因果关系看作客观世界的必然规则，具有唯物主义色彩，让人们致力于发现自然世界的规则。把因果关系看作主观的思维规则，具有唯心主义色彩，是向自然世界颁布法则，现代西方哲学深受这种观点的影响，他们像休谟一样认为因果关系只是我们主观的一种思维模式，而大家普遍同意的东西就是主观意义上的客观性。到了康德就更进一步，认为主观普遍性就是客观性，没有完全脱离人的绝对的客观性，即使有绝对的客观性，它在认识论上也是毫无意义的，并不能成为我们的认识对象。</li><li>休谟对因果关系的颠覆也是对传统符合论的颠覆，符合论认为一切思想都是对客观世界的反映，主观必须符合客观，但休谟则把客观世界的规则说成是主观建构的结果。</li></ul><h3 id="对理性神学的批判"><a href="#对理性神学的批判" class="headerlink" title="对理性神学的批判"></a>对理性神学的批判</h3><ul><li>休谟在《自然宗教对话录》里批判了传统理性神学关于上帝存在的证明，他首先提出了基于经验论思想的三段论：“我们的观念超不出我们的经验，我们没有关于神圣的属性与作为的经验，我用不着为我这个三段论式下结论，你自己能得出推论来的。”</li><li>设计论也叫目的论证明，从具有精美结构的钟表必有一个制造者，推出具有更加精美结构的大自然必有一个制造者。休谟认为，这种类比推理缺乏经验依据，充其量是关于一个相似因的一种猜想、揣测或假设。</li><li>宇宙论证明建立在因果关系的基础上，认为宇宙中所见的运动、原因、偶然性、秩序等事实足以证明上帝的存在。休谟认为，因果关系是主观或然的。</li><li>莱布尼茨的神正论认为最好世界证明了上帝存在，休谟列举大量经验事实，说明世界上充满各种罪恶，而充满罪恶的世界推不出至善的上帝。(这一点反而比莱布尼茨狭隘了)</li></ul><h3 id="经验论的死胡同"><a href="#经验论的死胡同" class="headerlink" title="经验论的死胡同"></a>经验论的死胡同</h3><ul><li>休谟把经验论贯彻到底，把整个世界说成是各种印象和观念的集合，但这恰恰背离了经验论的初衷，即寻找普遍必然性的知识，因为在休谟的怀疑论下，实体被颠覆了，客观规律被颠覆了，乃至整个客观世界也被颠覆了，排除这些以后，认识论和知识论的可靠的基础就只剩下一堆混乱无序的印象和观念了。没有了普遍必然性的知识，认识论也就没什么意义了，当休谟把经验论贯彻到底时，也亲手终结了经验论。</li><li>从经验论基本原则出发，休谟的理论滴水不漏、严谨至极，所以问题的根源就在于经验论基本原则这个大前提。同理，唯理论贯彻到底之所以成了独断论，根本原因也是天赋观念这个大前提。康德正是看透了这个问题，他认为经验论和唯理论的要害都是对理性的态度，经验论彻底贬低理性，唯理论彻底夸大理性，所以康德认为首先要批判地考察一下理性的能力和界限。</li><li>休谟的怀疑论和不可知论并不矛盾，因为他的怀疑论并不彻底，他的怀疑只是在已知和未知的层面，而对于一个东西可知还是不可知他并不去怀疑，只不过因为他只承认自身经验的知识，所以表现为一种对经验以外的世界的不可知论。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="网课笔记" scheme="https://shivakasu.cn/categories/%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哲学" scheme="https://shivakasu.cn/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《西方哲学史》2：中世纪时期</title>
    <link href="https://shivakasu.cn/2020/02/18/phi1/"/>
    <id>https://shivakasu.cn/2020/02/18/phi1/</id>
    <published>2020-02-18T11:17:20.000Z</published>
    <updated>2020-02-22T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网课的内容讲的比较简略，似乎不太重视中世纪这部分。</p><h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1 概论"></a>1 概论</h1><ul><li>中世纪(Middle Age)始于公元476年西罗马帝国的灭亡，终于公元1453年东罗马帝国的灭亡，之前称为古典时期(Classical Age)，之后称为近现代时期。</li><li>古典时期哲学以本体论为核心，主要研究世界的本原问题。近现代哲学以认识论为核心，主要研究真理是什么以及如何认识真理。本体论和认识论以人为中心，思考的是人观察世界并认识世界的问题，而中世纪哲学则以宗教哲学为核心，在人和世界之中插入了神的存在，宗教哲学的神学维度是以上帝为核心、以信仰为前提、以圣经为基础、以灵修为指向、以得救为盼望。</li><li>基督教哲学是一种精神哲学，认为人在身和心之外还有属灵的部分。心灵的理性让我们区别于动物，却无法区别与纯理性的机器人，所以在感性和理性之外还有一个超理性的部分，让我们区别于机器人。基督教把这种超理性定义成属灵，是对上帝、对圣经的服从。而我们可以把这种超理性理解成自由或自由意志，自由就是不被规定，如萨特所说“人是其所不是，又不是其所是”，能为了更高的追求去违抗本能和规定。如果把这种自由绝对化，进而把人的所有属性都绝对化，结果就是全知全能全善的神的形象，所以宗教哲学的哲学维度就是主体(人)以本体(神)的形式呈现。我们研究宗教哲学的目的就是要在神的形象中找到放大的人性。</li><li>中世纪宗教哲学是古典到近现代的必要过渡，是一个精神的炼狱，让人的精神在宗教哲学中锤炼、升华，得以发展成西方近现代的精神哲学、逻辑学等。</li><li>新柏拉图主义在时间上属于希腊化时期，与基督教是同时兴起的，但新柏拉图主义在哲学上的基本思维方式是基督教所秉承的。</li><li>教父哲学时期哲学家的任务是护教和确立基督教正统，而后的经院哲学时期哲学家的任务是在基督教统治的背景下完善基督教的理论体系，详细地论证基督教哲学如何解释世界，所以经院哲学又称繁琐哲学。</li></ul><h1 id="2-新柏拉图主义"><a href="#2-新柏拉图主义" class="headerlink" title="2 新柏拉图主义"></a>2 新柏拉图主义</h1><ul><li>古典时期末期的哲学具有“药方”的作用，在普遍悲观的希腊化背景下给人们精神上的安慰，但每派哲学都有其副作用。犬儒主义倡导放浪形骸，是以道德理想疾世愤俗，副作用是玩世不恭，用疾世愤俗反过来标榜自己有道德理想。伊壁鸠鲁主义主张快乐论，副作用就是境界不够的人扭曲了快乐的本意，变得贪图享乐。斯多葛主义主张禁欲，副作用是禁欲过度导致对生活的失去盼望，甚至引起自杀。怀疑主义反对独断论，不作任何判断，副作用是让人变得迷茫。之所以有副作用，是因为希腊化时期哲学的共同追求就是不动心，但人类的本性就是动心(有冲动和热情)。</li><li>新柏拉图主义是古典时期到中世纪时期的中介，一方面他是古典哲学的集大成者，是古典哲学的最终形态，另一方面他也对古典哲学有所否定。由于希腊化时期的罗马吸收了来自东方的神秘主义和信仰主义，新柏拉图主义就是把柏拉图主义和神秘主义(尤其是犹太的圣经)结合。</li></ul><h2 id="2-1-斐洛"><a href="#2-1-斐洛" class="headerlink" title="2.1 斐洛"></a>2.1 斐洛</h2><ul><li>基督教思想来源是两希，希腊和希伯来，希腊代表理性，是思辨精神和对定义与概念的追求，希伯来代表信仰，是人对终极实在的体悟。希伯来最重要的文化遗产是圣教历史，强调神与人的关系。希伯来的亚伯拉罕是基督教、伊斯兰教、犹太教的共同祖先。</li><li>斐洛被称为“基督教教义之父”，是亚历山大里亚的学生，亚历山大里亚是希腊化时代的文明中心，有最多的藏书，所以斐洛其实是个学霸。斐洛还是精通希腊文化的犹太人，他发现以理性的角度来看圣教历史会有很多不可解释的东西，所以他用了寓意解经的方法，把柏拉图主义和圣教历史相结合，字面上荒诞又解释不通的东西就可以理解了，比如摩西指代哲学家，天使指代理念，善和恶指代精神和物质，亚当和夏娃代表理智和情感，再比如他用分离说解释神作为无限者与世俗的绝对区别，用理念论解释神以理性逻格斯(一)为工具创世。</li><li>斐洛折中的方法让他两头不讨好，哲学家和教徒都把他当成异端，但他的贡献在于结合了希腊与希伯来的传统，开启了基督教精神的传统，他把以亚伯拉罕为始祖的神与人的关系纳入到了哲学思辨的考察范围之内。</li><li>斐洛主张最高的美德不是禁欲而是虔诚，这就杜绝了斯多葛主义导致的自杀，因为人是神创造的，人的生命属于神，所以自行了断是行使了神的权力，是对神的僭越。同时这种观点也导致了对理性的警觉，与虔诚对立的是骄傲，所有的恶都是源于骄傲，而骄傲就是过于相信自己的理性所导致的自以为是。从神学的角度看，自杀是人的自我膨胀，但从人学的角度看，自杀是人的自我贬低，康德认为自杀的道德问题在于把自我当工具，用自我毁灭来逃避生活或证明自己。</li><li>从上还可以看出，基督教处处充满吊诡，人的骄傲其实是对自己道德的贬损，人对神的谦卑反而成了一种骄傲，从神与人对应的角度理解，这是因为人的本质就是吊诡的，我们认为人的本质是自由，但这句话本身是矛盾的，自由是不受规定，而本质就是一种规定，所以人的本质就是反对一切本质。</li><li>斐洛还主张抛开知识，以“出神”状态接受启示。“出神”不是指失去神志的、非理性的出神，而是建立在理性之上又超理性的一种出神，这又是一个吊诡的概念，因为从思辨的角度看理性本身就是吊诡的，真正的理性是要理性地对待理性，这就导致也要理性地对待非理性，以及非理性地对待理性。</li></ul><h2 id="2-2-普罗提诺"><a href="#2-2-普罗提诺" class="headerlink" title="2.2 普罗提诺"></a>2.2 普罗提诺</h2><ul><li>普罗提诺提出了“太一”、“努斯”和“灵魂”三位一体的形而上学，太一是无法用定义的方式来加以表述的本原概念，努斯是太一因自身充盈而流溢的结果，是体现为一的太一，灵魂是努斯进一步流溢成的多，灵魂继续流溢就是物质。</li><li>从柏拉图主义的层面理解，太一就是所有理念中的终极理念，也就是“善”，太一无法被定义正如善无法被定义，因为善是一切的基础，对善的所有定义都是废话一样的重言式，善什么都不是，也不能被我们认识，但确实我们认识一切的基础，是我们认识世界时必须设定的不可继续追溯的东西。当善要表现自己时，需要表现为某种具体的东西，也就是理念，所以太一流溢成努斯就是善表现为理念。把握理念的主体是我们的灵魂。理念进而表现成具体的事物，就是物质。</li><li>从基督教神学的层面理解，这就是圣父、圣子、圣灵的三位一体，太一代表圣父，是高高在上的不可知的上帝，努斯代表圣子，是以人的形象表现为上帝的上帝，灵魂代表圣灵，是在人们心中的上帝。基督教内部的“和子”分歧就是关于圣灵是由圣子创造的还是由圣父和圣子共同创造的。</li><li>从生活的层面理解，太一就是人的自由意志，自由意志不被规定，也就产生了规定其他事物的冲动，正如太一流溢出努斯。当我们把这种冲动具象化到具体的可操作的行为，就是努斯流溢出灵魂的过程。当我们把行为在物质世界付诸实现，就是灵魂流溢出物质的过程。普罗提诺认为灵魂有两种张力，上溯太一和堕入物质，代表着我们在生活中对目标的坚持和对世俗的苦恼。</li></ul><h1 id="3-教父哲学"><a href="#3-教父哲学" class="headerlink" title="3 教父哲学"></a>3 教父哲学</h1><ul><li>基督教在罗马传播的最早的阶段叫做使徒阶段，主要是耶稣的门徒们传播耶稣的福音，让作为新宗教的基督教在罗马生根发芽，他们主要完成的工作就是记载耶稣的教诲，编成了《福音书》、保罗的书信、彼得的书信等。</li><li>教父是继使徒之后出现的一批具有希腊哲学素养和基督教信仰的人，他们主要生活在罗马帝国时期，是基督教教义的重要奠基者和诠释者。在使徒阶段，神学思想渗透在福音书的字里行间，但不成型，而教父们能够依靠自身的哲学功底，把耶稣的思想总结为系统性、理论性的的神学思想。</li><li>教父主要的发展时期是西罗马帝国崩溃之前，因为西罗马崩溃以后蛮族入侵，人们无心研究神学或哲学，直到公元十世纪，依靠教父时期打下的基础，基督教开始恢复元气，再加上各个城市建立大学发展学术，最终导致了经院哲学的出现。经院哲学理性的东西比较多，暗含了近代经验论、唯理论的理性基础。</li><li>教父哲学的思想基础是柏拉图主义和新柏拉图主义，强调神秘主义、超理性的信仰，贬抑理性而弘扬信仰。经院哲学的思想基础是从埃及、阿拉伯等地区传回来的亚里士多德的理论，因为经过之前的教父时期，基督教已经成为了正统、成为了西欧人民共同的唯一的信仰，基督教就从之前的宽容变成了不宽容，对所有希腊罗马思想赶尽杀绝，基督教虽然潜移默化地接受了希腊罗马哲学的影响，但却极度排斥他们，所以亚里士多德的思想没有被流传下来，只能靠北非国家传回西欧。因此亚里士多德主义的复兴是经院哲学产生的思想根源，经院哲学也就自然而然继承了亚里士多德的理性色彩。</li><li>在《米兰敕令》颁布之前，基督教刚开始传播，教父们的职责是为处于受压抑状态的基督教信仰进行辩护，所以他们又被叫做护教士。在《米兰敕令》颁布之后，基督教已经站稳了脚步，但分散在罗马帝国各地的教会都有着各自的教义，所以就需要统一各个教会以及确立正统理论，教父们的主要职责是通过对各种异端思想的批判来确立正统性的教义。表面上是理论之争，其实是权力之争，最后争执不下，分裂成了西罗马帝国的天主教和东罗马帝国的东正教。</li></ul><h2 id="3-1-教父哲学对待理性与信仰的基本态度"><a href="#3-1-教父哲学对待理性与信仰的基本态度" class="headerlink" title="3.1 教父哲学对待理性与信仰的基本态度"></a>3.1 教父哲学对待理性与信仰的基本态度</h2><ul><li>希腊教父与拉丁教父之争，就是罗马占领希腊后两个民族不同文化的分歧。希腊教父普遍理性色彩浓厚，对哲学持肯定态度，他们虽然认为信仰高于理性、基督教高于希腊哲学，但他们也认为二者并不冲突，试图统一信仰与理性、统一基督教和希腊哲学。</li><li>希腊教父一派里，查士丁第一个提出了“基督教哲学”的概念，并将其作为一切希腊哲学的最终目标，这种调和基督教信仰与希腊哲学理性精神的基调是希腊教父的共同特征。他还提出了“基督教是真正的哲学”，意思是希腊哲学不够完备，基督教哲学是对希腊哲学的一种弥补、提升和再造。他认为当耶稣把天国的福音向人们昭示以前，希腊哲学已经用一种隐喻的方式昭示了圣经里的思想，比如逻格斯就是基督，苏格拉底的“灵异”也是基督。</li><li>拉丁教父的文化背景是相对粗鄙的罗马文化，他们看不起希腊哲学，认为信仰是反理性或超理性的，代表人物是德尔图良。德尔图良将哲学视为“人与魔鬼的学说” ，主张抛弃一切哲学，以信仰排斥理性，这种敌视哲学与理性的基调是拉丁教父的普遍特征。德尔图良摆出了信仰与理性的矛盾，用理性来解释神学是解释不通的，所以必须站在反理性的立场，用信仰的眼光看待神学。他做了一个比喻，理性就像器皿，上帝的奥秘就像汪洋大海，器皿注定装不下上帝的奥秘，所以必须抛弃理性拥抱信仰。</li><li>两派的斗争中，拉丁教父往往处于上风，所以基督教的教义中保留了很多超理性的成分。</li><li>基督教的教义就是关于上帝、耶稣和人的关系，耶稣是上帝与人沟通的中介。</li><li>关于上帝的教义就是上帝论，上帝论的权威定义就是三位一体，认为上帝有唯一的实体但是有三个不同的位格，这是为了反驳当时的两种异端，既不能认为上帝是绝对的唯一，又不能认为有圣父圣子圣灵三个独立的神，所以上帝必须既是一又是三，因为是反理性的，所以很难理解。</li><li>关于耶稣的教义就是基督论，基督在希腊语里的意思是救世主，基督相当于希伯来语的弥撒亚。耶稣是神与人的中介，所以耶稣必须与神与人都有联系，既是十足的神又是十足的人。耶稣有着神性与人性的双重本性，神性的一面向人们昭示上帝的福音，人性的一面让他在十字架上承担了世人的罪，让世人也能像他一样死而复生。其他的对耶稣的解读都是异端，比如耶稣生前是人，死而复生之后是神，再比如有两个耶稣，一个是神一个是人。耶稣的神性和人性有“四道围墙”，表明完全的神性和完全的人性之间的关系，即不能混合，不能分开，不能改变，不能离散。</li><li>关于人的教义是最重要的，基督教的最大意义就是帮人解决死的问题，死亡是人最大的苦恼，上帝和耶稣最后都要落脚到人身上才值得信仰。这一部分涉及到后面奥古斯丁的原罪和救赎的理论，亚当夏娃是有原罪的，后代的人们通过遗传继承了这种罪，而死亡就是上帝对人的惩罚，原罪是人与生俱来的一种形而上的罪，因为不是自己犯的罪，所以是人们无法解决的，所以也就需要耶稣来解罪，耶稣代表第二亚当，人们在亚当的罪里死了一次，还要在第二亚当的罪里死一次，死了又死就意味着活。</li></ul><h2 id="3-2-奥古斯丁"><a href="#3-2-奥古斯丁" class="headerlink" title="3.2 奥古斯丁"></a>3.2 奥古斯丁</h2><ul><li>奥古斯丁早年信奉摩尼教(就是波斯明教)，主张善恶二元论，但由于他母亲是天主教徒，而后又受到米兰主教安布罗斯的点化，就成了基督教徒。基督教是一元论的，上帝代表着善，但奥古斯丁受到原来二元论的影响，总是在思考恶的问题，既然全善的上帝不可能创造恶，那么恶的来源就成了问题。</li></ul><h3 id="上帝创世说"><a href="#上帝创世说" class="headerlink" title="上帝创世说"></a>上帝创世说</h3><ul><li>古希腊创世说的典型是工匠说，创世不是无中生有，上帝创世之前就已经存在着质料了，上帝创世的过程就是给质料以形式。</li><li>奥古斯丁的创世说是无中生有的，上帝创世之前什么都没有，“上帝言说”创造了一切(上帝说要有光)，这是广义的道成世界、道成肉身(狭义的道成肉身是上帝成为耶稣)。时空间也是上帝创造的，所以也就不存在上帝在哪里、在什么时候创世的问题。奥古斯丁认为上帝创世之前的事就是不可问、不可知的奥秘，只能信仰不能理解。</li></ul><h3 id="人性论"><a href="#人性论" class="headerlink" title="人性论"></a>人性论</h3><ul><li>奥古斯丁和托马斯·阿奎那构成了中世纪基督教神学的两大台柱，人们常说中世纪基督教有两个传统，奥古斯丁传统和阿奎那传统。奥古斯丁的教父哲学强调超理性、神秘性的东西，阿奎那的经院哲学强调理性，理性氛围浓厚。</li><li>奥古斯丁一生被恶的问题所困扰，因为作为基督教徒他必须承认上帝的全知全能全善，以及上帝创造了世界，所以她就提出了原罪与救赎。原罪与救赎是连在一起的，如果没有原罪，人们就不会感到自己是有罪之身，也就不会感到需要上帝的拯救，如果没有救赎，人们就永远不得解脱，信仰也就失去了现实意义。</li><li>思考恶的来源之前，必须要弄清恶的本质是什么。奥古斯丁认为恶没有本质，善是一种本质，上帝的本质就是善，而恶正是对上帝(善)的背离、缺乏所导致的，它所缺乏的就是本质，所以恶没有质料因。又因为上帝(善)是人们追求的目标，对上帝的背离同样导致了无目的性，所以恶也没有目的因。可以理解为，一切东西都是上帝创造的，上帝没有创造恶，所以恶就不是个东西，恶是一种背离(虽然经不起推敲吧)。</li><li>奥古斯丁早期把恶分为主动性的恶和遭受性的恶。主动性的恶就是人们主动作恶，遭受性的恶就是人们遭受到的不幸。到了后期，他把恶分成了三种，物理的恶、认识的恶和道德的恶。因为恶就是缺乏，所以每种恶都对应了一种缺乏。其中物理的恶是指与肉体痛苦相关的恶，实际上体现了肉体的受限，受限就是一种缺乏。认识的恶是指人们达不到上帝要求人们所达到的，实际上是一种认识的欠缺，所以认识不足也是一种恶。道德的恶是指人们滥用自由意志所导致的恶，道德上犯错叫做罪，所以道德的恶也叫罪恶，奥古斯丁讨论的重心就是罪恶，前两种恶都是一种与生俱来的欠缺，是一种形而上学的恶，是人固有的欠缺，因为上帝创造的事物都没有上帝本身那么完善，道德的恶虽然是我们与生俱来的，但对于亚当夏娃来说却不是与生俱来的，是与人的自由意志有关系的。</li><li>奥古斯丁认为世界上本来是没有罪恶的，上帝为了表示对人的格外恩宠，就赋予了人一定的自由意志，本意是让人们运用自由意志去行善。但亚当夏娃却滥用了自由意志，用自由意志去违背上帝的意志，也就是上帝不让吃他们偏要吃，所以亚当夏娃就导致了人类的第一个罪恶，即原罪。奥古斯丁认为罪恶的根源不是自由意志，而是滥用自由意志，但后世的康德、黑格尔对此反驳道，滥用自由意志的根据说到底还是自由意志，如果自由意志不允许背离上帝就不叫自由意志了。</li><li>原罪不是一次偶然性的罪恶，也不是只关系到亚当夏娃两个人的，原罪的本质是对人类本性的败坏和污染，让人的本性有了一种向恶的趋向，并通过遗传影响了亚当夏娃的后代，所以基督教会认为人性本恶，人们生而有罪，这是一种决定论的罪恶观。</li><li>奥古斯丁认为人们不能自己赎罪，因为原罪败坏人本性的同时，也败坏了人的自由意志，自由意志变成了罪恶意志，人们已经不能在善恶之间自由选择，而是只能在两种不同的恶之间选择。也就是人类第一次的堕落就注定了永久的堕落，就像人本来有选择生死的自由，可一旦自杀以后就不能再选择生了。所以道德的努力不能使我们脱离原罪，只能由耶稣来为世人赎罪。</li><li>奥古斯丁认为上帝在创造世界的时候已经决定了哪些人将被拯救，哪些人不能被拯救，至于如何决定的，就是我们不可知的奥秘了。事实上所有人都是不该被拯救的，父罪子偿天经地义，人们都继承了原罪，都要承担原罪的最终代价，也就是死亡，一个人被上帝拯救不是因为他的自我救赎，而是上帝的格外开恩，人就是恩典的器皿，人们得到了上帝的恩典，就能够重新拥有自由向善的意志，也能够摆脱死亡。</li><li>既然是否被拯救早就注定了，自然就会让人产生消极的态度，觉得道德上的努力都是徒劳。奥古斯丁对此的解释是，虽然我们不知道自己是否会被拯救，但被拯救的一定的信仰坚定、道德水平高的人，所以一个人的信仰越坚定，就越有理由相信自己会被拯救。虽然一切是上帝早就决定好的，但就是有人会因为这种决定论的思想相信自己是天选之子，认为自己做的一切都是不得不做的，所以他们仍然会坚持做道德上的努力。</li><li>罪恶的问题还让人们对上帝的全知全善产生了怀疑，如果上帝是全善的，就代表他不知道人类会产生罪恶，如果上帝是全知的，就是默许了人类应该承担罪恶。奥古斯丁对此的解释是，上帝只是预知了人类会滥用自由意志，但没有预定人类要滥用自由意志，上帝对原罪不需要负责任。然而这并没有完全解决问题，上帝是全善的就没有理由会不作为，放任人类的堕落。所以这个问题是基督教神学里的一个大问题，属于“神正论”的问题。</li></ul><h3 id="上帝之城与世俗之城"><a href="#上帝之城与世俗之城" class="headerlink" title="上帝之城与世俗之城"></a>上帝之城与世俗之城</h3><ul><li>奥古斯丁写了一本《上帝之城》，当时汪达尔人在罗马烧杀抢掠，有人就觉得这是罗马人信上帝的结果，于是奥古斯丁就写书为基督教辩护。他认为上帝是在借蛮族之手惩罚那些堕落、无道的罗马人，是上帝的鞭策。他进而提出在人们的灵肉之间存在着上帝之城和世俗之城，人的灵魂向往上帝之城，人的肉体向往世俗之城，当一个人爱上帝胜过爱自己，就会属于上帝之城，当一个人爱自己胜过爱上帝，就会属于世俗之城。</li></ul><h3 id="光照说"><a href="#光照说" class="headerlink" title="光照说"></a>光照说</h3><ul><li>奥古斯丁在认识论上综合了柏拉图的回忆说和亚里士多德关于积极能动的灵魂的观点，提出了光照说。他把上帝比作真理之光，上帝的光照一方面赋予了万事万物可见性，另一方面又赋予人的灵魂以能见性。所以人的认识能力都是来自于上帝。</li></ul><h3 id="上帝存在的证明"><a href="#上帝存在的证明" class="headerlink" title="上帝存在的证明"></a>上帝存在的证明</h3><ul><li>教父哲学的普遍基调是反理性的、神秘主义的，而奥古斯丁则是一个理性色彩比较重的人(虽然比不上阿奎那)，他试图以理性的方式论证上帝的存在性。他提出了三种论证方法：一是通过宇宙的秩序，也就是后来的设计论或目的论。二是通过万物的等级，这两种都属于宇宙论证明。三是通过人心的内省和思辨，属于本体论证明，我们一提到上帝，就能在心中想起来他，就是因为关于上帝的观念早就存在于我们的心灵之中。中世纪常用的一条推理原则是“结果不能大于原因”，所以论证的结果是心中的上帝，那么必然存在一个更大的上帝的概念作为原因，因此上帝是存在的。后世有人认为奥古斯丁的这种方法只能证明心中存在上帝的观念，无法推导出上帝的存在。</li></ul><h1 id="4-经院哲学"><a href="#4-经院哲学" class="headerlink" title="4 经院哲学"></a>4 经院哲学</h1><h2 id="4-1-实在论与唯名论"><a href="#4-1-实在论与唯名论" class="headerlink" title="4.1 实在论与唯名论"></a>4.1 实在论与唯名论</h2><h3 id="“共相”问题"><a href="#“共相”问题" class="headerlink" title="“共相”问题"></a>“共相”问题</h3><ul><li>“共相”问题源自新柏拉图主义的波菲利在朱姐亚里士多德《范畴篇》时提出的三个问题：共相(即种属)是独立存在的还是存在于理智中？共相是有形的还是无形的？共相是与可感事物相分离的还是寓于可感事物之中？就内容而言，“共相”问题是一个纯粹的哲学问题，但他的结果会影响神学，所以也算是个神学问题。</li><li>“黑暗时期”的拉丁教父波爱修将共相问题引入哲学，并作出了回答。他认为共相是独立于人的理智而存在的普遍实质，共相是无形的，以及共相存在于可感事物中并与可感事物相一致。他的观点符合亚里士多德，也接近唯物主义的思想。共相的三个问题其实可以归结为一个问题：共相到底是独立存在的客观实体，还是仅仅寓于可感事物之中的普遍实质。如果是客观实体，就相当于柏拉图的理念，倾向于唯心主义，如果是普遍实质，就符合亚里士多德的形式因在实体内部的观点，倾向于唯物主义。中世纪时期在这个问题上分出了实在论和唯名论两派，实在论认为共相是客观实体，正如柏拉图认为理念是比所有实在事物还实在的实在，唯名论认为共相是普遍实质，共相只是个名字或概念，只有可感事物才是实在的。</li></ul><h3 id="唯名论"><a href="#唯名论" class="headerlink" title="唯名论"></a>唯名论</h3><ul><li>极端唯名论的代表人物是洛色林，他认为共相只是个声音、名字、符号，他否认共相本身所具有的客观内涵，“唯名论”也是因此而得名的。</li><li>温和唯名论的代表人物是阿伯拉尔，他认为共相不仅是个名字，还是有客观内涵的，但共相的客观所指不能独立存在，必须寓于可感事物之中。他认为共相是概念，所以他的理论又叫“概念论”。他既否定实在论又承认共相的客观性，实际上是一种辩证的思想，因此他也认为共相既有形又无形，以及共相虽然寓于可感事物，但被人们思考的时候却是在头脑中的独立于可感事物的存在。(最高明的回答)</li><li>唯名论在中世纪的命运比较惨，因为唯名论的观点加以引申就会触犯基督教正统教义。比如洛色林不承认上帝的三位一体，他只承认圣父圣子圣灵的三神论，却否认三者的共相是上帝。而实在论就比较迎合基督教的传统，因为上帝就是最大的共相。</li></ul><h3 id="实在论"><a href="#实在论" class="headerlink" title="实在论"></a>实在论</h3><ul><li>极端实在论的代表人物是安瑟尔谟，他认为共相是独立存在的客观实体，先于个别事物，比个别事物更实在。</li><li>温和实在论的代表人物是托马斯·阿奎那，他认为共相是客观实体，但却是先于、寓于、后于个别事物的，先于体现在上帝按照共相创造事物，寓于体现在上帝创造出事物后共相就会寓于其中，后于体现在人们从个别事物中能够抽象出共相，这也是辩证的思想。</li><li>安瑟尔谟被称为“最后一个教父和第一个经院哲学家”，他就是以柏拉图为基础的教父哲学和以亚里士多德为基础的经院哲学的分水岭。他开始受到亚里士多德的影响，试图用理性论证信仰，因为在教父时期普遍认为信仰是反理性、超理性的，理性不能用来论证信仰。</li></ul><h3 id="安瑟尔谟"><a href="#安瑟尔谟" class="headerlink" title="安瑟尔谟"></a>安瑟尔谟</h3><ul><li>安瑟尔谟在《上帝存在吗》里论证了上帝的存在，他认为任何一个愚顽人的头脑中都有一个最完满的东西的观点，最完满就意味着无所不包，自然就包括了存在，又因为上帝是最完满的，所以上帝是存在的，这是一个三段论形式的推理。之所以上帝包含了存在，是因为万事万物的本质与存在是分开的，上帝头脑中有人的概念，但它可以创造人也可以不创造人，所以我们的本质先于存在，但唯独上帝的本质不能先于存在，上帝不是被创造出来的，所以上帝的本质与存在是一体的，所以上帝就包含了存在。</li><li>后世康德对此的反驳是，安瑟尔谟把存在当成了一种属性，但存在是一种状态，无所谓包含不包含，就像头脑中的一百块钱和兜里的一百块钱没有什么先有后有、谁包含谁的必然关系，只是两种状态而已。康德认为存在不能用逻辑推出来，只能用经验判断。后来黑格尔又批判康德，认为康德的观点比安瑟尔谟还糟糕，因为康德认为头脑中的钱和兜里的钱毫不相干，彻底否定了思维与存在的同一性，黑格尔是辩证的观点，他认为思维和存在是互相影响的。</li><li>安瑟尔谟的问题在于理性不彻底，虽然用了理性的逻辑方法，但他的大前提小前提都是以信仰为基础的，比如上帝是最完满的。觉得信仰不靠谱，想用理性证明，结果还是在信仰的基础上做的理性证明，等于脱裤子放屁。</li></ul><h2 id="4-2-托马斯·阿奎那"><a href="#4-2-托马斯·阿奎那" class="headerlink" title="4.2 托马斯·阿奎那"></a>4.2 托马斯·阿奎那</h2><ul><li>古希腊的辩证法带有诡辩色彩，通过反击对方、揭露矛盾来接近真理。中世纪的辩证法明显具有我们现在所理解的辩证法的意义，是用矛盾的、一分为二的观点来解释事物，比如阿伯拉尔对共相的解释，自阿伯拉尔起，辩证法在中世纪开始流行开来，也就影响到了阿奎那。</li><li>阿奎那的观点与先前的教父哲学大同小异，认为信仰至上，理性次之，神学至上，哲学次之。但相比教父哲学，阿奎那更强调理性的作用，他认为基督教的很多教义可以通过双重的方式来达到和领悟，即理性的方式和天启(信仰)的方式。每个人都有信仰，所以每个人都能通过信仰把握到交教义，但有一部分教义也能通过理性的途径把握，比如上帝存在、灵魂不死可以用理性论证，而三位一体、道成肉身只能用信仰把握。</li><li>也有对阿奎那的理性持贬抑态度的，认为阿奎那的理性只是个幌子，理性在他的体系里是可有可无的，毕竟还是以信仰为基础的。罗素在他的哲学史里评论阿奎那的论证是没有科学精神的，阿奎那在论证之前已经有结论了，他做论证不是为了追求真理，纯碎是为了装逼。</li><li>阿奎那认为理性把握到的教义是自然神学，信仰把握到的教义是启示神学，两种神学是殊途同归的。阿奎那做理性证明的初衷是给不信上帝的人看的，不信上帝的人没有信仰，所以不能得到启示神学的真理，但只要他们有理性，就能够通过理性得到自然神学的真理。在这一点上，阿奎那看不上安瑟尔谟的理性论证，因为安瑟尔谟关于上帝存在的论证不能让无神论者相信，因为无神论者不会认为上帝是最完满的，所以安瑟尔谟论证的前提就是不成立的。所以阿奎那反对用上帝的观点来证明上帝的存在，这是不需要经验证据的先天证明，真正的理性论证是不需要信仰的、依靠经验证据的后天证明。</li><li>阿奎那使用后天证明，从人们已知的事实出发来推出其原因，这就是宇宙论证明和目的论证明，它们一共有五个，即著名的“圣托马斯五路证明”：<ul><li>从事物的运动或变化方面论证：万物的运动必然是有他物推动，所以必定有一个终极的存在者，他只推动其他事物而不被推动，他就是上帝。(不能是围成一个环互相推动吗？)</li><li>从动力因的性质来论证：万物作为结果都有各自的原因，所以必定有一个终极的存在者，他的原因在于他自身，同时又构成了万物存在的“第一原因”，他就是上帝。</li><li>从可能和必然性来论证：世界上一切个别的存在物都是偶然的和可能的，所以必定有某种绝对必然的存在者作为它们终极的根据，否则就会在某个时候一切事物都不存在，就会与事实相矛盾，这个绝对必然的存在者就是上帝。(没有见到那种偶然性就否定它的存在？)</li><li>从事物中发现的真实性的等级来论证：万物都有不同程度的完善性，这种有缺陷的完善性必定以最完善的东西为其判定标准和原因，这个至善的存在者就是上帝。(完善的概念是主观的还是客观的？)</li><li>从世界的秩序(或目的因)来论证：万物都为一个目的而活动，其活动总是遵循同一途径，以求获得最好的结果。如果它们不受某一个有知识和智慧的存在者指挥，那么它们也不能移动到目的地。所以必定有一个最高智慧的存在者，一切事物都靠它指向着它们的目的，这个最高智慧者就是上帝。</li></ul></li><li>前四个论证是有同构性的，罗素把他们的共同特点总结为“假定没有首项的级数是不可能的”，比如推动必须有个源头、原因也必须有个源头。至于现实的序列到底有没有首项，是个形而上的问题，康德的解释是，有首项和没首项都能够自己证明出一个结果，两个结果相反但都是成立的，这叫做二律背反。所以不能用经验证据来证明一个形而上的问题，在有限和无限的问题上没有对错，这就成了一个信仰的问题，不能用理性方法解决。</li><li>阿奎那发展了亚里士多德的四因说。他把形式因和质料因归为内因，把动力因和目的因归为外因。在内因方面，他把质料分为原初质料和第二性质料，原初质料就是纯粹潜能，第二性质料是已经获得了某种形式规定、从而具有一定现实性的物质，这个概念接近近代科学中的“物质”的概念。在外因方面，他把动力因分为第一因和第二性原因，第一因是上帝，第二性原因是普遍的因果关系。他把目的因分为终极目的和非终极目的，分别对应第一因的目的和第二性原因的目的。</li></ul><h2 id="4-3-反托马斯主义的方济各修会经院哲学家"><a href="#4-3-反托马斯主义的方济各修会经院哲学家" class="headerlink" title="4.3 反托马斯主义的方济各修会经院哲学家"></a>4.3 反托马斯主义的方济各修会经院哲学家</h2><ul><li>近代科学源自于中世纪的托马斯主义和斯各特主义，也就是以托马斯·阿奎那为代表的理论理性和以邓·斯各特为代表的经验理性。理论理性以推演为主要方法，经验理性以归纳为主要方法。理论理性的问题在于，以推演方法、目的论方法为基础，在构建体系时会把很多含混的东西当做不可置疑的前提来接受，正如亚里士多德忽视经验而得出的很多谬误。</li><li>经验理性的代表人物是方济各修会三杰，即罗吉尔·培根、邓·斯各特和威廉·奥卡姆，他们不喜欢纯粹的、形而上的、理性思辨的哲学，他们更关注具体事物本身。经验理性思想的渊源是基督教神学中的神秘主义，而不是讲“理”的理智主义。</li><li>罗吉尔·培根加入方济各修会的目的不纯，本想利用修会的资源完成自己的科学研究，但是却被会长视为异端，把他软禁了十多年。因为他在实验科学方面的贡献，被后人视为近代实验自然科学的先驱。</li><li>培根认为影响人们获得真理的障碍有四种，一是屈从于谬误甚多、毫无价值的权威，二是习惯的影响，三是流行的偏见，四是由于我们认识的骄妄虚夸而来的我们自己的潜在的无知。培根批判了经院学者片面地热衷于推理，他呼吁重视经验和科学实验。他把经验分成两种，内在经验和外在经验。内在经验是通过信仰的天恩获得的启示，外在经验是通过感官获得的关于外部事物的经验。这种“双重经验”的观点表明培根仍然试图在科学与宗教之间寻找一条调和之道。</li><li>培根在共相问题上是温和的唯名论观点，他一方面反对实在论，认为共相不能脱离个别事物，另一方面他又反对极端的唯名论，认为共相不只是个名字，它是寓于个别事物之中的同一类事物所具有的共性因素。</li><li>邓·斯各特持一种唯意志主义的观点，他认为理性无法把握上帝，坚决反对阿奎那用理性推出上帝的观点。他还反对阿奎那关于自然神学和启示神学具有同一性的观点，他认为二者是截然相反的，哲学上只需要理性，神学上只需要信仰。斯各特把哲学和神学看做对立的，哲学探讨现实世界而神学探讨超现实世界，哲学探讨经验世界而神学探讨超经验世界。康德在这个问题上符合斯各特主义的观点，他认为哲学和宗教、理性和信仰是井水不犯河水、互不相干的。斯各特反对除了上帝存在性证明之外的一切证明，在上帝存在性证明上他赞同安瑟尔谟的观点，也就是用上帝的观点论证上帝的存在，偏神秘主义色彩。</li><li>威廉·奥卡姆认为理性、经验都不能证明神学教义，甚至连上帝存在性都不能证明。他提出“唯独信仰”，在神学上没有任何理性、经验能帮助人们，只能依靠信仰。奥卡姆最重要的思想是奥卡姆剃刀原则，也被称为思维经济原则。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="网课笔记" scheme="https://shivakasu.cn/categories/%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哲学" scheme="https://shivakasu.cn/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《西方哲学史》1：古希腊罗马时期</title>
    <link href="https://shivakasu.cn/2020/02/05/phi0/"/>
    <id>https://shivakasu.cn/2020/02/05/phi0/</id>
    <published>2020-02-04T16:24:20.000Z</published>
    <updated>2020-02-13T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>课程地址：<a href="https://www.bilibili.com/video/av14582263" target="_blank" rel="noopener">https://www.bilibili.com/video/av14582263</a></li></ul><h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><ul><li>雅斯贝斯在《历史的起源与目标》中提出了轴心时代的概念，是指公元前500年前后同时出现在中国、西方和印度等地区的人类文化突破现象，诞生了一批伟大的思想家，奠定了此后几千年文明生存与发展的根本。</li><li>中国文明主要在中国内部，地域大民族少，而西方文明涉及到欧洲、美洲的多个国家，地域小民族多，所以西方文明的体系要比中国文明复杂。</li><li>中国文明的传统是以夏变夷，以不变应万变，因为早期周边地区都是文明水平比中国低的国家，所以中国能够用自己的文明同化和融合周边地区(东夷西戎北狄南蛮)的文明，来一个融合一个，中国文明因此没有断过线。但中国文明也因此相当保守，难以自我更新，到鸦片战争时期，遇到了强大的西方文明，就无法同化了。</li><li>西方文明的传统是融合更新，因为周边是两河文明、埃及文明等强大的文明，不存在类似夏夷的明显强弱局势，所以西方文明不像中国一样悠然自得，而是更有发展的内驱力，发展历程也比中国更复杂。</li><li>philosophy是两个希腊语的结合，philo是爱，sophia是智慧，所以philosophy本身是爱智慧的意思。</li><li>中国哲学重现世、尚事功、学以致用。西方哲学重超越、尚思辨、学以致知。西方哲学就是为学而学，没有功利性，所以是更纯粹的知识，但也因此容易脱离现实变成玄学。</li><li>陈修斋提出“哲学无定论”，哲学的终极问题都是没有定论的问题，但是热衷于思考这些问题是人的本性。</li><li>罗素认为哲学介于神学和科学之间。哲学与神学的区别是立足点，哲学基于理性思考，神学基于神圣权威思考。哲学和科学的区别是研究内容，哲学主要思考无定论的问题，科学研究确定性的早晚会有答案的问题。</li><li>哲学是不断批判与怀疑的思维过程，并不是一种刻板的知识体系，而是一种看问题的方式和思考问题的素养。</li><li>黑格尔认为哲学就是哲学史，因为哲学是传承的、发展的，每个阶段的哲学思想都是现今哲学思想的一部分，所以哲学史是一个整体，所有的哲学体系构成了真理全体。</li><li>西方哲学的发展分成四个阶段：最初的哲学问题就是关于世界的本原(arch)，古希腊时期的哲学基本都是以世界本原为核心。古希腊后期哲学转向对人本身的思考，到中世纪时期，主要研究起人的主观精神，贫瘠的现实让人们把个人精神放大，把自我异化成了神圣的形象，所以神是中世纪时期的哲学背景。 古希腊研究客观现实，中世纪研究主观精神，到了近代就开始了对二者关系的研究，自觉地探讨主客观世界的关系，通过这种认识论使人们能够掌握自然世界的力量。现代哲学研究人的主观能动性，因为人类不断把客观世界主观化，人的主观能动性在改变自然中不断提升。</li></ul><h1 id="2-古希腊哲学的背景及发展梗概"><a href="#2-古希腊哲学的背景及发展梗概" class="headerlink" title="2 古希腊哲学的背景及发展梗概"></a>2 古希腊哲学的背景及发展梗概</h1><h2 id="2-1-古希腊哲学的背景"><a href="#2-1-古希腊哲学的背景" class="headerlink" title="2.1 古希腊哲学的背景"></a>2.1 古希腊哲学的背景</h2><ul><li>第一时期在环爱琴海周边到处开花，出现各种哲学流派，四大流派分布两东两西。第二时期雅典崛起，主流哲学家都是雅典人或在雅典成名，雅典成为哲学交流和发展的中心。第三时期城邦集体衰落，马其顿雄起，希腊哲学由盛转衰，放弃探讨世界本原，开始立足现实思考人的问题。</li><li>古希腊哲学发展的根基是城邦制，城邦制国家具有分离主义的政治模式和自由主义的生活态度。</li><li>希腊的民族背景是哲学，中国的民族背景是伦理，印度的民族背景是宗教。哲学是希腊的专利，所以哲学概念放在其他文明里会很模糊。亚里士多德认为哲学的起因是惊异和闲暇，也就是吃饱了撑的胡思乱想，但这解释不了哲学没在东方发展起来。</li><li>中国文明的传统是中央集权，是靠血缘、宗族统治的，人民的地位很低。但希腊时期完成了君主制到僭主制到民主制的转变，在民主制里最高权力不属于少数人，而是由全体公民直接统治国家，公民有了极高的地位，并逐渐形成以公民法为权威的统治模式。法律的概念让希腊人民开始相信世界背后有一种超越现实的、任何个体都无法反抗的绝对力量，这种力量在希腊神话里表现为命运女神，在哲学里就表现为必然性和普遍性，所以对客观世界背后的普遍性的思考使希腊成为了哲学的发源地。</li></ul><h2 id="2-2-古希腊哲学的发展"><a href="#2-2-古希腊哲学的发展" class="headerlink" title="2.2 古希腊哲学的发展"></a>2.2 古希腊哲学的发展</h2><ul><li>第一时期也叫做自然哲学阶段，第二时期是自然哲学转向形而上学的阶段，第三时期是伦理学与人生哲学的阶段。</li><li>自然哲学阶段主要是四大学派，分为自然哲学(唯物)和形而上学源端(唯心)两个阵营。自然哲学派研究事物的物质性本质，比如泰勒斯的水和阿那克西米尼的气，形而上学研究事物的非物质性本质，比如赫拉克利特的逻各斯和毕达哥拉斯的数。各学派纷纷对世界的本原问题提出自己的观点，这导致了一批“后现代主义”哲学家(智者派)的出现，他们认为前人之所以对客观世界有不同的观点是因为主观意识的作用，于是人成了万物的尺度，哲学重心从客观转移到了主观，开始研究人本身。</li><li>第二阶段把自然哲学派推向了更高水平，开始思考早期所谓的世界本原背后的更小的本原物质，寻找到了空间上最小的结构，也就是原子，从看得见的水火土气到看不见的原子，从这个角度看自然哲学开始变得形而上。而形而上学一派逐渐成熟，开始思考更深刻、更抽象的概念，比如苏格拉底追问事物的定义，以及柏拉图继承发展了概念论。自然哲学派走向极致的物质结构，形而上学派走向了极致的抽象内涵，亚里士多德整合了这两种对立的观点，指出事物有质料和形式两个方面。</li><li>第三阶段的背景是城邦制的衰落以及亚历山大帝国的崛起，以自由精神为基础的希腊哲学不复存在，人们的眼界不再开阔，对世界本原的问题也不再感兴趣，人们开始悲观地思考在这个全然不同的世界里如何活得幸福，于是伦理学和人生哲学就取代了自然哲学和形而上学。这种悲观的哲学而后与以神为寄托的基督教哲学合流，古希腊哲学功成身退。</li></ul><h1 id="3-古希腊哲学的第一-早期-阶段"><a href="#3-古希腊哲学的第一-早期-阶段" class="headerlink" title="3 古希腊哲学的第一(早期)阶段"></a>3 古希腊哲学的第一(早期)阶段</h1><ul><li>希腊哲学诞生的背景是以希腊神话为主流思想的时代，这些神话包括荷马的《伊利亚特》、《奥德修纪》和赫西俄德的《神谱》。</li><li>四大学派中，位于东边的米利都学派和艾菲斯学派偏自然哲学，研究方法是还原，对事物进行时间和空间上的还原，也就是事物的起源和构成。位于西边的毕达哥拉斯学派和艾利亚学派偏形而上学，研究方法是抽象，是思考事物背后看不见的共性。东部产生自然哲学可能是因为东部地区相对繁荣、商业发达，人们眼界开阔，对客观事物更有好奇心。西部产生形而上学可能是因为西部地区相对落后、农业为主，人们研究比较局限，同时宗教氛围和神秘主义比较浓厚。</li></ul><h2 id="3-1-米利都学派"><a href="#3-1-米利都学派" class="headerlink" title="3.1 米利都学派"></a>3.1 米利都学派</h2><h3 id="泰勒斯"><a href="#泰勒斯" class="headerlink" title="泰勒斯"></a>泰勒斯</h3><ul><li>泰勒斯，与雅典的立法者梭伦等人并称古希腊七贤，鼎盛年公元前585年。被誉为(自然)哲学之父，是因为表述了“水是万物的本原”的观点。亚里士多德的一种解释是该观点是泰勒斯观察发现的结果，因为种子起源于湿润，而水是湿润的源头，所以他会认为水是万物本原。另一种解释从神话的角度考虑，因为水神是希腊神话中最古老的神，比如《神谱》中的天神和海神是大地女神盖亚最先孕育出的神，所以水是万物本原。</li><li>丹皮尔的《科学史》里指出，泰勒斯的重要意义在于摆脱了神话思维的束缚，开始独立地用自然物质来解释万物的本原。因为在神话思维里自然界的事物与现象都有着对应的神，用神的生殖繁衍来解释世界。</li><li>泰勒斯还提出了“万物有灵论”，但他所谓的“灵”是水的湿气，认为湿气是万物构成的原因。</li><li>泰勒斯没有把万物的质料因(物质性本原是什么)和动力因(本原构成万物的动力是什么)区分开，简单地把质料和动力都归结到水。后期的希腊哲学区分了质料因和动力因，因为物质性本原是惰性的、被动的，而本原构成万物需要一种能动性的驱动力，他们将其归结于精神力量。唯物主义似乎不擅长思考动力因，只会耍赖，比如“运动是事物的本性”，或者强行定义不需要证明的公理。</li></ul><h3 id="阿那克西曼德"><a href="#阿那克西曼德" class="headerlink" title="阿那克西曼德"></a>阿那克西曼德</h3><ul><li>阿那克西曼德，是泰勒斯的朋友和学生，鼎盛年公元前570年。最早提出了“本原”的概念，他认为泰勒斯把水看做本原是因为水在可见物里是无定形的，从这个角度考虑，火土水气都是无定形的，所以万物本原应该是一个比水更无定形的终极无定形物质。他没有具体解释这种物质是什么，只是起了个名字“阿派朗”(古希腊语里，阿是否定词，派朗是指定形)。用有形不能把握无形，所以一切对“阿派朗”的讨论都是无意义又无结果的。</li><li>黑格尔认为，阿派朗把绝对本质定义成一个否定形态，是哲学的进步和思维境界的提高。因为所有东西都是本原构成的，所以本原只可能不是个东西，他就必须只具有否定概念。正如道家的“道可道非常道”，道也是个不是东西的东西。又如新柏拉图主义提出的“太一”。(给无中生有赋予了哲学意义，哈哈)</li><li>阿派朗内部有冷热、干湿两组对立的机能，阿派朗生成万物的动力因就是内部冷热干湿的分离(矛盾产生斥力？)，比如冷和湿分离出来形成水、冷和干分离出来形成土、热和湿分离出来形成气、热和干分离出来形成火，而水土火气又进一步构成其他物质。同理，冷热干湿的聚合又使得万物归于阿派朗。</li><li>辛普里丘在介绍阿那克西曼德的哲学思想时写道：“万物由之产生的东西，万物又消灭而复归于它，这是命运规定了的。因为万物在时间的秩序中不公正，所以受到惩罚，并且彼此互相补充。”这是他以颇带诗意的语言说出的话，暗含了命运的决定论思想。</li><li>阿那克西曼德还提出了朴素的进化论的思想，认为人是鱼进化而来的，因为人在胚胎状态很像鱼。</li></ul><h3 id="阿那克西米尼"><a href="#阿那克西米尼" class="headerlink" title="阿那克西米尼"></a>阿那克西米尼</h3><ul><li>阿那克西米尼，是阿那克西曼德的学生，鼎盛年公元前546年。提出了气是万物本原，是两位前辈思想的折中，因为气既是客观存在的具体的物质，又具有阿派朗的无定形的特点，既超越了泰勒斯的局限性又有了阿那克西曼德不具备的肯定性。</li><li>阿那克西曼德的另一个学生毕达哥拉斯，没有选择妥协性的折中思想，而是极端地把阿派朗上升到更抽象、更理性的概念，也就是数，同时数的概念也把感性上的无定形变成了理性(思想)上的有定形。此外，冷热干湿的组合蕴含了一种量化的思想，所以冥冥中注定了阿那克西曼德之后必然会有人提出数的概念。</li><li>阿那克西米尼取消了干湿属性，认为气只有冷热属性。万物形成的动力因就是气在冷热作用下的凝聚和扩张，变化的逻辑可以理解为：火←气→风→云→水→土→石，其中往左是扩张往右是凝聚。但阿那克西米尼的逻辑漏洞在于，火比气更无定形，那么火更应该是本原，所以自然而然有了赫拉克利特的观点。气的凝聚扩张也是浓厚稀薄程度的不同，所以也蕴含了量化的思想。</li></ul><h2 id="3-2-毕达哥拉斯学派"><a href="#3-2-毕达哥拉斯学派" class="headerlink" title="3.2 毕达哥拉斯学派"></a>3.2 毕达哥拉斯学派</h2><ul><li>毕达哥拉斯，是泰勒斯和阿那克西曼德的学生，鼎盛年公元前531年。提出了数是万物的本原。他颠覆了前人的思想，认为本原不应该是无定形的，而应该是一种能被认知到的有定形的东西，既然通过感官无法找到本原，就应该用思想去把握它，从形而下上升到形而上。</li><li>毕达哥拉斯的抽象方法尚未成熟，他的数并没有完全脱离形体，“1”是数的第一本原，“1”的形表现为点，“1”构成“2”的形体表现是点构成面，再到面构成体、体构成水土火气，最后水土火气构成万物。</li><li>毕达哥拉斯有神秘主义和宗教的背景，所以他又认为数具有特殊的象征意义，1代表灵魂(最基本)，2代表意见(摇摆不定)，5代表爱情(第一个奇数加第一个偶数)，等等。再如，他从奇偶对立中引申出十对基本范畴(迷信10代表和谐完满)，包括奇对偶、有形对无形、一对多、左对右、阴对阳、静对动、直对曲、明对暗、善对恶、正方对长方(明显凑数)。再如，只观察到九个天体，非要杜撰出一个想象的天体凑个整。</li><li>埃及由于工程需要最早发明了几何学，但毕达哥拉斯最先从具体的几何图形中抽象出数学定理，他从直角三角形抽象出毕达哥拉斯定理，蕴含了一种数比形更有本质意义的思想。而后因为毕达哥拉斯定理引出的无理数危机(有时根据直角边算不出斜边的值，非奇也非偶)，加强了人们对数形分离的观念(直到笛卡尔的解析几何才实现了数形的统一)。数形分离的思想让数超越了感官知觉，培养出一种形而上学的倾向，也就是把超现实的抽象存在当做万物本原。</li><li>形而上的翻译源自《易经》中的“形而上者谓之道，形而下者谓之器”。中国传统思想是重经验的，讲究眼见为实，但形而上学相信眼见为虚、抽象为真，所以后面芝诺会提出一些超出人们经验认知、看起来很荒唐的悖论，因为他相信看起来真的东西不一定为真。</li><li>罗素对毕达哥拉斯有负面评价，认为他的数学思想是后期种种形而上学谬误和神秘主义信仰的根源。而黑格尔认同毕达哥拉斯的形而上，认为它是实在论哲学到理性哲学的过渡，也由此发展出西方哲学一脉相承一直到黑格尔的一种“本质决定存在”的本质主义的形而上学体系。与之相对的海德格尔和萨特所代表的“存在决定本质”的存在主义的形而上学体系，存在主义尊重人的自由和价值，认为本质主义只适用于物，对于人而言是存在先于物质的，因为本质主义有上帝按图施工创造世界的宿命感，所以要想肯定人的自由和主动性，必须要承认人的本质是人自己创造的，而不是高于人类存在的上帝之类的东西。</li><li>古希腊的传统宗教是现实主义、重肉体的，灵魂要依靠肉体存在，体现在希腊神话里就是神都拥有人的形象。而毕达哥拉斯从奥尔弗斯宗教继承了灵魂不死、轮回转世的灵肉分离思想，通过苏格拉底、柏拉图影响到了后期的基督教神学，体现在基督教里摆脱肉体的天国的概念。</li></ul><h2 id="3-3-艾菲斯学派"><a href="#3-3-艾菲斯学派" class="headerlink" title="3.3 艾菲斯学派"></a>3.3 艾菲斯学派</h2><ul><li>赫拉克利特，退隐山林的艾菲斯王子，鼎盛年公元前504-前501年。离群索居导致他的哲学语言和思想极度晦涩，连晦涩大佬黑格尔都觉得他晦涩。晚年得了水肿病不得不出山，因为交流障碍不治身亡。</li><li>提出了火本原说，一方面是受阿那克西米尼气本原说的影响，另一方面在希腊神话中火神地位很高。火与万物的转化就是燃烧与熄灭，燃烧又叫上升的道路，表现为稀薄化的倾向，如水→气→火，熄灭又叫下降的道路，表现为浓厚化的倾向，如气→水→土。从整个转化过程来看，上升和下降只是同一条路的不同方向，这就蕴含了辩证法对立统一的思想。</li><li>提出了逻格斯(logos，希腊语原意是话语)，有尺度、规律、命运、必然性的意思，到柏拉图就发展成理念和概念，概念的连接构成判断，判断的连接又构成推理，所以逻格斯是西方哲学一脉相承最重要的基本概念。命运就是一种必然性，所以赫拉克利特认为命运就是逻格斯，是贯穿宇宙的尺度。</li><li>赫拉克利特把世界分裂成理智世界的逻格斯和感观世界的万物，正是逻格斯控制着火与万物之间转化的分寸(又是耍赖的动力因)，所谓“一切是一，一也是一切”。与毕达哥拉斯不同的是，数只体现量的必然性，而逻格斯还体现了质的必然性。逻格斯既有客观规律的含义，又有主观理性的含义，主观与客观在赫拉克利特这里是统一的，因为理性或智慧就是对客观规律的认识和把握。赫拉克利特之所以鄙视荷马、赫西俄德、毕达哥拉斯，就是认为他们没有把握住自己的逻格斯，他们的思维不是理性和智慧的。</li><li>赫拉克利特认为“智慧就在于说出真理”，因为现实中很难只依靠感官的直观感受，我们生活在语言的世界，我们了解的世界是别人通过语言告诉我们的，逻格斯本意是话语，就是要用语言表达出来的。</li><li>赫拉克利特是辩证法的奠基人。毕达哥拉斯仅仅提出了奇偶、善恶这些对立的概念，而赫拉克利特开始在对立中寻求统一。他的辩证法思想有三点。第一点是一切事物都处于流变之中，“人不能两次走入同一条河流”(变化也可以看做存在与不存在的对立统一)，是发展变化的观点。第二点是一切事物都是对立统一的，对立导致和谐，相反才能向成，正如坏使好舒服、饿使饱舒服。第三点是事物的相对性和不同的评价标准，不同的人可以对同一事物有不同的认知。但辩证法容易发展成诡辩，赫拉克利特的弟子克拉底鲁只承认绝对运动不承认相对静止，提出了“人一次也不能踏入同一条河流”，这就等于承认因为世事在变化所以我们什么也把握不住，把哲学的路堵死了。</li></ul><h2 id="3-4-艾利亚学派"><a href="#3-4-艾利亚学派" class="headerlink" title="3.4 艾利亚学派"></a>3.4 艾利亚学派</h2><h3 id="克塞诺芬尼"><a href="#克塞诺芬尼" class="headerlink" title="克塞诺芬尼"></a>克塞诺芬尼</h3><ul><li>克塞诺芬尼，游吟诗人，鼎盛年公元前540年。最早对希腊神话进行解构、颠覆、怀疑和批判，这种反传统、犯众怒的人命运往往比较悲惨。针对神与人同形同性的特点，他认为不是神创造了人，而是人按照自己的形象创造了神，所以不同地域的人会有不同形象的神，而神也继承了人类恶劣的一面，如偷盗、奸淫。</li><li>克塞诺芬尼总结了前人思想(赫拉克利特的一，毕达哥拉斯的1)，认为万物的本原是“一”，“一”才是真正的全知全能的神(类似基督教的上帝)。这个神只是抽象的概念，不具有任何形体，不受任何限定。克塞诺芬尼第一次用朴素的归谬法论证了神是不生不灭的：假设神不是永恒的，神就只能是被派生出的，要么从存在中产生，要么从不存在中产生，二者最终都会推出矛盾。前人只是简单地断言，因为当时还没有逻辑推理的概念，到亚里士多德才奠定逻辑学。克塞诺芬尼也由此奠定了艾利亚学派注重论证的传统。</li></ul><h3 id="巴门尼德"><a href="#巴门尼德" class="headerlink" title="巴门尼德"></a>巴门尼德</h3><ul><li>巴门尼德，鼎盛年公元前500年，克塞诺芬尼的学生，但真正影响他的是毕达哥拉斯学派，同时也了解米利都学派，批判过赫拉克利特学派，所以对前面三个学派有继承和交汇。</li><li>巴门尼德提出了“存在者存在，非存在不存在”，但这里的概念与传统的经验相反，他认为感官认知的世界是非存在，抽象的理性世界是存在，实际上他颠覆了存在的概念。赫拉克利特的思想中也隐约暗含着这种观点，他持一种精英主义，认为逻格斯是存在，火与万物是非存在，所以一般人只能认识到非存在的表象，自己这么牛逼的人才能把握存在或本质。但巴门尼德只是把存在当做概念直接使用，没有指出存在具体是什么(其实就是抽象世界)，由此导致了后世的争论。</li><li>亚里士多德指出，四大学派的问题就在于只讨论什么是存在而忽视了存在是什么，也就是只断言诸如水土火气是存在、感官世界是存在、逻格斯是存在，但没有思考如何界定存在与非存在。</li><li>在巴门尼德看来，米利都学派的错误在于认为“非存在存在，而存在不存在”，也就是只看表象不看抽象，而赫拉克利特学派的错误在于认为“存在和非存在都存在”，因为赫拉克利特认为感官世界和逻格斯都存在，只是一个真实一个虚假。其实赫拉克利特不把话说死是因为他追求存在与非存在的对立统一，但是巴门尼德没有辩证的思想，一定要把二者严格对立，从这个角度看，赫拉克利特层次更高。</li><li>巴门尼德认为存在有四个特点：不生不灭(时间上永恒)、独一无二(不可分割)、不变不动、像一个滚圆的球体(空间上有限)。前三点是总结的克塞诺芬尼的观点，根据这三点可以推理出什么是存在，因为感官认知的一切事物都是不永恒、不独一、可变动的，所以存在自然就是抽象世界的。后来的理念论和原子论打破了存在的独一性，理念和原子遍地都是，相当于砸碎了的存在，大概是因为存在不独一能更好地解释世界。</li><li>因为找不到一个概念能归纳存在与非存在的共性，所以对万物本原的追溯会停止在存在上。巴门尼德的局限性在于只承认存在，而不承认非存在的存在性，到黑格尔就突破了这种局限，他从存在走向非存在，并讨论了存在与非存在的辩证关系。</li><li>巴门尼德认为存在是滚圆的球体，这是受毕达哥拉斯学派的影响，认为无定形是有缺陷的，连自己都定不了形怎么能产生定形的东西，所以存在一定是定形的，而球体被认为是最和谐、最完满的形状。</li><li>17世纪德国经院学者P·戈科列尼乌斯将这种关于存在的学问称为“本体论”(Ontology)，On是存在的意思，tology是学科的意思。所以本体论是哲学最基本、最重要的理论，然后再有认识论、方法论。</li><li>哲学的基本问题是思维与存在的关系。第一个问题是何者为第一性，由此区分出唯心和唯物，以及认为两者独立的二元论。第二个问题是思维与存在有没有同一性，由此区分出可知论和不可知论。巴门尼德是第一个提出思维与存在(这里指抽象)同一性的哲学家，也就是能被思想和表述的必定是存在，同时又没有不基于存在的思想和语言。</li><li>海德格尔认为巴门尼德把西方哲学引到了错误的方向上，过分关注抽象的思想而忽视了活生生的感性世界(没理解海德格尔的意思)，但从现在来看巴门尼德也确实对哲学的发展起到了相当大的积极的作用，抽象思维创造了认知发展的捷径。</li><li>巴门尼德虽然严格区分了真理(抽象思维)和意见(感官知觉)，但还是承认了意见对真理的积极意义，他说“意见虽然不含真理，你仍然要加以体验，因为必须通过全面的彻底研究，才能制服那种虚幻之见”，这其实是站在抽象世界角度的一种知己知彼的高傲态度。</li></ul><h3 id="芝诺"><a href="#芝诺" class="headerlink" title="芝诺"></a>芝诺</h3><ul><li>芝诺，巴门尼德最喜爱的学生，鼎盛年公元前468年，性情孤傲，积极参与政治斗争，最后因反对僭主被僭主打死。哲学思想上没什么建树，主要成就是论证老师的观点。</li><li>巴门尼德继承了克塞诺芬尼的归谬法来证明存在是不生不灭、独一无二的，芝诺则用归谬法补充论证了存在是不变不动、独一无二的，用悖论的形式说明运动和杂多会产生矛盾。</li><li>否定运动的悖论有二分法、阿客琉斯追龟、飞矢不动、运动场。亚里士多德对这些悖论做出了批评：二分法的错误在于对有限的距离做无限的分割导致与有限的时间产生数量上的不匹配。阿客琉斯追龟的错误在于对领先的时间做无限的分割导致与有限的距离产生数量上的不匹配。飞矢不动的错误在于承认时间的离散型而不承认其连续性。运动场的错误在于把一个运动物体经过另一运动物体所花的时间，看作等同于以相同速度经过相同大小的静止物体所花的时间。</li><li>否定多的悖论有大小论证、数的论证、地点的论证、谷粒的论证。也都是源于对有限与无限、连续与离散等概念的错误认识。</li><li>芝诺引领了一种不好的风气，只注重逻辑推理，而对事实视而不见。因为当时关于逻辑推理的思想不成熟，所以论证中会带有些许诡辩的色彩。但芝诺的论证中也含有深刻的辩证成分，所以亚里士多德把芝诺称为辩证法的创始人(赫拉克利特是奠基人)。</li></ul><h3 id="麦里梭"><a href="#麦里梭" class="headerlink" title="麦里梭"></a>麦里梭</h3><ul><li>麦里梭，巴门尼德的学生，鼎盛年公元前441年。他修改了巴门尼德的观点，认为存在在空间上也是无限的，因为如果空间有限，在它之外一定有别的东西，存在就不是独一的，就会产生先有谁后有谁的问题。</li><li>麦里梭没有像芝诺一样极端地否定运动与多，而是认为感性世界的运动与多是存在的，只不过是不真实的存在，相对于抽象世界里那个永恒的存在不过是过眼云烟。只有“虚空”才是不存在的，后来柏拉图就走的这条路。</li></ul><h1 id="4-古希腊哲学的第二-鼎盛-阶段"><a href="#4-古希腊哲学的第二-鼎盛-阶段" class="headerlink" title="4 古希腊哲学的第二(鼎盛)阶段"></a>4 古希腊哲学的第二(鼎盛)阶段</h1><h2 id="4-1-智者派"><a href="#4-1-智者派" class="headerlink" title="4.1 智者派"></a>4.1 智者派</h2><ul><li>四大学派的分歧就在于感性世界与理性世界的本原性和存在性问题，智者派大彻大悟、另辟蹊径，颠覆性地认为所谓本原可能并不存在，或者这些问题本来就是因人而异、见仁见智的问题。于是从本体论发展到怀疑论，研究重点从客观转移到了人的主观。</li><li>四大学派并不是完全意义上的的唯物与唯心的对立，他们是在承认世界有客观本原的基础上，讨论本原是一种物质的还原物还是思维的抽象物，其实都是对客观的追问，大同小异。而怀疑论是对当时自然哲学和形而上学两派思想的根本的颠覆，真正把客观问题转移到主观，认为本原是什么、客观是怎样无关紧要，重要的是世界对人来说是怎样的。但怀疑主义在哲学史的地位只是小憩，它主要深刻地解构和攻击别的思想，却不能形成自己的一套哲学体系，因为没有根基，所以看上去充满智慧、无懈可击，所以怀疑主义注定不能长久，说明既要大彻大悟也应该执迷不悟，既要解构也应该要建构。</li><li>智者派是古希腊哲学早期阶段与鼎盛阶段的过渡，解构前人启发后人。因为当时艾利亚学派影响比较大，所以智者派的攻击主要针对的是艾利亚学派的观点。</li><li>早期四大学派的分布都不在雅典，希波战争以后，雅典崛起，它所实行的民主制鼓励公民积极参与政治、表达思想，所以吸引了众多思想家的拜访，逐渐形成古希腊哲学中心。在这种鼓励思想碰撞的潮流下，辩术与修辞学变得尤为重要，于是出现了传授论辩技巧的智者派，作为以解构和攻击为己任的怀疑论者，他们所擅长的正是表达的技巧。这种表达技巧高于表达内容的风气，在芝诺与麦里梭时期就已经初露端倪，只不过雅典的民主制起到了积极助长的作用。这种论辩之风对古希腊后期发展出形式逻辑与辩证法起到了关键作用。所以智者派其实不是一个学派，而是雅典城中从事这样职业的一批人，他们自称智者(sophist)。</li><li>苏格拉底和亚里士多德等人鄙视智者派，他们认为重要的是说的内容而不是怎么说，智者的技术是一种似是而非的智慧，所以苏格拉底不屑与之为伍，他更愿意自称爱智慧(philosopher)。但罗素认为他们的贬低只是因为嫉妒智者的智慧，同行是冤家。</li></ul><h3 id="普罗泰格拉"><a href="#普罗泰格拉" class="headerlink" title="普罗泰格拉"></a>普罗泰格拉</h3><ul><li>普罗泰格拉是第一个自称智者的人，也是第一个传授论辩技术的人。他提出了人是万物的尺度，把哲学从天上拉到了人间，古罗马思想家西塞罗则认为是苏格拉底把哲学从天上拉到了人间，因为苏格拉底讨论了人的道德问题。因为智者派擅长的就是与人谈话和辩论，所以普罗泰格拉也是第一个采用辩证法，即后世所谓“苏格拉底式讨论方法”的人(不同于黑格尔那种独白式的辩证法)。</li><li>普罗泰格拉认为一切均以每个人的立场为转移，其实就是把所谓的“逻格斯”、“存在”从一打碎成多，变成每个人心里都有个一，从客观的一元主义变成了主观的多元主义，这种一变多的思想也被后来的原子论、理念论所继承，所以他们都被叫做打碎了的巴门尼德的理论。</li><li>普罗泰格拉也是第一个语言学家，对希腊语法进行了总结与修正，可能他认识到了语言的重要性，因为20世纪里海德格尔的存在主义、胡塞尔的现象学已经以一种不可知论的立场告诉我们，我们无法认识客观世界，我们存在的世界其实是我们用语言构造出的世界。从这个角度看，表达技巧其实也决定了表达的内容。</li><li>因为把一切都归结到每个人，普罗泰格拉也就成了相对主义者，提出了“一切理论都有其对立的说法”。然而普罗泰格拉把相对主义如此贯彻到底，就导致了“绝对的相对主义”悖论，也就是“一切都是相对的”这句话反而变成了绝对的，让普罗泰格拉在攻击别人的同时又产生了自我矛盾。</li><li>普罗泰格拉最高提出了社会契约的思想，他不承认有绝对的、客观的规则，自然规则见仁见智，社会秩序本质上也是人们约定俗成的一种普遍的主观性。这种普遍的主观性就是我们以为的社会意义上的客观性。</li></ul><h3 id="高尔吉亚"><a href="#高尔吉亚" class="headerlink" title="高尔吉亚"></a>高尔吉亚</h3><ul><li>高尔吉亚是芝诺的学生，杰出的辩论(诡辩)家，青出于蓝胜于蓝，用艾利亚学派的归谬法攻击艾利亚学派(杠精的祖宗)。</li><li>高尔吉亚提出了三个论点：“无物存在”、“即使有物存在，也无法认识”、“即使认识了，也无法告诉别人”。他同时否定了存在性、存在与思维的同一性、语言对存在的表述作用，这相当于全面推翻了老祖宗巴门尼德的理论。</li><li>“无物存在”的归谬论证：<script type="math/tex; mode=display">有物存在\begin{cases}该物是存在物\begin{cases}该存在物是永恒的(永恒意味着空间上无限)\begin{cases}该存在物大于它所在的地方(矛盾，无处存放了)\\\\该存在物等于它所在的地方(矛盾，既是地方又是物了，属于诡辩)\\\\该存在物小于它所在的地方(矛盾，它就不是无限了)\\\end{cases}\\\\该存在物是派生的(矛盾，存在物不能由存在物产生，又不能无中生有)\\\\该存在物既是永恒的又是派生的(矛盾，永恒与派生是严格对立的)\\\end{cases}\\\\该物是非存在物(矛盾，非存在物不能存在)\\\\该物既是存在物又是非存在物(矛盾，存在与非存在是严格对立的)\\\end{cases}</script></li><li>高尔吉亚论证得出的虚无主义结论呼应了普罗泰格拉的相对主义，因为“一切都真”必然会造成“一切都假”，因为已经无所谓真假了，整个世界说有就有说没就没，所以后世苏格拉底做的工作之一就是拯救本质。</li><li>高尔吉亚对存在、思维、语言三者的否定也揭示了两千年后的现代哲学研究的问题，传统的认识论认为语言表述思维、思维承载存在，只看到了三者的联系而忽视了三者之间的鸿沟。首先，有可能我们只是过度沉浸在思维世界里自以为我们能反映存在，但实际上思维或许永远无法触及真实的存在，或者思维对存在有遮蔽和扭曲的作用。比如康德认为存在与思维是绝对对立的，而黑格尔认为思维需要经历一系列辩证的过程才能进展到存在。其次，思维是不能用语言完全表达的，我们交流的是语言化的思维而不是思维本身，语言系统的不完善以及不同语言系统的差异也一定会遮蔽、扭曲思维。</li><li>高尔吉亚把路堵死了，所以后世的自然哲学和形而上学跳过了智者派，还是承接早期的四大学派继续发展。</li></ul><h2 id="4-2-原子论"><a href="#4-2-原子论" class="headerlink" title="4.2 原子论"></a>4.2 原子论</h2><ul><li>智者派把客观的一打碎成主观的多，而原子论是把客观的一打碎成客观的多。</li></ul><h3 id="恩培多克勒"><a href="#恩培多克勒" class="headerlink" title="恩培多克勒"></a>恩培多克勒</h3><ul><li>恩培多克勒综合了早期自然哲学的观点，提出了四根说，认为世界的本原是水火土气四种基本元素。但这不是对前人思想的简单总结，而是从寻找时间上的开端变成寻找空间上的元素。早期自然哲学中从本原到万物有一个转化链，比如气变成风，风再变成云，他们要找的本原其实是这个转化链的开端，也就是时间上的还原。恩培多克勒则认为万物不是转化而来的，而是四种元素不同比例混合直接构成的，水火土气都是永恒不变的一，他们不能互相转化只能混合组合。时间上的还原有相当大的风险和想象成分，但空间上的分解可以更大程度地基于观察。时间很难回溯，但空间分解是可操作的，能切到多小本原就有多小，这是一种兼具科学性和发展性的观点。</li><li>《心理学与生活》第13章提到的古希腊的希波克拉底提出人体有血液、粘液、黑胆汁、黄胆汁四种基本体液，个体人格是由体内何种体液占主导决定的。这种理论是受到了恩培多克勒的影响。</li><li>恩培多克勒认为四元素构成万物的动力因是另外两个独立的动力本源，爱和恨。爱是组合的力量，恨是分解的力量。恩培多克勒并没有把爱和恨归为纯粹的精神力量，他说过“爱的长和宽是相等的”，说明还是有一定物质性，因为当时希腊还没有明确的灵肉分离的思想，到阿那克萨戈拉才指出了精神和物质的区别。早期的自然哲学派都把动力因归结于质料因内部的属性或作用，比如气的收放、冷热的斥力，但恩培多克勒首次提出了独立于质料因之外的动力因。</li><li>恩培多克勒是第一个创立较为系统的认识论的哲学家，提出了流射说和同类相知说。他认为客观事物发出一种流射，作用于人的感官，组成感官的四元素能感知到客观事物的相同元素，正是同类元素的相通性使认识成为可能。这显然是相当朴素的观点。</li></ul><h3 id="阿那克萨戈拉"><a href="#阿那克萨戈拉" class="headerlink" title="阿那克萨戈拉"></a>阿那克萨戈拉</h3><ul><li>阿那克萨戈拉是第一个把哲学引入雅典的人，也是政治家伯利克里和悲剧家欧里庇得斯的老师。虽然雅典是民主制，人们还是很信仰希腊神话，阿那克萨戈拉被伯利克里反对派指控不敬神灵，最后被驱逐出境在流浪中死去，苏格拉底也是这么被迫害死的。因为古希腊的偏形而上学的哲学逐渐走向完善的过程中，会表现出与一般民众的神话、宗教观念格格不入，所以这一派哲学家在世时都比较惨，但是却成为了后世基督教文化的先驱，被基督教借鉴了很多思想。</li><li>阿那克萨戈拉提出了种子说，把恩培多克勒对本原的一分为四进一步发展成一分为无限。每个事物都各有自己的本原，称为“种子”或“同类的部分”。种子就是构成事物最小的微粒，种子的种类和数量无限多，体积无限小，性质永远不变如一，但不同的种子性质各异(原子论则强调数量不强调种类)。恩培多克勒的四发展到阿那克萨戈拉的无限是必然的，因为他对本原种类的限制没有解释，而本原种类越多方便解释的事物也就越多。但是推广到无限解释无限以后的问题在于，说了等于没说。</li><li>把本原分成无限后，事物之间看上去就只有对立而没有联系了，因此就需要解释事物之间的关系，以及事物之间是如何转化的。阿那克萨戈拉在《论自然》里提出，宇宙最初是混沌的状态，不同种子混杂在一起，通过一种旋涡运动，不同类种子逐渐分离，同类种子逐渐聚集，但是分离得不纯粹，所以事物本质上包含了多种种子，其中数量占主导的种子决定了事物的本性。因此事物之间的转化可以解释为内部某类不占主导的种子因为某种原因数量激增，改变了事物的本性(吃啥补啥的完美解释，哈哈)。</li><li>恩培多克勒和阿那克萨戈拉“化一为多，寓一于多”(就种子的概念而言，其实还是一)，把前人有形物的转化，发展成无形物对有形物的构造。这种思想对原子论有启发意义，是原子论的先驱，因为只要把种子的异质性改成同质性，就能把质料意义上的多变成构造形式上的多，就变成了原子论。其实种子的概念就相当于现在的分子，原子论是往前推进了一步。从这个角度想，阿那克西曼德是有大智慧的，他早就想明白任何有定形的物质都无法作为本原，只好提出了阿派朗。</li><li>阿那克萨戈拉还提出了心灵(nous，又译作努斯)，与赫拉克利特的逻格斯形成一组对立统一的概念。逻格斯象征着规律性、必然性，努斯就象征着自由和一种冲破规律的浪漫主义，二者相反相成，使世界既有一定规则又能不断超越、建立新的规则，形成一个辩证的发展的过程。</li><li>种子从混沌走向有序的动力因是一种旋涡运动，这种旋涡运动就是由心灵支配的。心灵与种子相反，种子是多心灵是一，种子异质心灵同质，种子是质料(物质)心灵是形式(精神)。恩培多克勒的爱和恨还遗留着一定的物质性，但阿那克萨戈拉的心灵是独立的、自为的和能动的，从外部推动宇宙，也就是独立于种子构成的物质宇宙之外，在物质之外显然就是指的精神。</li><li>心灵的提出造成了西方哲学史上唯物主义长久以来的困窘，因为阿那克萨戈拉已经把能动性归于精神方面，让后世形成了思维定式，认为物质没有能动性，这就使得唯物主义无法解释事物何以会运动。之后的原子论和现在的辩证唯物主义都是避开了这个问题，上来就说原子本来就能动、物质本来就能动，当成了不需要解释的法则，这也是唯物主义的思维定式。所以哲学里一些没有解释的、让人疑惑的东西，大概可以理解成那个时代的思维定式。</li><li>亚里士多德把他之前的哲学发展总结成四个因素：第一种是质料因，即形成物体的主要物质，比如水火土气。第二种是形式因，即背后的规律性，比如数、逻格斯。第三种是动力因，即为万物变化的动力。第四种是目的因，即让万物变化的目的。就是从心灵的概念里开始有了隐晦的目的因，因为心灵是一种精神性的东西，精神操纵物质一定是需要目的的，这与逻格斯不同，逻各斯是万物被动遵守的规则，不存在所谓的能动性，而心灵是要主动地产生改变，所以需要目的，可惜阿那克萨戈拉没有对这一点展开讨论。</li></ul><h3 id="留基波"><a href="#留基波" class="headerlink" title="留基波"></a>留基波</h3><ul><li>德谟克利特的老师，据说原子论是留基波最先提出的，但德谟克利特将其发扬光大。</li></ul><h3 id="德谟克利特"><a href="#德谟克利特" class="headerlink" title="德谟克利特"></a>德谟克利特</h3><ul><li>德谟克利特，是留基波和阿那克萨戈拉的学生，古希腊最博学的百科全书式人物。罗素认为德谟克利特代表了一种科学的方向，但当时的主流哲学过分强调了人，又出现了偏重思维世界的柏拉图大佬，所以德谟克利特的思想被掩盖了，直到2000年后才被西方学者发掘，可惜那时的科学已经远远超过德谟克利特的思想。</li><li>德谟克利特是古希腊自然哲学的顶峰，柏拉图是古希腊形而上学的顶峰，亚里士多德对两派观点进行了综合。</li><li>德谟克利特提出宇宙是由原子和虚空构成的，希腊语里原子的本意是不可分割。古代人不喜欢无限的概念，所以认为存在不可分割的最小微粒，其实物质能不能无限分割到现在也没研究明白。原子的特点有：不可分且不可入、数量无限而性质相同(只是形状次序位置不同)、在虚空中做直线运动、不生不灭。</li><li>种子和原子的概念就像现在的分子和原子，分子的不同体现在原子排列组合的数量近乎无限，原子的相同体现在原子种类的有限性(所谓性质相同不是绝对的相同)。德谟克利特的思想很超前，因为从现代物理学的角度看，基本粒子构成万物其实就只是数量的差别。</li><li>德谟克利特认为原子做直线运动，不同方向运动的原子碰撞产生漩涡并构成万物。这是为了避免偶然性，让原子受限于绝对的直线，体现出自然万物背后的必然性。后来的伊壁鸠鲁提出原子还有偏斜运动，马克思的博士论文就是从伊壁鸠鲁的偏斜运动谈到了自由意志的问题。</li><li>德谟克利特的原子和现代的原子概念上有不同，德谟克利特模糊了原子的物质性，有形而上的倾向，他认为原子的本原性在于构成万物而不属于万物，因为凡是我们能找到的物质都是无数原子构成的，原子更像是事物背后的一种必然性、规律性。原子论也因此被柏拉图、亚里士多德鄙视，原子什么都不是凭什么能构成万物。原子和万物的关系就像巴门尼德存在与非存在的关系，原子和巴门尼德存在的区别在于，原子是多而存在是一，原子永动而存在静止，从这个角度看，柏拉图的理念更接近砸碎了的存在。</li><li>原子论和理念论的分歧本质上是质料与形式的分歧，亚里士多德综合了这两点，就像现实的桌子是木头根据桌子的概念做成的，质料和形式缺一不可。</li><li>德谟克利特认为原子是存在，虚空是非存在，但与巴门尼德不同的是，他认为非存在是存在的，因为虚空是原子运动的场所，所以虚空必须是存在的。可是大家关于存在和非存在的定义都不一样，放在一起比较好像不太合适，亚里士多德的一个牛逼之处就是发现了这个问题。</li><li>德谟克利特奠定了到牛顿再到现在的人们最习以为常的时空观，世界是个无边无际的大罩子，有原子有虚空，我们在虚空里运动。其他的时空观还有笛卡尔的充实空间理论，没有虚空，世界是被物质充满的，事物在其他物质中的运动就像鱼在水中运动一样。还有爱因斯坦开创的更高级的相对论时空观。还有康德的主观时空观，他认为时空是我们人类主观感受世界的一种结果，不是客观存在的东西，比如人和狗看到的世界可能不一样。</li><li>德谟克利特认为原子的能动性是不需要解释的固有属性，同时也不需要像努斯一样的外部助力，所以他回避了动力因和目的因。但是原子既有能动性又不得不遵守直线运动的规则，就让人觉得背后一定有一种神秘的力量事先注定了这一切，所以绝对的必然性就变成了一个最大的偶然性，因为一次注定了一切的规则。当后世遇到这种绝对必然性的情况时，就提出了上帝的存在，指出世界就是上帝创造的偶然的奇迹。这个问题在我们的文化背景看来，就是必然和偶然的辩证关系。</li><li>德谟克利特还提出了比流射说更科学的影像说，物体发出与自身形状相似的影响，通过空气的作用进入人的感官，形成感觉和思想。这是唯物主义的反映论的首次明确的表达。同时他认为感觉是因人而异的，感觉获得的知识是暗昧的知识，理性获得的知识才是真理性的知识。</li></ul><h2 id="4-3-苏格拉底"><a href="#4-3-苏格拉底" class="headerlink" title="4.3 苏格拉底"></a>4.3 苏格拉底</h2><ul><li>苏格拉底一生述而不作，主要靠他的两个学生克塞诺芬尼(不是之前那个克塞诺芬尼)和柏拉图记载思想言行，前者侧重于记录生平事迹，后者侧重于记录思想。一般认为，柏拉图的早期著作真实地反映了苏格拉底的思想，而后期的著作是借苏格拉底之口表述柏拉图自己的思想。</li></ul><h3 id="认识你自己"><a href="#认识你自己" class="headerlink" title="认识你自己"></a>认识你自己</h3><ul><li>苏格拉底认为人不配拥有真正的智慧，只有神才拥有智慧，而人们普遍都没有认识到这一点，人们认为苏格拉底有智慧其实是因为他认识到了自己的无知。所以他一生都用一种批判的态度探寻智慧，对自称有智慧的人(特别是智者)进行揭露，因而得罪了不少人。因为人没有智慧，而他认为认识自然是需要智慧的，所以他进而认为人是不可能认识自然的，也就是否定了早期的自然哲学一派，觉得他们企图认识自然的行为太狂妄无知了。苏格拉底号召人们不要再去研究自然，而要把眼光拉回到人，人只应该也只能认识自己，所以西塞罗才认为苏格拉底把哲学从天上拉回了人间。</li><li>虽然普罗泰格拉也算是把哲学拉到人间，但他是把人理解成一个个独立的个体，强调人的独立性而忽视了人的联系，强调一切都是因人而异的，所以导致了相对主义。但苏格拉底思考的人是人之所以为人的本质，也就是道德伦理，所以苏格拉底被西方认为是道德哲学之父。</li></ul><h3 id="神学目的论"><a href="#神学目的论" class="headerlink" title="神学目的论"></a>神学目的论</h3><ul><li>之前的哲学家只明确探讨了质料因和动力因，苏格拉底并不满足，就像努斯安排了万物，但为什么会安排成这样。一般认为人是由两个部分构成的，即肉体和灵魂。苏格拉底关注人的这两部分就分别得出了两个结论：神学目的论和道德哲学。</li><li>通过观察人的身体构造，苏格拉底认为神的用意就表现在人的器官的某种目的性，因为他还没有进化论的高级思想，他认为人是生来如此的，人的身体构造能适应自然环境一定是因为神有目的的创造。这种论证成为了西方思想史上关于上帝存在的设计论证明的最初雏形。</li><li>我们觉得目的因荒谬是因为我们的思维定式里不承认目的因或回避了目的因，目的因很像因果论，可我们既不知道原因又不能确定结果，所以现代科学里习惯用动力因来解释现象，不考虑最初的目的也就不需要寻找最终的结果，所以可以把当前状态当做一个暂时的结果，研究动力因与当前状态的关系。</li><li>因为相信神创造人类的目的性，所以苏格拉底认为人认识自己其实是为了认识神。苏格拉底的神不同于希腊神话里的神，他认为那些与人同形同性的神都是傀儡，真正的神一定是超越它们的东西。他用一个灵异的神取代了传统的有血有肉的神，用一种理想主义和浪漫主义的生活观取代了传统的现实主义的生活观，比如他说“追求好的生活远过于活”，还认为死亡是比生活更高的境界，因为死后灵魂与神为伴，但民众的传统思想里认为好死不如赖活。苏格拉底的死就是对他这种思想的践行，他认为如果自己做了错事，“灵异”一定会出来阻止他，所以他没有做错拒不认罪。</li><li>苏格拉底的思想导致了后世基督教一脉相承的向死而生的唯灵主义，认为死后上天堂是比活着更好的境界。这与中国传统的儒家思想不同，儒家思想是现实主义的、入世的哲学，认为“未知生焉知死”、“子不语怪力乱神”，对神是存而不谈的。</li><li>毕达哥拉斯提出了灵魂转世的思想，认为肉体是灵魂的驿站，灵魂转世的本质是换个驿站，可见他认为灵魂还不能摆脱肉体。而到了苏格拉底，灵魂可以脱离肉体升华到更高的境界，肉体反而成了困住灵魂的囚牢。再到柏拉图，就进一步认为肉体有双重的罪过，一个是困住灵魂让我们道德败坏，一个是妨碍灵魂认识真理。</li></ul><h3 id="美德即知识"><a href="#美德即知识" class="headerlink" title="美德即知识"></a>美德即知识</h3><ul><li>人的另一方面是心灵，苏格拉底认为心灵的内在原则就是美德，因此美德问题是他关注的主要对象。这一点和中国的传统思想相同，《孟子》里有“人之所以异于禽兽者几希；庶民去之，君子存之。舜明于庶物，察于人伦，由仁义行，非行仁义也”，意思是人和禽兽的区别就在于伦理道德。</li><li>一般认为，知识论解决“真”的问题，道德沦解决“善”的问题，但苏格拉底第一次把两者统一，提出美德即知识。苏格拉底认为行为的善恶是相对的，因为人们评价善行恶行是看结果，对行为的理解因人而异，但他没有像普罗泰格拉一样钻牛角尖，而是跳出行为的层面，指出善的概念是一种绝对的、普遍的知识，真正的善行是人基于对善的概念的掌握做出的，不知道善的概念就只是盲目的伪善。美德是关于善的知识，同理，勇敢是关于勇敢的概念的知识，正义是关于正义的概念的知识。他还认为没有人会有意作恶，因为作恶往往会伤害自己，而人不会自己害自己，所以作恶的人都是因为无知，即“知识即美德，无知即罪恶”。这种把美德与知识等同起来的观点开创了西方伦理学中的一个重要思想流派，即唯智主义伦理学，也就是用概念的逻辑代替事物的逻辑。</li><li>后来基督教提出了一种相反的观点，认为知识反而是使人堕落、丧失道德的根源，人只要怀着纯洁的、虔诚的信仰就可以拥有道德，正如亚当夏娃的堕落就是因为偷食了知识之果。所以基督教认为最重要的三种道德是信(信仰)、望(对另外一个世界的希望)、爱，三者都与知识无关。</li><li>到了17、18世纪，经历了启蒙运动、文艺复兴、科学发展，西方文明又对知识充满了信心，认为知识就是力量，用知识可以征服自然，随着知识的增长，人不仅越来越幸福，道德水平也会提高。同时代也出现了相反的悲观主义观点，比如卢梭认为知识让人邪恶，反而是原始时期的人最淳朴善良。</li><li>苏格拉底一方面强调美德是心灵的内在原则，又认为美德作为一种知识是可以通过教育获得的。但这就面临一个问题和悖论：道德知识是人生而有之的还是后天习而得之的？如果是生而有之的就不用学了，如果是生而未知的就不知道从何学起，也就是人既不能学习已知的道德知识又不能学习未知的道德知识(别的知识还是可以学的)。</li><li>在道德知识的问题上苏格拉底得到一个悖论，后来柏拉图把它明确成知识论里的回忆说，认为理念一类的知识介于已知和未知之间，它们是灵魂生而具有的，但灵魂进入肉体时被肉体蒙蔽了以至于人们忘记了，通过后天不断地刺激与回忆又可以想起来，所以说这类知识既不是已知也不是未知。</li></ul><h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h3><ul><li>苏格拉底杠精式的对话被称为“苏格拉底式讨论方法”，也被称为“辩证法”(dialectic，希腊语原意是对话、论辩)。亚里士多德认为苏格拉底最大的贡献是归纳推理和普遍定义，因为不断提问、不断诘难的过程就是一个去伪存真、归纳定义、逐渐接近事物本质的过程。苏格拉底自称是“精神助产士”，意思是帮助别人发现他们心中隐藏的真理。这种方法可以不断深入问题，不断逼近答案，但不一定能得到答案，因为给事物下定义是很困难的。</li><li>智者派对前人思想进行解构，从相对主义走到虚无主义，走上了一条死路。原子论和苏格拉底摆脱了智者派留下的烂摊子，重新建构起一套新的哲学体系，重新建构万物的普遍本质。但苏格拉底找到的普遍性还停留在主观的精神世界、道德层面里，到了柏拉图才推而广之，寻找所有事物背后的一般性、普遍性，把主观的本质变成一种能独立于头脑的客观存在，成为了典型的唯心主义，即理念论。</li></ul><h3 id="小苏格拉底学派"><a href="#小苏格拉底学派" class="headerlink" title="小苏格拉底学派"></a>小苏格拉底学派</h3><ul><li>苏格拉底死后，学生们分散到希腊各处，形成了彼此不同的几个小学派。</li><li>麦加拉派，代表人物欧几里得、欧布里得，他们把苏格拉底的善和巴门尼德的存在结合起来，认为善是宇宙的普遍原则。欧布里得研究论辩术，提出了许多悖论，包括“说谎者悖论”、“蒙面人悖论”、“谷堆悖论”等，这其实也是像芝诺一样为了支持巴门尼德的思想，说明只有存在(善)才是绝对真实的，非存在会使人陷入思维困境。</li><li>昔尼克派(犬儒学派)，代表人物安提斯泰尼、第欧根尼，宣扬人应该像狗一样采取简单粗陋的生活方式，主张放浪形骸、我行我素的生活作风。其实就是让灵魂尽量摆脱客观世界的束缚，回归天然状态。</li><li>昔勒尼派，主张善就是快乐，对后世伊壁鸠鲁的伦理学产生了影响。</li></ul><h2 id="4-4-柏拉图"><a href="#4-4-柏拉图" class="headerlink" title="4.4 柏拉图"></a>4.4 柏拉图</h2><ul><li>柏拉图，苏格拉底的弟子，古希腊唯心主义的最高峰。政途屡屡受挫而在哲学教育上有所成就，创立了讲学的学园(Academy)，所以柏拉图一派的思想又称学园派。柏拉图的思想通过他的学生传承了下去，后来又成为了基督教神学的根基，与此相对的德谟克利特的唯物主义思想，由于没什么学生传承，又和主流的柏拉图思想相背，所以原子论的命运比较悲惨。</li><li>苏格拉底的哲学和他的人生是紧密相关的，但柏拉图政途受挫只能潜心做学问，所以他的生平经历不是很重要。</li></ul><h3 id="理念论"><a href="#理念论" class="headerlink" title="理念论"></a>理念论</h3><ul><li>柏拉图早年求学于赫拉克利特的学生克拉底鲁，克拉底鲁极端地承认绝对运动而否定相对静止，他认为语言无法表述事物，因为话说出口事物已经变了。这里的事物就是巴门尼德的非存在，柏拉图认为语言虽然不能表述非存在，但可以表述存在，也就是感官只能捕捉现象，思想只能把握本质。</li><li>从存在论的角度看，世界分为感性世界和本质，米利都学派只谈感性世界(水火土气)，毕达哥拉斯主要谈本质(数)，赫拉克利特两者都涉及(火和逻格斯)，巴门尼德把本质叫存在把感性世界叫非存在。从认识论的角度看，感性世界是感官的对象，本质是思想的对象，从毕达哥拉斯开始，普遍认为思想把握到的东西是更重要的，苏格拉底的一般定义也是关于本质的定义。思维的工具就是语言，所以语言不能表述事物是因为不再一条认识途径上，本质、思维、语言是一条线上的，所以到了柏拉图，存在、思维和语言三者就统一了。前人一脉相承的这种思想在发展中逐渐清晰，所以到了柏拉图就能够明确地将本质表述为理念论。</li><li>柏拉图的理念与苏格拉底的定义有两点区别。第一点，苏格拉底的定义局限于人的主观精神世界，他对自然界的客观事物不感兴趣，而柏拉图把理念扩展到整个宇宙，认为所有自然物和人造物也有自己的理念。第二点，苏格拉底对客观世界不感兴趣，所以他的定义仅仅是寓于事物之中的一种抽象概念，他并没有深入探讨这种概念本身是不是独立的客观存在，而柏拉图把理念实体化和客观化，理念既独立于客观事物又可以脱离大脑存在，他甚至认为万事万物的理念共同构成了一个独立于自然界的理念世界，所以列宁对此评论“原始的唯心主义认为：一般(概念、观念)是单个存在物。这看起来是野蛮的，骇人听闻的(确切些说：是幼稚的)荒谬的”。理念的人格化就是所谓的上帝，就像上帝是万事万物的根本，但上帝不属于万事万物也不属于人的精神世界，所以柏拉图的理念世界就相当于一个没有人格化的上帝但是客观存在的上帝头脑中的威望(因为上帝是根据头脑中的概念创造世界)。由于承认理念世界的客观性，所以柏拉图是客观唯心主义。</li><li>柏拉图认为具体事物是对理念的摹仿和分有，具体事物的形象是对原始理念摹仿的结果，虽然摹仿出的形象各不相同(大小长短等形态上不同)，但他们都或多或少分有了原始理念的一部分(再丑的人也是人)。又因为摹仿是不完美的，所以具体事物相比于完美的理念一定存在或大或小的缺陷，理念是具体事物追求而不可到达的目标。然而柏拉图并没有解释摹仿和分有具体是如何实现的，提出了一种解释却狡猾地回避了可实现性，因此亚里士多德在《形而上学》里对此评价“只不过是说空话,打诗意的比方而已”，罗素也认为柏拉图是浪漫主义的热情而亚里士多德是实证主义的审慎。</li><li>柏拉图把理念世界由低到高分成几个层次：<ul><li>自然物的理念：人、马、花、草等。</li><li>人造物的理念：桌子椅子等。</li><li>数学意义上的理念：三角形、圆、大于小于等，因为古希腊对数学比较感兴趣。</li><li>范畴意义上的理念：存在与非存在、静止与运动等。</li><li>道德和审美领域的理念：美、勇敢、正义等。</li><li>“善”的理念：终极理念，所有理念共同追求的最高目标，比苏格拉底的善更高级。</li></ul></li></ul><h3 id="“善”的理念与神创世界"><a href="#“善”的理念与神创世界" class="headerlink" title="“善”的理念与神创世界"></a>“善”的理念与神创世界</h3><ul><li>柏拉图把世界分成理念世界、感性世界和原始物质三个层面，原始物质通过对理念的摹仿与分有，形成了感性世界里的具体事物。巴门尼德把理念世界叫做存在，把感性世界和原始物质叫做非存在，而柏拉图在此基础上进行了细分，理念世界是存在，原始物质是非存在，中间的感性世界叫做虚假的存在。理念不仅赋予了客观事物以实在性，也就是让原始物质成为感性世界的事物，同时还赋予了我们主观上认识的能力，我们从理念世界抽离出理念到头脑中从而认识感性世界的事物。所以在柏拉图看来，人的主观世界和自然的客观世界不是简单的反映与映射的关系，而是在更高层的理念世界的协调下得以用主观精神认识客观事物，这种包含客观精神、客观事物和主观精神的三分世界的思想在近代哲学中有很多人支持，比如笛卡尔、斯宾诺莎、莱布尼茨。</li><li>从四因说的角度看，原始物质是质料，理念赋予了质料以形式，感性世界为了追求终极的“善”而进行摹仿和分有，所以“善”又是目的因，终极的“善”就像磁铁一样吸引底层理念和万事万物追求自己，所以“善”还是创造世界的根本动力。因此理念世界集形式、目的、动力三因素于一体，相对的是原始物质的质料因，这就是柏拉图的创世说，又叫做巨匠说，因为创造万事万物是需要原材料的，也就是把原始物质加工成具体事物。相比之下，基督教的创世说就不需要原材料，一切都是上帝凭空创造的。</li><li>柏拉图对创世说的表述是：“让我们来看一看造物主为什么要创造这个生灭变化的世界。他是善的，而善的东西就不会嫉妒任何东西。既然他是不会嫉妒的，因此他愿意使一切东西尽可能和他相像。这就是我们可以完全正确地从有智慧的人那里学来的宇宙变化的最高原则。”可见，“善”是创世的终极目的和动力。</li></ul><h3 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h3><ul><li>回忆说是柏拉图的认识论，正如理念论是柏拉图的存在论，认识论和存在论是一一对应的，所以我们的知识是对应的理念世界的东西。柏拉图的回忆说有三个重点。第一点，灵魂在进入肉体前居住在理念世界里，因此灵魂已经具有了关于各种理念的知识，但在进入肉体后受到肉体的遮蔽而暂时忘记了关于理念的知识，需要感觉经验的刺激才能回忆起来。因此在回忆说中，客观精神、主观精神、客观事物三者缺一不可，认识的过程就是客观事物刺激主观精神回忆起理念世界的知识，这就是典型的“先验论”，也就是在经验之前已经有了知识。第二点，回忆的内容是理念的知识，是事物的本质，而不是对某个具体事物的回忆，比如我们看到各种颜色各种形状的花，在这种刺激下回忆起的是抽象的花的概念，而不是某种特定形象的花。第三点，回忆是一个顺着理念的层次不断上升的过程，需要调动灵魂的主体能动性，能动性越强，回忆到达的层次就越接近终极的“善”，所以教育的目的也是为了提高能动性，进而提高人的认识(回忆)能力。</li><li>柏拉图用“洞喻”表述了认识的过程就是灵魂的不断“转向”，从洞壁转向洞口，从洞口转向外界，最后转向天上的太阳，所谓“转向”就是一个不断反思、不断超越假象，一步步走向事物本质的过程。整体上呈现为一个线性的上升过程，所以柏拉图又用“线喻”表述这个上升的过程，把一条线段分成三个部分表示知识的不同阶段，这三部分在存在论意义上表示原始物质、可见世界和可知世界，与之对应的认识论意义上的表示为无知(原始物质不具有知识)、意见(分为低级的想象和高级的信念)和真理(分为低级的理智和高级的理性)。</li><li>因此线性上升的认识过程就是：想象→信念→理智→理性。其中，可见世界的事物是对理念的摹仿和分有，所以从可见世界得到的想象和信念是低级的知识，比如马是对马的理念的摹仿，从马得到的知识是信念，马的画像是对马的摹仿，从马的画像得到的知识是想象，所以二者都是低级知识，而想象比信念更低级。可知世界的知识虽然是直接的理念，但由于理念也分六个层次，理念的知识也就有理智和理性两个层次， 像自然物、人造物、图形、大小关系，并不是彻底抽象的东西，还或多或少关联于所衍生出的具体事物，比如马的理念不能完全脱离马，所以理智相对低级，而范畴、道德和“善”三个层次的理念可以完全脱离具体事物讨论，所以理性相对高级，柏拉图又把理性叫做辩证法。(关于理智和理性的区别没完全理解，留坑)</li></ul><h3 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h3><ul><li>柏拉图的辩证法是一种研究纯粹理念的逻辑联系与相互转化的学说，不涉及抽象概念与具体事物之间的关系，所以不涉及低级的理智知识，探讨的对象是存在与非存在、动与静、一与多这类更抽象的范畴。之前的哲学家只强调这些范畴的对立而忽视统一，正如巴门尼德承认存在否定非存在，芝诺承认静否定动，柏拉图则发现这些纯粹哲学范畴有向对立面转化的内在必然趋势。比如在考察“一”的时候，“一是一”其实就包含了“一”和“是”两个范畴，因为“是”不是“一”，所以也就得到了两个范畴，也就是“多”，这就是“一”到“多”的转化。再如考察“无”的时候，一旦我们提到“无”，就已经承认有了“无”，那么“无”就变成了“有”。</li><li>对立范畴之间永无休止地转换，这与赫拉克利特所谓的变是一样的，都是消极的观点。柏拉图更进一步提出了“通种论”，把对立范畴的矛盾统一到第三者上，也就是用一个更普遍的“种”的概念统一对立双方。比如有无之间的转换都属于“变”，动静之间的转换都属于“存在”。在对立冲突中产生积极的观点，这就是黑格尔所谓的“积极的辩证说”。</li></ul><h3 id="理想国"><a href="#理想国" class="headerlink" title="理想国"></a>理想国</h3><ul><li>柏拉图出身于雅典贵族，在苏格拉底死后，他对雅典的民主政治充满了失望和仇恨，他在《国家篇》(又译作《理想国》)中提出了自己的政治观点，认为整个世界是由“善”的理念所统辖的秩序井然的体系，因此掌握了“善”的知识的人(哲学家)应当成为一个等级森严的国家的主宰，也因此他鄙视雅典的民主政治，崇尚斯巴达的寡头政治。</li><li>柏拉图认为国家是放大了的个人，人的灵魂由三部分构成，理性、意志和欲望，这三个部分各有其德性，即理性追求智慧，意志追求勇敢，欲望追求节制，当三个部分都恪守自己的德性时，整个灵魂也就到达了自然和谐，从而实现了最高的德性，即正义。灵魂的三部分对应国家的三个阶级，统治者、保卫者和劳动者，当三个阶级各司其职时，整个国家也就变成了遵循“正义”原则的“理想国”。其中，统治者是靠智慧统治国家，所以哲学家和统治者融为一体，成为一种“哲学王”。</li></ul><h2 id="4-5-亚里士多德"><a href="#4-5-亚里士多德" class="headerlink" title="4.5 亚里士多德"></a>4.5 亚里士多德</h2><ul><li>亚里士多德，柏拉图的学生，亚历山大的老师，因为常常与学生们一边散步一边教学，他的学派被人们称为“逍遥学派”。关于和亚历山大的关系，黑格尔认为“亚历山大的精神和事业的伟大乃是来自亚里士多德深刻的形而上学”，而罗素认为亚里士多德对亚历山大的影响是零，亚历山大不愿意接受教育，他对待亚里士多德就只能是认为他是一个迂腐的没有趣味的老头。</li><li>亚里士多德注重科学、理性、逻辑，所以当中世纪早期基督教兴起后，亚里士多德的哲学在西方沉寂了很久，反而在北非的埃及等地被伊斯兰教发扬光大，公元十二世纪后因为十字军东征等原因才传回西方。</li></ul><h3 id="对理念论的批判"><a href="#对理念论的批判" class="headerlink" title="对理念论的批判"></a>对理念论的批判</h3><ul><li>“吾爱吾师，吾更爱真理”，亚里士多德从科学的角度对理念论进行了批判。</li><li>第一点，理念只能寓于具体事物中，因为理念作为具体事物的本质，不可能独立于具体事物存在并与具体事物相对立，同时在时间上、逻辑上又先于具体事物存在。</li><li>第二点，柏拉图论证理念存在的方法站不住脚，它们或是缺乏必然性的推论，或是推出了一些没有与之对应的东西的理念。比如“否定了的东西”、“缺乏”也有其理念，但本来就没有的东西怎么可能会有对应的理念。再比如理念是具体事物追求的目标，按理说应该比具体事物更完美、更完善，但脏东西也有其理念，它的理念应该在某种意义上比脏东西更脏，所以此时理念的完美变成了一种贬义反而仍能吸引脏东西追求它，这种动力显然是荒谬的。再比如将具体事物与理念分离必然会导致“第三者”的出现，“大”的理念在大人和大树上的体现不同，说明大人和大树不是摹仿的同一个“大”的理念，所以原始的“大”的理念和大人大树之间一定存在着类似大动物和大植物的事物，大人摹仿大动物而大树摹仿大植物，这种第三者的存在会无限推下去。总之意思到了就行，因为柏拉图没提到摹仿和分有的实现过程，所以可批判的漏洞太多了。</li><li>第三点，亚里士多德认为“分有”只能是对“实体”的分有，“非实体”的东西也具有理念就和“分有”矛盾了。其次，“摹仿”是无稽之谈，不论人的理念是否存在，现实里的人都是该生生该死死。最后，如果事物是对理念的摹仿，那么人本身既是对动物的摹仿，同时又是每个个体摹仿的对象，所以人本身既是原本又是摹本，就矛盾了。</li><li>第四点，理念对于认识事物没有任何意义，它只是下断言而没有解释性。理念本身是不变不动的，所以不能成为具体事物运动的原因。其次，摹仿和分有不能解释事物生成的过程，理念的存在反而让人们需要认识的东西变多了。</li><li>亚里士多德解决这些问题的方法是有机论，也叫生成论。事物之所以会运动是因为有内在的目的性在驱使它，事物就像一个生命体，具有一个内在物让它顽强地生长成它所要趋向的东西，而不需要对外在物的摹仿和分有。</li></ul><h3 id="第一哲学及存在论"><a href="#第一哲学及存在论" class="headerlink" title="第一哲学及存在论"></a>第一哲学及存在论</h3><ul><li>亚里士多德更像一个讲逻辑、有科学精神的哲学家，而柏拉图更像一个诗人。</li><li>亚里士多德认为哲学是一切科学的总汇，分为理论科学、实践科学和艺术三大部分，其中理论科学又分为第一哲学(即形而上学，形而上是后人起的名字)、物理学或自然哲学，以及作为方法论的逻辑学，实践科学则包括伦理学和政治学。柏拉图鄙视艺术，但是亚里士多德比较认同艺术。</li><li>后人编纂亚里士多德的著作时，认为第一哲学的名字奇怪，但又不好分门别类，所以编在物理学后边，起了个暂时的名字metaphysic，meta是指在…之后，physic是指物理学。其他学科探讨的是作为某种特殊物的存在，比如作为自然界的存在、作为道德的存在、作为艺术的存在，但第一哲学是关于存在本身的学科，也就是关于存在的存在。亚里士多德把第一哲学作为哲学的根本可能是受柏拉图的影响，柏拉图就认为具体事物背后的理念比事物本身更重要，所以亚里士多德会认为研究存在本身是最重要的。metaphysic这个词汇本身没什么特殊意义，但因为指代第一哲学所以地位很高，后世把它等同于本体论(Ontology，又叫做存在论)，所以可以说本体论就是形而上学的核心。后来西方哲学先传到日本，由于日本受中国哲学影响较深，所以明治时期著名哲学家井上哲次郎根据metaphysic指代的意思，并结合中国《周易》里的“形而上者谓之道，形而下者谓之器”，最终将metaphysic翻译为“形而上学”(严复翻译成“玄学”，意思也差不多，因为“玄”就是高深的意思)。而到了黑格尔的时代，形而上学反而成了与辩证法相对的一种包含贬义的哲学，以至于影响了马克思，扭曲了形而上学的本意，使得我们认为形而上学是指片面的、孤立的、静止的思维方式。</li><li>亚里士多德认为定义是最首要的问题，“是什么”比其他问题更重要，之所以把第一哲学作为根本，就是因为第一哲学是对存在本身的理解。反观前人，巴门尼德虽然提出了存在，但没有解释存在是什么。苏格拉底虽然开始对本质进行追问，但仅仅局限在人的伦理道德上。柏拉图虽然把本质推广到万事万物，但理念只是存在砸碎成多的结果，他还是没有解释存在本身是什么。</li><li>前人都在探讨什么是存在，亚里士多德开始探讨存在是什么，就像前人一直在思考本原是什么，却没有对本原有一个清晰、严谨的定义，所以出现了分歧。亚里士多德从逻辑学出发，逻辑学里传统的下定义的方法是“定义=属+种差”，其中“属”是大类，比如人是动物属，“种差”是与同属的其他种类事物的差别，比如人和其他动物的差别是理性，所以人可以定义为“人=动物+理性”。然而对存在下定义不能用这个方法，因为没有比存在更高的“属”，所以亚里士多德换了个角度，考虑存在往下能分成几类，他认为可以分成两类：偶然的属性和必然的本质。偶然的属性即偶性，它不影响事物本质所以不重要，比如人的好坏不影响作为人的事实。必然的本质即范畴，是事物必须具有的东西，包括实体、性质、数量、关系、时间等，在这些范畴上有改变，事物的本质也就变了，比如人有两个头就不算人了。这些范畴中，最重要的就是实体，所以实体就是必然本质里的核心范畴，“存在是什么”的问题也就转化为“实体是什么”，第一哲学也因此又叫做实体哲学(研究不了整体就研究里面最重要的部分？两者没有差别么？)。</li></ul><h3 id="实体是什么-狭义的实体学说"><a href="#实体是什么-狭义的实体学说" class="headerlink" title="实体是什么(狭义的实体学说)"></a>实体是什么(狭义的实体学说)</h3><ul><li>实体(希腊语略，拉丁语substance)是作为哲学最基本的范畴是第一性和独立存在的。亚里士多德在《范畴篇》中对它的定义为：“实体，在最严格、最原始、最根本的意义上说，是既不述说一个主体，也不依存于一个主体的东西，如个别的人、个别的马”。这句话是从逻辑学的角度分析的，亚里士多德认为逻辑和存在是对应的，逻辑是对存在的一种抽象的、理性的概括，所以逻辑学的表述其实也是用一种抽象的、经验的方式表述的客观事实。在亚里士多德以后，逻辑才越来越形式化，形式逻辑逐渐重视形式而忽视内容，变成脱离现实的纯粹的概念之间的推演。但从发生学的角度看，形式逻辑的概念判断推理都是源于对现实世界、对真实存在事物之间关系的一种理论概括。</li><li>回到实体的定义，“不述说一个主体”，从逻辑学上解释，是指实体不能在一个陈述句里作为谓语来述说主语，我们可以说“苏格拉底是人”，其中人作为谓语修饰苏格拉底，所以人不是实体，我们不能反过来说“人是苏格拉底”，所以苏格拉底是实体，以实体作谓语的陈述句都是不合理的，比如“苏格拉底是苏格拉底”这句话是没有意义的，所以亚里士多德举的实体例子里都有“个别的”。“不依存于一个主体”，是指实体必须独立存在。简言之，实体就是独立存在的个别的东西。</li><li>实体有四个特点。第一，实体是具体的、个别的东西，这就与柏拉图的思想相反，柏拉图的理念不是“个别的”，而是一般、普遍的东西，他认为普遍的东西比个别的东西更具有实在性。第二，实体不同于属性，它没有与之相反的东西，比如冷热、大小是彼此相反的，但是没有与“苏格拉底”相反的东西(当时还没有反物质的概念)。第三，实体没有程度上的差别，也就是实体没有可比性，不能说一个实体比另一个实体更怎样。第四，实体是变中之不变，实体承载的具体属性可以变化，但作为实体本身是不变的。</li><li>亚里士多德虽然更爱真理，但也是爱老师的，后来他又倒向了柏拉图，提出了“第二实体”的概念，之前定义的实体就成了“第一实体”。第二实体就是“种”和“属”的概念，与第一实体的区别就在于可以述说主体，不再是“个别的”，所以“人”可以是第二实体，一般性的“理念”也是第二实体，虽然第二实体没有客观具体的指代对象，但在逻辑上是可以独立存在的概念。第二实体让亚里士多德部分回到了理念论，但他从此陷入了自相矛盾，实体是没有可比性的，而第一实体却明显比第二实体更实体，这种矛盾在某种意义上代表着强调个别事物的唯物主义与强调普遍概念的唯心主义之间的矛盾。</li></ul><h3 id="实体的原因是什么-四因说"><a href="#实体的原因是什么-四因说" class="headerlink" title="实体的原因是什么(四因说)"></a>实体的原因是什么(四因说)</h3><ul><li>亚里士多德在总结前人思想的基础上提出了四因说：质料因、形式因、动力因和目的因。正如水火土气是质料，数和逻格斯是形式，爱和恨是动力，努斯一直到苏格拉底又蕴含着目的。</li><li>亚里士多德认为四因在人造物中是彼此区别的，但在自然物中，形式因、动力因和目的因是合一的。比如做一个桌子，木料是质料因，桌子的形象是形式因，工匠的手艺是动力因，桌子的用途就是目的因。如果在自然界中也这样考虑四因，就需要引入一个类似工匠的外在的神，但亚里士多德不承认外在的神，动力和目的不能是世界之外的神提供的，所以就把动力因和目的因都归于形式因，形式因既是使质料成为事物的动力，同时又是质料要趋向的目的。在这个角度上，四因又可以归结为质料因和形式因这两个最基本的原因。</li><li>亚里士多德持一种生成论的思想，而不是机械论。他的父亲是医生，所以他在父亲的影响下倾向于把世界看做一个生命体。质料不是把事物分割成不可分的微粒，而是事物生长的起点，比如树的质料因是种子，而不是把树碾碎得到的粉末，树的形式因就是种子要长成的那个大树的形象，正是这个形式驱动着种子朝着目标不断发展(因为石头没有生命，所以石头的质料才是粉末)。这与目的论的区别就在于动力和目的是外部施加的力量，还是质料内部具有的内驱力。</li><li>任何实体都是质料与形式的统一，二者缺一不可，这就相当于把德谟克利特和柏拉图两派思想统一了起来。但亚里士多德又认为，形式因比质料因更重要。比如人的质料可以长成任何人的样子，但只有形式能让人长成特别的个体。形式代表一个实体的个别性，因而比具有无定形的普遍性的质料更是实体。形式才是使一个实体之成为“这一个”实体的东西，即作为本质的实体。</li><li>事物的形式与质料是相对的概念，对于低一级的事物是形式的东西，对于高一级的事物就成了质料。比如砖瓦既是泥土的形式又是房子的质料，房子既是砖瓦的形式又是街道的质料。这就成了一种辩证的观点，整个宇宙就变成一个从质料到形式交替上升的统一序列。但这个序列不是无限长的，无限的话就成了哲学家们讨厌的相对主义，所以一定存在一个最下端的不能作为形式的“纯质料”，以及一个最顶端的不能作为质料的“纯形式”，这是逻辑上的需要。在柏拉图的理论里，理念世界就是“纯形式”，原始物质就是“纯质料”，中间的部分就是感性世界，但亚里士多德的高明之处就在于把中间的部分解释成一个动态的、自底向上生长的序列关系，所以亚里士多德不需要引入神，因为这种向上生长的趋势就是动力与目的，而柏拉图只能提出神创世界。但是亚里士多德没有再继续解释形成这种生长关系的原因是什么，好像他觉得不需要解释，就像进化论没有解释为什么要进化一样。</li></ul><h3 id="实体是如何生成的-潜能与实现"><a href="#实体是如何生成的-潜能与实现" class="headerlink" title="实体是如何生成的(潜能与实现)"></a>实体是如何生成的(潜能与实现)</h3><ul><li>亚里士多德立足于目的论，提出了潜能与实现，其实就是上面的形式与质料对立统一的思想。任何事物都由质料和形式构成，形式看似是后于质料的结果，其实是先于质料的内在动机，当质料尚未获得该形式时，就叫做处于潜能状态，当获得该形式时，就叫做实现。潜能和实现是同一事物的两种不同的存在状态，实体的生成过程就是从潜能向实现的转化过程，这个转化过程就是运动。</li><li>潜能和实现也是相对的概念，比如人活的每一天都是相对于昨天更进一步的实现，同时又具有实现明天的状态的潜能，所以万事万物永远在运动。结合质料与形式的转化链，“纯质料”就是绝对潜能，“纯形式”就是绝对实现，二者之间的就是潜能与实现的不断转化。</li></ul><h3 id="认识论-1"><a href="#认识论-1" class="headerlink" title="认识论"></a>认识论</h3><ul><li>哲学的传统就是重理性轻感性，认为感官体验到的世界是不可靠的，但亚里士多德的认识论表现出一种折中与调和的特点。一方面，他表现出经验主义的倾向，承认感觉的重要性，我们对第一实体(个别事物)的认识只能从感觉开始，然后才能通过这种感觉经验上升我们的认识，这就不像之前的哲学家对感觉经验有明显的鄙视的态度。另一方面，他又表现出唯理主义的倾向，认为感觉只能感受事物的形式而不能把握其本质，他提出了“蜡块说”，把人的感性灵魂比作蜡块，事物在蜡块上只能留下形状的印记，所以我们的感觉只能认识到事物的表象，此外，通过感觉只能认识个别的事物，而不能把握一般性、普遍性的东西，因为普遍的东西是内在于理性灵魂之中的。</li><li>感觉是个别性知识的直接来源，而普遍性的知识内在于理性灵魂，感觉经验只是普遍知识的触媒，这就类似柏拉图的回忆说，回忆也是内在于灵魂的普遍性知识，需要在外界刺激下才能回忆起的。亚里士多德把理性灵魂分为两个部分：一部分是受到肉体遮蔽的消极被动的理性灵魂，它以外界事物为对象，建立在感觉、记忆和经验的基础之上，随着肉体的死亡而消失。另一部分是积极能动的理性灵魂，它摆脱了肉体束缚，只以自身为对象，只思维不涉及任何质料的“纯形式”，他不随肉体死亡而消失，而是以一种神秘的方式进入其他的肉体里，这一部分就类似柏拉图的理智和理性，都是真理，但是理智不能摆脱外在事物，而理性是彻底抽象的。亚里士多德还持有一种精英主义的观点，他认为积极能动的理性灵魂只存在于自由人身上，奴隶只有消极被动的理性灵魂。</li></ul><h3 id="逻辑学"><a href="#逻辑学" class="headerlink" title="逻辑学"></a>逻辑学</h3><ul><li>亚里士多德是形式逻辑的开创者，他创建了范畴表和谓词表。</li><li>谓词表是对谓词的分类。逻辑最重要的三个因素是概念、判断和推理，从判断的角度来说，一个判断句中的谓语比主语更重要，也就是“A是B”中的“B”判断性更强。所以他只对谓词做了分类，首先可以分为两大类，即属于定义的部分和不属于定义的部分，前者是对事物本质的规定，比如“桌子是木制品”，后者仅仅表示事物的某种性质，比如“桌子是圆的”或“人在动”。其次根据谓词所表述的内容又可以细分成五类，包括属、种差、定义、属性和偶性(有的地方把属和种反过来了，是翻译的问题，总之大的类是genus，小的类是species)，以人作主语为例子，“动物”是属，“有理性”是种差，“有理性的动物”是定义，这三类谓词是对本质的规定，属于定义的部分，“能学习语法”是属性，“白种人”是偶性，这两类谓词是关于性质的表述，不属于定义的部分。</li><li>范畴表是亚里士多德对客观存在进行归纳和抽象的基础上提出的十个范畴，分别是实体、数量、性质、关系、地点、时间、姿态、状态、动作和遭受，后来又增加了与事物变化相关的五个范畴，分别是对立、先于、同时、运动和所有。</li><li>在判断理论上，亚里士多德把判断分成了四类，包括“质”的判断、“量”的判断、“关系”的判断和“模态”判断。“质”的判断包括肯定判断和否定判断，也就是“是”和“不是”。“量”的判断包括全称判断和单称判断，也就是“所有…都…”、“某些…都…”和“某个…是…”。“关系”的判断包括简单判断和复合判断，复合判断就是多个判断构成的总的判断。“模态”判断即实然的、必然的和可能的判断。</li><li>亚里士多德在推理上的成就是制定了演绎三段论推理法则。从形式逻辑的角度可以把推理分成演绎推理和归纳推理，演绎推理是从一般到特殊，归纳推理是从特殊到一般。他针对三段论提出了4个格和24个式。都是逻辑学里的东西，略。</li><li>亚里士多德还提出了三段论演绎的三条公理，即同一律(真的判断永远为真)、矛盾律(互相矛盾的判断不能同时为真)和排中律(两个互相矛盾的命题之间不能有居中者)。</li><li>归纳是经验方法，演绎是纯逻辑推导方法，因为演绎法不能穷尽所有可能的情况，所以亚里士多德重演绎而轻归纳，导致他在自然科学方面有很多错误的观点，比如被伽利略证伪的铁球落地的结论。到了16、17世纪，近代实验科学和经验论之父弗朗西斯·培根开始注重归纳推理，他针对亚里士多德的《工具篇》写了《新工具》，强调经验归纳，反对单纯的演绎和证明。</li></ul><h3 id="伦理学"><a href="#伦理学" class="headerlink" title="伦理学"></a>伦理学</h3><ul><li>亚里士多德反对苏格拉底把美德等同于知识(即道德知识)的观点，他把美德分成了心智方面的知德和道德方面的行德。知德与道德知识有关，知识越多则心智上的美德越多，这种美德体现在人的理性沉思活动中，能从中获得悠闲自适且持久不变的愉悦，也就是有知识的人内心世界丰富，能自得其乐。行德与道德知识无关，亚里士多德对此提出“中庸”学说，把灵魂分成了激情、官能和性格状况三个部分，其中激情和官能谈不上美德，只有性格状况才存在美德和恶行的问题，道德上的美德就是以中庸之道对待激情。</li><li>中庸有以下特点：第一，中庸不是一个绝对的居间者，而是要具体情况具体判断。第二，中庸是与过度、不足这两端相对立的，因此它不是一个量的概念，而是性质上的概念。第三，中庸既与过度对立又与不足对立，所以可以理解成中庸就是“非两端”，因此中庸本身内部就不能再有过度和不足这种极端的概念。</li><li>基于中庸的观点，亚里士多德提出了他的政治观点，认为社会应该由不强不弱、不富不贫的中产阶级来统治。</li></ul><h1 id="5-古希腊哲学的第三-衰颓-阶段"><a href="#5-古希腊哲学的第三-衰颓-阶段" class="headerlink" title="5 古希腊哲学的第三(衰颓)阶段"></a>5 古希腊哲学的第三(衰颓)阶段</h1><ul><li>亚亚里士多德之后，古希腊城邦时代被亚历山大终结，建立了亚历山大帝国，开创了希腊化时代，希腊化是指希腊文化随着亚历山大帝国的扩张影响到埃及、西亚等地的文化。而后大帝国分裂成马其顿王国、托勒密王国和塞琉西王国。在城邦的时代，公民是自己的主人，城邦兴衰匹夫有责，所以人们关心国家、宇宙这种宏大主题，当帝国把自由的公民变成了臣民，表面上是空前的繁荣，实际上也是公民地位的丧失，国家和人民的命运基本掌握在强权的手中，人们对社会逐渐失望，没有了思考形而上的动力，变得只关心个人的安身立命，注重肉体的享乐。哲学堕落成伦理学，由引导人们追求真理的火炬变成了跟在生存斗争后面收拾病弱伤残的救护车。</li><li>这个时期的三大学派的特点是，对世界不感兴趣，在一个没有希望的世界里追问人如何活得幸福。这种消极的哲学而后导致了基督教哲学的出现，既然在这个世界了无希望，人们就把眼光投入到另一个世界(天国)。三大学派在某种意义上也算是后现代主义，对前人的宏大的哲学体系进行解构，像智者派一样认为本原、形而上之类的问题都不重要，一切都是因人而异的，人的感觉才最重要。</li></ul><h2 id="5-1-伊壁鸠鲁学派"><a href="#5-1-伊壁鸠鲁学派" class="headerlink" title="5.1 伊壁鸠鲁学派"></a>5.1 伊壁鸠鲁学派</h2><ul><li>伊壁鸠鲁认为哲学的目的是“寻求生活宁静之道”，哲学就是通过论辩和讨论的方式来获得幸福的一种活动。他把人们心灵不得宁静的原因归结为三点，一是自然灾害，二是对死亡的恐惧，三是人际矛盾与冲突。针对这三点，伊壁鸠鲁分别提出了原子论的宇宙观、感觉主义的认识论，以及快乐论的伦理学。</li><li>伊壁鸠鲁继承和发扬了德谟克利特的原子论，德谟克利特认为原子有形状、次序、位置等差异，伊壁鸠鲁认为原子还有重量上的区别。原子运动的原因有二，一是自身重量使原子在虚空中垂直下落，二是下落过程中产生偏斜导致原子相互碰撞，碰撞形成旋涡运动，从而构成万事万物。伊壁鸠鲁把这种偏斜的原因归结为偶然性，这就突破了德谟克利特强调原子运动必然性所导致的宿命论观点，马克思在博士论文中指出原子的偏斜运动体现了个体的能动性和自由意志。</li><li>伊壁鸠鲁认为宇宙间存在着许多彼此相似的世界，神存在于世界之间的缝隙中，它微不足道，并不能影响世界。自然灾害是原子运动导致的纯自然现象，因此不值得恐惧，也没必要谈神论鬼。</li><li>伊壁鸠鲁在认识论上倡导感觉主义，主张永远要以感觉以及感触作根据。感觉具有真理性，因此感觉本身是不会错的，错误只能源于理性对感觉的误判。</li><li>伊壁鸠鲁认为灵魂也是原子构成的，灵魂的主要功能就是感觉。人死后，构成灵魂的原子就消散了，也就丧失了感觉的能力。因此死亡不值得恐惧，生前感觉不到死亡的痛苦，死后也不能感觉到痛苦。(但是从生到死的过程是痛苦的呀！)</li><li>伊壁鸠鲁在伦理学上倡导快乐论。他认为社会是通过社会契约构成的，人们应该通过法律或契约尽可能维护这个社会，实在维护不了至少可以洁身自好、独善其身。伊壁鸠鲁的快乐主义又叫享乐主义，他所追求的快乐是肉体上的淡泊和精神上的安宁。然而，当西塞罗把哲学传到罗马时，推崇斯多葛学派，贬低伊壁鸠鲁学派，误导人们把快乐主义理解成了纵欲主义，败坏了伊壁鸠鲁的名声。</li><li>后人把伊壁鸠鲁的伦理学概括为医治心灵的四药方，即神不足惧、死不足忧、乐于行善、安于忍恶。秉持着这种宁静淡泊的生活态度，人际矛盾与冲突自然就不成问题了，这其实有点消极避世的态度。</li></ul><h2 id="5-2-斯多葛学派"><a href="#5-2-斯多葛学派" class="headerlink" title="5.2 斯多葛学派"></a>5.2 斯多葛学派</h2><ul><li>后人把伊壁鸠鲁学派理解成纵欲主义，与之相对的是代表禁欲主义的斯多葛学派。伦理学自此分成两派，伊壁鸠鲁主义认为幸福是快乐，斯多葛主义认为幸福是美德，道德主义自然就是禁欲的，而快乐主义也容易被理解成纵欲。</li><li>斯多葛学派的创始人是芝诺(不是之前那个芝诺)，他受到赫拉克利特、苏格拉底、犬儒等学派的影响，融会贯通形成了斯多葛学派。斯多葛学派分早期和晚期，早期是希腊化时代，晚期是罗马时代，哲学思想越到后期越表现得阴郁、悲观。</li><li>早期的斯多葛主义思想体现在自然哲学和伦理学。</li><li>早期的斯多葛主义把赫拉克利特的火和逻格斯加以神秘化，认为火是有灵魂的东西或能思想的火气，逻格斯是神圣的火的理性，即世界理性。人就是一副承载着灵魂的尸体，灵魂是人之为人的根本，这个灵魂作为理性灵魂其实是世界理性的一点火花。人人都是世界理性的火花，所以他们主张天下大同、人人平等、四海之内皆兄弟，这与当时的奴隶主义相背。</li><li>早期的斯多葛主义把苏格拉底的思想和逻格斯结合，提出了决定论色彩的伦理学，认为一切都是注定的、不可更改的，所以我们在命运面前只能逆来顺受。他们认为善就是顺应逻格斯，他们理解的自由不是随心所欲，而是认识并服从世界的必然性，这种自由观和后世斯宾诺莎的观点相近，斯宾诺莎也认为自由是对自然规律和社会规律的认识和服从。到了后期，斯多葛主义把这种思想总结为“顺应自然，服从命运”。</li><li>罗马共和国时期，西塞罗把斯多葛主义和柏拉图主义传到罗马，斯多葛主义成了罗马的主流哲学，相对立的伊壁鸠鲁主义就成了罗马人鄙视的对象。所以罗马时期的哲学家大多是斯多葛主义。</li><li>晚期的斯多葛学派目睹了罗马帝国的暴戾恣睢，采取了一种越来越偏激的禁欲主义姿态。晚期斯多葛主义代表人物有塞涅卡、爱比克泰德和马可·奥勒留。</li><li>塞涅卡是罗马大臣，也是暴君尼禄的老师。他明确提出了“顺应自然，服从命运”，主张面对一切欲望和激情的骚扰采取“不动心”的态度。但他本人没有践行禁欲主义，反而聚敛钱财享尽荣华，最终被尼禄嫉妒而赐死。</li><li>爱比克泰德是奴隶，因为才华出众被主人释放。奴隶的经历让它产生一种宿命论的观点，认为我们要服从命运，对苦难逆来顺受。他认为引起人们恐惧的不是灾难本身，而是人们对灾难的态度，如果面对灾难泰然处之，就不会感到痛苦了。宗教强大的改造力就在于让人面对苦难不畏惧，相信有上帝在保佑自己。(作为奴隶，能改变的也只有心态了)</li><li>马可·奥勒留是罗马帝国一位热爱哲学的帝王，著有《沉思录》。虽然地位极高，但是态度比前人更加阴郁和悲观，感慨人的渺小和命运的不可违(sb)。</li><li>斯多葛学派悲观透顶，最终成为基督教神学的重要思想来源，因为悲观的人渴望得到上帝的拯救。</li></ul><h2 id="5-3-怀疑主义"><a href="#5-3-怀疑主义" class="headerlink" title="5.3 怀疑主义"></a>5.3 怀疑主义</h2><ul><li>怀疑主义不像其他两派有自己独断的主张，他们认为导致心灵纷扰的根本原因在于人们在认识方面的独断论态度，因此他们保持中立，对一切观点采取怀疑的态度，不发表自己的意见和判断。正因为不做判断，所以怀疑主义者始终彷徨，这也是一种悲观。</li><li>早期怀疑主义创始人是皮浪，他的基本思想就是不做任何决定、悬置判断。他认为人不幸福的根源就是喜欢自以为是地下判断、妄作主张。“万物一致而不可分别”，我们把握不了任何事物。(认真你就输了？)</li><li>晚期怀疑主义者主要有埃奈西徳谟、阿格里帕和塞克斯都·恩披里克。他们把早期的怀疑主义思想进一步深化，并把怀疑的对象从感觉转向了理性本身。埃奈西徳谟在皮浪悬置判断的基础上提出了怀疑感觉可靠性的十个“老论式”，大概意思就是不同的人、不同的条件下产生的感觉不同。塞克斯都·恩披里克提出了怀疑理性可靠性的五个“新论式”，大概意思就是哲学家的分歧说明世界是不可知的，所谓的理论只能是建立在假设和断言上，所以理性也是不可靠的。总之，感觉和理性都不可靠(他们眼里只有绝对的可靠，否认了相对可靠性)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="网课笔记" scheme="https://shivakasu.cn/categories/%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哲学" scheme="https://shivakasu.cn/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《社会心理学》(暂停更新)</title>
    <link href="https://shivakasu.cn/2020/02/03/psy1/"/>
    <id>https://shivakasu.cn/2020/02/03/psy1/</id>
    <published>2020-02-02T17:40:20.000Z</published>
    <updated>2020-02-07T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Part-1：社会思维"><a href="#Part-1：社会思维" class="headerlink" title="Part 1：社会思维"></a>Part 1：社会思维</h1><h2 id="chapter-1：-社会心理学导论"><a href="#chapter-1：-社会心理学导论" class="headerlink" title="chapter 1： 社会心理学导论"></a>chapter 1： 社会心理学导论</h2><ul><li>社会心理学是一门研究人们如何看待他人、如何互相影响，以及如何与他人互相关联的科学，是心理学和社会学的一门交叉学科</li><li>社会心理学关注的核心问题：<ul><li>我们如何构建我们的世界。</li><li>我们的社会直觉如何指引或误导我们。</li><li>我们的社会行为如何受他人、我们自己的态度和性格以及生物性的影响</li><li>社会心理学原理如何应用于日常生活和研究领域。</li></ul></li><li>社会心理学的结论看似是显而易见的，是因为人们的认知往往有后见之明偏差，也就是如果之前有过与该结论相似或相关的模糊体验，会误以为自己已经知道了这个结论。</li></ul><h2 id="chapter-2：-社会中的自我"><a href="#chapter-2：-社会中的自我" class="headerlink" title="chapter 2： 社会中的自我"></a>chapter 2： 社会中的自我</h2><ul><li>焦点效应(spotlight effect)是指人们往往会把自己看做一切的中心，并且直觉地高估别人对我们的关注程度。透明度错觉(illusion of transparency)是指人们高估自己的个人心理状态被他人知晓的程度。这种现象表明了自我感觉与社会、他人是相互影响的。</li><li>自我图式(self-schemas)是自我概念构成要素以及定义自我的那些特殊信念，图式是指我们组织自己所处世界的心理模板。可能自我是指想象中的自我。</li><li>自我效能理论是指对自己能力与效率的乐观信念可以获得很大的回报，也就是乐观自信的人勇于面对逆境，更容易成功。</li><li>自尊是对自我价值的整体认识，影响我们如何评价自己的特点和能力。一种观点认为自尊是一种内驱力，指导我们通过行动来发展自我，寻求社会接纳和认同。另一种观点认为自尊的动机不仅是社会认同，也是为了追求生命的意义，来克服人必将死亡这一事实所带来的恐惧。</li><li>自我服务偏差包括自我服务归因(功劳都是自己的)、自我恭维比较(自己比别人优秀)、盲目乐观、虚假普遍性、虚假独特性。<ul><li>自我服务归因是指把好的结果归因于自己，而把坏的结果归因于他人，自我服务归因能激活与奖赏和愉悦相关的脑区。主观行为维度如(自律性)比客观行为维度(如守时性)更容易引发自我服务偏差，也就是越不依赖于客观基础，人就越容易盲目自信。</li><li>悲观主义的人容易遭受挫折，乐观主义的人更能增强自我效能感、促进健康和幸福感，防御性悲观主义(如居安思危)则可以避免盲目乐观。</li><li>虚假普遍性效应是指我们过高地估计别人对我们观点的赞成度以支持自己的立场，也就是高估自己想法的普遍性。虚假独特性效应是指我们把自己的才智和品德看成超乎寻常的以完善自己的自我形象，也就是高估自己能力的独特性。</li></ul></li><li>自我服务偏差可以帮助我们避免抑郁、缓解压力，但高估自己也让我们容易责怪别人和欲求不满。</li><li>人们有时会自我挫败和自我妨碍，这是出于对失败的恐惧，人们主动制造外因来避免自己在失败后自责，比如大考之前玩游戏，如果考砸了就可以归因于游戏而不是自己笨。</li><li>自我表露是指我们想要向外在的观众(别人)和内在的观众(自己)展现一种受赞许的形象，因为我们总是渴望被社会接纳。</li></ul><h2 id="chapter-3：-社会信念和判断"><a href="#chapter-3：-社会信念和判断" class="headerlink" title="chapter 3： 社会信念和判断"></a>chapter 3： 社会信念和判断</h2><ul><li>人的记忆系统是一个相互联结的网络，启动(priming)是指唤醒或者激活其中的某些特定联结。人们之所以无法客观、如实地对现实进行反应，就是因为现实的刺激容易诱发启动效应，使人们无意识地根据自己的信念和回忆有倾向性地解释现实。</li><li>信念固着(belief perseverance)现象是指人们一旦对某项事物建立了某种信念，尤其是为它建立了一个理论支持体系，那么就很难打破人们的这一看法，即使是相反的证据与信息出现时他们也往往视而不见。纠正信念固着的唯一方法是解释相反的观点，也就是换位思考。</li><li>启动效应说明事前的经验会影响人们对现实的认知，信念固着说明事后的判断也会影响对现实的认知。</li><li>人的记忆系统不能完美地存储过去的事实，我们的记忆是在回忆的过程中重构的，重构会受到主观情感、态度的影响，可能会把误导性信息整合到记忆中。</li><li>人的思维包括受控制加工和自动化加工两部分，直觉是自动化思维，受到图式、情绪反应、专业知识、无意识思维等的影响。</li><li>过度自信(overconfidence)是指人们在解释自己的经历和构建记忆时，有时会忽略记忆中的错误，一方面是因为人们倾向于把过去模糊的错误判断回忆成正确的，另一方面是因为有验证性误差，也就是人们更愿意寻找证据证明自己的直觉，而不是去证伪。纠正过度自信也是要从这两方面入手。</li><li>启发式判断(heuristics)是一种简单高效的思维策略，人们为了减少信息加工的时间，会根据以往的经验形成印象、做出决定和生成解释，但可能产生错误。<ul><li>代表性启发式判断是指对某个事物进行评价时，根据其与过去经验的相似程度来进行判断或预测，也就是基于相似性来预测可能性。比如我们认为鬼鬼祟祟的人更可能是坏人。</li><li>易得性启发式判断是指根据客体或事件在知觉或记忆中的可得性程度来进行判断或预测，也就是基于可得性来预测可能性，越容易回想起来的事情越有可能是真的。比如我们认为以k开头的单词比第三个字母是k的单词更多，</li></ul></li><li>反事实思维(counterfactual thinking)是指否定过去发生的事实，对可能的结果进行心理模拟。比如常见的“如果当初…就好了”和“幸亏…了”两种心理。反事实思维和情绪相关，事件本身越重要，反事实思维的强度越大。</li><li>错觉相关(illusory of correlation)是指当我们发现某种重要的联系时，很容易将各随机事件联系起来。控制错觉(illusion of control)是指认为各种随机事件受我们的影响，比如赌博时相信自己的手气。</li><li>归因理论(attribution theory)描述了我们怎样来解释人们的行为，包括内部原因和外部原因。归因理论先驱哈罗德·凯利提出了归因的三要素：<ul><li>一致性：个体在这种情境下出现类似行为的一致性。高一致性倾向于因果关系，低一致性倾向于偶然关系。</li><li>区别性：个体的这种行为是否具体对应于该特定情境。高区别性倾向于外因，低区别性倾向于内因。</li><li>共同反应：其他人在这种情境下出现类似行为的可能性如何。高共同反应倾向于外因，低共同反应倾向于内因。</li></ul></li><li>基本归因错误(fundamental attribution error)是指个体在归因时低估情境因素的作用，比如我们看到人摔倒会觉得他笨拙而不是去考虑路好不好走。情境因素也包括社会约束，比如拥有社会权力的人往往会导致人们高估他们的知识和智力水平，就像学生高估老师的智商。基本归因错误的原因一方面是人们注意力的习惯，当作为观察者时更注重活动的人而忽视环境，另一方面也受文化环境的影响，东西方文化对于环境作用的重视程度有差异。</li><li>自我实现预言是指信念能够导向自我实现，也就是我们的社会信念会引导我们以证实自己的方式去行动。社会期望可以表现成自我实现预言，当我们对某件事的结果有所期待时，自己的行为就可能无意识地受到影响。</li><li>人的理性是有局限的，我们无法避免社会思维中的错误，但是可以训练自己对思维错误的敏感度。</li></ul><h2 id="chapter-4：-态度和行为"><a href="#chapter-4：-态度和行为" class="headerlink" title="chapter 4： 态度和行为"></a>chapter 4： 态度和行为</h2><ul><li>态度(attitude)是个体对人或事物的积极或消极的评价性反应，通常根植于个体的信念，表现于个体的感受或者行为倾向中。态度ABC理论的三个维度是：情感(affect)、行为倾向(behavior tendency)和认知(cognition)。</li><li>很难通过态度预测行为是因为二者之外还有其他的影响因素。三种情况下态度可以较好地预测行为：<ul><li>把其他因素的影响最小化，比如大数据去噪声。</li><li>态度与行为紧密相关，比如根据爱不爱吃肉预测会不会吃肉，简单粗暴。</li><li>态度是强有力的，比如洗脑洗出的态度。</li></ul></li><li>每个人都在扮演特定的社会角色，这个社会对社会角色的规定行为影响了人们的态度。</li><li>人们的言语行为会以加深信念的方式影响态度。</li><li>登门槛现象是指先请人帮一个小忙再请他帮个大忙，会比直接请他帮个大忙成功率高，说明对小行为的承诺可以让人们更愿意做更大的事。</li><li>目前有三种理论解释为什么行为能影响态度：<ul><li>自我表露理论：我们表现出与自己行为一致的态度，是为了不让自己看起来自我矛盾。</li><li>认知失调(自我辩解)理论：行为和态度矛盾会给人压力，所以我们会努力说服自己改变态度，或者无意识地忽略掉让自己矛盾的信息。</li><li>自我知觉理论：当我们摇摆不定或态度不明确时，会站在局外人的角度观察自己的行为，来坚定自己的信念。登门槛现象就可以解释成在决定帮不帮大忙的时候，帮个小忙可以加强信念，以为自己很热心助人。衍生出的一个结论是过度合理化效应，付给人们报酬让他们做自己喜欢的事，能将他们的这种乐事变成苦差，因为得到报酬的行为会让自己觉得做事是因为有报酬而不是因为喜欢。</li></ul></li><li>自我表露理论仅仅解释了行为怎样影响表面态度。认知失调理论和自我知觉理论解释了行为怎样影响真实态度，一个是让态度迁就行为，一个是让行为坚定态度，两者同时起作用。当行为与态度明显冲突时更倾向于自我辩解，当态度模糊不定时更倾向于自我知觉。</li></ul><h1 id="Part-2：社会影响"><a href="#Part-2：社会影响" class="headerlink" title="Part 2：社会影响"></a>Part 2：社会影响</h1><h2 id="chapter-5：-基因、文化与性别"><a href="#chapter-5：-基因、文化与性别" class="headerlink" title="chapter 5： 基因、文化与性别"></a>chapter 5： 基因、文化与性别</h2><ul><li>人的共性体现在生物相似性，人们由相同的祖先进化而来，为了适应环境进化出相似的生理和心理偏好。进化心理学基于达尔文的进化论，研究自然选择如何影响人们有利于适应环境的生理特征、心理特征和社会行为。</li><li>人类进化出了学习能力和创造力，所以能超越生理基础的限制形成不同的文化环境。不同文化环境的社会规范既有差异性也有相似性(文化交流的结果？)。</li><li>女性解读他人情绪的能力更强，女性更擅长以非言语的方式表达情绪。男性更容易表现出社会支配性和攻击性，更渴望性行为。但都是实验结果，没有理论解释。</li><li>演化学家根据人类演化历程推理两性差异的原因。但批评者认为根据结果推理出解释属于倒推的机能主义，事后推测高估了事实的重要性，应该从不同角度看问题，考虑到没有发生的各种发展情况，况且并没有实际证据证明演化学家的推测。</li><li>生理因素和文化因素是相辅相成的，基因是心理活动和社会活动的基础，文化环境中的社会规范又能强化基因导致的外显差异。</li><li>这一章相当空洞，生理学家领域新研究难所以没结论，社会学家有实验结论但相对浅显。和初中课本的知识量差不多~</li></ul><h2 id="chapter-6：-从众和服众"><a href="#chapter-6：-从众和服众" class="headerlink" title="chapter 6： 从众和服众"></a>chapter 6： 从众和服众</h2><ul><li>从众(conformity)是指根据他人而做出的行为或信念的改变，有三种形式：<ul><li>顺从(compliance)：由外部力量施压而违心的从众行为，比如礼仪。</li><li>服从(obedience)：由明确命令引起的从众行为，属于顺从的一种，比如军队。</li><li>接纳(acceptance)：发自内心真诚的从众行为，比如洗脑。</li></ul></li><li>影响从众的因素。<ul><li>群体规模：抱团的人越多，越不敢有异议。</li><li>一致性：越没有其他人提出异议，自己就越不敢有异议。</li><li>凝聚力：群体凝聚力越强，越不敢有异议。</li><li>地位：群体成员地位越强，越不敢有异议。</li><li>公开反应：越是公共场合，越不敢表现出不合群。</li><li>事前承诺：当先前有过公开承诺或决定时，就不容易反悔。</li></ul></li><li>影响个体从众的原因。<ul><li>规范影响：个体倾向于获得群体的接纳或免遭拒绝，因为偏离群体要付出情感代价(压力、痛苦)。</li><li>信息影响：当自己态度不坚定、不确定时倾向于从众，把他人视作指导行为的信息来源，因为经验告诉我们多数人的选项往往是对的。</li></ul></li><li>对社会形象的关注容易产生规范影响，希望自己行事正确容易产生信息影响。</li><li>逆反(reactance)理论指出，企图限制个体的自由会引起事与愿违的反从众行为，也就是从众的不自由感超过了不从众的压力。</li></ul><h2 id="chapter-7：-说服"><a href="#chapter-7：-说服" class="headerlink" title="chapter 7： 说服"></a>chapter 7： 说服</h2><ul><li>说服的两种路径。<ul><li>中心路径说服：当人们积极主动，全面系统地思考问题时，就可能接受中心路径说服，也就是论据有力而令人信服，结果是人们态度的变化相对持久，甚至影响行为。比如学校的教育。</li><li>当人们不仔细思考，没时间仔细推敲信息的意义时，就可能接受外周路径说服，也就是关注那些能令人不假思索就接受的外部线索，而不关注论据，结果是只能导致肤浅而短暂的态度转变。比如拼多多的洗脑广告。</li></ul></li><li>说服的四要素：说服者，说服内容，说服渠道，说服对象。</li><li>说服者可信度越高，说服力越强，可信度体现在地位的权威性，比如中央发布的信息，也体现在表面上的可靠性，比如说话看起来有自信、没有顾虑等。</li><li>说服者的吸引力越高，说服力越强，比如舔狗相信女神的话。</li><li>说服信息使人心情愉快，则说服力更强。说服信息能引起人的消极情绪反应，则说服力更强，比如用烟鬼的肺宣传禁烟。</li><li>说服信息与说服对象已有观念的差异对说服效果的影响，取决于说服者的可信度。可信度越高，大差异观点的说服力越强。比如医生容易说服人严格戒烟，但是少抽烟的建议往往容易被忽视，而家人完全相反，少抽烟的建议往往更有效。</li><li>如果说服对象已经有了赞成的观点，那么相同观点的说服信息更有效。如果说服对象心思缜密或立场不确定，那么包含正反两方面的说服信息更有效。</li><li>首因效应是指最先呈现的信息更有说服力，也就是先发制人的看起来更强势。首因效应的影响随时间递减，同时产生近因效应，也就是后面呈现的信息更有说服力。</li><li>如果信息简单，面对面说服更有效，如果信息复杂，书面表达说服力更强。</li><li>年轻人比老人更容易说服。</li><li>邪教洗脑原理。<ul><li>登门槛效应：先让新成员承诺参加小活动，再循循善诱，逐渐提出更过分的要求，让新成员不忍拒绝。</li><li>说服者有人格魅力，容易让人轻信。</li><li>说服信息不断渲染温暖、救赎。</li><li>说服对象基本都是年轻人，三观还在形成中，态度不坚定，容易动摇。</li><li>把成员封闭在群体中，加强成员对群体的认同感和依赖感。</li></ul></li></ul><h2 id="chapter-8：-群体影响"><a href="#chapter-8：-群体影响" class="headerlink" title="chapter 8： 群体影响"></a>chapter 8： 群体影响</h2><ul><li>群体(group)是两个或更多的人在较长时间里进行互动，并以某种方式相互影响，将他们自己视为“我们”。</li><li>群体的社会助长作用是指他人在场能提高某些任务的准确性，社会阻抑作用是指他人在场能降低某些任务的准确性。扎荣茨把这两个相反的理论综合了起来：他人在场会引起唤醒状态，而唤醒状态能增强任何优势反应的趋势，优势反应是指学习得相当熟练能够不假思索做的的反应。在简单任务中，优势反应往往就是正确答案，比如不需要动脑的体力劳动，唤醒促进了优势反应，所以效率得到了提高。在复杂任务中，优势反应往往不是正确答案，比如解数学题，唤醒促进了优势反应，使得我们倾向于用直觉解题而不是深入思考，所以降低了效率。</li><li>置身于拥挤的人群同样会引起唤醒和促进优势反应。</li><li>唤醒的本质是减少脑力思考，更多地依赖本能反应。他人在场引起唤醒的原因就是让我们不得不减少精力思考的原因，主要有三个：<ul><li>评价顾忌：不管是否与他人交流，只要知道有观察者在场，我们就会想要知道别人怎么评价我们，引发我们的自我关注。</li><li>分心：在群体中我们会考虑别人的反应，这种注意他人和注意任务之间的冲突，会使认知系统负荷过重。</li><li>纯粹在场：即使不考虑评价顾忌和分心，仅仅是他人纯粹在场的状态也能一定程度地引发唤醒。</li></ul></li><li>群体的社会懈怠是指成员在集体任务中会减少自己的努力程度，主要原因是受到搭便车的诱惑。当自己成为群体的焦点时会提高评价顾忌，比如演讲，所以会引发社会助长作用。而当自己只是集体活动平凡的一部分时就会减少评价顾忌，比如拔河，所以会引发社会懈怠。</li><li>减少社会懈怠的方法是让个体作业成绩可识别，虽然每个个体都不是群体的焦点，但工作结果是可以被别人看到的，就会提高评价顾忌。此外，当工作目标本身具有吸引力时也能减少社会懈怠，比如比赛胜利有奖金，团队的每个人都会努力想得到奖金。</li><li>去个体化(deindividuation)是指在群体中成员抛弃道德约束、忘却个人身份而顺从于群体规范。这是因为社会助长和社会懈怠同时起作用，成员既被引发了唤醒而降低思考力，又降低了评价顾忌和分散了责任，导致成员隐蔽在群体中体验到匿名感和无自我感，结果是引发群体失控，比如摇滚音乐会上的群体发狂叫喊，又比如网络暴力。</li><li>群体极化又称“风险转移”，是指群体决策往往比个人决策更冒险，比如有人陪同时更可能鲁莽驾车。因为群体讨论能够加强群体原先的主导观点，无论是激进的观点还是保守的观点，比如大屠杀就是成员相互怂恿的极化结果。</li><li>群体极化的原因有两方面已经被证实：<ul><li>信息影响：群体讨论产生的大多数观点都和主导观点一致，在讨论中主导观点通过言语重复容易使成员转变态度。</li><li>规范影响：个体倾向于认为自己的意见更好更合理，在群体讨论中人们会通过社会比较发现自己其实并没有很出众，于是纷纷省悟，主动向群体主导观点靠拢。</li></ul></li><li>群体思维(groupthink)是指在群体决策中人们为了维护群体和睦而压制异议。症状表现有：<ul><li>无懈可击的错觉：成员过分自信，看不到群体的漏洞或弱点。</li><li>群体道义毋庸置疑：成员接受群体的内在道义，忽视了伦理和道德问题。</li><li>合理化：以集体投票的方式将决策合理化来减少挑战。</li><li>对对手的刻板印象：成员以为自己的群体很强大，低估对手实力。</li><li>从众压力：对群体中提出异议的人施加压力。</li><li>自我审查：成员为了维护群体一致性而抑制自我审查。</li><li>一致同意的错觉：都不敢提出异议，容易形成表面上的一致同意。</li><li>心理防御：成员保护群体不受质疑。</li></ul></li><li>预防群体思维的方法就是鼓励群体成员积极思考、交流观点、畅所欲言，更开放、全面地做决策。避免了群体思维的结果就是群体的问题解决，往往比个体决策更正确。因为群体内部的头脑风暴能产生更多观点，不同观点的碰撞可以消除认知偏见，从而产生更多的好点子。</li><li>立场坚定的少数派可以动摇多数派的态度，少数派的存在打破了群体的一致同意错觉，迫使多数派重新审视自己的观点，即使少数派的观点没有被采纳，整个群体的最终决策也会更优。</li></ul><h1 id="Part-3：社会关系"><a href="#Part-3：社会关系" class="headerlink" title="Part 3：社会关系"></a>Part 3：社会关系</h1><h2 id="chapter-9：-偏见"><a href="#chapter-9：-偏见" class="headerlink" title="chapter 9： 偏见"></a>chapter 9： 偏见</h2><ul><li>偏见(prejudice)的本质是对一个群体及其成员负面的预先判断。偏见的标志是负面评价，负面评价来自于刻板印象。刻板印象是一种概括性的看法，当过度概括或明显不对时，就会引发负面评价。</li><li>偏见证明了我们有双重态度系统，即我们对同一个目标可以同时拥有完全不同的外显态度和内隐态度。所以偏见也分为公开的、有意识的外显偏见和微妙的、无意识地内隐偏见。现代社会中内隐偏见比外显偏见涉及面更广。</li><li>偏见起源于不平等的社会经济地位以及其他社会原因，包括我们习得的价值观和态度、宗教原因、制度原因等。</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://shivakasu.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="心理学" scheme="https://shivakasu.cn/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《心理学与生活》</title>
    <link href="https://shivakasu.cn/2020/01/29/psy0/"/>
    <id>https://shivakasu.cn/2020/01/29/psy0/</id>
    <published>2020-01-29T08:46:20.000Z</published>
    <updated>2020-02-10T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-生活中的心理学"><a href="#1-生活中的心理学" class="headerlink" title="1 生活中的心理学"></a>1 生活中的心理学</h1><ul><li>心理学(psychology)是关于个体的行为及心智过程的科学研究。心理学的目标是观察、解释、预测和控制行为。观察的核心是客观性，解释的核心是想象力，预测的核心是精确可检验，预测和控制都是对解释的证明。</li><li>研究方法的争论：结构主义(structuralism)认为人类所有心理经验都可以作为基本成分的组合来理解，通过分析组成个体心理生活的感受及其他经验的构成元素，进而揭示人类心理的基础结构。机能主义(functionalism)认为意识是流动的，心理的特征是与环境持续进行相互作用，重要的是心理过程的行为和机能，而不是心理的内容。结构主义研究心理内容是什么，强调科学方法、精确测量以及数据统计分析，机能主义研究行为的目的和原因，强调创造性的解释而不是科学实验方法。</li><li>心理学家的观点决定了他们研究行为和心理过程的方式，书中介绍了七种观点，但是心理学家往往不会局限在单个观点上。<ul><li>心理动力学观点(psychodynamic perspective)：又称精神动力学或精神分析学，认为行为是由强大的内部力量驱使或激发的。人的行为是从先天的本能和生物驱动中产生的，而且试图解决个人需要和社会要求之间的冲突。代表人物弗洛伊德。</li><li>行为主义观点(behaviorist perspective)：寻求理解特定环境刺激如何控制特定类型的行为，研究重点是行为而不是意识。研究方法就是先改变环境再观察行为变化，使用严格的实验和定义变量，而不使用内省法。代表人物约翰·华生、B.F.斯金纳。</li><li>人本主义观点(humanistic perspective)：强调人的能动性以及人自身的发展，在人的认命历程中寻找行为模式。代表人物卡尔·罗杰斯、亚伯拉罕·马斯洛。</li><li>认知观点(cognitive perspective)：研究人的思维以及所有的认识过程，将思维同时视为外在行为的原因和结果，个体不是对物质的客观世界做出反应，而是对个体思维和想象的内在世界的主观现实做出反应。代表人物诺姆·乔姆斯基、让·皮亚杰。</li><li>生物学观点(biological perspective)：在基因、大脑、神经系统以及内分泌系统中寻找行为的原因，认为心理现象与社会现象能够最终依据生物化学过程加以解释。</li><li>进化论观点(evolutionary perspective)：结合了当代心理学与进化论，试图用进化的观点对人的心理的起源和本质以及一些社会现象进行深入的探讨和研究。</li><li>社会文化观点(sociocultural perspective)：研究行为的原因和结果中的跨文化差异，强调文化因素对心理学观点普遍性的影响。</li></ul></li></ul><h1 id="2-心理学的研究方法"><a href="#2-心理学的研究方法" class="headerlink" title="2 心理学的研究方法"></a>2 心理学的研究方法</h1><ul><li>观察者偏见(observer bias)是由于观察者个人的动机和预期导致的错误，减小观察者偏见的方法是标准化。对概念含义进行标准化的策略称为操作化，操作性定义是根据可观察、可测量、可操作的特征来界定变量含义的方法。</li><li>实验法要求操纵自变量观察因变量，但实验者会不自觉得引入混淆变量。有两种几乎存在于所有实验中的混淆变量(confounding variable)，一种是期望效应(expectancy effects)，实验者对实验对象的阐述包含了他对实验结果的预期，这种预期影响了实验对象的行为，另一种是安慰剂效应(placebo effects)，实验环境使实验对象对结果产生了某种预期，影响了实验对象的行为。</li><li>实验者消除混淆的策略称为控制程序，是使所有变量和条件保持恒定的方法。一种方法是双盲控制(double-blind control)，使实验助手和参与者都不知道哪些参与者接受了哪种处理。一种方法是安慰剂控制(placebo control)，引入无效的实验条件做对比实验，来解释安慰剂效应对实验的影响。</li><li>实验法的缺陷：人为实验环境与真实自然环境有区别，参与者往往知道自己在参与试验，某些研究问题受到伦理约束而不可能实施。</li><li>要确定两个变量、特质或者属性之间的关联程度时，需要基于相关法，计算两者的相关系数，判断是正相关、负相关还是不相关。</li><li>心理测量的目标是产生可靠而又有效的发现。信度(reliability)是指心理测验或实验研究得到的行为数据具有一致性或可靠性，效度(validity)是指研究或测验得到的信息准确地测量了研究者想要测量的心理变量或品质。书中介绍了两种数据收集的方法：<ul><li>针对参与者内部的心理状态和不适合现场观察的外部行为，采用自我报告法(self-report measures)收集数据，让参与者言语回答研究者提出的问题，自我报告包括问卷法和访谈法。自我报告法的缺陷有：不适合语言理解能力差的人，人们可能受社会期望的影响给出虚假的答案，访谈的情境会产生个人偏见和成见。</li><li>行为测量(behavioral measures)是研究外显行为和可观察、可记录的反应的方法。自然观察是在不改变或不干预自然环境的条件下观察自然情境下发生的行为。对于不方便观察或收集的行为，可以查询档案数据。</li></ul></li></ul><h1 id="3-行为的生物学和进化基础"><a href="#3-行为的生物学和进化基础" class="headerlink" title="3 行为的生物学和进化基础"></a>3 行为的生物学和进化基础</h1><ul><li>为了分离环境和基因的作用，研究者经常使用收养研究和双生子研究。前者评估儿童与其亲生父母以及养父母之间的相似性，后者比较同卵双生子和异卵双生子在特定性状或行为上的相似性。</li><li>感觉神经元携带来自感受器细胞的信息向内传至中枢神经系统，运动神经元携带来自中枢神经系统的信息向外传至肌肉和腺体，其他的都叫中间神经元。大脑的神经元网络之间有胶质细胞，负责固定神经元位置、清理脑内环境、轴突绝缘、隔离血液内的有害物质、以及影响神经冲动传递所必需的离子浓度。</li><li>动作电位(action potential)：又称神经冲动。在静息状态下，神经元外部钠离子浓度高，细胞内液相对于细胞外液具有跨膜负电压，也就是处于极化状态。神经元对神经冲动的输入发生反应时，静息电位转为动作电位，抑制性输入保持跨膜负电压，抑制了神经冲动的传输，兴奋性输入允许钠离子流入消除负电压，发生去极化，让动作电位继续向后传播，传播过后允许钾离子流出恢复静息电位。而细胞膜上的钠钾泵负责两种离子的反向供给。</li><li>动作电位在神经元之间靠突触传播。突触由突触前膜(发送神经元的终扣)、突触后膜(接受神经元的终扣)和突触间隙组成。动作电位沿轴突到达突触前膜后，开启离子通道允许钙离子流入，引起突触囊泡破裂释放神经递质，神经递质与突触后膜上的受体结合，由于神经递质与受体的结合具有专一性，所以可以说神经元接受的信号是兴奋还是抑制是由其上的受体决定的，但本质上是由神经递质和受体的组合决定的。</li><li>几种神经递质。<ul><li>乙酰胆碱：兴奋性递质，存在于中枢与外周神经系统，阿尔兹海默症的记忆丧失被认为是由于分泌乙酰胆碱的神经元退化所造成的。</li><li>GABA：是gamma-氨基丁酸的缩写，抑制性递质，存在于丘脑、下丘脑和枕叶皮层等脑结构，当脑中GABA水平降低时，人们会产生焦虑或抑郁。</li><li>谷氨酸：脑中最普遍的兴奋性递质，有助于在脑中传递信息，在情绪反应、学习和记忆过程中起着关键作用。</li><li>多巴胺、去甲肾上腺素：属于几茶酚胺，在心理障碍中有重要作用，如情感障碍和精神分裂症。</li><li>五羟色胺：位于脑干，抑制性递质，能让人产生愉悦情绪、抗抑郁。</li><li>内啡肽：属于神经调质，神经调质是能够改变或调节突触后神经元活动的物质。内啡肽是内源性吗啡的简称，在情绪行为和疼痛控制中有重要作用。</li></ul></li><li>神经系统分为中枢神经系统(central nervous system, CNS)和外周神经系统(peripheral nervous system, PNS)。CNS由脑和脊髓的所有神经元组成，作用是整合和协调所有身体功能，向身体不同部分发出指令，神经信息的发出和接受由脊髓完成。PNS由所有构成神经纤维的神经元组成，连接CNS与身体，作用是把来自感受器的信息提供给CNS。PNS包括躯体神经系统和自主神经系统，躯体神经系统调节身体骨骼肌的动作，自主神经系统维持机体的基本生命过程，如呼吸、消化。自主神经系统分为交感神经和副交感神经，交感神经支配应对紧急情况的反应，副交感神经监测身体内部功能的常规运行。</li><li>脑有三层结构：脑干、边缘系统和大脑。<ul><li>脑干：负责综合调节机体内部状态。延髓是呼吸、血压和心搏调节中枢。桥脑提供传入纤维到其他脑干结构和小脑之中。丘脑是感觉的最高中枢。小脑协调身体的运动和维持平衡。</li><li>边缘系统：与动机、情绪状态和记忆过程相关，也参与体温、血压和血糖水平的调节。海马在记忆获得中有重要作用。杏仁核在情绪控制和情绪记忆形成中起作用。下丘脑调节动机行为，包括摄食、饮水、体温调节和性唤醒，维持身体平衡或内稳态。</li><li>大脑：负责调节脑的高级认知功能和情绪功能。额叶参与运动控制和认知活动，包含与语言障碍相关的布罗卡区。顶叶负责触觉、痛觉和温度觉。枕叶是视觉信息到达的部位。颞叶负责听觉过程，包含与言语理解相关的威尔尼克区。额叶运动皮层控制身体肌肉。躯体感觉皮层处理温度、触觉、躯体位置和疼痛的信息。听皮层处理听觉信息。视皮层处理视觉信息。联络皮层负责整合不同感觉通道的信息。</li></ul></li><li>内分泌系统是一种腺体网络，制造和分泌激素到血液中。下丘脑是内分泌系统和中枢神经系统的中转站，下丘脑向脑垂体分泌激素，脑垂体再调节身体其他激素的释放。</li></ul><h1 id="4-感觉和知觉"><a href="#4-感觉和知觉" class="headerlink" title="4 感觉和知觉"></a>4 感觉和知觉</h1><ul><li>知觉(perception)是理解环境中客体和事件的所有过程，分成感觉、知觉组织以及辨认与识别客体三个阶段。感觉(sensation)是感受器受到刺激后产生神经冲动以反映身体内外经验的过程。知觉组织(perceptual organization)阶段大脑整合来自感官的信息形成对外部刺激的内部表征。辨认与识别(identification and recognition)阶段赋予知觉以意义。</li><li>环境中的物理客体称为远距刺激，如光线、空气振动，它们在感觉器官上直接产生的刺激称为近距刺激，如视网膜上的光学成像。知觉三个阶段的主要计算任务可以看成根据近距刺激中的信息来确定远距刺激。</li><li>心理物理学研究物理刺激与其所产生的心理行为和体验之间的关系，由古斯塔夫·费希纳首先提出。测量刺激的方法是确定阈限并建立感觉强度和刺激强度之间关系的心理物理量表。刺激的绝对阈限是产生感觉体验所需的最小物理刺激量，由于觉察过程不是突变的，所以绝对阈限的操作性定义为有一半次数能够觉察到感觉信号的刺激水平，绝对阈限的测量结果总结为心理测量函数，表示为每种刺激强度下刺激被觉察到的百分比的曲线，一般为S形曲线。感觉适应是指感觉系统对持续的刺激输入反应逐渐减小的现象。</li><li>阈限测量受反应偏差的影响，也就是测量中有干扰因素。针对反应偏差的研究方法是信号检测论(signal detection theory, SDT)，综合考虑测量结果的击中、漏报、虚报、正确否定的情况，相当于机器学习评价指标里true/false与positive/negtive组合的四个参数。</li><li>差别阈限是能够识别出两个刺激之间的最小物理差异，操作性定义为有一半次数觉察出差异的刺激值，又称最小可觉差。最小可觉差服从韦伯定律，即刺激之间的最小可觉差与标准刺激强度的比值是恒定的，标准刺激强度体现了感官对不同刺激的敏感程度，比如光强、气味、声音。</li><li>(人体感官的生物学知识略过~)</li><li>知觉组织的原则在格式塔心理学(Gestalt psychology)中得到深入研究，格式塔心理学注重对整体结构的理解，通过控制局部变化观察人们对整体的知觉组织的结果，总结出一套规律：<ul><li>接近律：人们会将最接近的元素组织在一起。</li><li>相似率：人们会将最相似的元素组织在一起。</li><li>连续率：即使线条被截断，人们也会将其知觉为连续的。</li><li>闭合率：人们倾向于填补小的空隙而将客体知觉为一个整体。</li><li>共同命运率：人们倾向于将看起来朝相同方向运动的客体组织起来。</li></ul></li></ul><h1 id="5-心理、意识和其他状态"><a href="#5-心理、意识和其他状态" class="headerlink" title="5 心理、意识和其他状态"></a>5 心理、意识和其他状态</h1><ul><li>非意识过程是很少进入意识的一些躯体活动，如血压调节，有些非意识过程可以有意识地调节，如控制呼吸。前意识记忆是指只有注意到之后才能到达意识的记忆。无意识行为由弗洛伊德提出，他主张某些意识经验具有威胁性以至于被心理过程排除在意识之外，如创伤性记忆和禁忌的欲望，但仍然能影响人的行为。</li><li>研究意识的方法：使深层的个人经验能够得到外显测量。一种方法是要求参与者在进行复杂任务时大声说出解决过程，记录成出声思维报告。另一种是经验抽样法，参与者提供关于他们在日常生活正常进程中的想法和感受的信息。</li><li>意识的作用。<ul><li>帮助生存：意识限制刺激的输入，通过过滤与当前目标无关的大量信息来限定人的注意力。意识允许将事件和经验按照个人需要分成相关的和无关的，选择性地存储人想要分析、解释并对将来起作用的刺激。意识允许人基于过去的知识思考可替代的方案和想象各种可能的结果。总之就是意识帮助人理解环境信息，计划最适宜而有效的行动。</li><li>对现实的个人和文化建构：基于个人或特定文化环境的知识、经验、记忆、需求、目标等，对当前情境做出独特的解释。</li></ul></li><li>弗洛伊德认为梦是对愿望的满足，梦里有两股动力，愿望和抵抗愿望的审查，审查是对愿望的伪装，把社会和个人不能接受的潜性梦境转化为可接受的显性梦境。梦的解析需要从显性梦境回溯到潜性梦境，也就是对梦中包含隐喻的意象进行解读。</li></ul><h1 id="6-学习与行为分析"><a href="#6-学习与行为分析" class="headerlink" title="6 学习与行为分析"></a>6 学习与行为分析</h1><ul><li>学习是基于经验而使行为或行为潜能发生相对一致变化的过程。<ul><li>学习只有通过经验才能发生，经验包括吸收信息和做出反应来影响环境。</li><li>无法直接观测学习本身，但学习能体现在外显行为表现的进步，或相对于外显行为的一种能改变行为的潜能，比如领悟力。</li><li>为了表明发生了学习，行为或行为潜能的变化必须在不同场合表现出相对一致性。</li></ul></li><li>学习的基本形式是习惯化和敏感化。习惯化是指，当刺激重复呈现时会减少行为回应，人会把注意焦点放在环境的新异事件上。敏感化是指，对重复呈现刺激的反应会变得更强烈。一般来说，在刺激很强烈或令人不适时更可能发生敏感化。习惯化和敏感化看似是相反的形式，但敏感化也可以理解成，重复的强刺激会使人对其他弱刺激的反应变得更强烈，导致总体上的反应是增强的，这也是一种习惯化。</li><li>约翰·华生创立了行为主义的心理学派，他认为主观的内省法不是研究行为的好方法，应该去研究客观的可观察的行为。斯金纳扩展了华生的理论，主张心理活动不是产生行为的原因，行为是由环境刺激产生的。斯金纳开创了行为分析理论，强调寻找学习和行为的环境决定因子，行为分析家的任务是在具有可比性的情景下，发现适用于包括人类在内的所有动物的普遍学习规则。</li><li>复杂形式的学习是简单学习形式的组合和加工，两种简单学习形式是经典条件作用和操作性条件作用。</li><li>经典条件作用是一种由一个刺激或事件预示另一个刺激或事件之到来的基本学习方式，是联想学习的一种形式，在此过程中有机体学会将两种刺激或事件联系起来。经典条件作用最初由巴甫洛夫观察狗分泌唾液的规律研究发现，所以又称巴甫洛夫条件作用。</li><li>经典条件作用的核心是反射性反应，如分泌唾液、瞳孔收缩。反射是由与有机体生物学相关的特定刺激自然诱发的，能自然诱发反射性行为的刺激叫做无条件刺激(unconditioned stimulus, UCS)，无条件刺激诱发的行为叫做无条件反应(unconditioned response, UCR)。不能自然诱发反射性行为，需要与UCS匹配使用的叫做条件刺激(CS)，CS诱发UCR的原因是它与UCS的联系，经过多次匹配使用后，单独使用CS也能引起的反射性行为叫做条件反应(CR)，CR就是学习的结果。一种反应是UCR还是CR是由诱因决定的，所以UCS引起的分泌唾液属于UCR，CS引起的分泌唾液属于CR。</li><li>经典条件作用就是通过USC-CS的匹配诱发CR。CS与USC有四种匹配模式，区别在于UCS的呈现时机：延迟条件作用是先呈现CS，UCS在CS取消前呈现。痕迹条件作用是先呈现CS，UCS在CS取消后呈现。同时性条件作用是UCS与CS同时呈现。倒摄条件作用是UCS先于CS呈现。同时性和倒摄条件作用效果较差，因为只有让CS先于UCS呈现，才能学到CS能预示UCS这样的联系。</li><li>当CS不再预示UCS时，CS逐渐无法诱发CR，这个过程叫做消退，消退后重新训练，CR的学习会更快速，说明消退只是削弱了行为，并没有消除先前全部的学习经验。</li><li>一旦CS与CR建立联系，与CS相似的刺激也能诱发CR，这种现象叫刺激泛化，由于重要刺激很少每次都以完全相同的形式出现，所以刺激泛化通过扩展最初的特定经验而扩大了学习范围。当某些与CS相似的刺激反复出现后，有机体对其他相似刺激的反应会减弱，这种现象叫刺激辨别。有机体需要平衡泛化和辨别的作用强度，避免产生过度选择(该反应的不反应)或过度反应(不该反应的瞎反应)。</li><li>有效的CS需要满足相倚性和信息性。相倚性是指CS要与UCS高度依赖，在没有CS时也不会有UCS。信息性是指CS要能提供UCS不具备的额外信息。</li><li>经典条件作用的应用：药物成瘾。药品(UCS)会诱发生理反应(UCR)，这种生理反应是机体对药物的对抗反应，久而久之，这种对抗反应变成了条件反应，在使用药物的场景(CS)中，如打针，机体会对药物的预期效应做好生理准备(CR)，机体需要消耗额外的药物克服CR，随着CR本身的增强，消耗的药物越来越多，慢慢呈现出药物上瘾。</li><li>爱德华·桑代克通过观察猫用试错法逃出迷笼，提出了效果律：随着体验行为带来的结果，机体自动学到了刺激-反应联结，导致带来满意结果的反应出现的概率会越来越大，而带来不满意结果的反应出现的概率会越来越小。</li><li>斯金纳继承了桑代克的观点，提出了操作性条件作用，操作性指的是机体自发产生的行为。操作性条件作用与经典条件作用的区别在于是否自愿，经典条件作用是在外部刺激下被动地学习，而操作性条件作用是通过主动产生行为并体验结果进行学习。</li><li>强化相倚是指某一反应和它使环境发生变化之间的一致性关系，这种一致性关系能够增大该反应出现的概率。其实和操作性条件作用是一个意思，就是通过体验反应的结果导致反应出现概率变大。当反应的结果是使喜爱的刺激出现，这种情况叫正强化。当反应的结果是使厌恶的刺激消失，这种情况叫负强化。正强化和负强化都增大了反应出现的概率，只是情感基础有区别。强化物是指与行为相倚的刺激，比如金钱奖励。和经典条件作用相同，操作性条件作用也有消退和快恢复的机制。</li><li>惩罚是减小反应出现概率的技术，与强化相倚的作用相反。当反应的结果是使厌恶的刺激出现，这种情况叫阳性惩罚。当反应的结果是使喜爱的刺激消失，这种情况叫阴性惩罚。区分强化和惩罚的关键在于反应出现的概率是增大还是减小。</li><li>三项相倚是指辨别性刺激-行为-结果这一序列。通过结合强化和惩罚，改变三项相倚中的成分，可以把某一行为限定在某一特定背景下。比如红灯和绿灯是两种辨别性刺激，在两种刺激下，过马路的行为会分别产生惩罚和强化两种结果。</li><li>部分强化效应表明，在部分强化中习得的反应比连续强化中习得的反应更能抵抗行为的消退。意思是不必在每次行为后都呈现强化物，有间隔地呈现强化物效果反而更好。强化程序表是指给予强化的策略，书中介绍了四种：<ul><li>固定比率(fixed-ratio, FR)程序表：强化物在有机体做出指定次数的反应后才出现。</li><li>可变比率(variable-ratio, VR)程序表：强化物在有机体平均做出指定次数的反应后才出现，具体到每一次强化前的反应次数是随意的。</li><li>固定间隔(fixed-interual, FI)程序表：强化物在固定时间间隔后，有机体首次做出反应时出现。</li><li>可变间隔(variable-interual, VI)程序表：强化物平均在固定时间间隔后，有机体首次做出反应时出现，具体到每一次强化前的时间间隔是随意的。</li></ul></li><li>学习的生物制约性指的是物种的遗传天赋给学习带来的任何限制。一种情况是本能漂移，实验者的强化物不能完美控制学习过程，随着时间的推移，习得的行为会向着本能行为漂移。一种情况是味觉-厌恶学习，比如老鼠在摄取有特殊味觉特征的食物后，如果出现腹泻等内脏不适症状，在以后的摄食活动中就会减少或拒绝摄取具有相同或相似味觉特征的食物，因为老鼠的遗传因素中对味道比较敏感，所以吃坏一次就能学到条件反应。</li><li>观察学习是指通过替代强化和替代惩罚的方式进行学习，通过观察他人的行为及结果，直接学习他人的经验来改变自己的行为。这是人类运用认知能力的高级学习方式。</li></ul><h1 id="7-记忆"><a href="#7-记忆" class="headerlink" title="7 记忆"></a>7 记忆</h1><ul><li>记忆是存储和提取信息的一种能力，也是一种信息加工过程。内隐记忆是指不需要有意识的努力就可以获得的信息，外显记忆是做了有意识的努力而恢复的信息。陈述性记忆是关于事实和事件的记忆，程序性记忆是关于怎样做某些事的记忆。</li><li>记忆涉及到对知识的编码、存储和提取。编码是把外部世界的信息加工成心理表征。存储是把编码后的信息在大脑结构中保存一段时间。提取是指被存储的信息在随后某一时间的恢复。</li><li>书中介绍了三种非持久记忆：<ul><li>映像记忆(iconic memory)：是一种视觉领域的记忆系统，属于感觉记忆的一种，能使大量信息被存储非常短暂的时间。</li><li>短时记忆(short-term memory, STM)：短期记忆有限的容量迫使注意力高度集中。在头脑里循环重复的方法叫做保持性复述，复述帮助人防止信息从短时记忆中衰退。当信息过于复杂不能被复述时，可以会使用组块策略，利用联想能力，把信息分解成几个有意义的组。</li><li>工作记忆(working memory)：用于完成诸如推理和言语理解这样的任务所需的记忆资源，包含语音环路、视觉空间画板、中央执行系统和情景缓冲区四个成分。短时记忆仅仅是对信息的存储，但工作记忆对信息进行了处理和加工，服务于随后的认知活动，比如心算和阅读理解都涉及工作记忆。</li></ul></li><li>长时记忆(long-term memory, LTM)是从感觉记忆和短时记忆中获得的所有体验、时间、信息、情感等的储存仓库，长时记忆构成了每个人对于世界和自我的全部知识。当编码信息的情景与试图提取它的情景能够很好匹配时，记忆效果最好，好的匹配体现在以下几个方面：<ul><li>提取线索：是指搜索一个特定记忆的时候可以利用的刺激，也就是提取记忆的目的。提取记忆的难易取决于提取线索的质量。比如再认测验比回忆测验更容易，因为再认的线索更有用。语义记忆(从不同情境的体验中总结出的一般化的抽象经验)比情景记忆(特定情景下的特定体验)更容易，因为情景记忆需要的线索更多。</li><li>背景和编码：编码特异性原则表明，当提取的背景与编码的背景相匹配时记忆最为有效。研究已经证明了存在背景依赖性记忆、状态依赖性记忆以及语言依赖性。</li><li>编码和提取的过程：加工水平理论认为，信息的加工水平越深，它转入记忆的可能性就越大，如果加工涉及的分析、理解、比较和精细处理越多越深，记忆效果就越好。传输适宜性加工理论认为，如果使用了一个特定类型的加工来编码信息，如物理的或语义的分析，那么使用相同类别的分析过程能更有效地提取信息。</li></ul></li><li>产生遗忘的原因是不同的记忆之间会互相干扰，前摄干扰是指过去获得的信息使你获得新信息更困难，倒摄干扰是指新信息的获得使你对旧信息的记忆更困难。艾宾浩斯是第一位严格通过实验证明干扰现象的研究者。</li><li>元记忆是指关于知道自己拥有什么信息的记忆，元记忆的一个主要问题是知道感是怎么产生的，也就是人为什么知道自己有哪些记忆。线索熟悉性假设认为，人们是基于他们对提取线索的熟悉性建立知道感的。易接近性假设认为，人们基于记忆中部分信息的可接近性或可得性来做出判断。总之就是人本身已经有相似或相关的记忆了，所以会自以为知道答案，这就是废话呀。</li><li>记忆的一项重要功能是把相似的信息连接起来。记忆结构包括概念、等级和图式。概念是有关归类或范畴的心理表征，等级是对概念的有意义的排列组合，图式是关于物体、人和情境的概念框架或知识群。</li><li>重构性记忆(reconstructive memory)是指不直接记忆新信息，而是基于记忆中更概括的知识来重构信息。重构记忆不是恢复一个特定的记忆表征，所以重构的记忆可能会与事实不符，弗雷德里克·巴特利特最先证明了记忆的扭曲，概括出三种扭曲的过程：趋平(简化故事)、精锐化(过分强调某些细节)和同化(将细节变得更符合自己的背景或知识)。</li><li>闪光灯记忆(flashbulb memory)是指当人们经历的事件引起情绪极大波动时，产生的鲜明的记忆，回忆出的信息与原始事件的情形完全一致，也就是所谓的历历在目，比如家里死人、911袭击。</li><li>记忆的物理痕迹广泛分布于整个大脑，小脑负责程序性记忆，纹状体是习惯的形成和刺激-反应间联系的基础，大脑皮层负责感觉记忆以及感觉间的关联记忆，海马组织负责事件、日期、名字等的陈述性记忆以及空间记忆的巩固，杏仁核在具有情绪意义的记忆的形成和提取中起着关键作用。记忆的生物学基础能够帮助解释遗忘症的原理。</li></ul><h1 id="8-认知过程"><a href="#8-认知过程" class="headerlink" title="8 认知过程"></a>8 认知过程</h1><ul><li>全是空话废话，就是推理、归纳、决策等等认知过程的基本阐述，学不到有意思的东西。</li></ul><h1 id="9-智力与智力测验"><a href="#9-智力与智力测验" class="headerlink" title="9 智力与智力测验"></a>9 智力与智力测验</h1><ul><li>心理测量是用来检测人们的能力、行为和个性特质的特定的测验程序。正式测量程序应该满足三方面要求：<ul><li>信度：是指某一测量工具给出的一致性分数的可信程度。检测信度的方法有三种。<ul><li>重测信度，对同一人使用同一种测验，计算两次结果的相关性。</li><li>平行测验，对同一人使用检测同一特质的不同测验，减少了参与者第一次测验的经验对后续测验的影响。</li><li>对单个测验进行内部一致性检验，比如对奇数项目和偶数项目的成绩进行一致性比较。</li></ul></li><li>效度：是指测验能够测得它所要测量的东西的程度。有三种重要的效度。<ul><li>内容效度：是指测验对欲测领域的所有方面的覆盖程度。</li><li>效标效度：又称预测效度，是指测验结果与效标的相关程度。效标是指与测验目标相关的其他指标，比如要测验智力，可以把权威的韦氏智力测验作为效标，与自己的测验结果相比较。</li><li>结构效度：是指充分测量潜在结构的程度。心理学家对一些抽象特质提出了相关理论或结构，如焦虑、抑郁等特质，测验结果与目标特质的结构越相关，结构效度就越高。</li></ul></li><li>标准化：是指在同一条件下对所有人、以同样的方式实施测验，得到的成绩分布就是测验的评分标准，也叫作常模。</li></ul></li><li>心理测量学是心理学的一个分支，主要是对心理能力进行全方位的测量，包括人格评定、智力评估和能力测量。通过在不同的能力测量中寻找统计相关，基于这些关系得到有关人类智力本质的结论，这种技术叫做因素分析。查理斯·斯皮尔曼认为存在一般智力因素或g因素，是所有智力操作的基础。雷蒙德·卡特尔认为一般智力分为两个相对独立的成分，一个是晶体智力，包括一个人获得的知识以及获得知识的能力，另一个是液体智力，是发现复杂关系和解决问题的能力。</li><li>罗伯特·斯滕伯格提出了三因素理论，认为智力包括分析、创造和实践三种类型。分析智力是对基础信息加工的能力。创造智力是处理新异问题的能力。实践能力是处理日常事物和适应环境的能力。</li><li>霍华德·加德纳提出了多元智力理论，归纳出语言、音乐、空间、逻辑-数学、自然主义、身体运动、人际和内观八种智力，政治家和生意人倾向于各种智力相对平衡，科学家和艺术家倾向于在一两种智力上表现卓越。</li><li>创造力是指就特定环境而言，个体产生新异的和合适的思想和产品的能力。创造力的测量集中在发散思维和聚合思维上，发散思维是对某一问题产生许多不寻常的想法的能力，聚合思维是整合不同来源信息从而解决问题的能力。</li><li>心理测量学的三个争议：<ul><li>基于测验的决策的公平性：用同一种常模评价所有的测验参与者，忽视了群体差异，使少数群体承受了负面后果。</li><li>测量用于教育评价的可行性：学校过分看重心理测验的成绩，扭曲了教育的目的，助长了撒谎作弊的风气。</li><li>以测验分数进行个体分类的意义：测验对人的标签化使得到负面评价的人产生心理障碍。</li></ul></li></ul><h1 id="10-人的毕生发展"><a href="#10-人的毕生发展" class="headerlink" title="10 人的毕生发展"></a>10 人的毕生发展</h1><ul><li>发展心理学是心理学一个分支，关注个体从受孕开始贯穿一生所发生的生理和心理机能的变化，对发展进行记录和解释。常模研究是指刻画某个特定年龄段或发展阶段的特征，使心理学家区分人的生理年龄。纵向研究是指连续多年持续观察同一个体，横向研究是指同一时间观测不同生理年龄阶段的参与者。</li><li>皮亚杰提出了一套关于儿童认知发展的理论。他把促使个体能够理解世界的心理结构称为图式，图式是发展变化的基本单元。认知的发展是两个基本过程的协同工作：同化和顺应。同化是对新的环境信息加以修改使之适合个体已有的知识结构。顺应是对已有的图式进行修改以使新的信息得到更全面的理解。同化和顺应协同的一个例子是婴儿基于先天的抓握行为改变抓握的尺度实现抓握奶瓶。</li><li>皮亚杰认为儿童的认知发展可以分为四个有序但不连续的阶段：<ul><li>感知运动阶段：从出生到两岁，婴儿基于注视、抓握等先天图式进行改善、组合来丰富自身的行为。婴儿期最重要的认知是获得了对不在眼前的客体形成心理表征的能力，也就是当感知目标消失了以后还能意识到它曾经存在过。</li><li>前运算阶段：2~7岁之间，前运算思维的特点是自我中心，也就儿童不能站在别人的角度思考问题，还有个特点是中心化，即儿童只会关注情境的某一方面而忽略其他相关方面。</li><li>具体运算阶段：7~11岁之间，儿童开始心理运算，在脑中产生逻辑思维的活动，可以用心理活动代替物理活动。儿童学会了守恒的概念，当改变物体的外表而不改变数量、质量等物理属性时，儿童能意识到这种不变性。</li><li>形式运算阶段：始于11岁，思维变得抽象，开始系统地思考复杂问题。</li></ul></li><li>社会性发展是个体的社会交往和社会期望在个体的一生中的变化。艾瑞克·埃里克森提出了8个心理社会发展阶段，每个阶段都有主要的冲突或危机：<ul><li>信任对不信任：0~1.5岁，通过与照料者之间的交往建立对环境的基本信任。相反，当儿童的基本需要没有得到满足，可能发展出不信任感、不安全感和焦虑感。</li><li>自主对自我怀疑：1.5~3岁，通过探索和操纵客体产生安全的自主感。相反，对儿童过分批评或约束可能导致他们产生自我怀疑。</li><li>主动对内疚：3~6岁，发展了基本信任感的儿童能够主动产生智力或运动行为，父母的鼓励促进了自主感和自信感。相反，父母的负面评价会使儿童产生内疚感。</li><li>勤奋对自卑：6岁~青春期，儿童系统地发展各项能力，努力追求能力的提升使自己感到有能力。相反，如果儿童仅作为旁观者或经历太多失败，会产生自卑感。</li><li>同一性对角色混乱：青少年期，对不同人扮演不同角色，并在这种混乱中培养对自我的一致感。反之则导致青少年缺乏稳定的、核心的自我形象。</li><li>亲密对孤独：成年早期，发展对他人做出充满感情、道德和性的承诺的能力。</li><li>繁殖对停滞：成年中期，把对自己和伴侣的承诺扩展为对整个家庭、工作、社会以及后代的承诺。</li><li>自我整合对绝望：成年晚期，回顾往事，不留遗憾，产生圆满感。</li></ul></li></ul><h1 id="11-动机"><a href="#11-动机" class="headerlink" title="11 动机"></a>11 动机</h1><ul><li>动机(motivation)是对所有引起、指向和维持生理和心理活动的过程的统称。心理学家采用动机的概念有五个目的：把生物学和行为联系起来、解释行为的多样性、以公开的行动来推断内心的状态、将责任感赋予行动、解释逆境中的意志。</li><li>动机来自于内因和外因。内因包括内驱力(drive)、本能(instinct)和历史学习，内驱力是指生物体为满足生理需求或维持平衡状态做出的反应，比如保持体温、消除紧张。外部诱因(incentive)是外部的刺激和奖赏，与生理需要没有直接联系。把动机来源看成内部还是外部，一定程度依赖于人对客观实体的主观认识。</li><li>亚伯拉罕·马斯洛提出了需要层次论，认为基本的动机形成了五个层次，在到达下一个更高层次之前，每一层次的需要都必须被满足。需求层次由低到高分别是：生理需要、安全需要、归属与爱的需要、尊重的需要、自我实现的需要。</li></ul><h1 id="12-情绪、压力和健康"><a href="#12-情绪、压力和健康" class="headerlink" title="12 情绪、压力和健康"></a>12 情绪、压力和健康</h1><ul><li>情绪(emotion)定义为对具体事件的特殊反应，强烈且持续时间短，而心境(mood)通常是不强烈且持续时间长的。</li><li>达尔文在《人类和动物的表情》里提出，所有物种的情绪与其他重要的结构及功能一同进化而来，是一种遗传得来、对世界上某类反复发生的情境做出反应的特定心理状态，比如婴儿一出生就能对巨大声响表现出恐惧。情绪作为进化的产物有适应能力，在不同的文化背景下，不同的社会规范影响了人们的情绪反应。</li><li>情绪反应的生物学基础是大脑和神经系统的协同作用，关于情绪与生理反应的关系，书中介绍了三种理论：<ul><li>詹姆斯-兰德理论：认为情绪来源于身体反馈，比如人不是因为难过而哭泣，而是因为哭泣而难过。这种理论把情绪链中最重要的角色赋给了内脏反应，直观上感觉是错误的。</li><li>坎农-巴德理论：认为情绪是中枢神经的作用，并通过实验证明了身体反应和心理反应的独立性。</li><li>认知评价理论：认为情绪的产生受到环境事件、生理状况和认知过 程三种因素的影响，其中认知过程是决定情绪性质的关键因素。</li></ul></li><li>应激(stress)是一种反应模式，当刺激事件打破了有机体的平衡和负荷能力，或者超过了个体的能力所及，就会体现为压力。分为急性应激和慢性应激。<ul><li>急性应激反应的中心是下丘脑，它控制自主神经系统调节机体活动，如心跳加快、血压上升，同时促进肾上腺素的分泌。面临危险时，男性的反应是身体做好防御、挣扎、逃跑的准备，这种应激叫做战斗或逃跑反应，女性的反应是照顾孩子的需求以及与相同目标的人结盟，这种应激叫做照料和结盟反应。然而这两种反应都不能完全适用于现实生活。</li><li>慢性应激时，有机体为了恢复平衡要经历报警、抵抗、衰竭三个阶段。应激激素的过度分泌会降低吞噬细胞的杀伤能力，损害免疫系统的完整性，出现心身失调的症状。</li></ul></li><li>健康心理学是心理学一个分支，研究人们怎样保持健康、患病的原因以及生病后的反应。健康是指身体和精神上的一种稳定、充满活力的一般状态。健康心理学以健康的生物心理社会模型为基础，生物心理社会模型将健康与心理状态和社会环境联系了起来。</li></ul><h1 id="13-理解人类人格"><a href="#13-理解人类人格" class="headerlink" title="13 理解人类人格"></a>13 理解人类人格</h1><ul><li>人格(personality)是一系列复杂的心理品质，具有跨时间、跨情境一致性的特点，对个体行为的特征性模式有独特的影响。人格理论是对个体人格结构和功能的假设性说明。</li><li>人格类型是依据人格理论对人的归类。有下几种人格类型理论：<ul><li>公元前五世纪，希波克拉底提出人体有血液、粘液、黑胆汁、黄胆汁四种基本体液，个体人格是由体内何种体液占主导决定的。</li><li>1942年，威廉·赛尔顿提出将体型与气质联系在一起，根据体型将人分成三种类型：内胚层型(胖、柔软、圆润)，中胚层型(肌肉发达、矩形身材、强壮)，外胚层型(瘦、长、虚弱)。</li><li>近些年，弗兰克·沙洛威提出基于出生顺序的现代类型理论，也就是在家里是先生子还是后生子。</li></ul></li><li>类型理论把人分成离散的几个类型，而特质理论推崇智力、友谊等连续性维度，特质就是人持久的品质或特征。有下几种人格特质理论：<ul><li>戈登·阿尔波特提出三种特质：首要特质、核心特质和次要特质。首要特质决定一个人如何组织生活，核心特质代表一个人主要特征和品质，次要特质有助于预测个体行为。</li><li>卡特尔提出了人类人格的16因素，称为根源特质。</li><li>艾森克根据人格测验的数据推论出三大维度：外向性(内向还是外向)、神经质(情绪稳定还是不稳定)和精神质(善良体贴还是冲动暴力)。</li><li>近年来提出了五因素模型，即外倾性(内向还是外向)、宜人性(善良还是冷漠)、尽责性(谨慎还是轻率)、神经质(情绪稳定还是不稳定)和开放性(聪明还是肤浅)，是艾森克理论的升级版。</li></ul></li><li>弗洛伊德提出了心理动力学的人格理论，认为是强大的内在驱力塑造人格并引发行为，试图从人格发展的起源和进程、心理的本质、变态人格的各个方面以及通过治疗改造人格进行解释。</li><li>弗洛伊德最初提出两种基本内驱力：自我生存和性本能。性欲心理发展有五个阶段和发展任务：口唇期(断奶)、肛门期(如厕)、生殖器期(俄狄浦斯情结)、潜伏期(防御机制的发展)和生殖期(成熟的性亲密行为)。弗洛伊德的精神决定论认为，所有心理和行为反应都是由早期经验决定的，行为可以被人意识不到的内驱力引发，所以弗洛伊德注重研究无意识，比如梦。</li><li>弗洛伊德认为人格的差异源于人们以不同的方式对待基本的驱力，人格是本我和超我的无休止的战斗，这种战斗由自我来调和。<ul><li>本我(id)：原始驱动力的储存处，非理性，受快乐原则支配，无节制地追求满足感而不计后果。</li><li>超我(superego)：价值观的储存处，与良心的概念相似。</li><li>自我(ego)：一个基于现实的方面，是关于行为的原因和后果的理性认识。受现实原则支配，使人选择能满足需求且后果可接受的行为，调和本我和超我的矛盾。</li></ul></li><li>自我防御机制是自我在寻求表现的本我冲动与否定他的超我要求之间的日常冲突中用来保护自身的心理策略，欲望的压抑就是一种自我防御，由此产生的强烈情绪反应就是焦虑。</li><li>后弗洛伊德理论是后继者对精神分析理论的修正：<ul><li>阿尔弗雷德·阿德勒提出人人都会体验到自卑感，会以自己的方式努力克服自卑感，人就是在这种基本的奋斗中构建人格。</li><li>凯伦·霍尼提出“子宫妒忌”使男人贬低女人，并通过无意识地进行创造性工作加以过度补偿。</li><li>卡尔·荣格提出了集体无意识的概念，是整个人类共有的基本心理事实。集体无意识可以解释人对普遍存在的、可构成原型的原始神话、艺术形式和象征的直觉性理解。</li></ul></li><li>人本主义学派从整合个体的个人经验和意识经验及成长潜能的角度理解人格，强调自我实现的驱力，自我实现是指个体不断努力开发自身智力、实现个人内在潜能的倾向。</li><li>人本主义理论具有三种特征：<ul><li>整体性：从个体的整体人格看待其分散的行为。</li><li>先天倾向性：关注影响、决定行为方向的个体内在特征，而把环境因素视为限制和障碍。</li><li>现象学性：强调个体的参考框架与对现实的主观看法，而不是观察者或治疗家的客观视角。</li></ul></li><li>不同的人格理论中存在着五个重要的差异：<ul><li>遗传和环境：对人格发展来说，生理因素和环境因素哪个更重要？</li><li>学习过程和先天法则：人格是先天决定的还是后天学习改变的？</li><li>过去、现在和将来：强调人生哪个阶段的人格发展。</li><li>意识与无意识：强调意识过程还是无意识过程？</li><li>内在倾向与外在情境：强调人格的内在倾向还是人格与环境的交互？</li></ul></li></ul><h1 id="14-心理障碍"><a href="#14-心理障碍" class="headerlink" title="14 心理障碍"></a>14 心理障碍</h1><ul><li>心理障碍(障碍:disorder)或心理病理是被认为不健康或变态的心理功能，严格说不是病，是一种对违反社会共识的心理状态。变态心理学研究的就是与个体意识、情绪和行为相关的病理问题。心理障碍有七个标识：痛苦或功能不良、适应不良(个体行为妨碍目标实现)、非理性、不可预测性、非惯常性和统计的极端性(个体行为不被公众接受且处于统计学的极端位置)、令观察者不适、以及对道德或理想标准的违反。</li><li>心理诊断是通过把观察到的行为模式归类到公认的诊断系统中。分类系统应当具有三点好处：<ul><li>通用的简略语言：促进心理病理领域的临床工作者和研究者之间快捷和清楚的相互理解。</li><li>病原学的理解：对于一种特定障碍的诊断应当将症状的病因澄清。</li><li>治疗计划：针对特定的障碍应当采取何种治疗方式。</li></ul></li><li>病原学(etiology)是指引起或促使心理疾病和医学疾病形成的因素，心理障碍的病因包括生物因素和心理因素。生物因素有遗传因素、脑损伤或感染等。心理因素目前主要有四种模型：<ul><li>心理动力学模型：行为是由人们意识不到的内驱力和愿望所驱动，心理病理症状的根源存在于无意识冲突和观念中。也就是由于自我无法调节本我和超我的冲突所导致的过度防御。</li><li>行为主义模型：变态的行为与健康的行为是通过同样的方式即学习和强化获得的。心理障碍之所以出现是因为个体学会了自我挫败或无效的行为方式。</li><li>认知模型：心理障碍的起源也在于人们如何感知或思考自己，以及与别人和周围环境之间的关系。心理问题是对现实情境的歪曲感知、错误推理，以及不良的问题解决所导致。</li><li>社会文化模型：特定文化背景对心理问题有诱发作用。</li></ul></li><li>焦虑障碍有五个主要类型：<ul><li>广泛性焦虑症：至少六个月以上的时间感到焦虑或担心，但不是由于特定危险的威胁。</li><li>惊恐障碍：意料之外的严重的惊恐发作，持续时间短，感觉到强烈的恐惧、害怕或惊慌。</li><li>恐惧症：恐惧是对于客观确认的外部危险的理性反应，恐惧症是病人持续和非理性地害怕某一特定的东西、活动或者情境，如社交恐惧症。</li><li>强迫症：无法摆脱特定的思维和行为模式，做出不合理的、多余的强迫行为。</li><li>创伤后应激障碍：通过痛苦的回忆、做梦、幻想或闪回，持续地重新体验到创伤事件。</li></ul></li><li>焦虑障碍的原因：<ul><li>生物学派：神经递质GABA的水平降低时会出现焦虑的感受。</li><li>心理动力学派：焦虑障碍的症状源自潜在的精神冲突或恐惧，目的是保护个体不受心理伤害。强迫行为是试图移除焦虑的一种努力。</li><li>行为主义学派：焦虑障碍的症状是强化或条件化的结果，中性刺激与恐怖经验一起出现时，会变成恐怖刺激，让人学到恐惧的条件反应。</li><li>认知学派：焦虑病人有认知上的偏差，可能高估了现实的危险，或低估了自己有效应对威胁的能力。</li></ul></li><li>人格障碍指的是一种持久的、不可变的、适应不良的感知、思维或行为模式，严重损害一个人在社交或职场中的功能，造成显著的痛苦。两种主要的人格障碍：<ul><li>边缘型人格障碍：人际关系紧张且极不稳定，部分原因是他们无法控制愤怒，表现出冲动性行为。还表现出对被遗弃的强烈恐惧。</li><li>反社会型人格障碍：持久的缺乏责任感、不遵守法律、做出违反社会规范的行为。</li></ul></li><li>精神分裂症是一种严重的心理病理形式，人格似乎解体，思维和知觉出现歪曲，情感变得迟钝。有五种主要类型：<ul><li>瓦解型：个体表现出不连贯的思维模式和非常怪异和紊乱的行为。</li><li>紧张型：表现出动作的紊乱和极端的违拗，即对所有的指示都表现出明显的、原因不明的抗拒。</li><li>偏执型：有复杂且具系统性的妄想，很少表现出紊乱行为，行为多半是激烈和正式的。</li><li>未分化型：表现出不止一种类型特征。</li><li>残留型：病人经受了上一次精神分裂症发作的影响，也就是精神病后遗症。</li></ul></li></ul><h1 id="15-心理治疗"><a href="#15-心理治疗" class="headerlink" title="15 心理治疗"></a>15 心理治疗</h1><ul><li>主要的治疗学派：<ul><li>生物医学治疗：关注改变中枢神经系统运转的机制。</li><li>心理动力学派：谈话治疗，帮助个体把外显症状与内部未能解决的冲突联系起来，引导其产生领悟。</li><li>行为治疗：对失调的行为进行矫正。</li><li>认知治疗：改变个体对问题的自我陈述，重建其思维方式，改变个体对困难的理解和认识。</li><li>人本主义学派：关注改善健康人的心理功能，而不是纠正处于严重失调的个体的症状，强调人的价值，认为要依靠自身的深化认识和潜能激发来恢复心理健康。</li></ul></li><li>心理动力学派起源于弗洛伊德的精神分析，一个重要目标是让病人能够洞察并领悟人际冲突。精神分析通过几项技术帮助病人将被压抑的冲突带回意识中并解决冲突：<ul><li>自由联想和宣泄：让病人的大脑处于自由状态，弗洛伊德认为自由联想的内容不是随机的，而是事先存在于个体的内心。鼓励病人宣泄情感，通过外显反应确定病因。</li><li>阻抗：在自由联想中，病人表现出不能或不愿意讨论某些观念、意愿或经历。心理治疗的目的是打破阻抗。</li><li>梦的解析：从无意识里寻找表达的潜在动机，以及某些重要生活经历或愿望所具有的象征意义。</li><li>移情和反移情：治疗过程中治疗师和病人相互产生的情绪反应，也就是拉近关系，帮助对方发现真实的自己。</li></ul></li><li>几种行为治疗。<ul><li>反作用条件是让个体学习一个新的条件反应去替代或对抗适应不良的反应，以反作用条件为基础发展出以下几种疗法：<ul><li>暴露疗法：让病人直接面对引发焦虑的客体或情境，主动学会放松自己。</li><li>系统脱敏法：交叉抑制理论认为神经系统无法同时处于放松和兴奋状态，所以原始暴露疗法是有缺陷的，应该让病人在放松状态逐步地暴露于刺激中。</li><li>满灌疗法：让病人迅速地暴露在刺激面前。</li><li>厌恶疗法：将诱发性刺激与令人厌恶的刺激混合，消除病人的负面条件反应。</li></ul></li><li>权变管理是借助改变行为的结果来改变行为的治疗策略，有两种主要的技术，正强化策略和消退策略，也就是施加适当的奖励或惩罚改变病人的行为。</li><li>社会学系疗法是通过设计特定情境，让来访者观察到榜样因表现出适应性行为而得到强化，进而矫正来访者的问题行为，也就是替代学习疗法。</li><li>泛化技术：增加治疗中的靶行为、强化物、榜样、刺激等与实际生活情境中事物的相似性，让病人在治疗中学会的新行为模式能运用在日常生活中。</li></ul></li><li>认知疗法就是口头教育，灌输正确价值观，我觉得我也可以。</li><li>人本主义有两种主要疗法：来访者中心疗法和格式塔疗法。来访者中心疗法就是众星捧月，一堆治疗师倾听来访者哔哔，帮助来访者开放表达，引发自己恢复心理健康的潜力。格式塔疗法就是帮助来访者自我对话，引发潜在力量。</li><li>生物医学治疗包括药物治疗、大脑手术治疗、大脑电击疗法等。</li></ul><h1 id="16-社会心理学"><a href="#16-社会心理学" class="headerlink" title="16 社会心理学"></a>16 社会心理学</h1><ul><li>战略性放弃</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://shivakasu.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="心理学" scheme="https://shivakasu.cn/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《人类简史》</title>
    <link href="https://shivakasu.cn/2020/01/26/read0/"/>
    <id>https://shivakasu.cn/2020/01/26/read0/</id>
    <published>2020-01-26T11:07:20.000Z</published>
    <updated>2020-01-27T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="认知革命-约7万年前"><a href="#认知革命-约7万年前" class="headerlink" title="认知革命(约7万年前)"></a>认知革命(约7万年前)</h1><ul><li>烹调技术的发明减少了食物所需要的咀嚼和消化的时间，让人类可以缩短肠道、降低能量消耗，有了发育大脑的余地。学会用火让人类能主动控制和利用自然的力量，有了发展的实力。</li><li>智人能够淘汰其他的人种征服世界，是因为偶然的基因突变改变了大脑，让智人拥有了新的语言技能，不仅能沟通信息，还有了虚构故事的能力，这是智人集结人力、团结合作的基础。因为依靠互相认识、交流所能维持的团体大约是150人，而共同相信一个虚构的故事或存在就能打破团体规模变大产生的认知壁垒。现代社会也是如此，没文化的可以有相同的宗教崇拜，有文化的可以考虑共同利益，人之间的合作不再严格需要彼此认识和了解。</li><li>认知革命以来，智人生活在双重现实中。一个是客观存在的现实，一个是能使人相信的想象中的现实。这种意识形态的产生使人类社会的发展不再由基因的演变所主导，而是可以根据需求主动引导社会的变革，使人类社会走上快速发展的道路，这是智人胜利的关键。从此智人超越了生物学对人类行为和能力的基本限制，创造了文化和历史。</li><li>有证据表明，自采集时代以来智人的脑容量在逐渐减少，因为随着社会分工的发展，人类越来越能够依赖别人的技能和成果，不需要精通各方面的知识和技能也可以很好地生存。</li><li>远古采集时代的智人有健康和多样化的饮食、相对较短的工时，也少有传染病发生，许多专家将这种社会定义为“最初的富裕社会”。普遍认为远古采集者是泛神论者，相信万物有灵。但是由于时间久远、生活习惯严重分化，目前还没有对远古采集者的可信的研究。</li><li>远古智人学会了航海，因为自然和人口的压力移居到了其他大陆。气候变迁加上人类狩猎和火耕的影响，使其他大陆遭受了物种灭绝。智人的殖民消灭了地球上半数的大型陆地动物。工业革命以来人类对海洋资源的过度滥用，使得海洋生物也开始面临生态危机。</li></ul><h1 id="农业革命-约1万年前"><a href="#农业革命-约1万年前" class="headerlink" title="农业革命(约1万年前)"></a>农业革命(约1万年前)</h1><ul><li>农业革命最早发生在中东、中国和中美洲，因为适合被驯化的少数几种动植物只生长在这些地方。</li><li>农业革命并不完全意味着人类文明的进步，驯化少数几种动植物虽然增加了食物的总量，但人类也承受了改造自然的代价。人类从丰富的饮食结构变成只依赖于少数几种农作物，还要花费额外的精力去维护农作物的生长环境以及抵抗自然灾害，农耕所产生的土地所有权问题还会加剧人类之间的暴力冲突。虽然后续文明的发展得益于农业革命，但对于初代农耕人类来说，农业革命是弊大于利的。</li><li>一种观点认为农业革命的产生是因为人类的误判，想让生活更轻松，却没有考虑到随之而来的负面问题，导致最终反倒加重了生存的压力。另一种观点认为人类文化里发展出了信仰建筑，为了围绕信仰建筑建立住所，人类自愿生活得更辛苦，从采摘生活转为农耕生活。</li><li>农业时代人类的活动空间缩小了，但需要规划的未来变长了。不断主动生产充足的食物，会造成人口的爆炸，让人类越来越难以回到碰运气的采摘生活，取而代之的是由农作计划主导的生存状况，所以农民不得不考虑到更长远的未来，努力维持生活水平。</li><li>在农业时代的群体冲突下产生了精英阶层，他们为了实现统治的目的需要创造出一套虚拟的意象来维持群体的秩序，比如宗教、人权。这种虚拟意象要能让人们相信，至少不能明显违背人们对客观现实的认知，同时还要一代代对人们洗脑，最终让它成为一种社会共识，让人们自然而然地以它为基础思考，遵守这种虚拟的规则。越多的人服从统治，要打破规则就越难。</li><li>蚂蚁和蜜蜂的群体秩序是基因决定的，天生就决定了社会分工，他们的行为模式也并不复杂。但人类社会的秩序是由一套庞大的虚构的故事和规则维持的，人类自身的基因和大脑并没有进化成熟到支持存储这么复杂的群体合作的生物信息，所以记忆的局限促成了文字的发明。</li><li>人类不满足于用文字只记录无聊的数据，开始进行文娱方面的大量创作，使得文字记录越来越多，多到需要一种专门负责数据管理和检索的职位。组织文献的行为强化了社会分工和分层管理的理念，改变了人类思维和看待世界的方式，过去的自由连接、整体思考，已经转变为分割思考、官僚制度。</li><li>由于人类社会的秩序建立在虚构的规则之上，不能彻底避免歧视，所以出现了精英群体主导下的社会阶级、种族阶级等歧视性的制度。但维持社会秩序又似乎离不开阶级制度，因为人们不必浪费精力详细了解彼此，只需要知道各自所处的阶级，就能大致掌握彼此的社会分工以及相处的规矩。久而久之，阶级甚至会被人们视为天然正确而合理的存在。</li><li>阶级制度大多是由偶然的历史事件促成的，完全是人类虚构出的制度，所以在不同群体里的表现相差很大，但重男轻女的思想却出奇的一致，说明性别歧视是与人类的生物学特征相关的。目前有几种理论试图解释重男轻女：肌肉理论认为男人比女人强壮，把体力优势转化成了政治上的优势。流氓理论认为男性基因里有更多的暴力和侵略倾向，更适合主导战争、统治群体。父权基因理论认为在数百万年的演化过程中男性和女性发展出了不同的生存和繁殖策略，男性倾向于保留积极好胜的基因，女性倾向于保留顺从、接受照顾的基因。</li></ul><h1 id="人类的融合统一"><a href="#人类的融合统一" class="headerlink" title="人类的融合统一"></a>人类的融合统一</h1><ul><li>社会秩序是人类虚构、臆想的，所以人与人之间、群体与群体之间必然会存在价值观的矛盾，当人们试图解决这些矛盾时，就容易把问题上升到文明的冲突。一方面，文明冲突引发了战争，另一方面，不同文明的碰撞又激励了人们的思考、创造，推动文明的发展。</li><li>从宏观的历史角度看，人类文明是趋于融合的，就像如今所有人类都接受几乎同样的地缘政治体系、经济制度、法律制度、科学体系，尽管不同群体存在着文化差异，但不会再像远古时期一样完全不懂对方的文化，有了冲突只能依靠战争解决，而是在一套公认的基本国际共识下进行争斗。</li><li>随着全球贸易交流的进行，人类文明进一步融合，小群体的社会秩序慢慢孕育出了“世界一家”的理念。公元前的1000年间，出现了三种有可能达到“世界一家”的秩序：经济上的货币秩序，政治上的帝国秩序，以及宗教上的全球性宗教。</li><li>货币的出现是因为以物易物难以高效运行在规模庞大、结构复杂的社会中，一种通用的、中间性的交易媒介能够提高交易的效率，也让财富的转换、存储和运输变得更容易。</li><li>金钱是有史以来最普遍也是最有效的互信系统。</li><li>帝国的两个特征是文化多元性和疆界灵活性。帝国是造成民族多样性大幅减少的主因之一，但帝国也通过剥削战败者创造了大量文化成就。</li><li>帝国思想加速了文明的融合，因为处于统治的目的，帝国本身会刻意推动传播共同文化，主动对思想、制度、习俗、规范进行标准化。由于帝国思想的理念在于普遍和包容，所以结果不会是征服者对被征服者的文化灭绝，征服者会吸收不同的文化而让帝国形成一种融合后的文明，也就是文化的涵化和同化。</li><li>当下的国际形势可以理解成正在走向一个统一的全球帝国。各个国家遵循着国际秩序进行合作，得以共同解决关乎人类利益的更宏大的问题。国家的独立性正在迅速消失，越来越难脱离全球性的组织。</li><li>社会秩序和阶级都只是想象的产物，社会规模越大它们就越脆弱，宗教的重要性就在于让这些脆弱的架构有了超人类的合法性，确保了社会的稳定。</li><li>泛神论时代人们认为万物有灵，世上所有的存在都是要平等尊重的。到了农业时代，人们打破了这种平衡，对动植物有了控制的欲望和需求，农业革命最初的宗教意义，就是让动植物从与人类平等的生物，变成了人类的所有物。当农业因为天灾人祸的影响暂时失控时，由于人们已经不再相信万物平等，于是发明了鬼神崇拜来解释这种失控，试图与高于动植物的神明进行沟通，逐渐发展成了多神教信仰。人类地位的提升是多神论与泛神论的区别。</li><li>大多数多神教都相信存在一个超越一般神灵的最高意志，真正与一神论不同的是，多神论的最高意志不带有任何私心或偏见，对人类的各种世俗的欲望、担心和忧虑毫不在意。最高意志包容着不同领域各有私心的一般神灵，所以多神论本质上就是开明、包容的。历史上的宗教迫害基本都是一神教对异教徒的暴力行为。</li><li>当某些多神论者对自己信仰的某位神灵格外虔诚，就不再相信其上的最高意志，而是把那位神灵本身当做最高意志，于是从多神教里分化出了一神教。一神教的最高意志有私心和偏见，让人类可以直接和最高意志谈条件，所以人们更乐于接受一神教。</li><li>从历史上看，一神论吸收了二元论、多神论、泛神论的思想。就像基督徒信奉一神论的上帝，相信二元论的魔鬼，崇拜多神论的圣人，还相信泛神论的鬼魂。</li><li>除了信奉超自然神灵的宗教，还有信奉自然法则的宗教。如佛教信奉佛法，神的存在与否并不重要，重要的是相信自然法则，指导自身的修行。</li></ul><h1 id="科学革命-约500年前"><a href="#科学革命-约500年前" class="headerlink" title="科学革命(约500年前)"></a>科学革命(约500年前)</h1><ul><li>现代科学与先前的知识体系有三点不同：愿意承认自己的无知，以观察和数学为中心，运用理论取得新能力。</li><li>承认无知是知识体系不断发展进步的驱动力，欧洲在1900年左右征服世界的最大功臣就是科学，而欧洲科学领先的原因就是先承认无知。先前的帝国主义征服世界是为了扩张领土和传播统治思想，但欧洲帝国主义的扩张还多了学习新知识的目的。</li><li>发现美洲是科学革命的一大奠基事件，不但让欧洲人知道实际的观察比过去的传统更重要，而且像征服美洲的欲望也让欧洲人开始求知若渴。</li><li>早期社会的经济不发达是因为人们不相信未来会更好，认为世界是固定大小的一块蛋糕，获得利益的唯一途径是互相争夺。在承认自己的无知后，人们开始相信只要投资进行研究，一切就能变得更好，有了这种信任的基础，人们就会减少争斗、着重发展经济。信任创造了信贷，信贷发展了经济。</li><li>亚当斯密指出：人类全体财富的基础，就在于希望增加个人利润的自私心理。所以贪婪是好的，利己就是利他，因为人们相信个人获利也会使整个经济蛋糕变大。</li><li>现代资本主义经济的一大重点，就在于出现了一种新的道德标准：应该把利润拿出来，继续投资生产。资本主义认为资本和财富不同，资本是人们主动投入生产的资源。这也是因为人们开始相信，生产是可以不断发展进步的，而支持这种信任的，就是科学技术的不断发展。</li><li>资本主义影响了欧洲帝国主义，征服世界的资金从税收逐渐转为信贷，商人和银行家直接成为统治精英，因为投资有利润回报，所以帝国能通过信贷筹集更多的资金。鸦片战争就是典型的国家为资本家服务，国家在鸦片商的施压下向中国宣战。</li><li>资本主义以利润为至高目标，所以让社会上出现大量不平等的压迫现象。所以资本主义和共产主义互相看不上。</li><li>工业革命的核心是能源转换的革命，不断增加可用的能源，来支持人们对社会发展的期望。</li><li>工业革命时期，国家和市场取代了家庭和社群的物质功能，并创造了想象的社群来代替原始社群的情感功能，比如民族和消费大众，将人们捆绑在一个想象中的大家庭里。</li><li>科学技术让人们可以打破自然选择的法则。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://shivakasu.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="社会学" scheme="https://shivakasu.cn/tags/%E7%A4%BE%E4%BC%9A%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>旅行商问题与最优解搜索算法</title>
    <link href="https://shivakasu.cn/2020/01/16/arg3/"/>
    <id>https://shivakasu.cn/2020/01/16/arg3/</id>
    <published>2020-01-16T07:00:20.000Z</published>
    <updated>2020-01-26T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h1><p>旅行商问题（Travelling Salesman Problem, TSP）是这样一个问题：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。它是组合优化中的一个NP困难问题。本文选择公开的<a href="http://elib.zib.de/pub/mp-testdata/tsp/tsplib/tsp/index.html" target="_blank" rel="noopener">a280数据集</a>进行测试，求解访问全部城市的最短路径。数据预处理及数据散点图如下：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import math,random,time,copy</span><br><span class="line"></span><br><span class="line"># 城市坐标</span><br><span class="line">cities &#x3D; []</span><br><span class="line"># 邻接矩阵，distance[i][j]表示cities[i]到cities[j]的距离</span><br><span class="line">distance &#x3D; []</span><br><span class="line"></span><br><span class="line">def init():</span><br><span class="line">    with open(&quot;a280.tsp&quot;,&#39;r&#39;) as f:</span><br><span class="line">        lines &#x3D; f.readlines()</span><br><span class="line">    i&#x3D;0</span><br><span class="line">    while &quot;NODE_COORD_SECTION&quot; not in lines[i]:</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">    for j in range(280):</span><br><span class="line">        c &#x3D; lines[i+1+j].split()</span><br><span class="line">        cities.append([int(c[1]),int(c[2])])</span><br><span class="line">    for i in range(len(cities)):</span><br><span class="line">        distance.append([])</span><br><span class="line">        for j in range(len(cities)):</span><br><span class="line">            if i&lt;&#x3D;j:</span><br><span class="line">                distance[i].append(math.sqrt((cities[i][0]-cities[j][0])**2+(cities[i][1]-cities[j][1])**2))</span><br><span class="line">            else:</span><br><span class="line">                distance[i].append(distance[j][i])</span><br><span class="line">                </span><br><span class="line"># 计算一个解的路径总长度</span><br><span class="line">def totalDistance(arr):</span><br><span class="line">    res &#x3D; 0</span><br><span class="line">    for i in range(len(arr)-1):</span><br><span class="line">        res +&#x3D; distance[arr[i]][arr[i+1]]</span><br><span class="line">    res +&#x3D; distance[arr[-1]][arr[0]]</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure><div id="echarts5447" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts5447'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>在最优解搜索问题中，首先需要明确的是解的形式是什么以及评价解好坏的标准是什么。在旅行商问题中，解的形式是遍历城市的顺序，也就是城市数组排列的一种顺序，评价解的标准是路径总长度。</p><h1 id="2-精确算法"><a href="#2-精确算法" class="headerlink" title="2 精确算法"></a>2 精确算法</h1><p>精确算法得到的结果是全局最优解，因而在求解NP完全问题时必然会遇到时间复杂度爆炸的瓶颈。</p><h2 id="2-1-暴力搜索"><a href="#2-1-暴力搜索" class="headerlink" title="2.1 暴力搜索"></a>2.1 暴力搜索</h2><p>暴力搜索是采用深度优先遍历，依次遍历所有可能的路径，保证最终能得到全局最优解。算法结构简单，占用空间小，但在问题包含 $N$ 个节点的情况下总路径数高达 $N!$ ，时间复杂度也是 $O(N!)$ 。</p><h2 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h2><p>首先要证明动态规划的可行性，即问题的最优解所包含的子问题的解也是最优的。在本题中就是要证明，当 $s_0\rightarrow s_1\rightarrow s_2 … \rightarrow s_{n-1} \rightarrow s_0$ 是从 $s_0$ 出发经过 $n$ 个城市回到 $s_0$ 的最短路径时，子问题 $s_1\rightarrow s_2…\rightarrow s_{n-1} \rightarrow s_0$ 就是从 $s_1$ 出发经过 $n-1$ 个城市到达 $s_0$ 的最短路径，使用反证法就能证明。</p><p>设 $dp(i,V)$ 表示从顶点 $s_i$ 出发经过 $V$ 中各个顶点一次且仅一次，最后回到出发点 $s_0$ 的最短路径长度。当 $V$ 是空集时，直接回到 $s_0$ 即可，路径长度就是 $s_i$ 到 $s_0$ 的距离，记为 $dp(i,\emptyset)=c_{i0}$ ，当 $V$ 不是空集时，就要遍历当前可选择的所有子问题，即 $dp(i,V)=min{c_{ik}+dp(k,V-{k})}$</p><p>时间复杂度 $O(2^nn^2)$ ，空间复杂度 $O(n2^n)$ </p><h1 id="3-个体启发式算法"><a href="#3-个体启发式算法" class="headerlink" title="3 个体启发式算法"></a>3 个体启发式算法</h1><h2 id="3-1-爬山法"><a href="#3-1-爬山法" class="headerlink" title="3.1 爬山法"></a>3.1 爬山法</h2><p>爬山法是一种简单的局部择优的算法。算法从一个随机位置开始（也就是先随机生成一个解），在每次迭代中随机访问当前最优解附近的一个解（也就是对当前最优解做一些微小的改变），如果新的解更优就更新为当前最优解，如果新的解更差就丢弃。直到在当前最优解附近找不到更优解，说明算法找到了一个局部最优解，就把这个解当做最终结果返回。在实际应用时，用这种随机方法寻找局部最优的时间可能很长，为了缩短程序的运行时间，需要设定最大迭代次数，当算法已经达到最大迭代次数，即使还未找到局部最优解也要停止迭代，返回当前最优解。Python3实现如下，迭代次数设为十万次：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def hillClimb():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    # 初始的随机解</span><br><span class="line">    arr &#x3D; list(range(len(cities)))</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    maxIter &#x3D; 100000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%1000&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        # 每次对解的改变就是随机交换两个位置的值</span><br><span class="line">        change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">        arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        newDistance &#x3D; totalDistance(arr)</span><br><span class="line">        if newDistance&lt;minDistance or minDistance&lt;0:</span><br><span class="line">            minDistance &#x3D; newDistance</span><br><span class="line">        else:</span><br><span class="line">            # 不是更优解就恢复原样</span><br><span class="line">            arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in arr]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure><p>最优结果对应的路线如下：</p><div id="echarts5638" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts5638'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[172, 93], [172, 77], [172, 69], [180, 61], [180, 53], [180, 29], [172, 29], [180, 77], [180, 85], [180, 101], [180, 109], [172, 109], [164, 137], [172, 145], [204, 145], [220, 145], [280, 109], [284, 93], [284, 85], [284, 77], [276, 85], [276, 93], [276, 101], [268, 97], [252, 101], [156, 137], [132, 137], [56, 129], [56, 145], [104, 161], [116, 161], [124, 169], [56, 153], [40, 145], [40, 137], [8, 41], [16, 25], [16, 17], [24, 17], [24, 25], [32, 73], [32, 89], [40, 99], [40, 113], [56, 121], [132, 169], [148, 169], [164, 169], [172, 169], [164, 145], [180, 117], [236, 85], [236, 77], [260, 77], [260, 85], [260, 93], [276, 77], [284, 69], [284, 61], [284, 53], [276, 61], [276, 69], [236, 69], [220, 73], [180, 69], [140, 65], [132, 61], [104, 49], [80, 41], [64, 41], [72, 41], [80, 25], [72, 25], [64, 21], [44, 11], [56, 9], [56, 17], [44, 35], [48, 51], [56, 81], [56, 89], [104, 105], [124, 109], [172, 85], [188, 93], [220, 125], [228, 145], [228, 125], [228, 117], [212, 117], [204, 109], [172, 101], [148, 85], [132, 81], [124, 85], [124, 77], [164, 81], [196, 101], [236, 145], [246, 141], [246, 157], [256, 157], [256, 141], [270, 133], [260, 129], [260, 109], [252, 125], [140, 145], [104, 169], [56, 169], [40, 161], [32, 161], [16, 109], [8, 89], [8, 57], [8, 49], [72, 9], [148, 9], [162, 9], [228, 21], [228, 29], [180, 21], [172, 21], [124, 37], [104, 41], [48, 63], [48, 73], [56, 73], [124, 117], [124, 125], [148, 137], [148, 145], [140, 137], [132, 145], [124, 145], [80, 157], [40, 169], [32, 169], [48, 83], [44, 43], [56, 25], [44, 27], [56, 33], [56, 41], [56, 105], [56, 113], [56, 137], [64, 157], [124, 101], [172, 61], [172, 53], [180, 45], [172, 45], [104, 57], [72, 49], [56, 57], [8, 81], [8, 73], [8, 65], [16, 57], [40, 63], [104, 89], [172, 117], [172, 125], [180, 125], [196, 145], [188, 145], [196, 161], [204, 169], [212, 169], [220, 169], [236, 169], [288, 149], [280, 133], [288, 129], [288, 109], [284, 101], [276, 53], [260, 29], [260, 37], [260, 45], [260, 53], [260, 61], [260, 69], [236, 45], [228, 37], [156, 25], [132, 21], [124, 21], [104, 33], [88, 49], [56, 97], [40, 121], [40, 129], [32, 137], [32, 129], [48, 99], [32, 25], [32, 17], [32, 41], [32, 65], [32, 97], [32, 113], [32, 121], [32, 145], [32, 153], [40, 153], [56, 161], [64, 165], [90, 165], [104, 153], [104, 137], [104, 145], [104, 129], [104, 121], [104, 113], [104, 81], [124, 53], [124, 61], [124, 69], [124, 93], [104, 73], [104, 65], [120, 9], [128, 9], [136, 9], [236, 29], [236, 21], [252, 21], [236, 37], [236, 53], [236, 61], [228, 109], [228, 161], [228, 169], [156, 145], [104, 97], [56, 49], [40, 51], [32, 49], [24, 45], [32, 57], [40, 83], [116, 145], [140, 169], [156, 169], [188, 169], [196, 169], [212, 145], [212, 65], [204, 57], [196, 49], [188, 41], [180, 37], [172, 37], [124, 45], [24, 89], [16, 97], [8, 109], [8, 97], [32, 81], [40, 73], [56, 65], [124, 29], [104, 17], [92, 9], [80, 9], [80, 25], [104, 25], [228, 53], [228, 45], [228, 61], [228, 69], [228, 77], [228, 85], [228, 101], [236, 101], [236, 93], [228, 93], [180, 93], [172, 93]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts2212" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts2212'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 34785.44749211156], [1000, 19353.928053910957], [2000, 15990.36106539108], [3000, 13907.361486648882], [4000, 12971.698829665102], [5000, 12106.015187587398], [6000, 11577.194724429764], [7000, 11387.98014104181], [8000, 11056.166015957479], [9000, 10747.544899934497], [10000, 10498.786823810482], [11000, 10179.57792450684], [12000, 9993.936333501777], [13000, 9910.278995349185], [14000, 9707.430276491103], [15000, 9592.808588624914], [16000, 9484.865119491764], [17000, 9354.789411464242], [18000, 9254.173599187503], [19000, 9211.638126464617], [20000, 9181.18561703581], [21000, 9129.946669826419], [22000, 9066.05502216996], [23000, 8947.643079000773], [24000, 8900.300665097733], [25000, 8858.430157973986], [26000, 8836.329616787592], [27000, 8801.868282679843], [28000, 8719.997067290158], [29000, 8657.454477721523], [30000, 8574.353392823134], [31000, 8510.628362689293], [32000, 8479.416515422137], [33000, 8350.620891677423], [34000, 8335.515801596865], [35000, 8320.650047002355], [36000, 8287.24830679945], [37000, 8263.777278938045], [38000, 8247.106338742791], [39000, 8225.139486807644], [40000, 8194.08962455832], [41000, 8160.6053551791365], [42000, 8133.806386817915], [43000, 8109.544807824241], [44000, 8076.693962845321], [45000, 8035.16907287191], [46000, 8032.495698356345], [47000, 8003.770743108615], [48000, 8003.770743108615], [49000, 7992.78996700886], [50000, 7980.460079147163], [51000, 7977.50615436722], [52000, 7961.833045793833], [53000, 7922.133569884537], [54000, 7897.88553922839], [55000, 7883.355987998853], [56000, 7845.334587547549], [57000, 7845.334587547549], [58000, 7827.847336635698], [59000, 7796.449910154846], [60000, 7776.99396386195], [61000, 7756.087485672815], [62000, 7746.450618302975], [63000, 7720.388837188945], [64000, 7701.099280287324], [65000, 7673.778341851368], [66000, 7664.8874403526925], [67000, 7658.280148888139], [68000, 7650.594077955203], [69000, 7628.45643887525], [70000, 7607.530023210174], [71000, 7597.594964510844], [72000, 7581.228277996682], [73000, 7561.654187119], [74000, 7531.348802729719], [75000, 7503.540382879502], [76000, 7493.710356815283], [77000, 7465.474074409009], [78000, 7455.788115130572], [79000, 7432.020821554273], [80000, 7414.6115815021785], [81000, 7401.726180560843], [82000, 7387.128172921726], [83000, 7373.812777236357], [84000, 7357.904505175984], [85000, 7355.067455725333], [86000, 7314.32368344745], [87000, 7296.716964497638], [88000, 7281.119395664033], [89000, 7263.907853160585], [90000, 7257.27443861171], [91000, 7250.239652458733], [92000, 7244.659180080416], [93000, 7244.245231903331], [94000, 7243.60911086437], [95000, 7236.705814133342], [96000, 7229.788199215191], [97000, 7219.717981814576], [98000, 7189.255339293897], [99000, 7171.7915439014705], [100000, 7162.610316569084]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="3-2-模拟退火"><a href="#3-2-模拟退火" class="headerlink" title="3.2 模拟退火"></a>3.2 模拟退火</h2><p>模拟退火算法（Simulated Annealing，SA）借鉴了物理中固体物质的退火过程，将固体加热到足够高的温度，使分子呈随机排列状态，然后逐步降温使之冷却，最后分子以低能状态排列，固体达到某种稳定状态。</p><p>模拟退火算法首先初始化一个随机解、一个较高的初始温度和一个降温速率，在每次迭代中对当前最优解做微小改变，如果新的解是更优解，就更新为当前最优解，与爬山法不同的是，如果新的解不是更优解，则以一个与当前温度呈正相关的概率接受新的解，一般根据Metropolis接受准则把概率设为 $p=exp(-\Delta F/T), \Delta F&gt;0$ ，其中 $\Delta F$ 是两个解在评估函数下的差值， $T$ 是当前温度。</p><p>以一定概率接受更差的解让算法有机会逃离局部最优，理论上能比爬山法找到更好的解。而随着温度下降，接受概率越来越低，最终趋近于0，表示不再接受差解，算法将收敛到一个更好的局部最优解。Python3实现如下，迭代次数设为十万次：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def SA():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    # 初始的随机解</span><br><span class="line">    arr &#x3D; list(range(len(cities)))</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    maxIter &#x3D; 100000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    T &#x3D; 10000</span><br><span class="line">    alpha &#x3D; 0.99</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%1000&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        # 每次对解的改变就是随机交换两个位置的值</span><br><span class="line">        change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">        arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        newDistance &#x3D; totalDistance(arr)</span><br><span class="line">        if newDistance&lt;minDistance or minDistance&lt;0:</span><br><span class="line">            minDistance &#x3D; newDistance</span><br><span class="line">        # 一定概率接受差解</span><br><span class="line">        elif random.random()&lt;math.exp(-(newDistance-minDistance)&#x2F;T):</span><br><span class="line">            minDistance &#x3D; newDistance</span><br><span class="line">        else:</span><br><span class="line">            arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">        T *&#x3D; alpha</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in arr]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure><p>最优结果对应的路线如下：</p><div id="echarts5171" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts5171'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[32, 41], [16, 57], [8, 89], [8, 109], [16, 109], [32, 137], [32, 145], [32, 129], [8, 97], [8, 57], [8, 41], [16, 25], [16, 17], [24, 17], [32, 17], [44, 27], [72, 41], [80, 41], [104, 57], [104, 65], [104, 81], [104, 73], [124, 29], [132, 21], [156, 25], [172, 21], [180, 21], [180, 29], [180, 37], [188, 41], [228, 21], [228, 29], [236, 37], [236, 45], [228, 45], [228, 53], [204, 57], [180, 69], [172, 69], [40, 83], [32, 89], [48, 83], [56, 81], [104, 89], [140, 65], [172, 61], [180, 61], [212, 65], [228, 93], [228, 101], [228, 109], [252, 125], [236, 145], [246, 141], [260, 129], [236, 101], [236, 93], [220, 73], [180, 45], [172, 37], [88, 49], [72, 49], [64, 41], [56, 49], [48, 73], [48, 99], [40, 99], [32, 153], [32, 161], [40, 161], [40, 153], [104, 129], [172, 85], [180, 85], [180, 93], [188, 93], [228, 77], [228, 85], [236, 85], [280, 109], [270, 133], [256, 141], [256, 157], [246, 157], [220, 169], [196, 169], [188, 169], [172, 169], [164, 169], [132, 169], [104, 113], [40, 73], [32, 73], [32, 65], [40, 63], [40, 51], [44, 43], [56, 25], [64, 21], [80, 25], [80, 25], [180, 77], [252, 101], [280, 133], [288, 109], [284, 85], [276, 69], [260, 53], [260, 61], [260, 77], [228, 117], [212, 145], [116, 161], [104, 161], [104, 153], [104, 145], [32, 49], [24, 45], [32, 25], [56, 33], [92, 9], [104, 17], [120, 9], [128, 9], [136, 9], [124, 21], [124, 61], [124, 77], [132, 81], [172, 117], [196, 161], [204, 169], [212, 169], [220, 145], [236, 77], [228, 61], [228, 37], [260, 37], [260, 45], [284, 69], [276, 77], [260, 69], [196, 49], [172, 45], [172, 53], [180, 53], [228, 69], [236, 69], [236, 61], [260, 29], [252, 21], [236, 21], [236, 29], [172, 101], [172, 109], [180, 109], [180, 117], [212, 117], [204, 109], [196, 101], [180, 101], [172, 93], [104, 97], [56, 65], [56, 73], [56, 89], [40, 113], [56, 121], [104, 137], [132, 137], [140, 137], [172, 145], [164, 137], [164, 145], [156, 145], [148, 137], [124, 101], [124, 93], [164, 81], [172, 77], [260, 85], [260, 93], [268, 97], [276, 93], [276, 85], [284, 93], [284, 101], [288, 129], [288, 149], [236, 169], [228, 169], [228, 161], [228, 145], [220, 125], [148, 145], [140, 145], [132, 145], [64, 165], [56, 169], [40, 169], [32, 169], [40, 145], [40, 137], [40, 121], [56, 113], [56, 105], [56, 97], [56, 57], [72, 25], [80, 9], [72, 9], [56, 17], [44, 35], [32, 113], [32, 121], [40, 129], [56, 129], [56, 137], [56, 145], [116, 145], [196, 145], [204, 145], [228, 125], [260, 109], [276, 101], [284, 77], [284, 61], [276, 61], [284, 53], [276, 53], [236, 53], [172, 29], [162, 9], [148, 9], [56, 41], [48, 51], [48, 63], [32, 81], [24, 89], [16, 97], [8, 81], [8, 73], [8, 65], [8, 49], [24, 25], [44, 11], [56, 9], [104, 25], [104, 33], [104, 41], [104, 49], [132, 61], [124, 85], [104, 105], [104, 121], [124, 169], [124, 145], [124, 125], [124, 117], [156, 137], [172, 125], [188, 145], [180, 125], [148, 85], [124, 53], [124, 45], [124, 37], [124, 69], [124, 109], [156, 169], [148, 169], [140, 169], [104, 169], [90, 165], [80, 157], [64, 157], [56, 161], [56, 153], [32, 97], [32, 57], [32, 41]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts647" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts647'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 33914.60282260142], [1000, 21270.207203195747], [2000, 16265.112854912211], [3000, 14299.767111200072], [4000, 13408.644532288059], [5000, 12339.311403835165], [6000, 11823.985679204936], [7000, 11340.060799778334], [8000, 10863.903182397295], [9000, 10686.875031225838], [10000, 10596.85666254361], [11000, 10451.941764063176], [12000, 10280.422705331453], [13000, 10044.441189882806], [14000, 9869.56451305229], [15000, 9753.033813298916], [16000, 9552.69239083618], [17000, 9441.766474587757], [18000, 9359.747071906064], [19000, 9226.203899000713], [20000, 9079.179917384592], [21000, 8959.383039845281], [22000, 8877.551048473331], [23000, 8817.714324753268], [24000, 8738.491978633952], [25000, 8686.918621102634], [26000, 8630.222988717873], [27000, 8622.913625929883], [28000, 8568.295779995724], [29000, 8468.68454402818], [30000, 8449.181390727734], [31000, 8359.869091551473], [32000, 8261.168345179232], [33000, 8233.750270533823], [34000, 8190.034063630316], [35000, 8140.79462671016], [36000, 8128.658561316616], [37000, 8118.778995284066], [38000, 8077.483249476699], [39000, 8052.586715575036], [40000, 8019.217846182968], [41000, 8002.205777605603], [42000, 7970.2023637285165], [43000, 7952.3704645344], [44000, 7936.880848055674], [45000, 7925.326070917763], [46000, 7856.029446794221], [47000, 7847.696786030943], [48000, 7826.492945497338], [49000, 7817.134810060771], [50000, 7802.275591244446], [51000, 7795.9553643803465], [52000, 7776.3994280254265], [53000, 7774.510884205429], [54000, 7769.328707059647], [55000, 7732.0669905684845], [56000, 7689.552626860808], [57000, 7608.917431266603], [58000, 7529.500704854002], [59000, 7525.151492554089], [60000, 7483.045048948701], [61000, 7463.155471971213], [62000, 7463.155471971213], [63000, 7453.030001510787], [64000, 7439.796155583298], [65000, 7400.594587954039], [66000, 7380.726291722335], [67000, 7377.720146717941], [68000, 7372.2296017471335], [69000, 7347.252534616578], [70000, 7328.506489513188], [71000, 7310.4996327846575], [72000, 7308.063033400559], [73000, 7277.750739408965], [74000, 7277.750739408965], [75000, 7277.750739408965], [76000, 7276.375076640651], [77000, 7239.6198953633675], [78000, 7223.211139312575], [79000, 7222.101896122617], [80000, 7204.190999948586], [81000, 7168.37394620814], [82000, 7130.631996481255], [83000, 7107.593395968574], [84000, 7058.659038192923], [85000, 7026.328141448473], [86000, 7009.3114853990855], [87000, 6993.94744719539], [88000, 6974.881458775223], [89000, 6971.567750276238], [90000, 6964.771051249861], [91000, 6950.13105705818], [92000, 6930.272598874511], [93000, 6908.141847824359], [94000, 6890.168476817055], [95000, 6876.768343682251], [96000, 6874.833600240957], [97000, 6858.471825848977], [98000, 6853.884080443336], [99000, 6848.763030961273], [100000, 6841.984535031416]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="3-3-禁忌搜索"><a href="#3-3-禁忌搜索" class="headerlink" title="3.3 禁忌搜索"></a>3.3 禁忌搜索</h2><p>禁忌搜索（Tabu Search或Taboo Search，简称TS）是对局部搜索（LS）的一种扩展，是一种全局寻优算法，其特点是采用禁忌技术，即用一个禁忌表记录下已经到达过的局部最优点及求解过程，在下一次搜索中，利用禁忌表中的信息不再或有选择地搜索这些点，以此来跳出局部最优点。该算法可以克服爬山算法全局搜索能力不强的弱点。</p><p>算法流程如下，</p><p><img src= "/img/loading.gif" data-src="https://file.shivakasu.cn/d1a41dd3e548144b7516/arg3-0.jpg" alt="arg3-0"></p><p>Python3实现如下，迭代次数设为四万次：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def TS():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    maxIter &#x3D; 40000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    searchNum &#x3D; 200</span><br><span class="line">    tabuLen &#x3D; 20</span><br><span class="line">    tabuTable &#x3D; []</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    # 初始的随机解</span><br><span class="line">    arr &#x3D; list(range(len(cities)))</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    minDistance &#x3D; totalDistance(arr)</span><br><span class="line">    localBestPath &#x3D; []</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%400&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        # 当前邻域搜索</span><br><span class="line">        while i&lt;searchNum:</span><br><span class="line">            tmp &#x3D; copy.deepcopy(arr)</span><br><span class="line">            change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">            tmp[change[0]],tmp[change[1]] &#x3D; tmp[change[1]],tmp[change[0]]</span><br><span class="line">            # 搜索不在禁忌表中的解</span><br><span class="line">            if tmp not in tabuTable:</span><br><span class="line">                newDistance &#x3D; totalDistance(tmp)</span><br><span class="line">                if newDistance&lt;minDistance:</span><br><span class="line">                    localBestPath &#x3D; copy.deepcopy(tmp)</span><br><span class="line">                    minDistance &#x3D; newDistance</span><br><span class="line">                i +&#x3D; 1</span><br><span class="line">        arr &#x3D; copy.deepcopy(localBestPath)</span><br><span class="line">        # 更新禁忌表</span><br><span class="line">        if len(tabuTable)&#x3D;&#x3D;tabuLen:</span><br><span class="line">            tabuTable &#x3D; tabuTable[1:]</span><br><span class="line">        tabuTable.append(localBestPath)</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in arr]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure><p>最优结果对应的路线如下：</p><div id="echarts2212" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts2212'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[48, 51], [56, 49], [72, 49], [104, 33], [156, 25], [172, 29], [172, 37], [180, 45], [180, 53], [180, 61], [124, 69], [56, 57], [16, 57], [8, 57], [8, 49], [8, 41], [16, 25], [24, 45], [32, 41], [56, 65], [104, 121], [104, 129], [104, 137], [56, 137], [56, 129], [40, 129], [40, 121], [32, 121], [32, 129], [40, 137], [56, 145], [124, 145], [260, 109], [276, 93], [284, 93], [284, 85], [284, 77], [284, 69], [284, 61], [284, 53], [276, 53], [260, 29], [252, 21], [236, 21], [56, 9], [44, 11], [56, 17], [64, 21], [228, 109], [252, 125], [260, 129], [270, 133], [256, 141], [246, 141], [236, 145], [220, 125], [212, 117], [180, 101], [172, 93], [180, 93], [180, 85], [172, 85], [172, 77], [164, 81], [72, 25], [56, 25], [44, 35], [44, 43], [32, 49], [32, 65], [32, 81], [48, 99], [56, 121], [56, 153], [56, 161], [56, 169], [40, 169], [32, 169], [32, 161], [40, 161], [40, 153], [40, 113], [40, 99], [32, 97], [32, 89], [24, 89], [16, 97], [8, 89], [8, 97], [32, 137], [32, 145], [32, 153], [40, 145], [56, 113], [56, 105], [88, 49], [104, 25], [104, 17], [124, 29], [124, 37], [124, 45], [124, 53], [180, 69], [204, 57], [236, 61], [260, 53], [260, 45], [260, 37], [236, 53], [228, 61], [220, 73], [188, 93], [196, 101], [204, 109], [228, 117], [228, 125], [228, 145], [220, 145], [212, 145], [196, 145], [188, 145], [172, 145], [172, 125], [180, 125], [180, 117], [228, 77], [236, 69], [236, 45], [236, 37], [236, 29], [180, 29], [180, 21], [172, 21], [162, 9], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 41], [104, 49], [124, 61], [132, 61], [140, 65], [172, 69], [172, 61], [172, 53], [172, 45], [180, 37], [188, 41], [196, 49], [228, 21], [228, 29], [228, 37], [228, 45], [228, 53], [228, 69], [228, 85], [228, 93], [236, 93], [268, 97], [276, 101], [284, 101], [280, 109], [280, 133], [236, 169], [228, 169], [220, 169], [204, 145], [196, 161], [188, 169], [172, 169], [164, 169], [164, 137], [172, 109], [172, 101], [148, 85], [132, 81], [104, 81], [40, 73], [32, 73], [8, 65], [8, 73], [8, 81], [32, 113], [64, 157], [104, 169], [116, 161], [124, 169], [132, 169], [140, 169], [148, 169], [140, 145], [132, 137], [140, 137], [148, 145], [148, 137], [124, 117], [124, 125], [116, 145], [104, 161], [90, 165], [64, 165], [80, 157], [104, 153], [104, 145], [124, 109], [124, 101], [124, 93], [124, 85], [124, 77], [104, 65], [80, 41], [72, 41], [32, 25], [24, 25], [16, 17], [24, 17], [32, 17], [44, 27], [56, 33], [56, 41], [64, 41], [120, 9], [128, 9], [136, 9], [148, 9], [132, 21], [124, 21], [104, 57], [56, 89], [56, 97], [16, 109], [8, 109], [40, 83], [48, 83], [48, 73], [56, 73], [56, 81], [104, 89], [104, 97], [104, 105], [104, 113], [132, 145], [156, 169], [196, 169], [204, 169], [212, 169], [228, 161], [246, 157], [276, 85], [276, 77], [276, 69], [276, 61], [288, 109], [288, 129], [288, 149], [256, 157], [164, 145], [156, 145], [156, 137], [172, 117], [180, 109], [228, 101], [236, 101], [252, 101], [260, 93], [260, 85], [260, 77], [236, 85], [236, 77], [260, 69], [260, 61], [212, 65], [180, 77], [104, 73], [48, 63], [40, 63], [32, 57], [40, 51], [48, 51]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts412" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts412'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 33890.23101543088], [400, 9414.267797183507], [800, 7693.759751536997], [1200, 6968.071523569924], [1600, 6637.457204487098], [2000, 6159.892480829687], [2400, 6042.076698585728], [2800, 5950.848808320309], [3200, 5913.12574102969], [3600, 5901.85703497971], [4000, 5891.8393048938215], [4400, 5891.8393048938215], [4800, 5891.8393048938215], [5200, 5891.8393048938215], [5600, 5891.8393048938215], [6000, 5891.8393048938215], [6400, 5891.8393048938215], [6800, 5891.8393048938215], [7200, 5891.8393048938215], [7600, 5891.8393048938215], [8000, 5891.8393048938215], [8400, 5891.8393048938215], [8800, 5891.8393048938215], [9200, 5891.8393048938215], [9600, 5891.8393048938215], [10000, 5891.8393048938215], [10400, 5891.8393048938215], [10800, 5891.8393048938215], [11200, 5891.8393048938215], [11600, 5891.8393048938215], [12000, 5891.8393048938215], [12400, 5891.8393048938215], [12800, 5891.8393048938215], [13200, 5891.8393048938215], [13600, 5891.8393048938215], [14000, 5891.8393048938215], [14400, 5891.8393048938215], [14800, 5891.8393048938215], [15200, 5891.8393048938215], [15600, 5891.8393048938215], [16000, 5891.8393048938215], [16400, 5891.8393048938215], [16800, 5891.8393048938215], [17200, 5891.8393048938215], [17600, 5891.8393048938215], [18000, 5891.8393048938215], [18400, 5891.8393048938215], [18800, 5891.8393048938215], [19200, 5891.8393048938215], [19600, 5891.8393048938215], [20000, 5891.8393048938215], [20400, 5891.8393048938215], [20800, 5891.8393048938215], [21200, 5891.8393048938215], [21600, 5891.8393048938215], [22000, 5891.8393048938215], [22400, 5891.8393048938215], [22800, 5891.8393048938215], [23200, 5891.8393048938215], [23600, 5891.8393048938215], [24000, 5891.8393048938215], [24400, 5891.8393048938215], [24800, 5891.8393048938215], [25200, 5891.8393048938215], [25600, 5891.8393048938215], [26000, 5891.8393048938215], [26400, 5891.8393048938215], [26800, 5891.8393048938215], [27200, 5891.8393048938215], [27600, 5891.8393048938215], [28000, 5891.8393048938215], [28400, 5891.8393048938215], [28800, 5891.8393048938215], [29200, 5891.8393048938215], [29600, 5891.8393048938215], [30000, 5891.8393048938215], [30400, 5891.8393048938215], [30800, 5891.8393048938215], [31200, 5891.8393048938215], [31600, 5891.8393048938215], [32000, 5891.8393048938215], [32400, 5891.8393048938215], [32800, 5891.8393048938215], [33200, 5891.8393048938215], [33600, 5891.8393048938215], [34000, 5891.8393048938215], [34400, 5891.8393048938215], [34800, 5891.8393048938215], [35200, 5891.8393048938215], [35600, 5891.8393048938215], [36000, 5891.8393048938215], [36400, 5891.8393048938215], [36800, 5891.8393048938215], [37200, 5891.8393048938215], [37600, 5891.8393048938215], [38000, 5891.8393048938215], [38400, 5891.8393048938215], [38800, 5891.8393048938215], [39200, 5891.8393048938215], [39600, 5891.8393048938215], [40000, 5891.8393048938215]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h1 id="4-群体启发式算法"><a href="#4-群体启发式算法" class="headerlink" title="4 群体启发式算法"></a>4 群体启发式算法</h1><h2 id="4-1-遗传算法"><a href="#4-1-遗传算法" class="headerlink" title="4.1 遗传算法"></a>4.1 遗传算法</h2><p>遗传算法（GeneticAlgorithm ，GA ）借鉴了生物进化过程来优化随机搜索策略，与上述两种算法不同的是，遗传算法维护并更新的不是单个解，而是用一组解模拟种群。在迭代中主要模拟选择、遗传、变异、免疫等过程实现种群中个体信息的交换，提升整个种群的质量。在本题中的主要步骤如下：</p><ul><li>1、初始化种群规模、迭代次数、突变概率三个参数</li><li>2、随机生成一组解，代表初代种群。根据每个解的路径长度设定它的适应度，适应度表示个体对环境的适应程度，优胜劣汰，越是精英的个体适应度应该越高，所以路径长度越短的解适应度就越高。设 $dis[i]$ 表示种群中第 $i$ 个解的路径长度， $totalDis$ 表示种群中所有解的路径长度总和，那么第 $i$ 个解的适应度就是:<script type="math/tex; mode=display">P(i) = \frac{\frac{totalDis}{dis[i]}}{\sum_k \frac{totalDis}{dis[k]}}</script></li><li>3、父代选择。选择将要生成下一代的两个父代个体，同样为了保证优胜劣汰，要让适应度高的个体容易被选中。一般采用轮盘赌法选择个体，首先产生一个随机概率 $rand$ ，依次累种群个体的适应度，当出现 $rand &lt; \sum_{k=0}^jP(k)$ 时，说明从第0个个体到第 $j$ 个个体的累积适应度超过了随机概率 $rand$ ，此时选择第 $j$ 个个体，完成一次选择过程。之所以叫轮盘赌法，是因为这个选择过程就好像以一个随机的力度转轮盘，结果从0转到 $j$ 停止，非常形象。</li><li>4、两个父代个体杂交产生一个子代个体。方法不固定，只要是综合两个解的信息生成新的解就可以，根据方法的不同，既可以生成一个子代，也可以生成两个子代。本文采取的方法是，随机生成一个交叉点 $i$ ，两个父代中位于交叉点之前的城市顺序不变，而交叉点之后的城市顺序改成在对方中的顺序，交叉完毕后两个父代变成了两个新的子代。</li><li>5、子代变异。对于杂交产生的每个子代，生成一个随机数，如果随机数小于预设的变异概率，就对该子代做微小改变，视为遗传变异。本文采取的变异方法是随机交换两个城市的位置。</li><li>6、种群更新。保留子代中的精英个体，本文采取的方式是通过杂交变异生成两倍种群大小的子代，根据每个子代的路径长度排序，选择路径最短的一半作为新一代种群。</li></ul><p>Python3实现如下，迭代次数设为四万次：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def GA():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    groupSize &#x3D; 1000</span><br><span class="line">    # 突变概率</span><br><span class="line">    mutation &#x3D; 0.01</span><br><span class="line">    maxIter &#x3D; 40000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    fatherGroup &#x3D; []</span><br><span class="line">    sonGroup &#x3D; []</span><br><span class="line">    fitness &#x3D; []</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    minPath &#x3D; []</span><br><span class="line">    # 初始化种群</span><br><span class="line">    totalDis &#x3D; 0</span><br><span class="line">    for i in range(groupSize):</span><br><span class="line">        arr &#x3D; list(range(len(cities)))</span><br><span class="line">        random.shuffle(arr)</span><br><span class="line">        fatherGroup.append(arr)</span><br><span class="line">        d &#x3D; totalDistance(arr)</span><br><span class="line">        fitness.append(d)</span><br><span class="line">        totalDis +&#x3D; d</span><br><span class="line">    # 计算适应度</span><br><span class="line">    fitness &#x3D; [totalDis&#x2F;i for i in fitness]</span><br><span class="line">    totalFit &#x3D; sum(fitness)</span><br><span class="line">    fitness &#x3D; [i&#x2F;totalFit for i in fitness]</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%400&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            print(&quot;ga: &quot;+str(currIter))</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        sonDis &#x3D; []</span><br><span class="line">        # 杂交</span><br><span class="line">        for i in range(groupSize):</span><br><span class="line">            # 轮盘赌选择父代</span><br><span class="line">            f1 &#x3D; -1</span><br><span class="line">            r &#x3D; random.random()</span><br><span class="line">            p &#x3D; 0    </span><br><span class="line">            while r&gt;p:</span><br><span class="line">                f1 +&#x3D; 1</span><br><span class="line">                p +&#x3D; fitness[f1]</span><br><span class="line">            f2 &#x3D; f1</span><br><span class="line">            while f1&#x3D;&#x3D;f2:</span><br><span class="line">                f2 &#x3D; -1</span><br><span class="line">                r &#x3D; random.random()</span><br><span class="line">                p &#x3D; 0    </span><br><span class="line">                while r&gt;p:</span><br><span class="line">                    f2 +&#x3D; 1</span><br><span class="line">                    p +&#x3D; fitness[f2]</span><br><span class="line">            f1 &#x3D; fatherGroup[f1]</span><br><span class="line">            f2 &#x3D; fatherGroup[f2]</span><br><span class="line">            # 杂交生成两个子代</span><br><span class="line">            r &#x3D; random.randint(0,len(cities)-2)</span><br><span class="line">            s1 &#x3D; f1[:i]</span><br><span class="line">            s2 &#x3D; f2[:i]</span><br><span class="line">            for k in f1:</span><br><span class="line">                if k not in s2:</span><br><span class="line">                    s2.append(k)</span><br><span class="line">            for k in f2:</span><br><span class="line">                if k not in s1:</span><br><span class="line">                    s1.append(k)</span><br><span class="line">            r &#x3D; random.random()</span><br><span class="line">            if r&lt;mutation:</span><br><span class="line">                # 突变就是随机交换两个位置的值</span><br><span class="line">                change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">                s1[change[0]],s1[change[1]] &#x3D; s1[change[1]],s1[change[0]]</span><br><span class="line">                s2[change[0]],s2[change[1]] &#x3D; s2[change[1]],s2[change[0]]</span><br><span class="line">            sonGroup.append(s1)</span><br><span class="line">            sonGroup.append(s2)</span><br><span class="line">            sonDis.append(totalDistance(s1))</span><br><span class="line">            sonDis.append(totalDistance(s2))</span><br><span class="line">        # 子代按路径长度排序</span><br><span class="line">        zipped&#x3D;zip(sonGroup,sonDis)</span><br><span class="line">        sort_zipped &#x3D; sorted(zipped,key&#x3D;lambda x:(x[1],x[0]))</span><br><span class="line">        result &#x3D; zip(*sort_zipped)</span><br><span class="line">        sonGroup, sonDis &#x3D; [list(x) for x in result]</span><br><span class="line">        sonGroup &#x3D; sonGroup[:groupSize]</span><br><span class="line">        sonDis &#x3D; sonDis[:groupSize]</span><br><span class="line">        # 种群更新</span><br><span class="line">        minDistance &#x3D; min(sonDis)</span><br><span class="line">        minPath &#x3D; sonGroup[sonDis.index(minDistance)]</span><br><span class="line">        totalDis &#x3D; sum(sonDis)</span><br><span class="line">        fitness &#x3D; [totalDis&#x2F;i for i in sonDis]</span><br><span class="line">        totalFit &#x3D; sum(fitness)</span><br><span class="line">        fitness &#x3D; [i&#x2F;totalFit for i in fitness]</span><br><span class="line">        fatherGroup &#x3D; sonGroup</span><br><span class="line">        sonGroup &#x3D; []</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in minPath]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure><p>最优结果对应的路线如下：</p><div id="echarts897" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts897'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[124, 45], [124, 37], [124, 29], [124, 21], [120, 9], [128, 9], [136, 9], [148, 9], [162, 9], [172, 21], [180, 21], [228, 45], [228, 53], [236, 45], [236, 53], [236, 61], [260, 77], [260, 85], [260, 93], [260, 109], [252, 125], [246, 141], [246, 157], [236, 169], [228, 169], [228, 161], [220, 169], [180, 125], [172, 125], [172, 117], [132, 61], [124, 53], [104, 33], [104, 25], [80, 25], [80, 25], [104, 73], [104, 105], [104, 113], [104, 121], [64, 157], [56, 153], [56, 145], [32, 137], [32, 129], [32, 121], [40, 121], [40, 129], [40, 137], [56, 129], [56, 121], [56, 113], [56, 105], [40, 99], [32, 97], [16, 57], [24, 25], [32, 25], [44, 27], [44, 35], [44, 43], [40, 63], [32, 73], [32, 65], [32, 57], [40, 51], [32, 49], [24, 45], [32, 41], [48, 51], [56, 49], [72, 41], [80, 41], [88, 49], [104, 49], [172, 53], [172, 61], [180, 61], [180, 69], [180, 77], [180, 85], [180, 101], [172, 101], [172, 109], [104, 97], [48, 83], [40, 83], [32, 89], [16, 97], [24, 89], [32, 81], [40, 73], [48, 73], [56, 73], [104, 81], [104, 89], [124, 85], [124, 93], [124, 101], [124, 109], [140, 137], [140, 145], [164, 169], [172, 169], [228, 145], [220, 145], [212, 145], [204, 145], [196, 145], [188, 145], [164, 145], [156, 145], [148, 145], [148, 137], [172, 37], [180, 29], [228, 21], [236, 21], [252, 21], [260, 29], [260, 37], [236, 37], [236, 29], [228, 29], [196, 49], [180, 53], [180, 45], [172, 45], [104, 41], [56, 57], [48, 63], [56, 65], [104, 65], [124, 69], [124, 77], [132, 81], [148, 85], [164, 81], [172, 85], [180, 93], [188, 93], [196, 101], [204, 109], [220, 125], [228, 125], [236, 145], [256, 157], [288, 149], [288, 129], [284, 85], [284, 77], [284, 69], [276, 77], [276, 93], [268, 97], [276, 101], [280, 109], [270, 133], [260, 129], [252, 101], [236, 101], [236, 93], [236, 85], [260, 61], [276, 69], [276, 61], [284, 61], [284, 53], [276, 53], [260, 53], [260, 45], [228, 37], [188, 41], [180, 37], [172, 29], [156, 25], [132, 21], [104, 17], [92, 9], [80, 9], [72, 9], [56, 25], [8, 41], [8, 49], [8, 57], [8, 65], [8, 73], [8, 81], [8, 89], [32, 113], [40, 113], [104, 137], [132, 145], [156, 137], [164, 137], [172, 145], [196, 161], [212, 169], [204, 169], [196, 169], [188, 169], [156, 169], [148, 169], [140, 169], [132, 169], [124, 169], [104, 169], [90, 165], [40, 161], [32, 161], [32, 153], [40, 145], [56, 137], [104, 129], [124, 125], [180, 109], [228, 109], [228, 101], [228, 93], [228, 85], [228, 77], [236, 77], [228, 69], [220, 73], [212, 65], [204, 57], [228, 61], [236, 69], [260, 69], [276, 85], [284, 93], [284, 101], [288, 109], [280, 133], [256, 141], [228, 117], [212, 117], [180, 117], [124, 117], [56, 97], [48, 99], [56, 89], [56, 81], [72, 25], [64, 21], [56, 17], [56, 9], [44, 11], [24, 17], [16, 17], [16, 25], [32, 17], [56, 33], [56, 41], [64, 41], [72, 49], [104, 57], [124, 61], [140, 65], [172, 69], [172, 77], [172, 93], [132, 137], [124, 145], [116, 145], [104, 145], [104, 153], [80, 157], [64, 165], [56, 161], [40, 153], [32, 145], [16, 109], [8, 97], [8, 109], [32, 169], [40, 169], [56, 169], [104, 161], [116, 161], [124, 45]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts4217" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts4217'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 31115.680460043088], [400, 15334.904769985365], [800, 12071.182794553366], [1200, 10698.827141318481], [1600, 9802.001624465336], [2000, 9363.246821117898], [2400, 8855.848613389555], [2800, 8549.646103173383], [3200, 7905.687169789544], [3600, 7640.008182252965], [4000, 7516.971538827085], [4400, 7460.390059229863], [4800, 7200.0973510901395], [5200, 7082.845365549378], [5600, 6978.533013510428], [6000, 6907.537885302301], [6400, 6869.699686143468], [6800, 6823.17796232125], [7200, 6674.49522306577], [7600, 6666.380071344395], [8000, 6633.3609340924295], [8400, 6597.376427533433], [8800, 6578.598330585508], [9200, 6556.286960088603], [9600, 6474.420573091844], [10000, 6456.020486728329], [10400, 6429.182170359672], [10800, 6371.598509726626], [11200, 6150.950225917906], [11600, 6137.483276498839], [12000, 6136.817159602187], [12400, 6128.433098194441], [12800, 6122.948394567252], [13200, 6121.990888588202], [13600, 6117.465969468466], [14000, 6108.045086009359], [14400, 6100.530453694365], [14800, 6044.424139457849], [15200, 6007.500448314685], [15600, 5994.222026814483], [16000, 5994.222026814483], [16400, 5994.222026814483], [16800, 5992.902025489408], [17200, 5987.447565187352], [17600, 5952.26454649637], [18000, 5926.7815784881], [18400, 5911.340727488466], [18800, 5903.943969863919], [19200, 5858.274377256338], [19600, 5677.451094165581], [20000, 5590.964423347894], [20400, 5583.820614362352], [20800, 5575.112715619656], [21200, 5564.2937512718345], [21600, 5564.2937512718345], [22000, 5558.186428738796], [22400, 5558.186428738796], [22800, 5558.186428738796], [23200, 5557.263600314162], [23600, 5557.263600314162], [24000, 5557.263600314162], [24400, 5557.263600314162], [24800, 5542.103563167821], [25200, 5538.32778373243], [25600, 5521.673384924751], [26000, 5516.955162350389], [26400, 5455.412913382425], [26800, 5454.581605653756], [27200, 5453.822244440534], [27600, 5453.118269038051], [28000, 5453.118269038051], [28400, 5453.118269038051], [28800, 5453.118269038051], [29200, 5446.960580111209], [29600, 5446.960580111209], [30000, 5443.485499230946], [30400, 5443.485499230946], [30800, 5443.485499230946], [31200, 5443.485499230946], [31600, 5443.485499230946], [32000, 5443.485499230946], [32400, 5443.485499230946], [32800, 5443.485499230946], [33200, 5438.761869151259], [33600, 5200.983199799323], [34000, 5200.983199799323], [34400, 5200.983199799323], [34800, 5200.983199799323], [35200, 5187.678339313514], [35600, 5171.529601838279], [36000, 5171.529601838279], [36400, 5171.529601838279], [36800, 5171.529601838279], [37200, 5171.529601838279], [37600, 5171.529601838279], [38000, 5171.529601838279], [38400, 5171.529601838279], [38800, 5171.529601838279], [39200, 5171.529601838279], [39600, 5171.529601838279], [40000, 5171.529601838279]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="4-2-蚁群算法"><a href="#4-2-蚁群算法" class="headerlink" title="4.2 蚁群算法"></a>4.2 蚁群算法</h2><p>蚁群算法（Ant Colony Optimization ，ACO ）的灵感来源于蚂蚁觅食。蚂蚁觅食是一种群体性行为，蚂蚁在寻找食物时，会在其经过的路径上释放一种信息素，并能够感知其他蚂蚁释放的信息素。信息素浓度的大小体现了路径的远近，因为蚂蚁会以较大的概率优先选择信息素浓度高的路径，并释放一定量的信息素，以增强该路径上的信息素浓度，这形成了一种正反馈，最终使得蚂蚁能够找到一条到食物源的最短路径。这种思路很适合解决旅行商问题，只需要把蚂蚁的行走路径表示为问题的解，每次迭代的过程就是把所有蚂蚁随机放置在不同的位置，根据路径的信息素浓度选择下一个访问的城市，当所有蚂蚁访问完所有的城市后，一个迭代结束。所以信息素的更新和路径的选择策略是蚁群算法的两大核心。</p><p>路径选择：设蚂蚁的数量为 $m$ ，城市的数量为 $n$ ，城市 $i$ 与城市 $j$ 之间的距离为 $d_{ij}$ ， $t$ 时刻城市 $i$ 与城市 $j$ 连接路径上的信息素浓度是 $\tau_{ij}(t)$ ，初始时刻，所有路径上的信息素浓度相同，即 $\tau_{ij}(0)=\tau_0$ 。设 $P_{ij}^k(t)$ 是 $t$ 时刻蚂蚁 $k$ 从城市 $i$ 转移到城市 $j$ 的概率，其计算公式为，</p><script type="math/tex; mode=display">P_{ij}^k(t)=\begin{cases}\frac{[\tau_{ij}(t)]^\alpha\times [\eta_{ij}(t)]^\beta}{\sum_{s\in allow_k}[\tau_{is}(t)]^\alpha\times [\eta_{is}(t)]^\beta} & s\in allow_k \\0 & s\notin allow_k \end{cases}</script><p>其中， $\eta_{ij}(t)$ 为启发函数， $\eta_{ij}(t)=1/d_{ij}$ ，表示蚂蚁从城市 $i$ 转移到城市 $j$ 的期望程度。 $allow_k$ 是蚂蚁 $k$ 待访问城市的集合，分段公式的第二段就表示蚂蚁转移到已经访问过的城市的概率是0。蚂蚁对下一个目的地的选择取决于信息素浓度和启发函数，而这里用的启发函数是距离的倒数，所以可以说蚂蚁的选择兼顾了群体行为留下的信息和当前城市到其他城市的客观距离，两个启发因子 $\alpha$ 和 $\beta$ 就是用来调节这两方面在决策中的重要程度。</p><p>信息素更新：当蚂蚁经过一条路径时，会释放信息素，同时路径上原有的信息素会有一定程度的挥发，设参数 $\rho(0&lt;\rho&lt;1)$ 表示信息素的挥发率，当所有蚂蚁完成一次循环后，各个路径上信息素的更新公式为，</p><script type="math/tex; mode=display">\begin{cases}\tau_{ij}(t+1)=(1-\rho)\tau_{ij}(t)+\Delta \tau_{ij} \\\Delta \tau_{ij}=\sum_{k=1}^n\Delta \tau_{ij}^k\end{cases}</script><p>其中， $\tau_{ij}^k$ 表示第 $k$ 只蚂蚁在城市 $i$ 到城市 $j$ 之间的路径上释放的信息素浓度， $\tau_{ij}$ 就表示所有蚂蚁在城市 $i$ 到城市 $j$ 之间的路径上释放的信息素浓度之和。对于 $\tau_{ij}^k$ 的计算方法，有三种模型：</p><ul><li>1、ant cycle system 模型<script type="math/tex; mode=display">\Delta\tau_{ij}^k=\begin{cases}Q/L_k & 第k只蚂蚁从城市i访问城市j \\0 & 其他\end{cases}</script>其中 $Q$ 为常数，表示蚂蚁循环一次所释放的信息素总量， $L_K$ 表示第 $k$ 只蚂蚁经过路径的长度</li><li>2、ant quantity system 模型<script type="math/tex; mode=display">\Delta\tau_{ij}^k=\begin{cases}Q/d_{ij} & 第k只蚂蚁从城市i访问城市j \\0 & 其他\end{cases}</script></li><li>3、ant density system 模型<script type="math/tex; mode=display">\Delta\tau_{ij}^k=\begin{cases}Q & 第k只蚂蚁从城市i访问城市j \\0 & 其他\end{cases}</script>在上述三种模型中，一般采用ant cycle system 模型，让信息素的浓度随蚂蚁迄今走过的总长度的增加而下降，使得路径上的信息素浓度更包含一种全局性的信息。</li></ul><p>Python3实现如下，迭代次数设为一万次：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def ACO():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    maxIter &#x3D; 500</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    minPath &#x3D; []</span><br><span class="line">    # 初始化参数</span><br><span class="line">    antNum &#x3D; len(cities)  </span><br><span class="line">    alpha &#x3D; 1</span><br><span class="line">    beta &#x3D; 5</span><br><span class="line">    rho &#x3D; 0.1</span><br><span class="line">    Q &#x3D; 1000</span><br><span class="line">    # 初始化信息素矩阵</span><br><span class="line">    pheromone &#x3D; [[1 for i in range(len(cities))] for j in range(len(cities))]</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%5&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            print(&quot;aco: &quot;+str(currIter)+&quot; &quot;+str(minDistance))</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        # 初始化行走的路径</span><br><span class="line">        path &#x3D; [[] for j in range(antNum)]</span><br><span class="line">        visit &#x3D; [[0 for i in range(len(cities))] for j in range(antNum)]</span><br><span class="line">        antDis &#x3D; []</span><br><span class="line">        # 随机放置蚂蚁</span><br><span class="line">        arr &#x3D; list(range(len(cities)))</span><br><span class="line">        random.shuffle(arr)</span><br><span class="line">        for i in range(antNum):</span><br><span class="line">            path[i].append(arr[i])</span><br><span class="line">            visit[i][arr[i]] &#x3D; 1</span><br><span class="line">        # 所有蚂蚁都走完一条完整路径时才算一次迭代</span><br><span class="line">        for i in range(antNum):</span><br><span class="line">            while len(path[i])&lt;len(cities):</span><br><span class="line">                # 路径选择概率表</span><br><span class="line">                weight &#x3D; [0 for k in range(len(cities))]</span><br><span class="line">                for k in range(len(cities)):</span><br><span class="line">                    if visit[i][k]&#x3D;&#x3D;0:</span><br><span class="line">                        weight[k] &#x3D; (pheromone[path[i][-1]][k]**alpha)&#x2F;(distance[path[i][-1]][k]**beta+0.0001)</span><br><span class="line">                # 轮盘赌法选下个城市</span><br><span class="line">                totalWeight &#x3D; sum(weight)</span><br><span class="line">                p &#x3D; [w&#x2F;totalWeight for w in weight]</span><br><span class="line">                r &#x3D; random.random()</span><br><span class="line">                sumP &#x3D; 0</span><br><span class="line">                nextCity &#x3D; -1</span><br><span class="line">                while r&gt;sumP:</span><br><span class="line">                    nextCity +&#x3D; 1</span><br><span class="line">                    sumP +&#x3D; p[nextCity]</span><br><span class="line">                path[i].append(nextCity)</span><br><span class="line">                visit[i][nextCity] &#x3D; 1</span><br><span class="line">        for i in path:</span><br><span class="line">            antDis.append(totalDistance(i))</span><br><span class="line">        minDistance &#x3D; min(antDis)</span><br><span class="line">        minPath &#x3D; path[antDis.index(minDistance)]</span><br><span class="line">        # 更新信息素</span><br><span class="line">        delta &#x3D; [[0 for i in range(len(cities))] for j in range(len(cities))]</span><br><span class="line">        for i in range(antNum):</span><br><span class="line">            tau &#x3D; Q&#x2F;antDis[i]</span><br><span class="line">            for j in range(1,len(cities)):</span><br><span class="line">                fromCity &#x3D; path[i][j-1]</span><br><span class="line">                toCity &#x3D; path[i][j]</span><br><span class="line">                delta[fromCity][toCity] +&#x3D; tau</span><br><span class="line">                delta[toCity][fromCity] +&#x3D; tau</span><br><span class="line">        for i in range(len(cities)):</span><br><span class="line">            for j in range(len(cities)):</span><br><span class="line">                pheromone[i][j] &#x3D; pheromone[i][j]*(1-rho)+delta[i][j]</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in minPath]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure><p>最优结果对应的路线如下：</p><div id="echarts9684" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts9684'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[260, 85], [260, 77], [260, 69], [260, 61], [260, 53], [260, 45], [260, 37], [260, 29], [252, 21], [228, 37], [228, 45], [228, 53], [228, 61], [236, 61], [236, 69], [228, 69], [228, 77], [228, 85], [228, 93], [228, 101], [228, 109], [228, 117], [228, 125], [220, 125], [212, 117], [204, 109], [196, 101], [188, 93], [180, 93], [180, 101], [180, 109], [180, 117], [180, 125], [172, 125], [172, 117], [172, 109], [172, 101], [172, 93], [172, 85], [180, 85], [180, 77], [180, 69], [172, 69], [172, 61], [172, 53], [180, 53], [180, 61], [172, 45], [172, 37], [180, 37], [180, 29], [180, 21], [172, 21], [172, 29], [156, 25], [162, 9], [148, 9], [136, 9], [128, 9], [120, 9], [124, 21], [124, 29], [124, 37], [124, 45], [124, 53], [124, 61], [124, 69], [124, 77], [132, 81], [124, 85], [124, 93], [124, 101], [124, 109], [124, 117], [124, 125], [132, 137], [140, 137], [148, 137], [156, 137], [164, 137], [164, 145], [172, 145], [188, 145], [196, 145], [204, 145], [212, 145], [220, 145], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [270, 133], [280, 133], [288, 129], [288, 149], [256, 157], [246, 157], [236, 169], [228, 169], [228, 161], [220, 169], [212, 169], [204, 169], [196, 169], [196, 161], [188, 169], [172, 169], [164, 169], [156, 169], [148, 169], [140, 169], [132, 169], [124, 169], [116, 161], [104, 153], [104, 161], [104, 169], [90, 165], [80, 157], [64, 157], [64, 165], [56, 169], [56, 161], [56, 153], [56, 145], [56, 137], [56, 129], [56, 121], [56, 113], [56, 105], [56, 97], [56, 89], [56, 81], [48, 83], [40, 83], [40, 73], [32, 73], [32, 81], [32, 89], [32, 97], [40, 99], [48, 99], [40, 113], [32, 113], [32, 121], [32, 129], [40, 129], [40, 137], [40, 145], [40, 153], [40, 161], [40, 169], [32, 169], [32, 161], [32, 153], [32, 145], [32, 137], [40, 121], [16, 109], [8, 109], [8, 97], [16, 97], [24, 89], [8, 89], [8, 81], [8, 73], [8, 65], [8, 57], [8, 49], [8, 41], [16, 25], [16, 17], [24, 17], [32, 17], [32, 25], [24, 25], [32, 41], [32, 49], [32, 57], [32, 65], [40, 63], [48, 63], [56, 65], [56, 57], [56, 49], [56, 41], [64, 41], [72, 41], [72, 49], [88, 49], [80, 41], [80, 25], [80, 25], [72, 25], [64, 21], [56, 17], [56, 9], [44, 11], [44, 27], [44, 35], [44, 43], [48, 51], [40, 51], [24, 45], [16, 57], [56, 73], [48, 73], [56, 33], [56, 25], [72, 9], [80, 9], [92, 9], [104, 17], [104, 25], [104, 33], [104, 41], [104, 49], [104, 57], [104, 65], [104, 73], [104, 81], [104, 89], [104, 97], [104, 105], [104, 113], [104, 121], [104, 129], [104, 137], [104, 145], [116, 145], [124, 145], [132, 145], [140, 145], [148, 145], [156, 145], [148, 85], [164, 81], [172, 77], [140, 65], [132, 61], [132, 21], [188, 41], [180, 45], [196, 49], [204, 57], [212, 65], [220, 73], [236, 77], [236, 85], [236, 93], [236, 101], [252, 101], [260, 109], [268, 97], [260, 93], [276, 93], [276, 85], [276, 77], [276, 69], [284, 69], [284, 77], [284, 85], [284, 93], [284, 101], [276, 101], [280, 109], [288, 109], [276, 61], [284, 61], [284, 53], [276, 53], [236, 29], [228, 29], [228, 21], [236, 21], [236, 37], [236, 45], [236, 53], [252, 125], [260, 85]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下，在几种算法里是效果最好的。因为蚁群算法的原始思想就是找最短路径，从初始化开始就是找最短路径，而不是像其他算法一样要修改成适合旅行商问题的形式，从一个随机初始化的解开始迭代。</p><div id="echarts7943" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts7943'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 3525.323483452664], [5, 3155.9786053991943], [10, 3198.1954305052404], [15, 3187.9624616192996], [20, 3077.925362696013], [25, 3170.7241673705093], [30, 3148.6702846278945], [35, 3111.7258487602144], [40, 3087.8800152281005], [45, 3107.8380050836017], [50, 3140.5883387538834], [55, 3127.0518427781685], [60, 3073.1342139772532], [65, 3129.571863142564], [70, 3077.862464224103], [75, 3080.9757259533485], [80, 3157.1901107704957], [85, 3052.9825087167287], [90, 3133.0425119448], [95, 3128.0609084583507], [100, 2924.095523108582], [105, 3085.9893019859123], [110, 3105.290547210402], [115, 3109.096048032235], [120, 3120.5840641270865], [125, 3041.203053161302], [130, 3070.5996216800936], [135, 3148.0287278021215], [140, 3127.138022828557], [145, 3068.1098045165318], [150, 3100.2402069545506], [155, 3091.7373782438494], [160, 3110.4581133000784], [165, 3052.5760813078714], [170, 3127.176731218702], [175, 3109.4249804651104], [180, 3101.676984024719], [185, 3087.3670212489383], [190, 3113.378413993024], [195, 3111.71731437653], [200, 3073.867193563927], [205, 3008.046745322756], [210, 3102.589946601963], [215, 3127.2554753512845], [220, 3096.04542909826], [225, 3097.964252847144], [230, 3121.037787377663], [235, 3076.706051206151], [240, 3091.0954356958214], [245, 3082.9460006162253], [250, 3104.778830112415], [255, 3051.8581665339666], [260, 3139.3284997306137], [265, 3098.045393805626], [270, 3040.103490383168], [275, 2992.8722260395716], [280, 3091.9427644856764], [285, 3099.0265609494772], [290, 3100.0710885212834], [295, 3099.213863345473], [300, 3152.6969208238816], [305, 3166.1283973949703], [310, 3067.0764321822116], [315, 3096.786127538351], [320, 3126.6943630919727], [325, 2992.5229676594026], [330, 3008.3374290370057], [335, 3116.1989866768076], [340, 3035.9752202551363], [345, 3049.724462504239], [350, 3097.4257992160933], [355, 3079.620375237138], [360, 3103.4251046299005], [365, 3138.3917235807894], [370, 3098.320004367942], [375, 3094.815939495362], [380, 3068.4730594876783], [385, 3102.3050596509356], [390, 3085.0351971959044], [395, 3021.352709120023], [400, 3028.8765272162104], [405, 3031.270448419514], [410, 3064.0751584809655], [415, 3072.4117823811976], [420, 3079.810714105713], [425, 3035.3561260388096], [430, 3115.7594277182284], [435, 3135.3076421918477], [440, 3133.4525449544262], [445, 3051.8050347787002], [450, 3082.2833212674973], [455, 3132.3622626312954], [460, 3118.9943123554644], [465, 3084.9142358320414], [470, 3083.5421423024504], [475, 3048.709322365078], [480, 3056.4137021152496], [485, 3083.4645884663823], [490, 3124.419980076434], [495, 3001.5161365085064], [500, 3070.6424520713927]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="4-3-粒子群算法"><a href="#4-3-粒子群算法" class="headerlink" title="4.3 粒子群算法"></a>4.3 粒子群算法</h2><p>粒子群算法（ Particle Swarm Optimization, PSO）源于对鸟群觅食行为的研究。一群鸟在随机搜索食物，在这个区域里只有一块食物。所有的鸟都不知道食物在那里。但是他们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢。最简单有效的就是搜寻离食物最近的鸟的周围区域。用粒子模拟单个鸟类个体，粒子的位置对应优化问题的一个候选解，粒子的飞行过程即为该个体的解空间搜索过程。粒子的飞行速度可根据粒子历史最优位置和种群历史最优位置进行动态调整。粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。每个粒子单独搜寻的最优解叫做个体极值，粒子群中最优的个体极值作为当前全局极值。不断迭代，更新速度和位置，最终得到满足终止条件的最优解。</p><p>更新规则：粒子群算法的核心就是根据两个极值更新粒子的速度和位置。首先速度的更新公式为，</p><script type="math/tex; mode=display">v_i=\omega\times v_i+c_1\times rand()\times (pbest_i-x_i)+c_2\times rand()\times (gbest-x_i)</script><p>其中， $v_i$ 是粒子 $i$ 的速度， $x_i$ 是粒子 $i$ 的位置， $rand()$ 是介于 $(0,1)$ 的随机数， $pbest_i$ 是粒子 $i$ 的个体极值， $gbest$ 是粒子群的全局极值。组成该式子的三个部分分别叫做记忆项、自身认知项和群体认知项。记忆项代表上次的速度和位置，自身认知项代表了个体自身的历史经验，群体认知项代表了粒子间协同合作和知识共享的结果。 $\omega$ 、 $c1$ 和 $c2$<br>是三个权重因子，用来调节这三部分在粒子速度更新过程中的重要程度。最后，位置的更新公式相对简单， $x_i=x_i+v_i$</p><p>但是粒子群算法的原生公式不适用于旅行商问题，在解决旅行商问题时，要先定义粒子、位置、速度分别代表什么。一般思路是把粒子定义成问题的一个解，也就是城市序列，这个序列同时也代表粒子的位置。粒子移动的本质就是所有粒子向极值靠近，所以序列向序列靠近可以解释成序列片段的复制。这样看来，用粒子群算法解决旅行商问题就变得很像遗传算法的思路，只不过是把父代之间的序列片段交换，变成了粒子和极值之间的交换，三个权重因子也就代表着三次交换的片段的长度。</p><h2 id="4-4-免疫算法"><a href="#4-4-免疫算法" class="headerlink" title="4.4 免疫算法"></a>4.4 免疫算法</h2><p>和遗传算法大同小异，都是优胜劣汰的种群更新思路。</p><h2 id="4-5-鱼群算法"><a href="#4-5-鱼群算法" class="headerlink" title="4.5 鱼群算法"></a>4.5 鱼群算法</h2><h2 id="4-6-人工蜂群算法"><a href="#4-6-人工蜂群算法" class="headerlink" title="4.6 人工蜂群算法"></a>4.6 人工蜂群算法</h2><h2 id="4-7-蛙跳算法"><a href="#4-7-蛙跳算法" class="headerlink" title="4.7 蛙跳算法"></a>4.7 蛙跳算法</h2><h2 id="4-8-烟花算法"><a href="#4-8-烟花算法" class="headerlink" title="4.8 烟花算法"></a>4.8 烟花算法</h2><h2 id="4-9-萤火虫算法"><a href="#4-9-萤火虫算法" class="headerlink" title="4.9 萤火虫算法"></a>4.9 萤火虫算法</h2><h2 id="4-10-细菌觅食算法"><a href="#4-10-细菌觅食算法" class="headerlink" title="4.10 细菌觅食算法"></a>4.10 细菌觅食算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="https://shivakasu.cn/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://shivakasu.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Manacher 算法</title>
    <link href="https://shivakasu.cn/2020/01/15/arg2/"/>
    <id>https://shivakasu.cn/2020/01/15/arg2/</id>
    <published>2020-01-15T12:14:20.000Z</published>
    <updated>2020-01-15T15:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、算法背景"><a href="#一、算法背景" class="headerlink" title="一、算法背景"></a>一、算法背景</h1><p>Manacher算法，中文名马拉车算法，用以解决求字符串中的最长回文子串。传统的寻找最长回文子串的方法是从左到右遍历字符串的每个字符，同时以每个字符为回文中心向左右两侧扩散寻找，当字符串中存在大量回文子串，比如在极端情况下 $“aa…aa”$ ，算法的时间复杂度是 $O(N^2)$ 。而Manacher算法能够把寻找最长回文子串的时间复杂度降到 $O(N)$ 。</p><h1 id="二、字符串预处理"><a href="#二、字符串预处理" class="headerlink" title="二、字符串预处理"></a>二、字符串预处理</h1><p>假设要处理的字符串是 $“abbabb”$ ，由于回文串有奇回文和偶回文，比如 $“bab”$ 是奇回文， $“abba”$ 是偶回文，奇回文的对称轴是一个字符，偶回文的对称轴是两个字符，为了消除这种差异，首先要对字符串预处理，在每个字符的两侧都添加占位符，比如 $“\sharp”$ ，原来的字符串就变成了 $“\sharp a\sharp b\sharp b\sharp a\sharp b\sharp b\sharp ”$ 。对于其中的每个回文串，预处理相当于在每个字符的右侧添加占位符，变成偶回文，再在整体回文串的左侧添加一个占位符，变成奇回文。比如上述两个回文串变成了 $“\sharp b\sharp a\sharp b\sharp ”$ 和 $“\sharp a\sharp b\sharp b\sharp a\sharp ”$ ，长度分别是7和9，都是奇回文。</p><h1 id="二、计算最长回文子串半径"><a href="#二、计算最长回文子串半径" class="headerlink" title="二、计算最长回文子串半径"></a>二、计算最长回文子串半径</h1><p>除了对字符串的预处理，算法还需要一个辅助数组 $p$ ，设预处理后的字符串是 $arr$ ，则 $p[i]$ 表示以 $arr[i]$ 为回文中心的最大回文半径。由于所有回文串都是奇回文，所以回文半径可以表示为 $(回文串长度+1)\div 2$ ，也就是包含回文中心的回文串的一半。比如下表中， $p[3]=2$ 表示以 $arr[3]$ 为回文中心的最长回文子串是 $“\sharp b\sharp ”$ ，回文半径是2，即 $“\sharp b”$ 的长度。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i ：</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">arr：</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p ：</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><p>计算数组 $p$ 需要两个辅助变量， $maxright$ 表示遍历至此发现的回文串所能达到的最右边界， $center$ 表示到达最右边界的回文串的回文中心。当遍历到 $arr[i]$ 时，要计算的是以 $arr[i]$ 为回文中心的最大回文半径，由于 $center$ 和 $maxright$ 是当前已知的回文中心和回文边界，所以一定是在之前的步骤算出来的，所以必有 $center&lt;i&lt;maxright$ ，又因为 $arr[center..maxright]$ 是一个回文串的右半部分，所以在 $arr[0..center]$ 中必有 $i$ 的对称点，记为 $i’$ ，以及 $maxright$ 的对称点 $maxright’$ ，至此，可以确定以下数组下标的位置关系：</p><script type="math/tex; mode=display">maxright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow maxright</script><p>Manacher算法的核心就是利用之前步骤算出的 $p$ 数组的值来减少对字符串的遍历。在当前的步骤中就体现在根据 $p[i’]$ 值的情况优化计算 $p[i]$ 的过程，把以 $arr[i]$ 为回文中心的回文串的右边界记为 $iright$ ，关于 $center$ 的对称点记为 $iright’$ ，分为两种情况：</p><p>情况一：$p[i’]&lt;maxright-i$<br>$p[i’]$ 是 $i’$ 到 $iright’$ 的距离，$maxright-i$ 是 $i’$ 到 $maxright’$ 的距离，位置关系如下，</p><script type="math/tex; mode=display">maxright'\rightarrow iright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow iright\rightarrow maxright</script><p>说明以 $arr[i]$ 为回文中心的回文串被完全包含在以 $arr[center]$ 为回文中心的回文串中。必有 $p[i]=p[i’]$ </p><p>情况二：$p[i’]\geq maxright-i$<br>位置关系如下，</p><script type="math/tex; mode=display">iright'\rightarrow maxright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow maxright\rightarrow iright</script><p>说明以 $arr[i]$ 为回文中心的最大回文半径至少是 $maxright-i$ ，而 $maxright’$ 左侧与 $maxright$ 右侧的字符是否匹配还不知道，因为 $maxright$ 就是当前遍历到的最右边界，再右边的字符还没遍历到，所以此时可以把 $maxright’$ 和 $maxright$ 当做左右边界向外扩散匹配，而回文中心 $i$ 到 $maxright$ 之间的字符就不必判断了，因为 $p[i’]$ 保证了这一段一定是能匹配成功的。</p><p>一句话总结， $p$ 数组的计算过程就是利用算过的 $p$ 数组的值优化左右扩散匹配。</p><h1 id="三、最长回文子串起始坐标"><a href="#三、最长回文子串起始坐标" class="headerlink" title="三、最长回文子串起始坐标"></a>三、最长回文子串起始坐标</h1><p>算好了数组 $p$ ，其中最大的值就是最长回文子串的半径，但这里得到的长度和坐标都是基于预处理后的字符串 $arr$ ，获取最长回文子串需要知道他在原字符串 $str$ 里的起始点和半径。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i ：</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">arr：</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p ：</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">str：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td></tr></tbody></table></div><p>在上图的例子中，基于 $arr$ 得到的回文中心是 $arr[7]$ ，回文半径是 $p[7]=6$ ，而在目标字符串中需要找到的回文串是 $str[1..5]$ 。</p><p>回文串在原字符串中的起始坐标是 $index=(i-p[i])\div 2$ ，其中 $i-p[i]$ 是 $arr$ 起点到回文串左边界的距离，在例子中就是 $“\sharp a”$ 这一段，由于最大回文字符串的首尾一定是占位符，所以从 $arr$ 起点到回文左边界这一段中的每个字符只有左侧有占位符，也就是说字符和占位符的数量是相同的，所以式子最后要除以2，才能得到其中所有有效字符的数量，这个去除了占位符的长度就是原字符串 $str$ 中起点到回文左边界的距离。</p><p>$str$ 中的回文半径也容易计算。如果 $arr$ 中的回文中心是有效字符，说明这个回文串预处理前是奇回文，回文串的左半部分中每个字符的左侧都有一个占位符，在例子里也就是 $“\sharp b\sharp b\sharp a”$ ，这时真实的回文半径就是 $p[i]\div 2$ 。如果 $arr$ 中的回文中心是占位符，说明这个回文串预处理前是偶回文，回文串的左半部分中每个字符的左侧都有一个占位符，同时多了回文中心上的一个占位符，这时真实的回文半径就是 $(p[i]-1)\div 2$ 。</p><p>Manacher算法的 $O(N)$ 时间复杂度可以理解成 $maxright$ 从 $arr$ 起点移动到终点的过程， $maxright$ 左侧的字符都是不必重复匹配的，右侧随着匹配过程不断更新 $maxright$ 的位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="https://shivakasu.cn/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://shivakasu.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
