<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHIVAKASU</title>
  <icon>https://www.gravatar.com/avatar/db3726c77acefe0355d29843a28e9ca4</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shivakasu.github.io/"/>
  <updated>2020-01-05T11:28:44.065Z</updated>
  <id>http://shivakasu.github.io/</id>
  
  <author>
    <name>w.k.x.</name>
    <email>wkx1996@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>流畅的Python Chapter 7：函数装饰器和闭包</title>
    <link href="http://shivakasu.github.io/2019/02/10/fpy4/"/>
    <id>http://shivakasu.github.io/2019/02/10/fpy4/</id>
    <published>2019-02-09T17:56:20.000Z</published>
    <updated>2020-01-05T11:28:44.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、python中的函数装饰器(Function decorator)用来“标记函数”，以某种方式增强函数的行为，其实就是一种语法糖(syntactic sugar)，用来简化复杂的代码。如下：</p><p><a href="/2019/02/10/fpy4/fpy4-0.png" data-fancybox="group" data-caption="fpy4-0" class="fancybox"><img alt="fpy4-0" title="fpy4-0" data-src="/2019/02/10/fpy4/fpy4-0.png" class="lazyload"></a></p><p>可以用装饰器实现函数的替换，虽然这么做没什么意义：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def deco(func):</span><br><span class="line">...     def inner():</span><br><span class="line">...print(&#39;running inner()&#39;)</span><br><span class="line">...     return inner #1</span><br><span class="line">&gt;&gt;&gt; @deco</span><br><span class="line">... def target(): #2</span><br><span class="line">...     print(&#39;running target()&#39;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; target() #3</span><br><span class="line">running inner()</span><br><span class="line">&gt;&gt;&gt; target #4</span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at 0x10063b598&gt;</span><br></pre></td></tr></table></figure></div></p><p>还可以用作注册函数，对于新增的函数，只需要添加装饰器，而不用手动进行注册：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">registry &#x3D; []</span><br><span class="line"></span><br><span class="line">def register(func):</span><br><span class="line">  print(&#39;running register(%s)&#39; % func) </span><br><span class="line">    registry.append(func)</span><br><span class="line">  return func</span><br><span class="line"></span><br><span class="line">@register</span><br><span class="line">def f1():</span><br><span class="line">    print(&#39;running f1()&#39;)</span><br><span class="line"></span><br><span class="line">@register</span><br><span class="line">def f2():</span><br><span class="line">    print(&#39;running f2()&#39;)</span><br><span class="line"></span><br><span class="line">def f3():</span><br><span class="line">    print(&#39;running f3()&#39;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&#39;running main()&#39;) </span><br><span class="line">    print(&#39;registry -&gt;&#39;, registry) </span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line">    </span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;: </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div></p><p>装饰器在函数定义后立即运行，这通常是在导入(import)时，例如上面代码的执行结果是：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python3 registration.py</span><br><span class="line">running register(&lt;function f1 at 0x100631bf8&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x100631c80&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x100631bf8&gt;, &lt;function f2 at 0x100631c80&gt;] running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure></div></p><p>单独执行import操作，得到的结果是：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import registration</span><br><span class="line">running register(&lt;function f1 at 0x10063b1e0&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x10063b268&gt;)</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;2、闭包(closures)指的是嵌套函数的作用于问题，如图，内层函数可以直接使用上层函数定义的变量，这种变量又叫做自由变量。</p><p><a href="/2019/02/10/fpy4/fpy4-1.png" data-fancybox="group" data-caption="fpy4-1" class="fancybox"><img alt="fpy4-1" title="fpy4-1" data-src="/2019/02/10/fpy4/fpy4-1.png" class="lazyload"></a></p><p>但自由变量只能使用，如果对自由变量进行赋值，就会被解释器当做局部变量而抛出“变量未定义”的异常，如下，这是由于python不要求像C一样先声明变量再使用变量，所以遇到对非全局变量的赋值操作会直接看作局部变量。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    total &#x3D; 0</span><br><span class="line">    def averager(new_value):</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        total +&#x3D; new_value</span><br><span class="line">        return total &#x2F; count</span><br><span class="line">    return averager</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; avg &#x3D; make_averager()</span><br><span class="line">&gt;&gt;&gt; avg(10)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">UnboundLocalError: local variable &#39;count&#39; referenced before assignment</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></div></p><p>这种情况下不能使用<code>global</code>关键字，因为没有涉及全局变量，而是嵌套函数中因为层次关系产生的相对外层的变量，这时候就要用<code>nonlocal</code>关键字，用法和<code>global</code>一样。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    total &#x3D; 0</span><br><span class="line">    def averager(new_value):</span><br><span class="line">        nonlocal count, total</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        total +&#x3D; new_value</span><br><span class="line">        return total &#x2F; count</span><br><span class="line">    return averager</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;3、functools模块有两个实用的装饰器。<code>lru_cache</code>用来缓存函数的中间结果，LRU即Least Recently Used，如下，在计算斐波那契数的递归过程中，计算过的值会保存在缓存中，减少重复计算。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">@functools.lru_cache()</span><br><span class="line">def fibonacci(n):</span><br><span class="line">    if n&lt;2:</span><br><span class="line">        return n</span><br><span class="line">    return fibonacci(n-2) + fibonacci(n-1)</span><br></pre></td></tr></table></figure></div></p><p><code>singledispatch</code>装饰器用来生成泛函数(generic function)，指的是根据函数参数的类型以不同方式执行操作。由于<code>singledispatch</code>只根据函数第一个参数，所以称作单分派泛函数，与之对应的是多分派(multiple-dispatch)。用法如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from functools import singledispatch</span><br><span class="line">from collections import abc</span><br><span class="line">import numbers</span><br><span class="line">import html</span><br><span class="line"></span><br><span class="line">@singledispatch</span><br><span class="line">def htmlize(obj):</span><br><span class="line">    content &#x3D; html.escape(repr(obj))</span><br><span class="line">    return &#39;&lt;pre&gt;&#123;&#125;&lt;&#x2F;pre&gt;&#39;.format(content)</span><br><span class="line"></span><br><span class="line">@htmlize.register(str) </span><br><span class="line">def _(text):        </span><br><span class="line">    content &#x3D; html.escape(text).replace(&#39;\n&#39;, &#39;&lt;br&gt;\n&#39;)</span><br><span class="line">    return &#39;&lt;p&gt;&#123;0&#125;&lt;&#x2F;p&gt;&#39;.format(content)</span><br><span class="line"></span><br><span class="line">@htmlize.register(numbers.Integral)</span><br><span class="line">def _(n):</span><br><span class="line">    return &#39;&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;&#x2F;pre&gt;&#39;.format(n)</span><br><span class="line"></span><br><span class="line">@htmlize.register(tuple)</span><br><span class="line">@htmlize.register(abc.MutableSequence)</span><br><span class="line">def _(seq):</span><br><span class="line">    inner &#x3D; &#39;&lt;&#x2F;li&gt;\n&lt;li&gt;&#39;.join(htmlize(item) for item in seq)</span><br><span class="line">    return &#39;&lt;ul&gt;\n&lt;li&gt;&#39; + inner + &#39;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;&#39;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;4、闭包是静态作用域(static scope)下的概念，与之相对的是动态作用域(dynamic scope)。静态作用域又叫做词法作用域(lexical scope)，C、C++、Python、Java等大多数现在程序设计语言都是采用静态作用域规则，指的是变量的作用域是确定的，词法分析时不会逐层检查函数的调用链，而是检查函数定义时的外部环境，从当前作用域由内而外寻找最近的该变量的定义。动态作用域完全相反，变量的作用域是不确定的，根据函数的调用层次确定变量的定义，也就是说只要在调用函数之前在当前环境重新定义变量，函数就能使用新定义的变量，不关注结构上的层次。个人理解动态作用域的缺点就是变量随意覆盖可能引起意外bug，而且代码中一个变量有多个版本也会大大降低可读性吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 5：一等函数</title>
    <link href="http://shivakasu.github.io/2019/02/10/fpy3/"/>
    <id>http://shivakasu.github.io/2019/02/10/fpy3/</id>
    <published>2019-02-09T16:45:20.000Z</published>
    <updated>2020-01-05T11:26:31.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、在python中，函数是一等对象(first-class object)，一等对象的特征有：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ul><p>接受函数为参数或把函数作为结果返回的函数又叫高阶函数(higher-order function)，常见的高阶函数例如python内置的<code>sorted</code>，其接收一个参数key，当想根据长度排序时，可以写成<code>sorted(xxx,key=len)</code>，这就是把<code>len()</code>函数作为参数传给<code>sorted()</code>。在函数式编程范式中，常用的高阶函数有<code>map</code>、<code>filter</code>、<code>reduce</code>和<code>apply</code>，然而在python中不常用这些函数，因为已经有了更简单的替代方式。</p><ul><li><code>map</code>函数用来求一个序列或者多个序列进行函数映射之后的值，<code>filter</code>函数用来过滤掉序列中不符合函数条件的元素，二者完全可以用列表推导式替代，对应for循环和if条件判定。</li><li><code>reduce</code>函数用来对一个序列进行压缩运算，在python3中已经移到了functools模块，该方法最常用于序列求和，因此可以用python内置的<code>sum</code>函数替代。</li><li><code>apply(func [, args [, kwargs ]])</code>函数用于当函数参数已经存在于一个元组或字典中时，间接地调用函数。因为python本来就支持函数定义中包含不定量参数，所以<code>apply</code>函数反而多此一举，python3中已经移除了。但在第三方库例如pandas中还在使用。</li></ul><p>&emsp;&emsp;2、python中能使用调用符号“()”的对象称为可调用对象(Callable Objects)，有7种可调用对象：</p><ul><li>用户用<code>def</code>或<code>lambda</code>定义的函数</li><li>内置函数：使用C语言实现的函数，如<code>len</code>或<code>time.strftime</code></li><li>内置方法：使用C语言实现的方法，如<code>dict.get</code></li><li>方法：在类的定义体中定义的函数</li><li>类：由于python没有new函数，所以创建实例时直接调用类</li><li>类的实例：如果类定义了<code>__call__</code>方法，它的实例就可以作为函数调用</li><li>生成器函数：使用<code>yield</code>关键字的函数或方法</li></ul><p>&emsp;&emsp;3、有必要理解一下关键字、方法、函数的区别：</p><ul><li>关键字：内置的、具有特殊意义的表示符，使用时不加“()”</li><li>方法：封装了独立的功能，需要用对象调用，对象.方法名(参数)</li><li>函数：也是封装了独立的功能，直接调用或使用模块名调用</li></ul><p>&emsp;&emsp;4、operator模块提供了对函数式编程的支持。例如在使用<code>reduce</code>函数对序列求和时，需要传入一个函数，因此不能直接使用“+”，所以需要另外定义表示加减乘除这类运算的函数，operator模块内置了这些函数，所以就没必要自己定义了。</p><p>&emsp;&emsp;operator模块的<code>itemgetter</code>和<code>attrgetter</code>函数可用于替代从序列中取出元素或读取对象属性的lambda表达式，如下：</p><p><a href="/2019/02/10/fpy3/fpy3-0.png" data-fancybox="group" data-caption="fpy3-0" class="fancybox"><img alt="fpy3-0" title="fpy3-0" data-src="/2019/02/10/fpy3/fpy3-0.png" class="lazyload"></a></p><p>&emsp;&emsp;5、第六章讲的是用一等函数实现设计模式，思想很简单，因为函数也能作为参数，所以就可以简化代码，不必为了实现特定功能而创建一个类，再用类的实例调用方法，而是可以直接定义函数，把函数作为参数传进方法里调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 3：字典和集合</title>
    <link href="http://shivakasu.github.io/2019/02/07/fpy2/"/>
    <id>http://shivakasu.github.io/2019/02/07/fpy2/</id>
    <published>2019-02-07T07:35:20.000Z</published>
    <updated>2020-01-05T11:25:05.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、collections.abc模块中有Mapping和MutableMapping两个抽象基类，它们的作用是为dict和其他类似的类型定义形式接口。</p><p><a href="/2019/02/07/fpy2/fpy2-0.png" data-fancybox="group" data-caption="fpy2-0" class="fancybox"><img alt="fpy2-0" title="fpy2-0" data-src="/2019/02/07/fpy2/fpy2-0.png" class="lazyload"></a></p><p>&emsp;&emsp;2、标准库里的所有映射类型都是利用dict实现的，只有可散列(hashable)的数据类型才能用作这些映射里的键。如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现<code>__hash__()</code>方法进行散列，也要实现<code>__eq__()</code>方法进行键的比较。python的原子不可变类型(str、bytes和数值类型)是可散列的，一个元组是可散列的当且仅当其包含的元素都是可散列的。所以严格来说不可变类型不都是可散列的，元组不一定。</p><p>&emsp;&emsp;3、和列表推导式类似，字典也有推导构建法：</p><p><a href="/2019/02/07/fpy2/fpy2-1.png" data-fancybox="group" data-caption="fpy2-1" class="fancybox"><img alt="fpy2-1" title="fpy2-1" data-src="/2019/02/07/fpy2/fpy2-1.png" class="lazyload"></a></p><p>&emsp;&emsp;4、处理字典可能找不到键的情况：</p><ul><li>使用<code>setdefault()</code>方法，如下图。这样做的好处是减少了查询字典的次数，如果键不存在，不使用<code>setdefault()</code>就需要查三次字典。</li></ul><p><a href="/2019/02/07/fpy2/fpy2-2.png" data-fancybox="group" data-caption="fpy2-2" class="fancybox"><img alt="fpy2-2" title="fpy2-2" data-src="/2019/02/07/fpy2/fpy2-2.png" class="lazyload"></a></p><ul><li><p>使用<code>collections.defaultdict</code>字典，提供一个可调用对象作为参数。例如当用语句<code>index = collections.defaultdict(list)</code>创建字典后，执行<code>index[&#39;new_key&#39;]</code>找不到键，则会自动调用<code>list()</code>方法生成空列表，并以<code>new_key</code>为键添加到字典中，最后返回该列表的引用。</p></li><li><p>上述两种方法的原理都是实现了<code>__missing__</code>方法，字典使用<code>__getitem__</code>方法进行查询，当找不到键时，如果实现了<code>__missing__</code>方法，<code>__getitem__</code>会直接调用，否则抛出异常。原始的dict没有实现<code>__missing__</code>方法，但它知道有了<code>__missing__</code>方法就可以用。所以第三种方法是创建dict的子类，实现<code>__missing__</code>方法。</p></li></ul><p>&emsp;&emsp;5、types模块有一个封装类MappingProxyType，用于返回一个字典的不可变的视图，这个视图是动态的，原字典改变视图也会随之改变，所以如果不想字典在使用过程中被修改，可能会用到这个类。</p><p><a href="/2019/02/07/fpy2/fpy2-3.png" data-fancybox="group" data-caption="fpy2-3" class="fancybox"><img alt="fpy2-3" title="fpy2-3" data-src="/2019/02/07/fpy2/fpy2-3.png" class="lazyload"></a></p><p>&emsp;&emsp;6、python的集合类型有set和frozenset，集合中的元素必须是可散列的，set本身是不可散列的，但frozenset是可散列的。</p><p>&emsp;&emsp;7、set集合除了可以从列表生成，还可以使用集合字面量(set literals)定义。比如<code>s=set([1,2,3])</code>和<code>s={1,2,3}</code>是等价的，但字面量方式更高效。需要注意，空集只能用<code>s=set()</code>生成，字面量形式的<code>s={}</code>是生成空字典。此外，frozenset不支持字面量操作，所以只能从列表生成。由于支持字面量定义，set集合还能用推导式生成，和列表推导式类似，只不过两端是大括号。</p><p>&emsp;&emsp;8、集合类的继承关系如下：</p><p><a href="/2019/02/07/fpy2/fpy2-4.png" data-fancybox="group" data-caption="fpy2-4" class="fancybox"><img alt="fpy2-4" title="fpy2-4" data-src="/2019/02/07/fpy2/fpy2-4.png" class="lazyload"></a></p><p>&emsp;&emsp;9、dict是用散列表实现的，理论上只要字典不超过内存大小，查询操作耗费的时间都能忽略不计。散列表的查询流程如下，其中bucket指的是散列表中的单元，即表元，dict的每个键值对占用一个表元。由于流程中使用散列值的一部分进行匹配，可能会发生匹配部分相同但整体键不相等，这就叫散列冲突(hash collision)，这时就会取散列值的另一部分再进行匹配。虽然看似效率低下，但散列函数的特性是不相等的对象散列值差别很大，所以实际上发生散列冲突的概率非常小。</p><p><a href="/2019/02/07/fpy2/fpy2-5.png" data-fancybox="group" data-caption="fpy2-5" class="fancybox"><img alt="fpy2-5" title="fpy2-5" data-src="/2019/02/07/fpy2/fpy2-5.png" class="lazyload"></a></p><p>&emsp;&emsp;10、字典提供了无视数据量大小的快速访问，代价是空间效率低下，因为散列表必须是稀疏的，需要占用大量空间。此外，不能对字典同时进行迭代和修改，如果往字典里添加新键，解释器可能会做出为字典扩容的决定，将当前散列表迁移到更大的散列表中，在这个过程中对字典进行迭代，可能会出现问题。</p><p>&emsp;&emsp;11、set和frozenset集合也是基于散列表实现的，只不过表元是对单个元素的引用。所以集合类型也有时间效率高、空间效率低的特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 2：序列构成的数组</title>
    <link href="http://shivakasu.github.io/2019/02/06/fpy1/"/>
    <id>http://shivakasu.github.io/2019/02/06/fpy1/</id>
    <published>2019-02-06T15:13:20.000Z</published>
    <updated>2020-01-05T11:22:40.238Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、python标准库用C实现了丰富的序列类型：</p><ul><li>容器序列(Container sequences)：list、tuple、collections.deque这些序列能存放不同类型数据。</li><li>扁平序列(Flat sequences)：str、bytes、bytearray、memoryview、array.array这些序列只能容纳一种类型。</li><li>可变序列(Mutable sequences)：list、bytearray、array.array、collections.deque、memoryview这些序列可以原地修改。</li><li>不可变序列(Immutable sequences)：tuple、str、bytes这些序列不能原地修改。</li></ul><p>&emsp;&emsp;下图是序列对象的继承关系，箭头从子类指向父类，可以看到可变对象之所以能够修改是因为实现了<code>__setitem__</code>、<code>__delitem__</code>等方法。</p><p><a href="/2019/02/06/fpy1/fpy1-0.png" data-fancybox="group" data-caption="fpy1-0" class="fancybox"><img alt="fpy1-0" title="fpy1-0" data-src="/2019/02/06/fpy1/fpy1-0.png" class="lazyload"></a></p><p>&emsp;&emsp;2、python会忽略代码里[]、()、{}中的换行，所以写列表推导时直接回车换行，不用加续行符“\”。</p><p>&emsp;&emsp;3、当使用“*”对序列进行复制时，要保证序列里没有对其他可变对象的引用，引用只能浅复制，当修改其中一个引用时，其他的也会改变。如下：</p><p><a href="/2019/02/06/fpy1/fpy1-1.png" data-fancybox="group" data-caption="fpy1-1" class="fancybox"><img alt="fpy1-1" title="fpy1-1" data-src="/2019/02/06/fpy1/fpy1-1.png" class="lazyload"></a></p><p>&emsp;&emsp;4、不要把可变对象放到元组里，修改元组里的可变对象虽然会抛出异常，但对象可能会真的被修改。</p><p>&emsp;&emsp;5、<code>list.sort()</code>原地排序，<code>sorted()</code>创建新列表排序并返回。</p><p>&emsp;&emsp;6、如果需要一个只包含数字的列表，使用array.array比list更高效，因为list将数字存成python的整形和浮点型，而array.array把数字直接存成机器翻译，也就是字节表述。道理是这样，用的时候还是对比一下速度吧，list、array和numpy的array。</p><p>&emsp;&emsp;7、python内置的排序函数使用了Timsort排序算法。Timsort混合了插入排序和归并排序，因为真实世界中的数据往往带有一定的顺序，所以根据输入的特点进行分区，分区内插入排序，分区间归并排序。</p><p><a href="/2019/02/06/fpy1/fpy1-2.png" data-fancybox="group" data-caption="fpy1-2" class="fancybox"><img alt="fpy1-2" title="fpy1-2" data-src="/2019/02/06/fpy1/fpy1-2.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 1：Python 数据模型</title>
    <link href="http://shivakasu.github.io/2019/02/04/fpy0/"/>
    <id>http://shivakasu.github.io/2019/02/04/fpy0/</id>
    <published>2019-02-04T07:08:20.000Z</published>
    <updated>2020-01-05T05:18:16.106Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;这一章写的是python的特殊方法(special method)，又叫作魔术方法(magic method)。最常见的就是面向对象编程时的初始化方法<code>__init__</code>，这类方法的特点有：</p><ul><li>方法名首尾有两个下划线。</li><li>所有特殊方法都是python内置的，使用时只需要在类里重写，最好不要自己定义新的特殊方法。</li><li>特殊方法都与特殊操作绑定，不需要显式调用。如<code>__init__</code>与对象初始化绑定，<code>__len__</code>与<code>len()</code>方法绑定，<code>__add__</code>与<code>+</code>运算绑定。</li></ul><p>&emsp;&emsp;部分特殊方法如下，首先是与运算符无关的特殊方法：<br><a href="/2019/02/04/fpy0/fpy0-0.png" data-fancybox="group" data-caption="fpy0-0" class="fancybox"><img alt="fpy0-0" title="fpy0-0" data-src="/2019/02/04/fpy0/fpy0-0.png" class="lazyload"></a></p><p>然后是与运算符有关的特殊方法：<br><a href="/2019/02/04/fpy0/fpy0-1.png" data-fancybox="group" data-caption="fpy0-1" class="fancybox"><img alt="fpy0-1" title="fpy0-1" data-src="/2019/02/04/fpy0/fpy0-1.png" class="lazyload"></a></p><p>&emsp;&emsp;<code>__repr__</code>和<code>__str__</code>都是用于定义对象的字符串表示形式。区别是前者用于在命令行直接输入一个对象时返回的字符串，后者是调用<code>str()</code>方法或<code>print()</code>时返回的字符串。如果只想实现其中一个特殊方法，就实现<code>__repr__</code>，因为没有<code>__str__</code>时解释器会自动调用<code>__repr__</code>。</p><p>&emsp;&emsp;<code>__bool__</code>用于定义一个对象的真值，如果对象需要参与条件判定的话，可以用<code>bool()</code>方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 6：文档-语言及属性</title>
    <link href="http://shivakasu.github.io/2019/02/03/mir4/"/>
    <id>http://shivakasu.github.io/2019/02/03/mir4/</id>
    <published>2019-02-02T18:20:20.000Z</published>
    <updated>2020-01-05T11:19:38.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-文本相似度"><a href="#1-文本相似度" class="headerlink" title="1 文本相似度"></a>1 文本相似度</h2><p>&emsp;&emsp;文本的相似度依靠距离函数度量，距离函数应该是对称的，即不受参数顺序影响，并且应该满足三角不等式：</p><script type="math/tex; mode=display">distance(a,c)\leq distance(a,b)+distance(b,c)</script><p>&emsp;&emsp;常见的距离函数如下：</p><ul><li>海明距离(Hamming distance)：对于相同长度的字符串，定义它们之间的距离为他们拥有不同字符的位置的个数。</li><li>编辑距离(Edit distance)：使两个字符串相同而在其中任何一个字符串上进行字符插入、删除和替换操作的最少次数。如“color”和“colour”的编辑距离是1。编辑距离是处理语法错误的首选模型。</li><li>最长公共子序列(longest common subsequence, LCS)：如“survey”和“surgery”的最长公共子序列是“surey”。</li><li>余弦相似度：第三章提到过。</li><li>类似度(resemblance)：两个文档词汇表的重合度。定义 <script type="math/tex">W(d_j)</script> 是 <script type="math/tex">d_j</script> 中所有不同词的集合，两个文档的类似度定义为：<script type="math/tex; mode=display">R(d_i,d_j)=\frac{|W(d_i)\cap W(d_j)|}{|W(d_i)\cup W(d_j)|}</script></li></ul><p>&emsp;&emsp;任何在 <script type="math/tex">[0,1]</script> 范围内的相似度度量都可以通过以下方式方便地转换为距离函数：</p><script type="math/tex; mode=display">D(d_i,d_j)=1-Sim(d_i,d_j)</script><h2 id="2-文档预处理"><a href="#2-文档预处理" class="headerlink" title="2 文档预处理"></a>2 文档预处理</h2><p>&emsp;&emsp;文档预处理阶段的逻辑视图如下，主要分为五个步骤：<br><a href="/2019/02/03/mir4/mir4-0.png" data-fancybox="group" data-caption="mir4-0" class="fancybox"><img alt="mir4-0" title="mir4-0" data-src="/2019/02/03/mir4/mir4-0.png" class="lazyload"></a></p><h3 id="2-1-词汇分析"><a href="#2-1-词汇分析" class="headerlink" title="2.1 词汇分析"></a>2.1 词汇分析</h3><p>&emsp;&emsp;词汇分析(Lexical analysis)是将字符流转化为单词流的过程，就是分词。主要考虑以下几种情况：</p><ul><li>空格(Space)：最常见的分词符。</li><li>数字(Numbers)：根据上下文确定数字代表的意义，如量化数值、时间点，或是“512B.C.”这样的混合词。</li><li>连字符(Hyphens)：要不要拆，像“state-of-the-art”可拆可不拆，像表示序号的“A-3”最好不要拆。</li><li>标点符号(Punctuation marks)：区别对待句间分隔符、词间分隔符和词内分隔符。</li><li>大小写：要不要区分单词大小写，通常会影响到一些专有名词，如人名、地名、组织名。</li></ul><h3 id="2-2-去除停用词"><a href="#2-2-去除停用词" class="headerlink" title="2.2 去除停用词"></a>2.2 去除停用词</h3><p>&emsp;&emsp;停用词(Stopwords)通常是出现频率较多的词，被认为没有什么区分度，常见的是冠词、介词和连词。去除停用词可以减少索引结构的大小，但也会造成召回率的降低，也就是把一些相关的文本删到识别不出。所以有些Web搜索引擎会采用全文检索，不去除停用词。</p><h3 id="2-3-词干提取"><a href="#2-3-词干提取" class="headerlink" title="2.3 词干提取"></a>2.3 词干提取</h3><p>&emsp;&emsp;词干(stem)提取就是所谓的词形还原，把名词复数、动词过去式等还原。我觉得比较靠谱的方法也就是根据语法规则和查词表两种，但是词干提取对检索性能是否有帮助仍然存在争论。</p><h3 id="2-4-关键词选择"><a href="#2-4-关键词选择" class="headerlink" title="2.4 关键词选择"></a>2.4 关键词选择</h3><p>&emsp;&emsp;和全文索引相对立，只选取文本中一部分代表性的词作为索引项，因此这种索引项也叫作关键词。关键词通常都是名词或者名词组，因为名词能够携带更多的信息。</p><h3 id="2-5-同义词典"><a href="#2-5-同义词典" class="headerlink" title="2.5 同义词典"></a>2.5 同义词典</h3><p>&emsp;&emsp;好像没什么用。</p><h2 id="3-组织文档"><a href="#3-组织文档" class="headerlink" title="3 组织文档"></a>3 组织文档</h2><p>&emsp;&emsp;顾名思义，就是文档的组织方式。主要有分类体系法(Taxonomies)和分众分类法(Folksonomies)。</p><p>&emsp;&emsp;分类体系法的核心是层次化，需要有一个清晰的分类层次，也需要对文档的类别有准确的描述，如下图：<br><a href="/2019/02/03/mir4/mir4-1.png" data-fancybox="group" data-caption="mir4-1" class="fancybox"><img alt="mir4-1" title="mir4-1" data-src="/2019/02/03/mir4/mir4-1.png" class="lazyload"></a></p><p>&emsp;&emsp;分众分类法的核心是扁平化，最常见的是标签云，如下图。因为不能准确、完全地描述文档，所以只提取一些用户感兴趣的关键词作为标签。<br><a href="/2019/02/03/mir4/mir4-2.png" data-fancybox="group" data-caption="mir4-2" class="fancybox"><img alt="mir4-2" title="mir4-2" data-src="/2019/02/03/mir4/mir4-2.png" class="lazyload"></a></p><h2 id="4-文本压缩"><a href="#4-文本压缩" class="headerlink" title="4 文本压缩"></a>4 文本压缩</h2><p>&emsp;&emsp;文本压缩的目的是减少空间开销、输入/输出开销和通信时延。选择压缩方法时需要考虑的因素有：</p><ul><li>压缩比，即压缩后大小与压缩前大小之比。</li><li>压缩和解压缩的速度，通常解压缩的速度更重要，因为只有在存储文档的时候需要压缩，而后续每次访问文档时都需要进行解压。</li><li>压缩文本是否支持搜索，即检索过程可以直接在压缩文档上进行，不需要预先解压缩，直接搜索压缩文档的速度会更快。</li></ul><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>&emsp;&emsp;文本压缩有两个通用方法：统计方法(statistical)和基于字典的方法(dictionary based)。统计方法估计每个文本符号出现的概率，根据出现概率将文本符号转换为二进制编码。字典方法从文档中识别出一系列可以被引用的短语，短语的集合称为字典，压缩的过程就是把文本中的短语替换成相应字典条目的指针。虽然压缩分为无损压缩和有损压缩，但在文档存储和检索的任务中，使用的基本都是无损压缩。</p><h3 id="4-2-统计方法"><a href="#4-2-统计方法" class="headerlink" title="4.2 统计方法"></a>4.2 统计方法</h3><p>&emsp;&emsp;统计方法定义为两个任务的组合：建模和编码。前者估计每个后续字符的概率，后者把后续符号编码成模型分配给他的概率函数，把每个符号表示成码字(codeword)。统计方法的理论基础是香农的信息论，信息压缩的下界是信息熵，文本的熵定义为：</p><script type="math/tex; mode=display">E=\sum p_ilog_2\frac{1}{p_i}</script><p>也就是出现概率为 <script type="math/tex">p_i</script> 的符号至少需要长度为 <script type="math/tex">log_2\frac{1}{p_i}</script> 的码字表示，由于码字通常是整数个编码单元，实际长度往往会大于这个理论值。同时，编码需要给出现概率高的符号尽可能短的码字，这样才能保证较低的压缩率。</p><h3 id="4-3-统计方法：建模"><a href="#4-3-统计方法：建模" class="headerlink" title="4.3 统计方法：建模"></a>4.3 统计方法：建模</h3><p>&emsp;&emsp;压缩模型分为自适应模型(adaptive model)、静态模型(static model)和半静态模型(semi-static model)。</p><ul><li>自适应模型：不需要关于文本的先验知识，只需要处理文本一遍，在处理过程中根据读入的新文档动态调整字符的概率分布。有两个缺点，一是速度慢，因为需要动态更新，二是只能从压缩文档的开头进行解压，因为关于分布的信息数据实在文件中增量存储的。</li><li>静态模型：对所有输入的文本假设一个分布，只需要处理文本一遍，对所有要压缩的文本都使用这个分布。缺点是不使用，假设的分布在新的文档上往往效果很差。</li><li>半静态模型：不需要假设分布，但是要处理文本两遍。第一遍学习字符的概率分布，第二遍进行压缩，优缺点也很明显。</li></ul><p>&emsp;&emsp;模型的阶(order)指的是用来估计下一个符号的概率而使用的前面符号的个数。 <script type="math/tex">0</script> 阶模型就是所谓的上下文无关模型，每个符号概率的计算都是独立的。高阶模型压缩效果更好，但是需要更大的空间存储和运行，此外，任一位置的解压都需要知道前面 <script type="math/tex">k</script> 个符号，所以高阶模型只能从开头进行解压，不支持随机访问。</p><p>&emsp;&emsp;除了基于字符的模型，还有基于词的模型，也就是直接对单词进行编码。词模型的理论基础是两个统计法则。一是 <script type="math/tex">Heaps</script> 法则，指出 <script type="math/tex">n</script> 个词的自然语言文本的词汇表大小 <script type="math/tex">V</script> 的增长是 <script type="math/tex">V=O(n^\beta)</script> ，其中 <script type="math/tex">\beta <1</script> 是一个依赖于特定文本的常数。第二个法则是 <script type="math/tex">Zipf</script> 法则，指出最常出现的第 <script type="math/tex">i</script> 个单词出现 <script type="math/tex">O(n/i^\alpha)</script> 次，其中 <script type="math/tex">\alpha >1</script> 是依赖于文本的常数。这两个法则保证了基于词的模型不会产生量级的爆炸，同时概率分布具有良好的偏斜性。</p><h3 id="4-4-统计方法：编码"><a href="#4-4-统计方法：编码" class="headerlink" title="4.4 统计方法：编码"></a>4.4 统计方法：编码</h3><p>&emsp;&emsp;霍夫曼编码(Huffman coding)是基于二叉树的前缀无关编码，通常使用霍夫曼树的规范树(canonical tree)形式，规范树规定任何结点的右子树不能高于他的左子树，因此给出有序的叶节点可以方便地还原规范树的结构。霍夫曼编码的缺点是只能从开头解码，因此不支持随机检索，例如考虑以下编码：A(0)、B(10)、C(110)、D(111)，若随机检索到编码片段 “11110”，就无法确定是“DB”还是开头少了一个1的“DC”，也就是两个码字的结合包含了第三个码字。更严谨的说法是不支持从任意位置解码，支持从任意码字的开头进行解码，虽然这么说没什么意义吧。</p><p>&emsp;&emsp;字节霍夫曼编码(Byte-Huffman coding)是基于词的模型，使用字节代替位进行编码，因此编码树不是二叉树，而是256叉树。好像用的不是很多。</p><p>&emsp;&emsp;密集编码(Dense coding)也是基于字节的编码，如下图，其中“<128>”指的是该字节的值是128。密集编码比字节霍夫曼编码更简单，在各个方面都优于字节霍夫曼编码，更重要的是密集编码支持从任意位置解码。因为密集编码可以很好地区分码头和码尾，整个字节的识别是很简单的，而观察到密集编码的结束字节值是在128到255之间的，这种属性称作自同步(self-synchronizing)，结束的字节称为停止符，之前的所有字节都称为持续符。更广义的密集编码记作 <script type="math/tex">(s,c)</script> 密集编码，不把128作为持续符和停止符的界限，只要保证 <script type="math/tex">s+c=256</script> ，可以修改为 <script type="math/tex">c</script> 个持续符和 <script type="math/tex">s</script> 个停止符，选择最优的组合。<br><a href="/2019/02/03/mir4/mir4-3.png" data-fancybox="group" data-caption="mir4-3" class="fancybox"><img alt="mir4-3" title="mir4-3" data-src="/2019/02/03/mir4/mir4-3.png" class="lazyload"></a></128></p><p>&emsp;&emsp;算术编码，只写了一段，细节太少，没看懂。</p><h3 id="4-5-字典方法"><a href="#4-5-字典方法" class="headerlink" title="4.5 字典方法"></a>4.5 字典方法</h3><p>&emsp;&emsp;字典方法就不区分建模和编码的环节了，核心就是查字典而已。唯一需要考虑的问题是如何选择字典条目，同样也分成静态、半静态和自适应的方法，缺点也和上面说的类似。静态方法泛化性差，自适应方法的代表是 Ziv-Lempel 算法，字典随着压缩过程动态创建，问题就是不支持随机访问，半静态的方法最好，代表是 Re-Pair 算法。 Re-Pair 算法的核心简单说就是消除所有的重复符号对，首先给每个符号赋予一个整数，如果有重复的整数对“AB”，就用新的整数“C”替换“AB”，替换规则也可以嵌套，比如“CD”又重复了，就用“E”替换“CD”。缺点其实就是半静态方法的缺点，慢。</p><h3 id="4-6-压缩预处理"><a href="#4-6-压缩预处理" class="headerlink" title="4.6 压缩预处理"></a>4.6 压缩预处理</h3><p>&emsp;&emsp;文本压缩的最新趋势是压缩前的预处理，比较著名的方法是 Burrows-Wheeler 变换，简称BWT。流程就看下面两张图，原始字符串是“mississippi$”，其中“$”是可以是别的特殊终结符。首先列出原始字符串循环移位的矩阵，矩阵的每一行是上一行左移一位后的字符串。然后根据矩阵第一列按字典序排序，排序后矩阵的最后一列就是变换后的字符串。BWT的优点有两个，一是可逆，根据变换后的字符串可以还原出原始字符串，二是能够保证原始字符串中重复出现的字符可以在变换后的字符串中连续出现或至少离得比较近，图中的例子不太明显，比如“SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES”经过变换后成了“TEXYDST.E.IXIXIXXSSMPPS.B..E.S.EUSFXDIIOIIIT”，就很明显了。<br><a href="/2019/02/03/mir4/mir4-4.png" data-fancybox="group" data-caption="mir4-4" class="fancybox"><img alt="mir4-4" title="mir4-4" data-src="/2019/02/03/mir4/mir4-4.png" class="lazyload"></a><br><a href="/2019/02/03/mir4/mir4-5.png" data-fancybox="group" data-caption="mir4-5" class="fancybox"><img alt="mir4-5" title="mir4-5" data-src="/2019/02/03/mir4/mir4-5.png" class="lazyload"></a></p><h3 id="4-7-压缩方法的比较"><a href="#4-7-压缩方法的比较" class="headerlink" title="4.7 压缩方法的比较"></a>4.7 压缩方法的比较</h3><p><a href="/2019/02/03/mir4/mir4-6.png" data-fancybox="group" data-caption="mir4-6" class="fancybox"><img alt="mir4-6" title="mir4-6" data-src="/2019/02/03/mir4/mir4-6.png" class="lazyload"></a></p><h3 id="4-8-结构化文本压缩"><a href="#4-8-结构化文本压缩" class="headerlink" title="4.8 结构化文本压缩"></a>4.8 结构化文本压缩</h3><p>&emsp;&emsp;结构化文本就是XML一类的文本，区分属性、元素这种层次。压缩方法其实就是根据文本的结构修改或者组合上面提到的这些方法，本质上没什么特别的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 4：检索评价</title>
    <link href="http://shivakasu.github.io/2019/02/01/mir3/"/>
    <id>http://shivakasu.github.io/2019/02/01/mir3/</id>
    <published>2019-02-01T10:09:20.000Z</published>
    <updated>2020-01-05T11:13:54.892Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>&emsp;&emsp;检索评价针对信息检索系统响应用户查询的返回结果，系统化地给出了一个量化的指标。这个指标应该和检索结果与用户的相关性直接联系。计算这个指标的通常方法是，对于给定的一组查询，比较由系统产生的结果和由人产生的结果。这里的检索评价仅针对检索系统的结果质量，不考虑界面设计、系统性能等因素的影响。</p><h2 id="2-检索指标"><a href="#2-检索指标" class="headerlink" title="2 检索指标"></a>2 检索指标</h2><h3 id="2-1-精度和召回率"><a href="#2-1-精度和召回率" class="headerlink" title="2.1 精度和召回率"></a>2.1 精度和召回率</h3><p>&emsp;&emsp;精度(Precison)是检出文档中相关文档的比例，召回率(Recall)是相关文档集中被检出的比率。将相关文档集记作 <script type="math/tex">R</script> ，系统得出的结果集为 <script type="math/tex">A</script> ，则：</p><script type="math/tex; mode=display">精度=p=\frac{|R\cap A|}{|A|}</script><script type="math/tex; mode=display">召回率=r=\frac{|R\cap A|}{|R|}</script><p>以横坐标为召回率，纵坐标为精度可绘制精度-召回率曲线，曲线下面积(Area Unser the Curve, AUC)可用于评估不同答案集的质量，面积越大表明质量越好。</p><p>&emsp;&emsp;缺点：</p><ul><li>召回率无法准确估计。</li><li>精度和召回率是相关联的指标，将二者结合为单一指标会更合适。</li><li>只能度量批处理状态下对一组查询进行处理的结果。</li><li>对于只需要弱偏序关系的系统来说，精度和召回率可能不适合。(?)</li></ul><h3 id="2-2-单值总结"><a href="#2-2-单值总结" class="headerlink" title="2.2 单值总结"></a>2.2 单值总结</h3><p>&emsp;&emsp;(1) 前 <script type="math/tex">n</script> 平均精度 <script type="math/tex">P@n</script> ：大部分搜索不需要高的召回率，绝大部分用户只需要顶部的几篇相关文档，通常计算前5篇或前10篇文档的平均精度(不管是相关还是不相关)， <script type="math/tex">P@n</script> 提供了可靠的指标来评价Web搜索引擎的用户是否在排序的顶部得到了相关文档。</p><p>&emsp;&emsp;(2) 平均精度均值(Mean Average Precision, MAP)：通过对每个新观察到的相关文档计算精度并做平均来得到关于排序的总结性的单一指标。查询 <script type="math/tex">q_i</script> 的平均精度定义为：</p><script type="math/tex; mode=display">MAP_i=\frac{1}{|R_i|}\sum_{k=1}^{|R_i|}P(R_i[k])</script><p>其中 <script type="math/tex">R_i</script> 是 <script type="math/tex">q_i</script> 对应的相关文档的集合， <script type="math/tex">P(R_i[k])</script> 是从头遍历结果集的排序队列直到观察到 <script type="math/tex">R_i</script> 中第 <script type="math/tex">k</script> 篇文档时的精度，如果没有观察到就记作0。此外，在一组查询上的平均精度均值定义为：</p><script type="math/tex; mode=display">MAP=\frac{1}{|N_q|}\sum_{i=1}^{|N_q|}MAP_i</script><p>其中 <script type="math/tex">N_q</script> 是查询的总数目。</p><p>&emsp;&emsp;(3) <script type="math/tex">R</script> 精度：设当前查询的相关文档集 <script type="math/tex">R</script> 的容量为 <script type="math/tex">n</script> ，取排序队列的前 <script type="math/tex">n</script> 篇文档计算精度，简单粗暴。但是对于一组查询，计算每个查询的 <script type="math/tex">R</script> 精度再取平均效果可能不好。</p><p>&emsp;&emsp;(4) 精度直方图：核心思想就是对于一组查询，可以分别比较每个查询在不同算法上的 <script type="math/tex">R</script> 精度，来比较两个算法的检索质量，废话。</p><p>&emsp;&emsp;(5) 平均排序倒数：适用于QA系统、特定主页查询等任务，更关注第一个正确的结果，而不是整个排序的结果集。设 <script type="math/tex">R_i</script> 是相对于查询 <script type="math/tex">q_i</script> 的排序， <script type="math/tex">S_{correct}(R_i)</script> 函数返回在 <script type="math/tex">R_i</script> 中第一个正确答案的位置，给定一个排序位置阈值 <script type="math/tex">S_h</script> ， <script type="math/tex">R_i</script> 的排序倒数定义为：</p><script type="math/tex; mode=display">\begin{cases}\frac{1}{S_{correct}(R_i)} & S_{correct}(R_i)\leq S_h \\0 & otherwise\end{cases}</script><p>对于由 <script type="math/tex">N_q</script> 个查询组成的集合 <script type="math/tex">Q</script> 来说，平均排序倒数(Mean Reciproach Rank, MRR)是所有排序倒数的均值，即：</p><script type="math/tex; mode=display">MRR(Q)=\frac{1}{N_q}\cdot\sum_{i=1}^{N_q}\frac{1}{S_{correct}(R_i)}</script><script type="math/tex; mode=display">MRR$$ 是倾向于那些第一个正确的结果出现在排序顶部的指标。&emsp;&emsp;(6) E值：结合精度和召回率，公式为：$$E(j)=1-\frac{1+b^2}{\frac{b^2}{r(j)}+\frac{1}{P(j)}}</script><p>其中 <script type="math/tex">r(j)</script> 是在排序中第 <script type="math/tex">j</script> 个位置的召回率， <script type="math/tex">P(j)</script> 是在排序中第 <script type="math/tex">j</script> 个位置的精度， <script type="math/tex">b(b\geq 0)</script> 是用户定义的参数。</p><p>&emsp;&emsp;(7) F值：同样是结合精度和召回率，公式为：</p><script type="math/tex; mode=display">F(j)=\frac{2}{\frac{1}{r(j)}+\frac{1}{P(j)}}</script><p>注意到，当E值的 <script type="math/tex">b=1</script> 时， <script type="math/tex">F(j)=1-E(j)</script> 。</p><p>&emsp;&emsp;(8) 摘要统计表：就是把查询数、文档数等统计特征列个表，没什么用。</p><h3 id="2-3-面向用户的指标"><a href="#2-3-面向用户的指标" class="headerlink" title="2.3 面向用户的指标"></a>2.3 面向用户的指标</h3><p>&emsp;&emsp;在相关文档集 <script type="math/tex">R</script> 和结果集 <script type="math/tex">A</script> 之外，考虑用户的认知范围，即用户已知的文档 <script type="math/tex">K</script> ，如下图：<br><a href="/2019/02/01/mir3/mir3-0.png" data-fancybox="group" data-caption="mir3-0" class="fancybox"><img alt="mir3-0" title="mir3-0" data-src="/2019/02/01/mir3/mir3-0.png" class="lazyload"></a></p><p>定义覆盖率为：</p><script type="math/tex; mode=display">coverage=\frac{|K\cap R\cap A|}{|K\cap R|}</script><p>定义新颖率为：</p><script type="math/tex; mode=display">novelty=\frac{|(R\cap A)-K|}{|K\cap R|}</script><p>高覆盖率表明系统找到了用户期望看到的大部分相关文档，高新颖率表明系统向用户展示了许多之前未知的新的相关文档。</p><h3 id="2-4-折扣累计增益"><a href="#2-4-折扣累计增益" class="headerlink" title="2.4 折扣累计增益"></a>2.4 折扣累计增益</h3><p>&emsp;&emsp;上述基于相关文档集和结果集计算的指标只考虑文档与查询的相关与否，而没有考虑到相关性的强弱。当检查查询的结果时，可以观察到两个重要的现象：</p><ul><li>在排序的顶部我们更希望是高度相关的文档，而不是轻度相关的文档。</li><li>出现在排序底部的相关文档的价值不高。</li></ul><p>&emsp;&emsp;针对第一个现象，赋予每个相关文档相关性强度，0表示不相关，值越大表示相关性越强，对系统返回的排序列表，增益向量(gain vector) <script type="math/tex">G</script> 定义为其中每个元素的相关性强度组成的向量，如：</p><script type="math/tex; mode=display">G=(1,0,1,0,0,3,0,0,0,2,0,0,0,0,3)</script><p>累计增益(Cumulated Gain) $CG$ 定义为：</p><script type="math/tex; mode=display">CG[i]=\begin{cases}G[1] & i=1 \\G[i]+CG[i-1] & i>1\end{cases}</script><p>则对于上面的增益向量：</p><script type="math/tex; mode=display">CG=(1,1,2,2,2,5,5,5,5,7,7,7,7,7,10)</script><p>&emsp;&emsp;针对第二个问题，按照文档在排序列表中的位置进行价值衰减，定义折扣累计增益(Discounted Cumulated Gain) $DCG$ 为：</p><script type="math/tex; mode=display">DCG[i]=\begin{cases}G[1] & i=1 \\\frac{G[i]}{log_2i}+DCG[i-1] & i>1\end{cases}</script><p>则对于上面的增益向量：</p><script type="math/tex; mode=display">DCG=(1.0,1.0,1.6,1.6,1.6,2.8,2.8,2.8,2.8,3.4,3.4,3.4,3.4,3.4,4.2)</script><p>同理，对于由多个查询组成的集合，可计算平均累计增益 <script type="math/tex">\overline{CG}</script> 和平均折扣累计增益 <script type="math/tex">\overline{DCG}</script> 。</p><p>&emsp;&emsp;由于累计增益没有参照，定义理想 <script type="math/tex">CG</script> 和 <script type="math/tex">DCG</script> 为最优排序列表得到的结果，即文档相关性强度从大到小排列，记作 <script type="math/tex">ICG</script> 和 <script type="math/tex">IDCG</script> 。将原始的 <script type="math/tex">CG</script> 和 <script type="math/tex">DCG</script> 进行归一化：</p><script type="math/tex; mode=display">NCG[i]=\frac{\overline{CG[i]}}{\overline{ICG[i]}}</script><script type="math/tex; mode=display">NDCG[i]=\frac{\overline{DCG[i]}}{\overline{IDCG[i]}}</script><p>得到了在区间 <script type="math/tex">[0,1]</script> 上的累计增益指标，可用于不同排序算法之间的比较。</p><h3 id="2-5-二元偏好"><a href="#2-5-二元偏好" class="headerlink" title="2.5 二元偏好"></a>2.5 二元偏好</h3><p>&emsp;&emsp;Todo</p><h3 id="2-6-排序相关性测度"><a href="#2-6-排序相关性测度" class="headerlink" title="2.6 排序相关性测度"></a>2.6 排序相关性测度</h3><p>&emsp;&emsp;当没有参照或没有评测人员时，很难计算出上述指标，则可以直接度量两个排序函数产生的结果的相关性，若对其中一个排序函数有一定的了解，就可以根据二者的相关性分析另一个排序函数的优劣。</p><p>&emsp;&emsp;斯皮尔曼系数(Spearman coefficient)根据相同文档在不同排序中的位置差值计算相关性。设 <script type="math/tex">s_{1,j}</script> 是文档 <script type="math/tex">d_j</script> 在排序 <script type="math/tex">R_1</script> 中的位置， <script type="math/tex">s_{2,j}</script> 是文档 <script type="math/tex">d_j</script> 在排序 <script type="math/tex">R_2</script> 中的位置，则位置差值是 <script type="math/tex">|s_{1,j}-s_{2,j}|</script> ，或计算差值平方和 <script type="math/tex">(s_{1,j}-s_{2,j})^2</script> 。如果有K篇排序文档，对排序差值求平方和，则差值平方和的最大值是 <script type="math/tex">\frac{K\times(K^2-1)}{3}</script> ，即两个排序互为反序。使用该最大值进行差值平方和的归一化，即：</p><script type="math/tex; mode=display">\frac{\sum_{j=1}^K(s_{1,j}-s_{2,j})^2}{\frac{K\times(K^2-1)}{3}}</script><p>将该分式乘2，再用1减去结果，就得到了在区间 <script type="math/tex">[-1,1]</script> 上的斯皮尔曼系数：</p><script type="math/tex; mode=display">S(R_1,R_2)=1-\frac{6\times\sum_{j=1}^K(s_{1,j}-s_{2,j})^2}{K\times(K^2-1)}</script><p>值越大表明相关性越强。然而，通常两个排序文档集的大小和内容是不同的，这时的做法是取并集，将 <script type="math/tex">R_2</script> 中不属于 <script type="math/tex">R_1</script> 的文档添加在 <script type="math/tex">R_1</script> 尾部，同时将 <script type="math/tex">R_1</script> 中不属于 <script type="math/tex">R_2</script> 的文档添加在 <script type="math/tex">R_2</script> 尾部，之后再对这两个增广排序计算斯皮尔曼系数。</p><p>&emsp;&emsp;肯德尔系数(Kendall Tau coefficient)比斯皮尔曼系数代数结构简单，有更清楚和直观的解释。给定两篇文档 <script type="math/tex">d_j</script> 和 <script type="math/tex">d_k</script> ，若在两个排序列表 <script type="math/tex">R_1</script> 和 <script type="math/tex">R_2</script> 中， <script type="math/tex">s_{1,j}-s_{1,k}</script> 和 <script type="math/tex">s_{2,j}-s_{2,k}</script> 同号，那么就说文档二元组 <script type="math/tex">[d_j,d_k]</script> 在这两个排序中是协调的，反之则是不协调的。如果有K篇排序文档，则共有 <script type="math/tex">K(K-1)</script> 个文档二元组，肯德尔系数定义为：</p><script type="math/tex; mode=display">\tau(R_1,R_2)=1-\frac{2\times\Delta(R_1,R_2)}{K(K-1)}</script><p>和斯皮尔曼系数的形式是几近相同的，当两个排序文档集不同时，也可以用相同的方式增广排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 3：信息检索建模</title>
    <link href="http://shivakasu.github.io/2019/01/24/mir2/"/>
    <id>http://shivakasu.github.io/2019/01/24/mir2/</id>
    <published>2019-01-24T05:40:20.000Z</published>
    <updated>2020-01-05T05:41:18.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-信息检索模型"><a href="#1-信息检索模型" class="headerlink" title="1 信息检索模型"></a>1 信息检索模型</h2><p>&emsp;&emsp;信息检索模型是一个四元组 <script type="math/tex">[D,Q,F,R(q_i,d_i)]</script> 。其中D(Document)是文档表示的集合，Q(Query)是查询表示的集合，F(Framework)是对文档、查询及其关系建模的框架，例如布尔框架、线性框架，R(Ranking)是排序函数，对于查询表达式 <script type="math/tex">q_i\in Q</script> 和文档表达式 <script type="math/tex">d_i\in D</script> ，函数返回文档 <script type="math/tex">d_i</script> 关于查询<script type="math/tex">q_i</script>的文档次序。</p><p>&emsp;&emsp;信息检索主要基于文本，文本模型也细分为是否考虑文本结构，所谓考虑文本结构就是区别对待标题、段落等文档不同结构处的内容。在web中，由于文档数量巨大，还需要考虑网页之间的链接，如今的web排序函数结合了经典的信息检索模型和基于链接模型的特征来提高检索性能。信息检索还可基于图像、音频等多媒体数据，检索策略更复杂。信息检索模型的分类体系见下图：<br><a href="/2019/01/24/mir2/mir2-0.png" data-fancybox="group" data-caption="mir2-0" class="fancybox"><img alt="mir2-0" title="mir2-0" data-src="/2019/01/24/mir2/mir2-0.png" class="lazyload"></a></p><h2 id="2-经典信息检索"><a href="#2-经典信息检索" class="headerlink" title="2 经典信息检索"></a>2 经典信息检索</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><ul><li>索引项(index term)：文档里的一个词或一组连续的词，主要是名词，因为名词相比于形容词、副词等往往能包含更多信息，具体的选择策略因人而异。</li><li>词汇表(vocabulary)： <script type="math/tex">V=(k_1,k_2,\cdots ,k_t)</script> ，其中 <script type="math/tex">t</script> 是文档集中索引项的数量， <script type="math/tex">k_i</script> 是某个索引项。</li><li>文档表示：就是简单的词袋方法，表示成和词汇表一样长的向量，其中每个元素是0或1，0表示对应的索引项在文档中未出现，1表示对应的索引项在文档中出现。</li><li>查询表示：和文档表示相同，每个元素表示相应索引项是否在查询中出现。</li><li>项-文档矩阵：行数是索引项个数，列数是文档个数，元素 <script type="math/tex">f_{i,j}</script> 表示第 <script type="math/tex">i</script> 个索引项在第 <script type="math/tex">j</script> 个文档中出现的频数。显然，在词袋方法中是0-1矩阵。</li><li>文档的逻辑视图：大概就是表示文档的方式。通常是把文档全文转变成索引项集合，流程如下图：<br><a href="/2019/01/24/mir2/mir2-1.png" data-fancybox="group" data-caption="mir2-1" class="fancybox"><img alt="mir2-1" title="mir2-1" data-src="/2019/01/24/mir2/mir2-1.png" class="lazyload"></a></li></ul><h3 id="2-2-布尔模型"><a href="#2-2-布尔模型" class="headerlink" title="2.2 布尔模型"></a>2.2 布尔模型</h3><p>&emsp;&emsp;使用词袋方法表示文档，用析取范式(disjunct normal form)表示查询。例如对于词汇表 <script type="math/tex">V=(k_a,k_b,k_c,k_d)</script> 和查询 <script type="math/tex">q=k_a\wedge (k_b\vee k_c)</script> ，用析取范式表示查询为：</p><script type="math/tex; mode=display">q_{DNF}=(1,1,1,0)\vee(1,1,1,1)\vee(1,1,0,0)\vee(1,1,0,1)\vee(1,0,0,0)\vee(1,0,0,1)</script><p>文档与查询的相关度定义为析取范式中是否有一项与文档表示相同，因此也是二值的。</p><p>&emsp;&emsp;布尔模型的优点是简单，缺点是不支持排序。因为相关度是二值的，只能表示相关与否，而不能表示相关的程度。</p><h3 id="2-3-项权重"><a href="#2-3-项权重" class="headerlink" title="2.3 项权重"></a>2.3 项权重</h3><p>&emsp;&emsp;提高检索质量的一个方法是给每个索引项设置权重，通常根据索引项在整个文档集中出现的频次设置权重。如果不假设索引项之间相互独立，还要考虑索引项之间的相关性，因为索引项之间的关联往往会反映文档之间的关联，一种计算项间相关性的方法是项-文档矩阵乘他的转置矩阵，如下图：<br><a href="/2019/01/24/mir2/mir2-2.png" data-fancybox="group" data-caption="mir2-2" class="fancybox"><img alt="mir2-2" title="mir2-2" data-src="/2019/01/24/mir2/mir2-2.png" class="lazyload"></a><br>假设项间相互独立可以简化模型、提高计算效率，而利用项间相关性提高排序水平也是十分复杂的工作，考虑了项间相关性并不能保证排序水平的提高，因此是否假设项间相互独立没有固定的标准。</p><h3 id="2-4-TD-IDF"><a href="#2-4-TD-IDF" class="headerlink" title="2.4 TD-IDF"></a>2.4 TD-IDF</h3><p>&emsp;&emsp;TF-IDF是一个常用的计算项权重的指标，其中TF(Term frequency)表示项频，IDF(Inverse document frequency)表示反比文档频率。</p><p>&emsp;&emsp;使用项频是基于Luhn假设，即高频项对描述文档的关键主题是重要的。可以直接将索引项的频次作为TF权重，即 <script type="math/tex">tf_{i,j}=f_{i,j}</script> ，但考虑到要与IDF权重结合，而IDF使用了对数运算，因此通常使用TF权重的一个变种：</p><script type="math/tex; mode=display">tf_{i,j}=\begin{cases}1+log_2f_{i,j} & f_{i,j}>0 \\0 & otherwise\end{cases}</script><p>&emsp;&emsp;TF权重倾向于给频次高的索引项更大的权重，但也要考虑索引项的区分度，即索引项特异性(term specificity)。如果一个索引项在每个文档中都出现，虽然出现频次高，但是对于文档排序等任务没有太大帮助，最常见的就是a、the这样的冠词、连词和介词。因此不仅要考虑高频项，还要考虑区分度大的索引项。IDF权重考虑的就是某个索引项在多少个文档中出现，即相对文档频率 <script type="math/tex">n_i/N</script> ， <script type="math/tex">IDF_i=log_2\frac{N}{n_i}</script> ，其中 <script type="math/tex">N</script> 是文档集中的文档数量， <script type="math/tex">n_i</script> 是出现索引项 <script type="math/tex">k_i</script> 的文档数量，因为相对文档频率越小的索引项区分度越大，所以IDF使用了相对文档频率的倒数，称作反比文档频率。</p><p>&emsp;&emsp;TF-IDF将二者结合起来，计算方法如下：</p><script type="math/tex; mode=display">w_{i,j}=\begin{cases}(1+log_2f_{i,j})*log_2\frac{N}{n_i} & f_{i,j}>0 \\0 & otherwise\end{cases}</script><p>&emsp;&emsp;TF、IDF和TF-IDF有多种变体。TF变体如下：<br><a href="/2019/01/24/mir2/mir2-3.png" data-fancybox="group" data-caption="mir2-3" class="fancybox"><img alt="mir2-3" title="mir2-3" data-src="/2019/01/24/mir2/mir2-3.png" class="lazyload"></a></p><p>IDF变体如下：<br><a href="/2019/01/24/mir2/mir2-4.png" data-fancybox="group" data-caption="mir2-4" class="fancybox"><img alt="mir2-4" title="mir2-4" data-src="/2019/01/24/mir2/mir2-4.png" class="lazyload"></a></p><p>TF-IDF变体如下：<br><a href="/2019/01/24/mir2/mir2-5.png" data-fancybox="group" data-caption="mir2-5" class="fancybox"><img alt="mir2-5" title="mir2-5" data-src="/2019/01/24/mir2/mir2-5.png" class="lazyload"></a></p><p>&emsp;&emsp;通过下图可以分析出TF-IDF的性质。TF和IDF权重表现出的幂律特性会相互平衡，高TF权重趋于和低IDF权重结合，低TF权重趋于和高IDF权重结合，结果是TF-IDF权重最高的索引项往往具有中等TF和IDF权重，而项频太高的项和文档频率太低的项经过平衡后都具有较低的TF-IDF权重。妙啊！<br><a href="/2019/01/24/mir2/mir2-6.png" data-fancybox="group" data-caption="mir2-6" class="fancybox"><img alt="mir2-6" title="mir2-6" data-src="/2019/01/24/mir2/mir2-6.png" class="lazyload"></a></p><h3 id="2-5-文档长度归一化"><a href="#2-5-文档长度归一化" class="headerlink" title="2.5 文档长度归一化"></a>2.5 文档长度归一化</h3><p>&emsp;&emsp;对于给定的查询，较长的文档仅仅因为包含更多的索引项而更可能被检出，为了消除这一影响，可以把文档的排序除以其长度，这个过程称为文档长度归一化，如何计算文档长度取决于文档的表示形式。</p><h3 id="2-6-向量模型"><a href="#2-6-向量模型" class="headerlink" title="2.6 向量模型"></a>2.6 向量模型</h3><p>&emsp;&emsp;布尔模型使用析取范式的每一项和文档表示进行严格匹配，难以得到理想的结果。向量模型将文档和查询表示为向量形式，使用向量夹角的余弦值衡量相似度，成功将相似度量化为可用于比较和排序的数值，基于相似度的排序可以理解为一种部分匹配策略。文档的向量表示为 <script type="math/tex">\vec{d_j}=(w_{1,j},w_{2,j},\cdots,w_{t,j})</script> ，其中 <script type="math/tex">t</script> 是索引项总个数， <script type="math/tex">w_{i,j}</script>是项-文档对 <script type="math/tex">(k_i,d_j)</script> 的权重，一般采用TF-IDF权重，查询的向量表示为 <script type="math/tex">\vec{q}=(w_{1,q},w_{2,q},\cdots,w_{t,q})</script> , <script type="math/tex">w_{i,q}</script>是项-查询对 <script type="math/tex">(k_i,q)</script> 的权重。文档-查询余弦相似度公式为：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{\vec{d_j}\cdot\vec{q}}{|\vec{d_j}|\times|\vec{q}|}</script><p>注意到余弦公式分母的向量范数恰好也起到了文档长度归一化的作用。</p><h3 id="2-7-概率模型"><a href="#2-7-概率模型" class="headerlink" title="2.7 概率模型"></a>2.7 概率模型</h3><p>&emsp;&emsp;概率模型的目标是估计文档与查询相关的概率，他假定这种相关性仅依赖于文档和查询本身的表示，并假定存在一个理想答案集，仅包含所有与查询相关的文档，因此能够最大化与用户相关的总体概率。显然，这种假设是对真实情况的简化，所以必然会存在一些缺陷。</p><p>&emsp;&emsp;概率模型计算相关度的公式是：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{P(R|\vec{d_j})}{P(\overline{R}|\vec{d_j})}</script><p>其中 <script type="math/tex">R</script> 是与查询 <script type="math/tex">q</script> 相关的文档的集合， <script type="math/tex">\overline{R}</script> 是与查询 <script type="math/tex">q</script> 不相关的文档的集合， <script type="math/tex">P(R|\vec{d_j})</script>是文档 <script type="math/tex">d_j</script> 与查询 <script type="math/tex">q</script> 相关的概率， <script type="math/tex">P(\overline{R}|\vec{d_j})</script>是文档 <script type="math/tex">d_j</script> 与查询 <script type="math/tex">q</script> 不相关的概率。根据贝叶斯公式：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{P(\vec{d_j}|R,q)\times P(R,q)}{P(\vec{d_j}|\overline{R},q)\times P(\overline{R},q)}\sim\frac{P(\vec{d_j}|R,q)}{P(\vec{d_j}|\overline{R},q)}</script><p>其中 <script type="math/tex">P(\vec{d_j}|R,q)</script> 表示从查询 <script type="math/tex">q</script> 的相关文档集 <script type="math/tex">R</script> 中随机选择的一偏文档表示为 <script type="math/tex">\vec{d_j}</script> 的概率， <script type="math/tex">P(R,q)</script> 表示从整个文档集中随机选择的文档和查询 <script type="math/tex">q</script> 相关的概率， <script type="math/tex">P(\vec{d_j}|\overline{R},q)</script> 和 <script type="math/tex">P(\overline{R},q)</script> 的含义是相似且互补的。概率模型中不考虑项权重，所以 <script type="math/tex">\vec{d_j}</script> 是一个二值向量，如果假设索引项间的独立性，即所谓的二值独立假设，可以得到：</p><script type="math/tex; mode=display">sim(d_j,q)\sim\frac{(\prod_{k_i|w_{i,j}=1}p_{iR})\times(\prod_{k_i|w_{i,j}=0}(1-p_{iR}))}{(\prod_{k_i|w_{i,j}=1}q_{iR})\times(\prod_{k_i|w_{i,j}=0}(1-q_{iR}))}</script><p>其中 <script type="math/tex">p_{iR}</script> 表示索引项 <script type="math/tex">k_i</script> 出现在从查询 <script type="math/tex">q</script> 的相关文档集 <script type="math/tex">R</script> 中随机选择的一偏文档内的概率， <script type="math/tex">q_{iR}</script> 表示索引项 <script type="math/tex">k_i</script> 出现在从查询 <script type="math/tex">q</script> 的不相关文档集 <script type="math/tex">\overline{R}</script> 中随机选择的一偏文档内的概率。使用对数函数只改变数值而不改变排序结果，所以可以进一步简化为：</p><script type="math/tex; mode=display">sim(d_j,q)\sim\sum_{k_i\in q\wedge k_i\in d_j}log(\frac{p_{iR}}{1-p_{iR}})+log(\frac{1-q_{iR}}{q_{iR}})</script><p>得到了相似度公式，接下来就是如何计算 <script type="math/tex">p_{iR}</script> 和 <script type="math/tex">q_{iR}</script> 。</p><p>&emsp;&emsp;一种计算方法是使用索引项出现列联表，如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">相关文档数</th><th style="text-align:center">不相关文档数</th><th style="text-align:center">总文档数</th></tr></thead><tbody><tr><td style="text-align:center">包含 $k_i$ 的文档</td><td style="text-align:center">$r_i$</td><td style="text-align:center">$n_i-r_i$</td><td style="text-align:center">$n_i$</td></tr><tr><td style="text-align:center">不包含 $k_i$ 的文档</td><td style="text-align:center">$R-r_i$</td><td style="text-align:center">$N-n_i-(R-r_i)$</td><td style="text-align:center">$N-n_i$</td></tr><tr><td style="text-align:center">所有文档</td><td style="text-align:center">$R$</td><td style="text-align:center">$N-R$</td><td style="text-align:center">$N$</td></tr></tbody></table></div><p>那么可以得到，</p><script type="math/tex; mode=display">p_{iR}=\frac{r_i}{R}\quad, \quad q_{iR}=\frac{n_i-r_i}{N-R}</script><script type="math/tex; mode=display">sim(d_j,q)\sim\sum_{k_i\in q\wedge k_i\in d_j}log(\frac{(r_i+0.5)(N-n_i-R+r_i+0.5)}{(R-r_i+0.5)(n_i-r_i+0.5)})</script><p>之所以给每个包含 <script type="math/tex">r_i</script> 的项加0.5，是为了减小极端情况下过小的 <script type="math/tex">r_i</script> 对 <script type="math/tex">log</script> 计算的影响。这种方法需要人工估计 <script type="math/tex">r_i</script> 和 <script type="math/tex">R</script> 值，所以不实用，同时缺少文档长度归一化的操作，使得排序效果也不是很好。</p><p>&emsp;&emsp;另一种方法是在避免人工估计的条件下，基于几条假设来自动更新 <script type="math/tex">r_i</script> 和 <script type="math/tex">R</script> 值，个人认为这里的假设太牵强，理解不了。</p><p>&emsp;&emsp;概率模型的优点是能按照相关概率进行排序，但其认为相关性仅与文档和查询的内容有关，所以实际应用时效果难以保证。此外，概率模型不可避免地要做初始估计将文档分为相关和不相关集合，不太好操作。观察上面计算 <script type="math/tex">sim(d_j,q)</script> 的公式，与IDF权重的公式是相似的，从这个角度看，概率模型的另一个缺点是没有用到TF特征，也没有进行文档长度归一化。</p><h2 id="3-其他集合论模型"><a href="#3-其他集合论模型" class="headerlink" title="3 其他集合论模型"></a>3 其他集合论模型</h2><h3 id="3-1-基于集合的模型"><a href="#3-1-基于集合的模型" class="headerlink" title="3.1 基于集合的模型"></a>3.1 基于集合的模型</h3><p>&emsp;&emsp;基于集合的模型不考虑单独的索引项，而是考虑索引项之间的相互依赖性，通过引入项集的概念表示索引项之间的关联。</p><p>&emsp;&emsp;项集(Termset)：项集 <script type="math/tex">S_i=\{k_a,k_b,\cdots,k_n\}</script> 是文档集中索引项的子集。若 <script type="math/tex">S_i</script> 中所有的索引项都出现在文档 <script type="math/tex">d_j</script> 中，就称项集 <script type="math/tex">S_i</script> 出现在 <script type="math/tex">d_j</script> 中。</p><p>&emsp;&emsp;显然，若文档集中有 <script type="math/tex">t</script> 个索引项，则理论上有 <script type="math/tex">2^t</script> 个项集，但实际数据集中一般仅包含部分项集。同时，用项集表示替代索引项表示就需要把项的词汇表改为项集的词汇表，即 <script type="math/tex">V_S=\{S_1,S_2,\cdots,S_{2^t}\}</script> 。</p><p>&emsp;&emsp;频繁项集(Frequent termsets)：由 <script type="math/tex">n</script> 个项构成的项集称为 <script type="math/tex">n</script> 项集，如果包含某个 <script type="math/tex">n</script> 项集的文档数 <script type="math/tex">\mathcal{N}_i</script> 高于某个给定的阈值，那么这个 <script type="math/tex">n</script> 项集 <script type="math/tex">S_i</script> 称为是频繁的。显然，一个 <script type="math/tex">n</script> 项集是频繁的当且仅当他的所有 <script type="math/tex">(n-1)</script> 项集都是频繁地。</p><p>&emsp;&emsp;在TF-IDF中，计算的权重是项-文档矩阵的元素，在集合模型中与之类似，计算的权重是项集-文档矩阵的元素。对于 <script type="math/tex">(S_i,d_j)</script> ，令 <script type="math/tex">N</script> 是文档集中文档总数，<script type="math/tex">\mathcal{F}_{i,j}</script> 是项集 <script type="math/tex">S_i</script> 在文档 <script type="math/tex">d_j</script> 中的原始出现频率，赋予项集权重：</p><script type="math/tex; mode=display">\mathcal{W}_{i,j}=\begin{cases}(1+log_2\mathcal{F}_{i,j})*log_2(1+\frac{N}{\mathcal{N}_i}) & \mathcal{F}_{i,j}>0 \\0 & otherwise\end{cases}</script><p>同理， <script type="math/tex">\vec{d_j}=(\mathcal{W}_{1,j},\mathcal{W}_{2,j},\cdots,\mathcal{W}_{2^t,j})</script> ， <script type="math/tex">\vec{q}=(\mathcal{W}_{1,q},\mathcal{W}_{2,q},\cdots,\mathcal{W}_{2^t,q})</script>，相似度计算公式为：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{\vec{d_j}\cdot\vec{q}}{|\vec{d_j}|\times|\vec{q}|}=\frac{\sum_{S_i}\mathcal{W}_{i,j}\times\mathcal{W}_{i,q}}{|\vec{d_j}|\times|\vec{q}|}</script><p>由于项集空间是项空间的指数级大小，所以相似度的计算十分复杂，需要进行计算简化。例如在计算向量范数时只考虑 <script type="math/tex">1</script> 项集。或是进一步缩小项集的范围，只考虑频繁闭项集，闭项集(Closed termset)就是项集的闭包，比如项集 <script type="math/tex">\{k_1\}</script> 、 <script type="math/tex">\{k_2\}</script> 、 <script type="math/tex">\{k_1,k_2\}</script>出现在相同的文档子集中，那么可以只计算 <script type="math/tex">\{k_1,k_2\}</script>，大大减小了计算量，除了频繁闭项集，还可选择最大频繁集，即添加任何索引项都不能使其保持频繁性。从项集数目上看，频繁项集&gt;频繁闭项集&gt;最大频繁集，需要注意的是，减少计算必然伴随着信息的损失，因此需要根据实际情况进行权衡。</p><h3 id="3-2-扩展布尔模型"><a href="#3-2-扩展布尔模型" class="headerlink" title="3.2 扩展布尔模型"></a>3.2 扩展布尔模型</h3><p>&emsp;&emsp;用向量模型的特征扩展布尔模型，狗尾续貂？</p><h3 id="3-3-模糊集模型"><a href="#3-3-模糊集模型" class="headerlink" title="3.3 模糊集模型"></a>3.3 模糊集模型</h3><p>&emsp;&emsp;模糊集模型基于模糊集理论，对于每一个索引项 <script type="math/tex">k_i</script> ，为其分配一个模糊集(fuzzy set) <script type="math/tex">D_i</script> ，模糊集为每一个文档 <script type="math/tex">d_j</script> 分配一个介于区间 <script type="math/tex">[0,1]</script> 之间的隶属度(degree of membership)  <script type="math/tex">\mu_{i,j}</script> ，若 <script type="math/tex">\mu_{i,j}\sim 1</script> 表明 <script type="math/tex">k_i</script> 是 <script type="math/tex">d_j</script> 的良好模糊索引项，若 <script type="math/tex">\mu_{i,j}\sim 0</script> 表明 <script type="math/tex">k_i</script> 不是 <script type="math/tex">d_j</script> 的良好模糊索引项。隶属度可以通过项间相关性矩阵 <script type="math/tex">C</script> 来计算，索引项 <script type="math/tex">k_i</script> 和 <script type="math/tex">k_l</script> 的相关性计算公式为：</p><script type="math/tex; mode=display">c_{i,l}=\frac{n_{i,l}}{n_i+n_l-n_{i,l}}</script><p>其中 <script type="math/tex">n_i</script> 是含有索引项 <script type="math/tex">k_i</script> 的文档数， <script type="math/tex">n_l</script> 是含有索引项 <script type="math/tex">k_l</script> 的文档数， <script type="math/tex">n_{i,l}</script> 是同时含有这两个索引项的文档数，这种相关性度量被广泛应用在聚类算法中。有了相关性度量，就可以计算隶属度：</p><script type="math/tex; mode=display">\mu_{i,j}=1-\prod_{k_l\in d_j}(1-c_{i,l})</script><p>这其实就是在考虑 <script type="math/tex">k_i</script> 和 <script type="math/tex">d_j</script> 中每一个索引项的相关性，可以看出，只要 <script type="math/tex">d_j</script> 中至少有一个索引项 <script type="math/tex">k_l</script> 与 <script type="math/tex">k_i</script> 关系密切(即 <script type="math/tex">c_{i,l}\sim 1</script> )，则 <script type="math/tex">\mu_{i,j}\sim 1</script> 。此外，采用代数和的方式计算而不是对所有相关性使用 <script type="math/tex">max</script> 函数，可以使 <script type="math/tex">\mu_{i,j}</script> 的值变得平滑。</p><p>&emsp;&emsp;有了文档相对索引项的隶属度，就可以进一步计算文档相对于查询的隶属度，因为借鉴布尔模型的方法，查询可以表示成索引项组成的逻辑表达式。例如对于查询 <script type="math/tex">q=k_a\wedge (k_b\vee\neg k_c)</script> ，可以写成析取范式 <script type="math/tex">\vec{q}_{dnf}=(1,1,1)\vee(1,1,0)\vee(1,0,0)</script> ，设 <script type="math/tex">D_a</script> 、 <script type="math/tex">D_b</script> 、 <script type="math/tex">D_c</script> 分别是 <script type="math/tex">k_a</script> 、 <script type="math/tex">k_b</script> 、 <script type="math/tex">k_c</script> 的模糊集，查询的模糊集 <script type="math/tex">D_q</script> 可以从下图理解：<br><a href="/2019/01/24/mir2/mir2-7.png" data-fancybox="group" data-caption="mir2-7" class="fancybox"><img alt="mir2-7" title="mir2-7" data-src="/2019/01/24/mir2/mir2-7.png" class="lazyload"></a><br>其中， <script type="math/tex">cc_1=\mu_{a,j}\mu_{b,j}\mu_{c,j}</script> 、 <script type="math/tex">cc_2=\mu_{a,j}\mu_{b,j}(1-\mu_{c,j})</script> 、 <script type="math/tex">cc_3=\mu_{a,j}(1-\mu_{b,j})(1-\mu_{c,j})</script> ，则：</p><script type="math/tex; mode=display">\mu_{q,j}=1-\prod_{i=1}^3(1-cc_i)</script><p>同样，采用代数和的方式计算而不是对所有相关性使用 <script type="math/tex">max</script> 函数，可以使<script type="math/tex">\mu_{q,j}</script> 的值变得平滑。</p><h2 id="4-其他代数模型"><a href="#4-其他代数模型" class="headerlink" title="4 其他代数模型"></a>4 其他代数模型</h2><h3 id="4-1-广义向量空间模型"><a href="#4-1-广义向量空间模型" class="headerlink" title="4.1 广义向量空间模型"></a>4.1 广义向量空间模型</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 2：用户搜索界面</title>
    <link href="http://shivakasu.github.io/2019/01/19/mir1/"/>
    <id>http://shivakasu.github.io/2019/01/19/mir1/</id>
    <published>2019-01-19T09:26:20.000Z</published>
    <updated>2020-01-05T05:00:41.633Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="人们如何搜索"><a href="#人们如何搜索" class="headerlink" title="人们如何搜索"></a>人们如何搜索</h3><ul><li><p>信息查找(information lookup)类似于事实检索或问题回答，只需要简短而离散的信息。</p></li><li><p>探索式搜索(exploratory search)分为学习和调查两类，需要花费更长的时间并整合更多内容。</p></li><li><p>信息搜寻过程是由一系列相互关联但又不完全相同的搜索所组成的，搜索带来的主要价值体现在搜索过程中持续的学习和所获得的信息，而不只是最后的搜索结果。</p></li><li><p>信息搜寻过程的经典模型：明确问题-&gt;表达信息需求-&gt;构造查询-&gt;评价结果。经典模型假设用户的信息需求是静态的，最近的模型强调搜索过程的动态性，认为用户会根据搜索结果动态调整信息需求，这种动态过程有时称为搜索的采摘模型(berry picking model)。例如，用户给出一个快速、不精确的查询，近似得到信息空间的一部分内容，再进行一系列本地导航操作，从而获得更贴近用户兴趣的信息。有些搜索模型关注搜索策略，对搜索策略建模，预测用户的搜索行为。</p></li><li><p>除了传统的搜索框查询，还可以使用导航界面，让用户通过浏览导航和点击链接搜寻信息。</p></li></ul><h3 id="现今的搜索界面"><a href="#现今的搜索界面" class="headerlink" title="现今的搜索界面"></a>现今的搜索界面</h3><ul><li><p>启动搜寻：通常使用Web搜索引擎。导航网站逐渐被淘汰，一是因为网络规模变大，无法手动构造目录，二是因为Web搜索的精度提高。</p></li><li><p>查询描述：解析查询项，Web排序</p></li><li><p>查询描述界面：搜索框placeholder提示，自动补全建议列表。根据用户搜索历史或其他用户的热门搜索。</p></li><li><p>检索结果显示：文档摘要，查询项高亮。</p></li><li><p>查询重构：拼写校对或建议，相关查询项推荐。</p></li><li><p>组织搜索结果：分类和聚类。区别在于是否需要人工组织层次结构。</p></li></ul><p>(这章真的是看不下去了，一个搜索界面说了这么多废话，太无聊了)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 1：引言</title>
    <link href="http://shivakasu.github.io/2019/01/18/mir0/"/>
    <id>http://shivakasu.github.io/2019/01/18/mir0/</id>
    <published>2019-01-18T08:36:26.000Z</published>
    <updated>2020-01-05T04:57:35.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>信息检索涉及对文档、网页、联机目录、结构化和半结构化记录及多媒体对象等信息项的表示、存储、组织和访问。信息项的表示和组织必须便于用户访问他们感兴趣的信息。</p></li><li><p>信息检索发展的关键阶段：书籍-&gt;图书馆-&gt;索引-&gt;计算机-&gt;排序技术和搜索引擎等现代研究内容</p></li><li><p>信息检索系统的主要目标是检出所有和用户查询相关的文档，并且把检出的不相关文档控制在最低限度。相关性的概念对信息检索至关重要。对相关性的评估没有固定标准，不存在能在任何时间给任何用户提供完美答案的检索系统。</p></li><li><p>检索任务可分为浏览和搜索，浏览是探索式检索，目标不太明确，搜索则相反。</p></li><li><p>信息检索系统的高层软件架构：<br><a href="/2019/01/18/mir0/mir0-0.png" data-fancybox="group" data-caption="mir0-0" class="fancybox"><img alt="mir0-0" title="mir0-0" data-src="/2019/01/18/mir0/mir0-0.png" class="lazyload"></a></p></li><li><p>文档的索引、检索和排序过程：<br><a href="/2019/01/18/mir0/mir0-1.png" data-fancybox="group" data-caption="mir0-1" class="fancybox"><img alt="mir0-1" title="mir0-1" data-src="/2019/01/18/mir0/mir0-1.png" class="lazyload"></a></p></li><li><p>Web流行的根源：出版自由。</p></li><li><p>Web对搜索的影响：网页爬取新技术，海量文档集和海量查询流量，相关性预测更复杂，从文字搜索转向结构化数据搜索，垃圾信息泛滥。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>解决 anaconda3 安装 xgboost：/usr/lib/libstdc++.so.6：version &#39;GLIBCXX_3.4.14&#39; not found问题</title>
    <link href="http://shivakasu.github.io/2017/07/01/bugfix0/"/>
    <id>http://shivakasu.github.io/2017/07/01/bugfix0/</id>
    <published>2017-07-01T15:00:20.000Z</published>
    <updated>2020-01-05T12:03:39.003Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda install libgcc</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda中关于Qt的bug</title>
    <link href="http://shivakasu.github.io/2016/10/27/bugfix3/"/>
    <id>http://shivakasu.github.io/2016/10/27/bugfix3/</id>
    <published>2016-10-27T12:59:20.000Z</published>
    <updated>2020-01-05T12:08:16.713Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先安装了anaconda，可以使用。<br>之后使用conda命令安装了Orange，由于Orange会安装Qt，可能会导致与anaconda自带的Qt冲突，然后我惊喜的发现anaconda-navigator打不开了，报出以下错误：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;bin&#x2F;anaconda-navigator&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    import anaconda_navigator.app.main</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#x2F;anaconda_navigator&#x2F;app&#x2F;main.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    from anaconda_navigator.widgets.dialogs.splash import SplashScreen</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#x2F;anaconda_navigator&#x2F;widgets&#x2F;__init__.py&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    from anaconda_navigator.utils.analytics import GATracker</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#x2F;anaconda_navigator&#x2F;utils&#x2F;analytics.py&quot;, line 33, in &lt;module&gt;</span><br><span class="line">    from qtpy.QtCore import QT_VERSION_STR, QObject, QThread, QTimer, Signal</span><br><span class="line">ImportError: cannot import name &#39;QT_VERSION_STR&#39;</span><br></pre></td></tr></table></figure></div><p>参照了<a href="https://github.com/ContinuumIO/anaconda-issues/issues/1095的解决方法成功修复，具体方法是：" target="_blank" rel="noopener">https://github.com/ContinuumIO/anaconda-issues/issues/1095的解决方法成功修复，具体方法是：</a><br>打开 /anaconda3/pkgs/anaconda-navigator-1.2.3-py35_0/lib/python3.5/site-packages/anaconda_navigator/utils/analytics.py<br>把</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from qtpy.QtCore import QT_VERSION_STRING , QObject, QThread, QTimer, Signal</span><br></pre></td></tr></table></figure></div><p>改成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from qtpy.QtCore import __version__ as qt_version , QObject, QThread, QTimer, Signal</span><br></pre></td></tr></table></figure></div><p>把</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.info &#x3D; &#123;&#39;python&#39;: python_version, &#39;language&#39;: self.get_language(),</span><br><span class="line">             &#39;os&#39;: operating_system, &#39;version&#39;: app_version,</span><br><span class="line">             &#39;platform&#39;: self.api.conda_platform(),</span><br><span class="line">             &#39;qt&#39;: QT_VERSION_STR, &#39;pyqt&#39;: pyqt_version,</span><br><span class="line">             &#39;conda&#39;: conda_version&#125;</span><br></pre></td></tr></table></figure></div><p>改成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.info &#x3D; &#123;&#39;python&#39;: python_version, &#39;language&#39;: self.get_language(),</span><br><span class="line">             &#39;os&#39;: operating_system, &#39;version&#39;: app_version,</span><br><span class="line">             &#39;platform&#39;: self.api.conda_platform(),</span><br><span class="line">             &#39;qt&#39;: qt_version, &#39;pyqt&#39;: pyqt_version,</span><br><span class="line">             &#39;conda&#39;: conda_version&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下安装scrapy遇到的问题及解决过程</title>
    <link href="http://shivakasu.github.io/2016/10/07/bugfix2/"/>
    <id>http://shivakasu.github.io/2016/10/07/bugfix2/</id>
    <published>2016-10-06T16:13:20.000Z</published>
    <updated>2020-01-05T12:07:10.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用 pip install scrapy 来安装scrapy时，遇到以下输出：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collecting cffi&gt;&#x3D;1.4.1 (from cryptography&gt;&#x3D;1.3.4-&gt;pyOpenSSL-&gt;scrapy)</span><br><span class="line">  Downloading cffi-1.8.3-cp27-cp27mu-manylinux1_x86_64.whl (386kB)</span><br><span class="line">    100% |████████████████████████████████| 389kB 454kB&#x2F;s </span><br><span class="line">Collecting pycparser (from cffi&gt;&#x3D;1.4.1-&gt;cryptography&gt;&#x3D;1.3.4-&gt;pyOpenSSL-&gt;scrapy)</span><br><span class="line">  Downloading pycparser-2.14.tar.gz (223kB)</span><br><span class="line">    100% |████████████████████████████████| 225kB 609kB&#x2F;s </span><br><span class="line">Building wheels for collected packages: Twisted, PyDispatcher, cryptography, zope.interface, pycparser</span><br><span class="line">  Running setup.py bdist_wheel for Twisted ... done</span><br><span class="line">  Stored in directory: &#x2F;home&#x2F;shiva&#x2F;.cache&#x2F;pip&#x2F;wheels&#x2F;0e&#x2F;53&#x2F;62&#x2F;e7b4cea7df9113fb2818b224eb5d143be981568d9c43057a0a</span><br><span class="line">  Running setup.py bdist_wheel for PyDispatcher ... done</span><br><span class="line">  Stored in directory: &#x2F;home&#x2F;shiva&#x2F;.cache&#x2F;pip&#x2F;wheels&#x2F;86&#x2F;02&#x2F;a1&#x2F;5857c77600a28813aaf0f66d4e4568f50c9f133277a4122411</span><br><span class="line">  Running setup.py bdist_wheel for cryptography ... error</span><br><span class="line">  Complete output from command &#x2F;usr&#x2F;bin&#x2F;python -u -c &quot;import setuptools, tokenize;__file__&#x3D;&#39;&#x2F;tmp&#x2F;pip-build-UDAHL4&#x2F;cryptography&#x2F;setup.py&#39;;exec(compile(getattr(tokenize, &#39;open&#39;, open)(__file__).read().replace(&#39;\r\n&#39;, &#39;\n&#39;), __file__, &#39;exec&#39;))</span><br></pre></td></tr></table></figure></div><p>可以看到是在安装cryptography时出的问题，报错信息为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;temp.linux-x86_64-2.7&#x2F;_openssl.c:433:30: fatal error: openssl&#x2F;opensslv.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure></div><p>于是又可以追踪到是openssl的问题，通过百度安装过程，发现执行以下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libssl-dev</span><br></pre></td></tr></table></figure></div><p>即可解决报错问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决安装rails时出现 ERROR：Failed to build gem native extension. 的问题</title>
    <link href="http://shivakasu.github.io/2016/10/03/bugfix1/"/>
    <id>http://shivakasu.github.io/2016/10/03/bugfix1/</id>
    <published>2016-10-03T10:36:20.000Z</published>
    <updated>2020-01-05T12:06:47.881Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>执行 gem install rails 时出现了错误，错误信息如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Fetching: pkg-config-1.1.7.gem (100%)</span><br><span class="line">Successfully installed pkg-config-1.1.7</span><br><span class="line">Fetching: nokogiri-1.6.8.gem (100%)</span><br><span class="line">Building native extensions.  This could take a while...</span><br><span class="line">ERROR:  Error installing rails:</span><br><span class="line">ERROR: Failed to build gem native extension.</span><br><span class="line"></span><br><span class="line">    current directory: &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;nokogiri-1.6.8&#x2F;ext&#x2F;nokogiri</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby2.3 -r .&#x2F;siteconf20161003-4423-1bf9irh.rb extconf.rb</span><br><span class="line">Using pkg-config version 1.1.7</span><br><span class="line">checking if the C compiler accepts ... yes</span><br><span class="line">Building nokogiri using packaged libraries.</span><br><span class="line">Using mini_portile version 2.1.0</span><br><span class="line">checking for gzdopen() in -lz... no</span><br><span class="line">zlib is missing; necessary for building libxml2</span><br><span class="line">*** extconf.rb failed ***</span><br><span class="line">Could not create Makefile due to some reason, probably lack of necessary</span><br><span class="line">libraries and&#x2F;or headers.  Check the mkmf.log file for more details.  You may</span><br><span class="line">need configuration options.</span><br><span class="line"></span><br><span class="line">Provided configuration options:</span><br><span class="line">--with-opt-dir</span><br><span class="line">--without-opt-dir</span><br><span class="line">--with-opt-include</span><br><span class="line">--without-opt-include&#x3D;$&#123;opt-dir&#125;&#x2F;include</span><br><span class="line">--with-opt-lib</span><br><span class="line">--without-opt-lib&#x3D;$&#123;opt-dir&#125;&#x2F;lib</span><br><span class="line">--with-make-prog</span><br><span class="line">--without-make-prog</span><br><span class="line">--srcdir&#x3D;.</span><br><span class="line">--curdir</span><br><span class="line">--ruby&#x3D;&#x2F;usr&#x2F;bin&#x2F;$(RUBY_BASE_NAME)2.3</span><br><span class="line">--help</span><br><span class="line">--clean</span><br><span class="line">--use-system-libraries</span><br><span class="line">--enable-static</span><br><span class="line">--disable-static</span><br><span class="line">--with-zlib-dir</span><br><span class="line">--without-zlib-dir</span><br><span class="line">--with-zlib-include</span><br><span class="line">--without-zlib-include&#x3D;$&#123;zlib-dir&#125;&#x2F;include</span><br><span class="line">--with-zlib-lib</span><br><span class="line">--without-zlib-lib&#x3D;$&#123;zlib-dir&#125;&#x2F;lib</span><br><span class="line">--enable-cross-build</span><br><span class="line">--disable-cross-build</span><br><span class="line"></span><br><span class="line">To see why this extension failed to compile, please check the mkmf.log which can be found here:</span><br><span class="line"></span><br><span class="line">  &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;extensions&#x2F;x86_64-linux&#x2F;2.3.0&#x2F;nokogiri-1.6.8&#x2F;mkmf.log</span><br><span class="line"></span><br><span class="line">extconf failed, exit code 1</span><br><span class="line"></span><br><span class="line">Gem files will remain installed in &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;nokogiri-1.6.8 for inspection.</span><br><span class="line">Results logged to &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;extensions&#x2F;x86_64-linux&#x2F;2.3.0&#x2F;nokogiri-1.6.8&#x2F;gem_make.out</span><br></pre></td></tr></table></figure></div><p>可以看出是在安装nokogiri时遇到了问题，此时执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libxml2-dev libxslt-dev</span><br></pre></td></tr></table></figure></div><p>即可解决问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Rails" scheme="http://shivakasu.github.io/tags/Rails/"/>
    
  </entry>
  
</feed>
