<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHIVAKASU</title>
  <icon>https://www.gravatar.com/avatar/db3726c77acefe0355d29843a28e9ca4</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shivakasu.github.io/"/>
  <updated>2020-01-30T17:12:22.108Z</updated>
  <id>http://shivakasu.github.io/</id>
  
  <author>
    <name>w.k.x.</name>
    <email>wkx1996@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《心理学与生活》笔记</title>
    <link href="http://shivakasu.github.io/2020/01/29/pal0/"/>
    <id>http://shivakasu.github.io/2020/01/29/pal0/</id>
    <published>2020-01-29T08:46:20.000Z</published>
    <updated>2020-01-30T17:12:22.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-生活中的心理学"><a href="#1-生活中的心理学" class="headerlink" title="1 生活中的心理学"></a>1 生活中的心理学</h1><ul><li>心理学(psychology)是关于个体的行为及心智过程的科学研究。心理学的目标是观察、解释、预测和控制行为。观察的核心是客观性，解释的核心是想象力，预测的核心是精确可检验，预测和控制都是对解释的证明。</li><li>研究方法的争论：结构主义(structuralism)认为人类所有心理经验都可以作为基本成分的组合来理解，通过分析组成个体心理生活的感受及其他经验的构成元素，进而揭示人类心理的基础结构。机能主义(functionalism)认为意识是流动的，心理的特征是与环境持续进行相互作用，重要的是心理过程的行为和机能，而不是心理的内容。结构主义研究心理内容是什么，强调科学方法、精确测量以及数据统计分析，机能主义研究行为的目的和原因，强调创造性的解释而不是科学实验方法。</li><li>心理学家的观点决定了他们研究行为和心理过程的方式，书中介绍了七种观点，但是心理学家往往不会局限在单个观点上。<ul><li>心理动力学观点(psychodynamic perspective)：又称精神动力学或精神分析学，认为行为是由强大的内部力量驱使或激发的。人的行为是从先天的本能和生物驱动中产生的，而且试图解决个人需要和社会要求之间的冲突。代表人物弗洛伊德。</li><li>行为主义观点(behaviorist perspective)：寻求理解特定环境刺激如何控制特定类型的行为，研究重点是行为而不是意识。研究方法就是先改变环境再观察行为变化，使用严格的实验和定义变量，而不使用内省法。代表人物约翰·华生、B.F.斯金纳。</li><li>人本主义观点(humanistic perspective)：强调人的能动性以及人自身的发展，在人的认命历程中寻找行为模式。代表人物卡尔·罗杰斯、亚伯拉罕·马斯洛。</li><li>认知观点(cognitive perspective)：研究人的思维以及所有的认识过程，将思维同时视为外在行为的原因和结果，个体不是对物质的客观世界做出反应，而是对个体思维和想象的内在世界的主观现实做出反应。代表人物诺姆·乔姆斯基、让·皮亚杰。</li><li>生物学观点(biological perspective)：在基因、大脑、神经系统以及内分泌系统中寻找行为的原因，认为心理现象与社会现象能够最终依据生物化学过程加以解释。</li><li>进化论观点(evolutionary perspective)：结合了当代心理学与进化论，试图用进化的观点对人的心理的起源和本质以及一些社会现象进行深入的探讨和研究。</li><li>社会文化观点(sociocultural perspective)：研究行为的原因和结果中的跨文化差异，强调文化因素对心理学观点普遍性的影响。</li></ul></li></ul><h1 id="2-心理学的研究方法"><a href="#2-心理学的研究方法" class="headerlink" title="2 心理学的研究方法"></a>2 心理学的研究方法</h1><ul><li>观察者偏见(observer bias)是由于观察者个人的动机和预期导致的错误，减小观察者偏见的方法是标准化。对概念含义进行标准化的策略称为操作化，操作性定义是根据可观察、可测量、可操作的特征来界定变量含义的方法。</li><li>实验法要求操纵自变量观察因变量，但实验者会不自觉得引入混淆变量。有两种几乎存在于所有实验中的混淆变量(confounding variable)，一种是期望效应(expectancy effects)，实验者对实验对象的阐述包含了他对实验结果的预期，这种预期影响了实验对象的行为，另一种是安慰剂效应(placebo effects)，实验环境使实验对象对结果产生了某种预期，影响了实验对象的行为。</li><li>实验者消除混淆的策略称为控制程序，是使所有变量和条件保持恒定的方法。一种方法是双盲控制(double-blind control)，使实验助手和参与者都不知道哪些参与者接受了哪种处理。一种方法是安慰剂控制(placebo control)，引入无效的实验条件做对比实验，来解释安慰剂效应对实验的影响。</li><li>实验法的缺陷：人为实验环境与真实自然环境有区别，参与者往往知道自己在参与试验，某些研究问题受到伦理约束而不可能实施。</li><li>要确定两个变量、特质或者属性之间的关联程度时，需要基于相关法，计算两者的相关系数，判断是正相关、负相关还是不相关。</li><li>心理测量的目标是产生可靠而又有效的发现。信度(reliability)是指心理测验或实验研究得到的行为数据具有一致性或可靠性，效度(validity)是指研究或测验得到的信息准确地测量了研究者想要测量的心理变量或品质。书中介绍了两种数据收集的方法：<ul><li>针对参与者内部的心理状态和不适合现场观察的外部行为，采用自我报告法(self-report measures)收集数据，让参与者言语回答研究者提出的问题，自我报告包括问卷法和访谈法。自我报告法的缺陷有：不适合语言理解能力差的人，人们可能受社会期望的影响给出虚假的答案，访谈的情境会产生个人偏见和成见。</li><li>行为测量(behavioral measures)是研究外显行为和可观察、可记录的反应的方法。自然观察是在不改变或不干预自然环境的条件下观察自然情境下发生的行为。对于不方便观察或收集的行为，可以查询档案数据。</li></ul></li></ul><h1 id="3-行为的生物学和进化基础"><a href="#3-行为的生物学和进化基础" class="headerlink" title="3 行为的生物学和进化基础"></a>3 行为的生物学和进化基础</h1><ul><li>为了分离环境和基因的作用，研究者经常使用收养研究和双生子研究。前者评估儿童与其亲生父母以及养父母之间的相似性，后者比较同卵双生子和异卵双生子在特定性状或行为上的相似性。</li><li>感觉神经元携带来自感受器细胞的信息向内传至中枢神经系统，运动神经元携带来自中枢神经系统的信息向外传至肌肉和腺体，其他的都叫中间神经元。大脑的神经元网络之间有胶质细胞，负责固定神经元位置、清理脑内环境、轴突绝缘、隔离血液内的有害物质、以及影响神经冲动传递所必需的离子浓度。</li><li>动作电位(action potential)：又称神经冲动。在静息状态下，神经元外部钠离子浓度高，细胞内液相对于细胞外液具有跨膜负电压，也就是处于极化状态。神经元对神经冲动的输入发生反应时，静息电位转为动作电位，抑制性输入保持跨膜负电压，抑制了神经冲动的传输，兴奋性输入允许钠离子流入消除负电压，发生去极化，让动作电位继续向后传播，传播过后允许钾离子流出恢复静息电位。而细胞膜上的钠钾泵负责两种离子的反向供给。</li><li>动作电位在神经元之间靠突触传播。突触由突触前膜(发送神经元的终扣)、突触后膜(接受神经元的终扣)和突触间隙组成。动作电位沿轴突到达突触前膜后，开启离子通道允许钙离子流入，引起突触囊泡破裂释放神经递质，神经递质与突触后膜上的受体结合，由于神经递质与受体的结合具有专一性，所以可以说神经元接受的信号是兴奋还是抑制是由其上的受体决定的，但本质上是由神经递质和受体的组合决定的。</li><li>几种神经递质。<ul><li>乙酰胆碱：兴奋性递质，存在于中枢与外周神经系统，阿尔兹海默症的记忆丧失被认为是由于分泌乙酰胆碱的神经元退化所造成的。</li><li>GABA：是gamma-氨基丁酸的缩写，抑制性递质，存在于丘脑、下丘脑和枕叶皮层等脑结构，当脑中GABA水平降低时，人们会产生焦虑或抑郁。</li><li>谷氨酸：脑中最普遍的兴奋性递质，有助于在脑中传递信息，在情绪反应、学习和记忆过程中起着关键作用。</li><li>多巴胺、去甲肾上腺素：属于几茶酚胺，在心理障碍中有重要作用，如情感障碍和精神分裂症。</li><li>五羟色胺：位于脑干，抑制性递质，能让人产生愉悦情绪、抗抑郁。</li><li>内啡肽：属于神经调质，神经调质是能够改变或调节突触后神经元活动的物质。内啡肽是内源性吗啡的简称，在情绪行为和疼痛控制中有重要作用。</li></ul></li><li>神经系统分为中枢神经系统(central nervous system, CNS)和外周神经系统(peripheral nervous system, PNS)。CNS由脑和脊髓的所有神经元组成，作用是整合和协调所有身体功能，向身体不同部分发出指令，神经信息的发出和接受由脊髓完成。PNS由所有构成神经纤维的神经元组成，连接CNS与身体，作用是把来自感受器的信息提供给CNS。PNS包括躯体神经系统和自主神经系统，躯体神经系统调节身体骨骼肌的动作，自主神经系统维持机体的基本生命过程，如呼吸、消化。自主神经系统分为交感神经和副交感神经，交感神经支配应对紧急情况的反应，副交感神经监测身体内部功能的常规运行。</li><li>脑有三层结构：脑干、边缘系统和大脑。<ul><li>脑干：负责综合调节机体内部状态。延髓是呼吸、血压和心搏调节中枢。桥脑提供传入纤维到其他脑干结构和小脑之中。丘脑是感觉的最高中枢。小脑协调身体的运动和维持平衡。</li><li>边缘系统：与动机、情绪状态和记忆过程相关，也参与体温、血压和血糖水平的调节。海马在记忆获得中有重要作用。杏仁核在情绪控制和情绪记忆形成中起作用。下丘脑调节动机行为，包括摄食、饮水、体温调节和性唤醒，维持身体平衡或内稳态。</li><li>大脑：负责调节脑的高级认知功能和情绪功能。额叶参与运动控制和认知活动，包含与语言障碍相关的布罗卡区。顶叶负责触觉、痛觉和温度觉。枕叶是视觉信息到达的部位。颞叶负责听觉过程，包含与言语理解相关的威尔尼克区。额叶运动皮层控制身体肌肉。躯体感觉皮层处理温度、触觉、躯体位置和疼痛的信息。听皮层处理听觉信息。视皮层处理视觉信息。联络皮层负责整合不同感觉通道的信息。</li></ul></li><li>内分泌系统是一种腺体网络，制造和分泌激素到血液中。下丘脑是内分泌系统和中枢神经系统的中转站，下丘脑向脑垂体分泌激素，脑垂体再调节身体其他激素的释放。</li></ul><h1 id="4-感觉和知觉"><a href="#4-感觉和知觉" class="headerlink" title="4 感觉和知觉"></a>4 感觉和知觉</h1><ul><li>知觉(perception)是理解环境中客体和事件的所有过程，分成感觉、知觉组织以及辨认与识别客体三个阶段。感觉(sensation)是感受器受到刺激后产生神经冲动以反映身体内外经验的过程。知觉组织(perceptual organization)阶段大脑整合来自感官的信息形成对外部刺激的内部表征。辨认与识别(identification and recognition)阶段赋予知觉以意义。</li><li>环境中的物理客体称为远距刺激，如光线、空气振动，它们在感觉器官上直接产生的刺激称为近距刺激，如视网膜上的光学成像。知觉三个阶段的主要计算任务可以看成根据近距刺激中的信息来确定远距刺激。</li><li>心理物理学研究物理刺激与其所产生的心理行为和体验之间的关系，由古斯塔夫·费希纳首先提出。测量刺激的方法是确定阈限并建立感觉强度和刺激强度之间关系的心理物理量表。刺激的绝对阈限是产生感觉体验所需的最小物理刺激量，由于觉察过程不是突变的，所以绝对阈限的操作性定义为有一半次数能够觉察到感觉信号的刺激水平，绝对阈限的测量结果总结为心理测量函数，表示为每种刺激强度下刺激被觉察到的百分比的曲线，一般为S形曲线。感觉适应是指感觉系统对持续的刺激输入反应逐渐减小的现象。</li><li>阈限测量受反应偏差的影响，也就是测量中有干扰因素。针对反应偏差的研究方法是信号检测论(signal detection theory, SDT)，综合考虑测量结果的击中、漏报、虚报、正确否定的情况，相当于机器学习评价指标里true/false与positive/negtive组合的四个参数。</li><li>差别阈限是能够识别出两个刺激之间的最小物理差异，操作性定义为有一半次数觉察出差异的刺激值，又称最小可觉差。最小可觉差服从韦伯定律，即刺激之间的最小可觉差与标准刺激强度的比值是恒定的，标准刺激强度体现了感官对不同刺激的敏感程度，比如光强、气味、声音。</li><li>(人体感官的生物学知识略过~)</li><li>知觉组织的原则在格式塔心理学(Gestalt psychology)中得到深入研究，格式塔心理学注重对整体结构的理解，通过控制局部变化观察人们对整体的知觉组织的结果，总结出一套规律：<ul><li>接近律：人们会将最接近的元素组织在一起。</li><li>相似率：人们会将最相似的元素组织在一起。</li><li>连续率：即使线条被截断，人们也会将其知觉为连续的。</li><li>闭合率：人们倾向于填补小的空隙而将客体知觉为一个整体。</li><li>共同命运率：人们倾向于将看起来朝相同方向运动的客体组织起来。</li></ul></li></ul><h1 id="5-心理、意识和其他状态"><a href="#5-心理、意识和其他状态" class="headerlink" title="5 心理、意识和其他状态"></a>5 心理、意识和其他状态</h1><ul><li>非意识过程是很少进入意识的一些躯体活动，如血压调节，有些非意识过程可以有意识地调节，如控制呼吸。前意识记忆是指只有注意到之后才能到达意识的记忆。无意识行为由弗洛伊德提出，他主张某些意识经验具有威胁性以至于被心理过程排除在意识之外，如创伤性记忆和禁忌的欲望，但仍然能影响人的行为。</li><li>研究意识的方法：使深层的个人经验能够得到外显测量。一种方法是要求参与者在进行复杂任务时大声说出解决过程，记录成出声思维报告。另一种是经验抽样法，参与者提供关于他们在日常生活正常进程中的想法和感受的信息。</li><li>意识的作用。<ul><li>帮助生存：意识限制刺激的输入，通过过滤与当前目标无关的大量信息来限定人的注意力。意识允许将事件和经验按照个人需要分成相关的和无关的，选择性地存储人想要分析、解释并对将来起作用的刺激。意识允许人基于过去的知识思考可替代的方案和想象各种可能的结果。总之就是意识帮助人理解环境信息，计划最适宜而有效的行动。</li><li>对现实的个人和文化建构：基于个人或特定文化环境的知识、经验、记忆、需求、目标等，对当前情境做出独特的解释。</li></ul></li><li>弗洛伊德认为梦是对愿望的满足，梦里有两股动力，愿望和抵抗愿望的审查，审查是对愿望的伪装，把社会和个人不能接受的潜性梦境转化为可接受的显性梦境。梦的解析需要从显性梦境回溯到潜性梦境，也就是对梦中包含隐喻的意象进行解读。</li></ul><h1 id="6-学习与行为分析"><a href="#6-学习与行为分析" class="headerlink" title="6 学习与行为分析"></a>6 学习与行为分析</h1><ul><li>学习是基于经验而使行为或行为潜能发生相对一致变化的过程。<ul><li>学习只有通过经验才能发生，经验包括吸收信息和做出反应来影响环境。</li><li>无法直接观测学习本身，但学习能体现在外显行为表现的进步，或相对于外显行为的一种能改变行为的潜能，比如领悟力。</li><li>为了表明发生了学习，行为或行为潜能的变化必须在不同场合表现出相对一致性。</li></ul></li><li>学习的基本形式是习惯化和敏感化。习惯化是指，当刺激重复呈现时会减少行为回应，人会把注意焦点放在环境的新异事件上。敏感化是指，对重复呈现刺激的反应会变得更强烈。一般来说，在刺激很强烈或令人不适时更可能发生敏感化。习惯化和敏感化看似是相反的形式，但敏感化也可以理解成，重复的强刺激会使人对其他弱刺激的反应变得更强烈，导致总体上的反应是增强的，这也是一种习惯化。</li><li>约翰·华生创立了行为主义的心理学派，他认为主观的内省法不是研究行为的好方法，应该去研究客观的可观察的行为。斯金纳扩展了华生的理论，主张心理活动不是产生行为的原因，行为是由环境刺激产生的。斯金纳开创了行为分析理论，强调寻找学习和行为的环境决定因子，行为分析家的任务是在具有可比性的情景下，发现适用于包括人类在内的所有动物的普遍学习规则。</li><li>复杂形式的学习是简单学习形式的组合和加工，两种简单学习形式是经典条件作用和操作性条件作用。</li><li>经典条件作用是一种由一个刺激或事件预示另一个刺激或事件之到来的基本学习方式，是联想学习的一种形式，在此过程中有机体学会将两种刺激或事件联系起来。经典条件作用最初由巴甫洛夫观察狗分泌唾液的规律研究发现，所以又称巴甫洛夫条件作用。</li><li>经典条件作用的核心是反射性反应，如分泌唾液、瞳孔收缩。反射是由与有机体生物学相关的特定刺激自然诱发的，能自然诱发反射性行为的刺激叫做无条件刺激(unconditioned stimulus, UCS)，无条件刺激诱发的行为叫做无条件反应(unconditioned response, UCR)。不能自然诱发反射性行为，需要与UCS匹配使用的叫做条件刺激(CS)，CS诱发UCR的原因是它与UCS的联系，经过多次匹配使用后，单独使用CS也能引起的反射性行为叫做条件反应(CR)，CR就是学习的结果。一种反应是UCR还是CR是由诱因决定的，所以UCS引起的分泌唾液属于UCR，CS引起的分泌唾液属于CR。</li><li>经典条件作用就是通过USC-CS的匹配诱发CR。CS与USC有四种匹配模式，区别在于UCS的呈现时机：延迟条件作用是先呈现CS，UCS在CS取消前呈现。痕迹条件作用是先呈现CS，UCS在CS取消后呈现。同时性条件作用是UCS与CS同时呈现。倒摄条件作用是UCS先于CS呈现。同时性和倒摄条件作用效果较差，因为只有让CS先于UCS呈现，才能学到CS能预示UCS这样的联系。</li><li>当CS不再预示UCS时，CS逐渐无法诱发CR，这个过程叫做消退，消退后重新训练，CR的学习会更快速，说明消退只是削弱了行为，并没有消除先前全部的学习经验。</li><li>一旦CS与CR建立联系，与CS相似的刺激也能诱发CR，这种现象叫刺激泛化，由于重要刺激很少每次都以完全相同的形式出现，所以刺激泛化通过扩展最初的特定经验而扩大了学习范围。当某些与CS相似的刺激反复出现后，有机体对其他相似刺激的反应会减弱，这种现象叫刺激辨别。有机体需要平衡泛化和辨别的作用强度，避免产生过度选择(该反应的不反应)或过度反应(不该反应的瞎反应)。</li><li>有效的CS需要满足相倚性和信息性。相倚性是指CS要与UCS高度依赖，在没有CS时也不会有UCS。信息性是指CS要能提供UCS不具备的额外信息。</li><li>经典条件作用的应用：药物成瘾。药品(UCS)会诱发生理反应(UCR)，这种生理反应是机体对药物的对抗反应，久而久之，这种对抗反应变成了条件反应，在使用药物的场景(CS)中，如打针，机体会对药物的预期效应做好生理准备(CR)，机体需要消耗额外的药物克服CR，随着CR本身的增强，消耗的药物越来越多，慢慢呈现出药物上瘾。</li><li>爱德华·桑代克通过观察猫用试错法逃出迷笼，提出了效果律：随着体验行为带来的结果，机体自动学到了刺激-反应联结，导致带来满意结果的反应出现的概率会越来越大，而带来不满意结果的反应出现的概率会越来越小。</li><li>斯金纳继承了桑代克的观点，提出了操作性条件作用，操作性指的是机体自发产生的行为。操作性条件作用与经典条件作用的区别在于是否自愿，经典条件作用是在外部刺激下被动地学习，而操作性条件作用是通过主动产生行为并体验结果进行学习。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="心理学" scheme="http://shivakasu.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《人类简史》摘记</title>
    <link href="http://shivakasu.github.io/2020/01/26/read0/"/>
    <id>http://shivakasu.github.io/2020/01/26/read0/</id>
    <published>2020-01-26T11:07:20.000Z</published>
    <updated>2020-01-27T09:50:51.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="认知革命-约7万年前"><a href="#认知革命-约7万年前" class="headerlink" title="认知革命(约7万年前)"></a>认知革命(约7万年前)</h1><ul><li>烹调技术的发明减少了食物所需要的咀嚼和消化的时间，让人类可以缩短肠道、降低能量消耗，有了发育大脑的余地。学会用火让人类能主动控制和利用自然的力量，有了发展的实力。</li><li>智人能够淘汰其他的人种征服世界，是因为偶然的基因突变改变了大脑，让智人拥有了新的语言技能，不仅能沟通信息，还有了虚构故事的能力，这是智人集结人力、团结合作的基础。因为依靠互相认识、交流所能维持的团体大约是150人，而共同相信一个虚构的故事或存在就能打破团体规模变大产生的认知壁垒。现代社会也是如此，没文化的可以有相同的宗教崇拜，有文化的可以考虑共同利益，人之间的合作不再严格需要彼此认识和了解。</li><li>认知革命以来，智人生活在双重现实中。一个是客观存在的现实，一个是能使人相信的想象中的现实。这种意识形态的产生使人类社会的发展不再由基因的演变所主导，而是可以根据需求主动引导社会的变革，使人类社会走上快速发展的道路，这是智人胜利的关键。从此智人超越了生物学对人类行为和能力的基本限制，创造了文化和历史。</li><li>有证据表明，自采集时代以来智人的脑容量在逐渐减少，因为随着社会分工的发展，人类越来越能够依赖别人的技能和成果，不需要精通各方面的知识和技能也可以很好地生存。</li><li>远古采集时代的智人有健康和多样化的饮食、相对较短的工时，也少有传染病发生，许多专家将这种社会定义为“最初的富裕社会”。普遍认为远古采集者是泛神论者，相信万物有灵。但是由于时间久远、生活习惯严重分化，目前还没有对远古采集者的可信的研究。</li><li>远古智人学会了航海，因为自然和人口的压力移居到了其他大陆。气候变迁加上人类狩猎和火耕的影响，使其他大陆遭受了物种灭绝。智人的殖民消灭了地球上半数的大型陆地动物。工业革命以来人类对海洋资源的过度滥用，使得海洋生物也开始面临生态危机。</li></ul><h1 id="农业革命-约1万年前"><a href="#农业革命-约1万年前" class="headerlink" title="农业革命(约1万年前)"></a>农业革命(约1万年前)</h1><ul><li>农业革命最早发生在中东、中国和中美洲，因为适合被驯化的少数几种动植物只生长在这些地方。</li><li>农业革命并不完全意味着人类文明的进步，驯化少数几种动植物虽然增加了食物的总量，但人类也承受了改造自然的代价。人类从丰富的饮食结构变成只依赖于少数几种农作物，还要花费额外的精力去维护农作物的生长环境以及抵抗自然灾害，农耕所产生的土地所有权问题还会加剧人类之间的暴力冲突。虽然后续文明的发展得益于农业革命，但对于初代农耕人类来说，农业革命是弊大于利的。</li><li>一种观点认为农业革命的产生是因为人类的误判，想让生活更轻松，却没有考虑到随之而来的负面问题，导致最终反倒加重了生存的压力。另一种观点认为人类文化里发展出了信仰建筑，为了围绕信仰建筑建立住所，人类自愿生活得更辛苦，从采摘生活转为农耕生活。</li><li>农业时代人类的活动空间缩小了，但需要规划的未来变长了。不断主动生产充足的食物，会造成人口的爆炸，让人类越来越难以回到碰运气的采摘生活，取而代之的是由农作计划主导的生存状况，所以农民不得不考虑到更长远的未来，努力维持生活水平。</li><li>在农业时代的群体冲突下产生了精英阶层，他们为了实现统治的目的需要创造出一套虚拟的意象来维持群体的秩序，比如宗教、人权。这种虚拟意象要能让人们相信，至少不能明显违背人们对客观现实的认知，同时还要一代代对人们洗脑，最终让它成为一种社会共识，让人们自然而然地以它为基础思考，遵守这种虚拟的规则。越多的人服从统治，要打破规则就越难。</li><li>蚂蚁和蜜蜂的群体秩序是基因决定的，天生就决定了社会分工，他们的行为模式也并不复杂。但人类社会的秩序是由一套庞大的虚构的故事和规则维持的，人类自身的基因和大脑并没有进化成熟到支持存储这么复杂的群体合作的生物信息，所以记忆的局限促成了文字的发明。</li><li>人类不满足于用文字只记录无聊的数据，开始进行文娱方面的大量创作，使得文字记录越来越多，多到需要一种专门负责数据管理和检索的职位。组织文献的行为强化了社会分工和分层管理的理念，改变了人类思维和看待世界的方式，过去的自由连接、整体思考，已经转变为分割思考、官僚制度。</li><li>由于人类社会的秩序建立在虚构的规则之上，不能彻底避免歧视，所以出现了精英群体主导下的社会阶级、种族阶级等歧视性的制度。但维持社会秩序又似乎离不开阶级制度，因为人们不必浪费精力详细了解彼此，只需要知道各自所处的阶级，就能大致掌握彼此的社会分工以及相处的规矩。久而久之，阶级甚至会被人们视为天然正确而合理的存在。</li><li>阶级制度大多是由偶然的历史事件促成的，完全是人类虚构出的制度，所以在不同群体里的表现相差很大，但重男轻女的思想却出奇的一致，说明性别歧视是与人类的生物学特征相关的。目前有几种理论试图解释重男轻女：肌肉理论认为男人比女人强壮，把体力优势转化成了政治上的优势。流氓理论认为男性基因里有更多的暴力和侵略倾向，更适合主导战争、统治群体。父权基因理论认为在数百万年的演化过程中男性和女性发展出了不同的生存和繁殖策略，男性倾向于保留积极好胜的基因，女性倾向于保留顺从、接受照顾的基因。</li></ul><h1 id="人类的融合统一"><a href="#人类的融合统一" class="headerlink" title="人类的融合统一"></a>人类的融合统一</h1><ul><li>社会秩序是人类虚构、臆想的，所以人与人之间、群体与群体之间必然会存在价值观的矛盾，当人们试图解决这些矛盾时，就容易把问题上升到文明的冲突。一方面，文明冲突引发了战争，另一方面，不同文明的碰撞又激励了人们的思考、创造，推动文明的发展。</li><li>从宏观的历史角度看，人类文明是趋于融合的，就像如今所有人类都接受几乎同样的地缘政治体系、经济制度、法律制度、科学体系，尽管不同群体存在着文化差异，但不会再像远古时期一样完全不懂对方的文化，有了冲突只能依靠战争解决，而是在一套公认的基本国际共识下进行争斗。</li><li>随着全球贸易交流的进行，人类文明进一步融合，小群体的社会秩序慢慢孕育出了“世界一家”的理念。公元前的1000年间，出现了三种有可能达到“世界一家”的秩序：经济上的货币秩序，政治上的帝国秩序，以及宗教上的全球性宗教。</li><li>货币的出现是因为以物易物难以高效运行在规模庞大、结构复杂的社会中，一种通用的、中间性的交易媒介能够提高交易的效率，也让财富的转换、存储和运输变得更容易。</li><li>金钱是有史以来最普遍也是最有效的互信系统。</li><li>帝国的两个特征是文化多元性和疆界灵活性。帝国是造成民族多样性大幅减少的主因之一，但帝国也通过剥削战败者创造了大量文化成就。</li><li>帝国思想加速了文明的融合，因为处于统治的目的，帝国本身会刻意推动传播共同文化，主动对思想、制度、习俗、规范进行标准化。由于帝国思想的理念在于普遍和包容，所以结果不会是征服者对被征服者的文化灭绝，征服者会吸收不同的文化而让帝国形成一种融合后的文明，也就是文化的涵化和同化。</li><li>当下的国际形势可以理解成正在走向一个统一的全球帝国。各个国家遵循着国际秩序进行合作，得以共同解决关乎人类利益的更宏大的问题。国家的独立性正在迅速消失，越来越难脱离全球性的组织。</li><li>社会秩序和阶级都只是想象的产物，社会规模越大它们就越脆弱，宗教的重要性就在于让这些脆弱的架构有了超人类的合法性，确保了社会的稳定。</li><li>泛神论时代人们认为万物有灵，世上所有的存在都是要平等尊重的。到了农业时代，人们打破了这种平衡，对动植物有了控制的欲望和需求，农业革命最初的宗教意义，就是让动植物从与人类平等的生物，变成了人类的所有物。当农业因为天灾人祸的影响暂时失控时，由于人们已经不再相信万物平等，于是发明了鬼神崇拜来解释这种失控，试图与高于动植物的神明进行沟通，逐渐发展成了多神教信仰。人类地位的提升是多神论与泛神论的区别。</li><li>大多数多神教都相信存在一个超越一般神灵的最高意志，真正与一神论不同的是，多神论的最高意志不带有任何私心或偏见，对人类的各种世俗的欲望、担心和忧虑毫不在意。最高意志包容着不同领域各有私心的一般神灵，所以多神论本质上就是开明、包容的。历史上的宗教迫害基本都是一神教对异教徒的暴力行为。</li><li>当某些多神论者对自己信仰的某位神灵格外虔诚，就不再相信其上的最高意志，而是把那位神灵本身当做最高意志，于是从多神教里分化出了一神教。一神教的最高意志有私心和偏见，让人类可以直接和最高意志谈条件，所以人们更乐于接受一神教。</li><li>从历史上看，一神论吸收了二元论、多神论、泛神论的思想。就像基督徒信奉一神论的上帝，相信二元论的魔鬼，崇拜多神论的圣人，还相信泛神论的鬼魂。</li><li>除了信奉超自然神灵的宗教，还有信奉自然法则的宗教。如佛教信奉佛法，神的存在与否并不重要，重要的是相信自然法则，指导自身的修行。</li></ul><h1 id="科学革命-约500年前"><a href="#科学革命-约500年前" class="headerlink" title="科学革命(约500年前)"></a>科学革命(约500年前)</h1><ul><li>现代科学与先前的知识体系有三点不同：愿意承认自己的无知，以观察和数学为中心，运用理论取得新能力。</li><li>承认无知是知识体系不断发展进步的驱动力，欧洲在1900年左右征服世界的最大功臣就是科学，而欧洲科学领先的原因就是先承认无知。先前的帝国主义征服世界是为了扩张领土和传播统治思想，但欧洲帝国主义的扩张还多了学习新知识的目的。</li><li>发现美洲是科学革命的一大奠基事件，不但让欧洲人知道实际的观察比过去的传统更重要，而且像征服美洲的欲望也让欧洲人开始求知若渴。</li><li>早期社会的经济不发达是因为人们不相信未来会更好，认为世界是固定大小的一块蛋糕，获得利益的唯一途径是互相争夺。在承认自己的无知后，人们开始相信只要投资进行研究，一切就能变得更好，有了这种信任的基础，人们就会减少争斗、着重发展经济。信任创造了信贷，信贷发展了经济。</li><li>亚当斯密指出：人类全体财富的基础，就在于希望增加个人利润的自私心理。所以贪婪是好的，利己就是利他，因为人们相信个人获利也会使整个经济蛋糕变大。</li><li>现代资本主义经济的一大重点，就在于出现了一种新的道德标准：应该把利润拿出来，继续投资生产。资本主义认为资本和财富不同，资本是人们主动投入生产的资源。这也是因为人们开始相信，生产是可以不断发展进步的，而支持这种信任的，就是科学技术的不断发展。</li><li>资本主义影响了欧洲帝国主义，征服世界的资金从税收逐渐转为信贷，商人和银行家直接成为统治精英，因为投资有利润回报，所以帝国能通过信贷筹集更多的资金。鸦片战争就是典型的国家为资本家服务，国家在鸦片商的施压下向中国宣战。</li><li>资本主义以利润为至高目标，所以让社会上出现大量不平等的压迫现象。所以资本主义和共产主义互相看不上。</li><li>工业革命的核心是能源转换的革命，不断增加可用的能源，来支持人们对社会发展的期望。</li><li>工业革命时期，国家和市场取代了家庭和社群的物质功能，并创造了想象的社群来代替原始社群的情感功能，比如民族和消费大众，将人们捆绑在一个想象中的大家庭里。</li><li>科学技术让人们可以打破自然选择的法则。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="社会学" scheme="http://shivakasu.github.io/tags/%E7%A4%BE%E4%BC%9A%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>旅行商问题与最优解搜索算法</title>
    <link href="http://shivakasu.github.io/2020/01/16/arg3/"/>
    <id>http://shivakasu.github.io/2020/01/16/arg3/</id>
    <published>2020-01-16T07:00:20.000Z</published>
    <updated>2020-01-23T12:26:14.287Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h1><p>旅行商问题（Travelling Salesman Problem, TSP）是这样一个问题：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。它是组合优化中的一个NP困难问题。本文选择公开的<a href="http://elib.zib.de/pub/mp-testdata/tsp/tsplib/tsp/index.html" target="_blank" rel="noopener">a280数据集</a>进行测试，求解访问全部城市的最短路径。数据预处理及数据散点图如下：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import math,random,time,copy</span><br><span class="line"></span><br><span class="line"># 城市坐标</span><br><span class="line">cities &#x3D; []</span><br><span class="line"># 邻接矩阵，distance[i][j]表示cities[i]到cities[j]的距离</span><br><span class="line">distance &#x3D; []</span><br><span class="line"></span><br><span class="line">def init():</span><br><span class="line">    with open(&quot;a280.tsp&quot;,&#39;r&#39;) as f:</span><br><span class="line">        lines &#x3D; f.readlines()</span><br><span class="line">    i&#x3D;0</span><br><span class="line">    while &quot;NODE_COORD_SECTION&quot; not in lines[i]:</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">    for j in range(280):</span><br><span class="line">        c &#x3D; lines[i+1+j].split()</span><br><span class="line">        cities.append([int(c[1]),int(c[2])])</span><br><span class="line">    for i in range(len(cities)):</span><br><span class="line">        distance.append([])</span><br><span class="line">        for j in range(len(cities)):</span><br><span class="line">            if i&lt;&#x3D;j:</span><br><span class="line">                distance[i].append(math.sqrt((cities[i][0]-cities[j][0])**2+(cities[i][1]-cities[j][1])**2))</span><br><span class="line">            else:</span><br><span class="line">                distance[i].append(distance[j][i])</span><br><span class="line">                </span><br><span class="line"># 计算一个解的路径总长度</span><br><span class="line">def totalDistance(arr):</span><br><span class="line">    res &#x3D; 0</span><br><span class="line">    for i in range(len(arr)-1):</span><br><span class="line">        res +&#x3D; distance[arr[i]][arr[i+1]]</span><br><span class="line">    res +&#x3D; distance[arr[-1]][arr[0]]</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure></div><div id="echarts5351" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts5351'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>在最优解搜索问题中，首先需要明确的是解的形式是什么以及评价解好坏的标准是什么。在旅行商问题中，解的形式是遍历城市的顺序，也就是城市数组排列的一种顺序，评价解的标准是路径总长度。</p><h1 id="2-精确算法"><a href="#2-精确算法" class="headerlink" title="2 精确算法"></a>2 精确算法</h1><p>精确算法得到的结果是全局最优解，因而在求解NP完全问题时必然会遇到时间复杂度爆炸的瓶颈。</p><h2 id="2-1-暴力搜索"><a href="#2-1-暴力搜索" class="headerlink" title="2.1 暴力搜索"></a>2.1 暴力搜索</h2><p>暴力搜索是采用深度优先遍历，依次遍历所有可能的路径，保证最终能得到全局最优解。算法结构简单，占用空间小，但在问题包含 $N$ 个节点的情况下总路径数高达 $N!$ ，时间复杂度也是 $O(N!)$ 。</p><h2 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h2><p>首先要证明动态规划的可行性，即问题的最优解所包含的子问题的解也是最优的。在本题中就是要证明，当 $s_0\rightarrow s_1\rightarrow s_2 … \rightarrow s_{n-1} \rightarrow s_0$ 是从 $s_0$ 出发经过 $n$ 个城市回到 $s_0$ 的最短路径时，子问题 $s_1\rightarrow s_2…\rightarrow s_{n-1} \rightarrow s_0$ 就是从 $s_1$ 出发经过 $n-1$ 个城市到达 $s_0$ 的最短路径，使用反证法就能证明。</p><p>设 $dp(i,V)$ 表示从顶点 $s_i$ 出发经过 $V$ 中各个顶点一次且仅一次，最后回到出发点 $s_0$ 的最短路径长度。当 $V$ 是空集时，直接回到 $s_0$ 即可，路径长度就是 $s_i$ 到 $s_0$ 的距离，记为 $dp(i,\emptyset)=c_{i0}$ ，当 $V$ 不是空集时，就要遍历当前可选择的所有子问题，即 $dp(i,V)=min{c_{ik}+dp(k,V-{k})}$</p><p>时间复杂度 $O(2^nn^2)$ ，空间复杂度 $O(n2^n)$ </p><h1 id="3-个体启发式算法"><a href="#3-个体启发式算法" class="headerlink" title="3 个体启发式算法"></a>3 个体启发式算法</h1><h2 id="3-1-爬山法"><a href="#3-1-爬山法" class="headerlink" title="3.1 爬山法"></a>3.1 爬山法</h2><p>爬山法是一种简单的局部择优的算法。算法从一个随机位置开始（也就是先随机生成一个解），在每次迭代中随机访问当前最优解附近的一个解（也就是对当前最优解做一些微小的改变），如果新的解更优就更新为当前最优解，如果新的解更差就丢弃。直到在当前最优解附近找不到更优解，说明算法找到了一个局部最优解，就把这个解当做最终结果返回。在实际应用时，用这种随机方法寻找局部最优的时间可能很长，为了缩短程序的运行时间，需要设定最大迭代次数，当算法已经达到最大迭代次数，即使还未找到局部最优解也要停止迭代，返回当前最优解。Python3实现如下，迭代次数设为十万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def hillClimb():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    # 初始的随机解</span><br><span class="line">    arr &#x3D; list(range(len(cities)))</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    maxIter &#x3D; 100000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%1000&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        # 每次对解的改变就是随机交换两个位置的值</span><br><span class="line">        change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">        arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        newDistance &#x3D; totalDistance(arr)</span><br><span class="line">        if newDistance&lt;minDistance or minDistance&lt;0:</span><br><span class="line">            minDistance &#x3D; newDistance</span><br><span class="line">        else:</span><br><span class="line">            # 不是更优解就恢复原样</span><br><span class="line">            arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in arr]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts4018" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts4018'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[172, 93], [172, 77], [172, 69], [180, 61], [180, 53], [180, 29], [172, 29], [180, 77], [180, 85], [180, 101], [180, 109], [172, 109], [164, 137], [172, 145], [204, 145], [220, 145], [280, 109], [284, 93], [284, 85], [284, 77], [276, 85], [276, 93], [276, 101], [268, 97], [252, 101], [156, 137], [132, 137], [56, 129], [56, 145], [104, 161], [116, 161], [124, 169], [56, 153], [40, 145], [40, 137], [8, 41], [16, 25], [16, 17], [24, 17], [24, 25], [32, 73], [32, 89], [40, 99], [40, 113], [56, 121], [132, 169], [148, 169], [164, 169], [172, 169], [164, 145], [180, 117], [236, 85], [236, 77], [260, 77], [260, 85], [260, 93], [276, 77], [284, 69], [284, 61], [284, 53], [276, 61], [276, 69], [236, 69], [220, 73], [180, 69], [140, 65], [132, 61], [104, 49], [80, 41], [64, 41], [72, 41], [80, 25], [72, 25], [64, 21], [44, 11], [56, 9], [56, 17], [44, 35], [48, 51], [56, 81], [56, 89], [104, 105], [124, 109], [172, 85], [188, 93], [220, 125], [228, 145], [228, 125], [228, 117], [212, 117], [204, 109], [172, 101], [148, 85], [132, 81], [124, 85], [124, 77], [164, 81], [196, 101], [236, 145], [246, 141], [246, 157], [256, 157], [256, 141], [270, 133], [260, 129], [260, 109], [252, 125], [140, 145], [104, 169], [56, 169], [40, 161], [32, 161], [16, 109], [8, 89], [8, 57], [8, 49], [72, 9], [148, 9], [162, 9], [228, 21], [228, 29], [180, 21], [172, 21], [124, 37], [104, 41], [48, 63], [48, 73], [56, 73], [124, 117], [124, 125], [148, 137], [148, 145], [140, 137], [132, 145], [124, 145], [80, 157], [40, 169], [32, 169], [48, 83], [44, 43], [56, 25], [44, 27], [56, 33], [56, 41], [56, 105], [56, 113], [56, 137], [64, 157], [124, 101], [172, 61], [172, 53], [180, 45], [172, 45], [104, 57], [72, 49], [56, 57], [8, 81], [8, 73], [8, 65], [16, 57], [40, 63], [104, 89], [172, 117], [172, 125], [180, 125], [196, 145], [188, 145], [196, 161], [204, 169], [212, 169], [220, 169], [236, 169], [288, 149], [280, 133], [288, 129], [288, 109], [284, 101], [276, 53], [260, 29], [260, 37], [260, 45], [260, 53], [260, 61], [260, 69], [236, 45], [228, 37], [156, 25], [132, 21], [124, 21], [104, 33], [88, 49], [56, 97], [40, 121], [40, 129], [32, 137], [32, 129], [48, 99], [32, 25], [32, 17], [32, 41], [32, 65], [32, 97], [32, 113], [32, 121], [32, 145], [32, 153], [40, 153], [56, 161], [64, 165], [90, 165], [104, 153], [104, 137], [104, 145], [104, 129], [104, 121], [104, 113], [104, 81], [124, 53], [124, 61], [124, 69], [124, 93], [104, 73], [104, 65], [120, 9], [128, 9], [136, 9], [236, 29], [236, 21], [252, 21], [236, 37], [236, 53], [236, 61], [228, 109], [228, 161], [228, 169], [156, 145], [104, 97], [56, 49], [40, 51], [32, 49], [24, 45], [32, 57], [40, 83], [116, 145], [140, 169], [156, 169], [188, 169], [196, 169], [212, 145], [212, 65], [204, 57], [196, 49], [188, 41], [180, 37], [172, 37], [124, 45], [24, 89], [16, 97], [8, 109], [8, 97], [32, 81], [40, 73], [56, 65], [124, 29], [104, 17], [92, 9], [80, 9], [80, 25], [104, 25], [228, 53], [228, 45], [228, 61], [228, 69], [228, 77], [228, 85], [228, 101], [236, 101], [236, 93], [228, 93], [180, 93], [172, 93]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts7845" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts7845'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 34785.44749211156], [1000, 19353.928053910957], [2000, 15990.36106539108], [3000, 13907.361486648882], [4000, 12971.698829665102], [5000, 12106.015187587398], [6000, 11577.194724429764], [7000, 11387.98014104181], [8000, 11056.166015957479], [9000, 10747.544899934497], [10000, 10498.786823810482], [11000, 10179.57792450684], [12000, 9993.936333501777], [13000, 9910.278995349185], [14000, 9707.430276491103], [15000, 9592.808588624914], [16000, 9484.865119491764], [17000, 9354.789411464242], [18000, 9254.173599187503], [19000, 9211.638126464617], [20000, 9181.18561703581], [21000, 9129.946669826419], [22000, 9066.05502216996], [23000, 8947.643079000773], [24000, 8900.300665097733], [25000, 8858.430157973986], [26000, 8836.329616787592], [27000, 8801.868282679843], [28000, 8719.997067290158], [29000, 8657.454477721523], [30000, 8574.353392823134], [31000, 8510.628362689293], [32000, 8479.416515422137], [33000, 8350.620891677423], [34000, 8335.515801596865], [35000, 8320.650047002355], [36000, 8287.24830679945], [37000, 8263.777278938045], [38000, 8247.106338742791], [39000, 8225.139486807644], [40000, 8194.08962455832], [41000, 8160.6053551791365], [42000, 8133.806386817915], [43000, 8109.544807824241], [44000, 8076.693962845321], [45000, 8035.16907287191], [46000, 8032.495698356345], [47000, 8003.770743108615], [48000, 8003.770743108615], [49000, 7992.78996700886], [50000, 7980.460079147163], [51000, 7977.50615436722], [52000, 7961.833045793833], [53000, 7922.133569884537], [54000, 7897.88553922839], [55000, 7883.355987998853], [56000, 7845.334587547549], [57000, 7845.334587547549], [58000, 7827.847336635698], [59000, 7796.449910154846], [60000, 7776.99396386195], [61000, 7756.087485672815], [62000, 7746.450618302975], [63000, 7720.388837188945], [64000, 7701.099280287324], [65000, 7673.778341851368], [66000, 7664.8874403526925], [67000, 7658.280148888139], [68000, 7650.594077955203], [69000, 7628.45643887525], [70000, 7607.530023210174], [71000, 7597.594964510844], [72000, 7581.228277996682], [73000, 7561.654187119], [74000, 7531.348802729719], [75000, 7503.540382879502], [76000, 7493.710356815283], [77000, 7465.474074409009], [78000, 7455.788115130572], [79000, 7432.020821554273], [80000, 7414.6115815021785], [81000, 7401.726180560843], [82000, 7387.128172921726], [83000, 7373.812777236357], [84000, 7357.904505175984], [85000, 7355.067455725333], [86000, 7314.32368344745], [87000, 7296.716964497638], [88000, 7281.119395664033], [89000, 7263.907853160585], [90000, 7257.27443861171], [91000, 7250.239652458733], [92000, 7244.659180080416], [93000, 7244.245231903331], [94000, 7243.60911086437], [95000, 7236.705814133342], [96000, 7229.788199215191], [97000, 7219.717981814576], [98000, 7189.255339293897], [99000, 7171.7915439014705], [100000, 7162.610316569084]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="3-2-模拟退火"><a href="#3-2-模拟退火" class="headerlink" title="3.2 模拟退火"></a>3.2 模拟退火</h2><p>模拟退火算法（Simulated Annealing，SA）借鉴了物理中固体物质的退火过程，将固体加热到足够高的温度，使分子呈随机排列状态，然后逐步降温使之冷却，最后分子以低能状态排列，固体达到某种稳定状态。</p><p>模拟退火算法首先初始化一个随机解、一个较高的初始温度和一个降温速率，在每次迭代中对当前最优解做微小改变，如果新的解是更优解，就更新为当前最优解，与爬山法不同的是，如果新的解不是更优解，则以一个与当前温度呈正相关的概率接受新的解，一般根据Metropolis接受准则把概率设为 $p=exp(-\Delta F/T), \Delta F&gt;0$ ，其中 $\Delta F$ 是两个解在评估函数下的差值， $T$ 是当前温度。</p><p>以一定概率接受更差的解让算法有机会逃离局部最优，理论上能比爬山法找到更好的解。而随着温度下降，接受概率越来越低，最终趋近于0，表示不再接受差解，算法将收敛到一个更好的局部最优解。Python3实现如下，迭代次数设为十万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">def SA():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    # 初始的随机解</span><br><span class="line">    arr &#x3D; list(range(len(cities)))</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    maxIter &#x3D; 100000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    T &#x3D; 10000</span><br><span class="line">    alpha &#x3D; 0.99</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%1000&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        # 每次对解的改变就是随机交换两个位置的值</span><br><span class="line">        change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">        arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        newDistance &#x3D; totalDistance(arr)</span><br><span class="line">        if newDistance&lt;minDistance or minDistance&lt;0:</span><br><span class="line">            minDistance &#x3D; newDistance</span><br><span class="line">        # 一定概率接受差解</span><br><span class="line">        elif random.random()&lt;math.exp(-(newDistance-minDistance)&#x2F;T):</span><br><span class="line">            minDistance &#x3D; newDistance</span><br><span class="line">        else:</span><br><span class="line">            arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">        T *&#x3D; alpha</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in arr]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts8146" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts8146'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[32, 41], [16, 57], [8, 89], [8, 109], [16, 109], [32, 137], [32, 145], [32, 129], [8, 97], [8, 57], [8, 41], [16, 25], [16, 17], [24, 17], [32, 17], [44, 27], [72, 41], [80, 41], [104, 57], [104, 65], [104, 81], [104, 73], [124, 29], [132, 21], [156, 25], [172, 21], [180, 21], [180, 29], [180, 37], [188, 41], [228, 21], [228, 29], [236, 37], [236, 45], [228, 45], [228, 53], [204, 57], [180, 69], [172, 69], [40, 83], [32, 89], [48, 83], [56, 81], [104, 89], [140, 65], [172, 61], [180, 61], [212, 65], [228, 93], [228, 101], [228, 109], [252, 125], [236, 145], [246, 141], [260, 129], [236, 101], [236, 93], [220, 73], [180, 45], [172, 37], [88, 49], [72, 49], [64, 41], [56, 49], [48, 73], [48, 99], [40, 99], [32, 153], [32, 161], [40, 161], [40, 153], [104, 129], [172, 85], [180, 85], [180, 93], [188, 93], [228, 77], [228, 85], [236, 85], [280, 109], [270, 133], [256, 141], [256, 157], [246, 157], [220, 169], [196, 169], [188, 169], [172, 169], [164, 169], [132, 169], [104, 113], [40, 73], [32, 73], [32, 65], [40, 63], [40, 51], [44, 43], [56, 25], [64, 21], [80, 25], [80, 25], [180, 77], [252, 101], [280, 133], [288, 109], [284, 85], [276, 69], [260, 53], [260, 61], [260, 77], [228, 117], [212, 145], [116, 161], [104, 161], [104, 153], [104, 145], [32, 49], [24, 45], [32, 25], [56, 33], [92, 9], [104, 17], [120, 9], [128, 9], [136, 9], [124, 21], [124, 61], [124, 77], [132, 81], [172, 117], [196, 161], [204, 169], [212, 169], [220, 145], [236, 77], [228, 61], [228, 37], [260, 37], [260, 45], [284, 69], [276, 77], [260, 69], [196, 49], [172, 45], [172, 53], [180, 53], [228, 69], [236, 69], [236, 61], [260, 29], [252, 21], [236, 21], [236, 29], [172, 101], [172, 109], [180, 109], [180, 117], [212, 117], [204, 109], [196, 101], [180, 101], [172, 93], [104, 97], [56, 65], [56, 73], [56, 89], [40, 113], [56, 121], [104, 137], [132, 137], [140, 137], [172, 145], [164, 137], [164, 145], [156, 145], [148, 137], [124, 101], [124, 93], [164, 81], [172, 77], [260, 85], [260, 93], [268, 97], [276, 93], [276, 85], [284, 93], [284, 101], [288, 129], [288, 149], [236, 169], [228, 169], [228, 161], [228, 145], [220, 125], [148, 145], [140, 145], [132, 145], [64, 165], [56, 169], [40, 169], [32, 169], [40, 145], [40, 137], [40, 121], [56, 113], [56, 105], [56, 97], [56, 57], [72, 25], [80, 9], [72, 9], [56, 17], [44, 35], [32, 113], [32, 121], [40, 129], [56, 129], [56, 137], [56, 145], [116, 145], [196, 145], [204, 145], [228, 125], [260, 109], [276, 101], [284, 77], [284, 61], [276, 61], [284, 53], [276, 53], [236, 53], [172, 29], [162, 9], [148, 9], [56, 41], [48, 51], [48, 63], [32, 81], [24, 89], [16, 97], [8, 81], [8, 73], [8, 65], [8, 49], [24, 25], [44, 11], [56, 9], [104, 25], [104, 33], [104, 41], [104, 49], [132, 61], [124, 85], [104, 105], [104, 121], [124, 169], [124, 145], [124, 125], [124, 117], [156, 137], [172, 125], [188, 145], [180, 125], [148, 85], [124, 53], [124, 45], [124, 37], [124, 69], [124, 109], [156, 169], [148, 169], [140, 169], [104, 169], [90, 165], [80, 157], [64, 157], [56, 161], [56, 153], [32, 97], [32, 57], [32, 41]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts2919" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts2919'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 33914.60282260142], [1000, 21270.207203195747], [2000, 16265.112854912211], [3000, 14299.767111200072], [4000, 13408.644532288059], [5000, 12339.311403835165], [6000, 11823.985679204936], [7000, 11340.060799778334], [8000, 10863.903182397295], [9000, 10686.875031225838], [10000, 10596.85666254361], [11000, 10451.941764063176], [12000, 10280.422705331453], [13000, 10044.441189882806], [14000, 9869.56451305229], [15000, 9753.033813298916], [16000, 9552.69239083618], [17000, 9441.766474587757], [18000, 9359.747071906064], [19000, 9226.203899000713], [20000, 9079.179917384592], [21000, 8959.383039845281], [22000, 8877.551048473331], [23000, 8817.714324753268], [24000, 8738.491978633952], [25000, 8686.918621102634], [26000, 8630.222988717873], [27000, 8622.913625929883], [28000, 8568.295779995724], [29000, 8468.68454402818], [30000, 8449.181390727734], [31000, 8359.869091551473], [32000, 8261.168345179232], [33000, 8233.750270533823], [34000, 8190.034063630316], [35000, 8140.79462671016], [36000, 8128.658561316616], [37000, 8118.778995284066], [38000, 8077.483249476699], [39000, 8052.586715575036], [40000, 8019.217846182968], [41000, 8002.205777605603], [42000, 7970.2023637285165], [43000, 7952.3704645344], [44000, 7936.880848055674], [45000, 7925.326070917763], [46000, 7856.029446794221], [47000, 7847.696786030943], [48000, 7826.492945497338], [49000, 7817.134810060771], [50000, 7802.275591244446], [51000, 7795.9553643803465], [52000, 7776.3994280254265], [53000, 7774.510884205429], [54000, 7769.328707059647], [55000, 7732.0669905684845], [56000, 7689.552626860808], [57000, 7608.917431266603], [58000, 7529.500704854002], [59000, 7525.151492554089], [60000, 7483.045048948701], [61000, 7463.155471971213], [62000, 7463.155471971213], [63000, 7453.030001510787], [64000, 7439.796155583298], [65000, 7400.594587954039], [66000, 7380.726291722335], [67000, 7377.720146717941], [68000, 7372.2296017471335], [69000, 7347.252534616578], [70000, 7328.506489513188], [71000, 7310.4996327846575], [72000, 7308.063033400559], [73000, 7277.750739408965], [74000, 7277.750739408965], [75000, 7277.750739408965], [76000, 7276.375076640651], [77000, 7239.6198953633675], [78000, 7223.211139312575], [79000, 7222.101896122617], [80000, 7204.190999948586], [81000, 7168.37394620814], [82000, 7130.631996481255], [83000, 7107.593395968574], [84000, 7058.659038192923], [85000, 7026.328141448473], [86000, 7009.3114853990855], [87000, 6993.94744719539], [88000, 6974.881458775223], [89000, 6971.567750276238], [90000, 6964.771051249861], [91000, 6950.13105705818], [92000, 6930.272598874511], [93000, 6908.141847824359], [94000, 6890.168476817055], [95000, 6876.768343682251], [96000, 6874.833600240957], [97000, 6858.471825848977], [98000, 6853.884080443336], [99000, 6848.763030961273], [100000, 6841.984535031416]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="3-3-禁忌搜索"><a href="#3-3-禁忌搜索" class="headerlink" title="3.3 禁忌搜索"></a>3.3 禁忌搜索</h2><p>禁忌搜索（Tabu Search或Taboo Search，简称TS）是对局部搜索（LS）的一种扩展，是一种全局寻优算法，其特点是采用禁忌技术，即用一个禁忌表记录下已经到达过的局部最优点及求解过程，在下一次搜索中，利用禁忌表中的信息不再或有选择地搜索这些点，以此来跳出局部最优点。该算法可以克服爬山算法全局搜索能力不强的弱点。</p><p>算法流程如下，</p><p><a href="https://file.shivakasu.cn/d1a41dd3e548144b7516/arg3-0.jpg" data-fancybox="group" data-caption="arg3-0" class="fancybox"><img alt="arg3-0" title="arg3-0" data-src="https://file.shivakasu.cn/d1a41dd3e548144b7516/arg3-0.jpg" class="lazyload"></a></p><p>Python3实现如下，迭代次数设为四万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def TS():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    maxIter &#x3D; 40000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    searchNum &#x3D; 200</span><br><span class="line">    tabuLen &#x3D; 20</span><br><span class="line">    tabuTable &#x3D; []</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    # 初始的随机解</span><br><span class="line">    arr &#x3D; list(range(len(cities)))</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    minDistance &#x3D; totalDistance(arr)</span><br><span class="line">    localBestPath &#x3D; []</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%400&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        # 当前邻域搜索</span><br><span class="line">        while i&lt;searchNum:</span><br><span class="line">            tmp &#x3D; copy.deepcopy(arr)</span><br><span class="line">            change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">            tmp[change[0]],tmp[change[1]] &#x3D; tmp[change[1]],tmp[change[0]]</span><br><span class="line">            # 搜索不在禁忌表中的解</span><br><span class="line">            if tmp not in tabuTable:</span><br><span class="line">                newDistance &#x3D; totalDistance(tmp)</span><br><span class="line">                if newDistance&lt;minDistance:</span><br><span class="line">                    localBestPath &#x3D; copy.deepcopy(tmp)</span><br><span class="line">                    minDistance &#x3D; newDistance</span><br><span class="line">                i +&#x3D; 1</span><br><span class="line">        arr &#x3D; copy.deepcopy(localBestPath)</span><br><span class="line">        # 更新禁忌表</span><br><span class="line">        if len(tabuTable)&#x3D;&#x3D;tabuLen:</span><br><span class="line">            tabuTable &#x3D; tabuTable[1:]</span><br><span class="line">        tabuTable.append(localBestPath)</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in arr]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts1662" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts1662'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[48, 51], [56, 49], [72, 49], [104, 33], [156, 25], [172, 29], [172, 37], [180, 45], [180, 53], [180, 61], [124, 69], [56, 57], [16, 57], [8, 57], [8, 49], [8, 41], [16, 25], [24, 45], [32, 41], [56, 65], [104, 121], [104, 129], [104, 137], [56, 137], [56, 129], [40, 129], [40, 121], [32, 121], [32, 129], [40, 137], [56, 145], [124, 145], [260, 109], [276, 93], [284, 93], [284, 85], [284, 77], [284, 69], [284, 61], [284, 53], [276, 53], [260, 29], [252, 21], [236, 21], [56, 9], [44, 11], [56, 17], [64, 21], [228, 109], [252, 125], [260, 129], [270, 133], [256, 141], [246, 141], [236, 145], [220, 125], [212, 117], [180, 101], [172, 93], [180, 93], [180, 85], [172, 85], [172, 77], [164, 81], [72, 25], [56, 25], [44, 35], [44, 43], [32, 49], [32, 65], [32, 81], [48, 99], [56, 121], [56, 153], [56, 161], [56, 169], [40, 169], [32, 169], [32, 161], [40, 161], [40, 153], [40, 113], [40, 99], [32, 97], [32, 89], [24, 89], [16, 97], [8, 89], [8, 97], [32, 137], [32, 145], [32, 153], [40, 145], [56, 113], [56, 105], [88, 49], [104, 25], [104, 17], [124, 29], [124, 37], [124, 45], [124, 53], [180, 69], [204, 57], [236, 61], [260, 53], [260, 45], [260, 37], [236, 53], [228, 61], [220, 73], [188, 93], [196, 101], [204, 109], [228, 117], [228, 125], [228, 145], [220, 145], [212, 145], [196, 145], [188, 145], [172, 145], [172, 125], [180, 125], [180, 117], [228, 77], [236, 69], [236, 45], [236, 37], [236, 29], [180, 29], [180, 21], [172, 21], [162, 9], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 41], [104, 49], [124, 61], [132, 61], [140, 65], [172, 69], [172, 61], [172, 53], [172, 45], [180, 37], [188, 41], [196, 49], [228, 21], [228, 29], [228, 37], [228, 45], [228, 53], [228, 69], [228, 85], [228, 93], [236, 93], [268, 97], [276, 101], [284, 101], [280, 109], [280, 133], [236, 169], [228, 169], [220, 169], [204, 145], [196, 161], [188, 169], [172, 169], [164, 169], [164, 137], [172, 109], [172, 101], [148, 85], [132, 81], [104, 81], [40, 73], [32, 73], [8, 65], [8, 73], [8, 81], [32, 113], [64, 157], [104, 169], [116, 161], [124, 169], [132, 169], [140, 169], [148, 169], [140, 145], [132, 137], [140, 137], [148, 145], [148, 137], [124, 117], [124, 125], [116, 145], [104, 161], [90, 165], [64, 165], [80, 157], [104, 153], [104, 145], [124, 109], [124, 101], [124, 93], [124, 85], [124, 77], [104, 65], [80, 41], [72, 41], [32, 25], [24, 25], [16, 17], [24, 17], [32, 17], [44, 27], [56, 33], [56, 41], [64, 41], [120, 9], [128, 9], [136, 9], [148, 9], [132, 21], [124, 21], [104, 57], [56, 89], [56, 97], [16, 109], [8, 109], [40, 83], [48, 83], [48, 73], [56, 73], [56, 81], [104, 89], [104, 97], [104, 105], [104, 113], [132, 145], [156, 169], [196, 169], [204, 169], [212, 169], [228, 161], [246, 157], [276, 85], [276, 77], [276, 69], [276, 61], [288, 109], [288, 129], [288, 149], [256, 157], [164, 145], [156, 145], [156, 137], [172, 117], [180, 109], [228, 101], [236, 101], [252, 101], [260, 93], [260, 85], [260, 77], [236, 85], [236, 77], [260, 69], [260, 61], [212, 65], [180, 77], [104, 73], [48, 63], [40, 63], [32, 57], [40, 51], [48, 51]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts1035" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts1035'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 33890.23101543088], [400, 9414.267797183507], [800, 7693.759751536997], [1200, 6968.071523569924], [1600, 6637.457204487098], [2000, 6159.892480829687], [2400, 6042.076698585728], [2800, 5950.848808320309], [3200, 5913.12574102969], [3600, 5901.85703497971], [4000, 5891.8393048938215], [4400, 5891.8393048938215], [4800, 5891.8393048938215], [5200, 5891.8393048938215], [5600, 5891.8393048938215], [6000, 5891.8393048938215], [6400, 5891.8393048938215], [6800, 5891.8393048938215], [7200, 5891.8393048938215], [7600, 5891.8393048938215], [8000, 5891.8393048938215], [8400, 5891.8393048938215], [8800, 5891.8393048938215], [9200, 5891.8393048938215], [9600, 5891.8393048938215], [10000, 5891.8393048938215], [10400, 5891.8393048938215], [10800, 5891.8393048938215], [11200, 5891.8393048938215], [11600, 5891.8393048938215], [12000, 5891.8393048938215], [12400, 5891.8393048938215], [12800, 5891.8393048938215], [13200, 5891.8393048938215], [13600, 5891.8393048938215], [14000, 5891.8393048938215], [14400, 5891.8393048938215], [14800, 5891.8393048938215], [15200, 5891.8393048938215], [15600, 5891.8393048938215], [16000, 5891.8393048938215], [16400, 5891.8393048938215], [16800, 5891.8393048938215], [17200, 5891.8393048938215], [17600, 5891.8393048938215], [18000, 5891.8393048938215], [18400, 5891.8393048938215], [18800, 5891.8393048938215], [19200, 5891.8393048938215], [19600, 5891.8393048938215], [20000, 5891.8393048938215], [20400, 5891.8393048938215], [20800, 5891.8393048938215], [21200, 5891.8393048938215], [21600, 5891.8393048938215], [22000, 5891.8393048938215], [22400, 5891.8393048938215], [22800, 5891.8393048938215], [23200, 5891.8393048938215], [23600, 5891.8393048938215], [24000, 5891.8393048938215], [24400, 5891.8393048938215], [24800, 5891.8393048938215], [25200, 5891.8393048938215], [25600, 5891.8393048938215], [26000, 5891.8393048938215], [26400, 5891.8393048938215], [26800, 5891.8393048938215], [27200, 5891.8393048938215], [27600, 5891.8393048938215], [28000, 5891.8393048938215], [28400, 5891.8393048938215], [28800, 5891.8393048938215], [29200, 5891.8393048938215], [29600, 5891.8393048938215], [30000, 5891.8393048938215], [30400, 5891.8393048938215], [30800, 5891.8393048938215], [31200, 5891.8393048938215], [31600, 5891.8393048938215], [32000, 5891.8393048938215], [32400, 5891.8393048938215], [32800, 5891.8393048938215], [33200, 5891.8393048938215], [33600, 5891.8393048938215], [34000, 5891.8393048938215], [34400, 5891.8393048938215], [34800, 5891.8393048938215], [35200, 5891.8393048938215], [35600, 5891.8393048938215], [36000, 5891.8393048938215], [36400, 5891.8393048938215], [36800, 5891.8393048938215], [37200, 5891.8393048938215], [37600, 5891.8393048938215], [38000, 5891.8393048938215], [38400, 5891.8393048938215], [38800, 5891.8393048938215], [39200, 5891.8393048938215], [39600, 5891.8393048938215], [40000, 5891.8393048938215]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h1 id="4-群体启发式算法"><a href="#4-群体启发式算法" class="headerlink" title="4 群体启发式算法"></a>4 群体启发式算法</h1><h2 id="4-1-遗传算法"><a href="#4-1-遗传算法" class="headerlink" title="4.1 遗传算法"></a>4.1 遗传算法</h2><p>遗传算法（GeneticAlgorithm ，GA ）借鉴了生物进化过程来优化随机搜索策略，与上述两种算法不同的是，遗传算法维护并更新的不是单个解，而是用一组解模拟种群。在迭代中主要模拟选择、遗传、变异、免疫等过程实现种群中个体信息的交换，提升整个种群的质量。在本题中的主要步骤如下：</p><ul><li>1、初始化种群规模、迭代次数、突变概率三个参数</li><li>2、随机生成一组解，代表初代种群。根据每个解的路径长度设定它的适应度，适应度表示个体对环境的适应程度，优胜劣汰，越是精英的个体适应度应该越高，所以路径长度越短的解适应度就越高。设 $dis[i]$ 表示种群中第 $i$ 个解的路径长度， $totalDis$ 表示种群中所有解的路径长度总和，那么第 $i$ 个解的适应度就是:<script type="math/tex; mode=display">P(i) = \frac{\frac{totalDis}{dis[i]}}{\sum_k \frac{totalDis}{dis[k]}}</script></li><li>3、父代选择。选择将要生成下一代的两个父代个体，同样为了保证优胜劣汰，要让适应度高的个体容易被选中。一般采用轮盘赌法选择个体，首先产生一个随机概率 $rand$ ，依次累种群个体的适应度，当出现 $rand &lt; \sum_{k=0}^jP(k)$ 时，说明从第0个个体到第 $j$ 个个体的累积适应度超过了随机概率 $rand$ ，此时选择第 $j$ 个个体，完成一次选择过程。之所以叫轮盘赌法，是因为这个选择过程就好像以一个随机的力度转轮盘，结果从0转到 $j$ 停止，非常形象。</li><li>4、两个父代个体杂交产生一个子代个体。方法不固定，只要是综合两个解的信息生成新的解就可以，根据方法的不同，既可以生成一个子代，也可以生成两个子代。本文采取的方法是，随机生成一个交叉点 $i$ ，两个父代中位于交叉点之前的城市顺序不变，而交叉点之后的城市顺序改成在对方中的顺序，交叉完毕后两个父代变成了两个新的子代。</li><li>5、子代变异。对于杂交产生的每个子代，生成一个随机数，如果随机数小于预设的变异概率，就对该子代做微小改变，视为遗传变异。本文采取的变异方法是随机交换两个城市的位置。</li><li>6、种群更新。保留子代中的精英个体，本文采取的方式是通过杂交变异生成两倍种群大小的子代，根据每个子代的路径长度排序，选择路径最短的一半作为新一代种群。</li></ul><p>Python3实现如下，迭代次数设为四万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">def GA():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    groupSize &#x3D; 1000</span><br><span class="line">    # 突变概率</span><br><span class="line">    mutation &#x3D; 0.01</span><br><span class="line">    maxIter &#x3D; 40000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    fatherGroup &#x3D; []</span><br><span class="line">    sonGroup &#x3D; []</span><br><span class="line">    fitness &#x3D; []</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    minPath &#x3D; []</span><br><span class="line">    # 初始化种群</span><br><span class="line">    totalDis &#x3D; 0</span><br><span class="line">    for i in range(groupSize):</span><br><span class="line">        arr &#x3D; list(range(len(cities)))</span><br><span class="line">        random.shuffle(arr)</span><br><span class="line">        fatherGroup.append(arr)</span><br><span class="line">        d &#x3D; totalDistance(arr)</span><br><span class="line">        fitness.append(d)</span><br><span class="line">        totalDis +&#x3D; d</span><br><span class="line">    # 计算适应度</span><br><span class="line">    fitness &#x3D; [totalDis&#x2F;i for i in fitness]</span><br><span class="line">    totalFit &#x3D; sum(fitness)</span><br><span class="line">    fitness &#x3D; [i&#x2F;totalFit for i in fitness]</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%400&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            print(&quot;ga: &quot;+str(currIter))</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        sonDis &#x3D; []</span><br><span class="line">        # 杂交</span><br><span class="line">        for i in range(groupSize):</span><br><span class="line">            # 轮盘赌选择父代</span><br><span class="line">            f1 &#x3D; -1</span><br><span class="line">            r &#x3D; random.random()</span><br><span class="line">            p &#x3D; 0    </span><br><span class="line">            while r&gt;p:</span><br><span class="line">                f1 +&#x3D; 1</span><br><span class="line">                p +&#x3D; fitness[f1]</span><br><span class="line">            f2 &#x3D; f1</span><br><span class="line">            while f1&#x3D;&#x3D;f2:</span><br><span class="line">                f2 &#x3D; -1</span><br><span class="line">                r &#x3D; random.random()</span><br><span class="line">                p &#x3D; 0    </span><br><span class="line">                while r&gt;p:</span><br><span class="line">                    f2 +&#x3D; 1</span><br><span class="line">                    p +&#x3D; fitness[f2]</span><br><span class="line">            f1 &#x3D; fatherGroup[f1]</span><br><span class="line">            f2 &#x3D; fatherGroup[f2]</span><br><span class="line">            # 杂交生成两个子代</span><br><span class="line">            r &#x3D; random.randint(0,len(cities)-2)</span><br><span class="line">            s1 &#x3D; f1[:i]</span><br><span class="line">            s2 &#x3D; f2[:i]</span><br><span class="line">            for k in f1:</span><br><span class="line">                if k not in s2:</span><br><span class="line">                    s2.append(k)</span><br><span class="line">            for k in f2:</span><br><span class="line">                if k not in s1:</span><br><span class="line">                    s1.append(k)</span><br><span class="line">            r &#x3D; random.random()</span><br><span class="line">            if r&lt;mutation:</span><br><span class="line">                # 突变就是随机交换两个位置的值</span><br><span class="line">                change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">                s1[change[0]],s1[change[1]] &#x3D; s1[change[1]],s1[change[0]]</span><br><span class="line">                s2[change[0]],s2[change[1]] &#x3D; s2[change[1]],s2[change[0]]</span><br><span class="line">            sonGroup.append(s1)</span><br><span class="line">            sonGroup.append(s2)</span><br><span class="line">            sonDis.append(totalDistance(s1))</span><br><span class="line">            sonDis.append(totalDistance(s2))</span><br><span class="line">        # 子代按路径长度排序</span><br><span class="line">        zipped&#x3D;zip(sonGroup,sonDis)</span><br><span class="line">        sort_zipped &#x3D; sorted(zipped,key&#x3D;lambda x:(x[1],x[0]))</span><br><span class="line">        result &#x3D; zip(*sort_zipped)</span><br><span class="line">        sonGroup, sonDis &#x3D; [list(x) for x in result]</span><br><span class="line">        sonGroup &#x3D; sonGroup[:groupSize]</span><br><span class="line">        sonDis &#x3D; sonDis[:groupSize]</span><br><span class="line">        # 种群更新</span><br><span class="line">        minDistance &#x3D; min(sonDis)</span><br><span class="line">        minPath &#x3D; sonGroup[sonDis.index(minDistance)]</span><br><span class="line">        totalDis &#x3D; sum(sonDis)</span><br><span class="line">        fitness &#x3D; [totalDis&#x2F;i for i in sonDis]</span><br><span class="line">        totalFit &#x3D; sum(fitness)</span><br><span class="line">        fitness &#x3D; [i&#x2F;totalFit for i in fitness]</span><br><span class="line">        fatherGroup &#x3D; sonGroup</span><br><span class="line">        sonGroup &#x3D; []</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in minPath]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts5085" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts5085'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[124, 45], [124, 37], [124, 29], [124, 21], [120, 9], [128, 9], [136, 9], [148, 9], [162, 9], [172, 21], [180, 21], [228, 45], [228, 53], [236, 45], [236, 53], [236, 61], [260, 77], [260, 85], [260, 93], [260, 109], [252, 125], [246, 141], [246, 157], [236, 169], [228, 169], [228, 161], [220, 169], [180, 125], [172, 125], [172, 117], [132, 61], [124, 53], [104, 33], [104, 25], [80, 25], [80, 25], [104, 73], [104, 105], [104, 113], [104, 121], [64, 157], [56, 153], [56, 145], [32, 137], [32, 129], [32, 121], [40, 121], [40, 129], [40, 137], [56, 129], [56, 121], [56, 113], [56, 105], [40, 99], [32, 97], [16, 57], [24, 25], [32, 25], [44, 27], [44, 35], [44, 43], [40, 63], [32, 73], [32, 65], [32, 57], [40, 51], [32, 49], [24, 45], [32, 41], [48, 51], [56, 49], [72, 41], [80, 41], [88, 49], [104, 49], [172, 53], [172, 61], [180, 61], [180, 69], [180, 77], [180, 85], [180, 101], [172, 101], [172, 109], [104, 97], [48, 83], [40, 83], [32, 89], [16, 97], [24, 89], [32, 81], [40, 73], [48, 73], [56, 73], [104, 81], [104, 89], [124, 85], [124, 93], [124, 101], [124, 109], [140, 137], [140, 145], [164, 169], [172, 169], [228, 145], [220, 145], [212, 145], [204, 145], [196, 145], [188, 145], [164, 145], [156, 145], [148, 145], [148, 137], [172, 37], [180, 29], [228, 21], [236, 21], [252, 21], [260, 29], [260, 37], [236, 37], [236, 29], [228, 29], [196, 49], [180, 53], [180, 45], [172, 45], [104, 41], [56, 57], [48, 63], [56, 65], [104, 65], [124, 69], [124, 77], [132, 81], [148, 85], [164, 81], [172, 85], [180, 93], [188, 93], [196, 101], [204, 109], [220, 125], [228, 125], [236, 145], [256, 157], [288, 149], [288, 129], [284, 85], [284, 77], [284, 69], [276, 77], [276, 93], [268, 97], [276, 101], [280, 109], [270, 133], [260, 129], [252, 101], [236, 101], [236, 93], [236, 85], [260, 61], [276, 69], [276, 61], [284, 61], [284, 53], [276, 53], [260, 53], [260, 45], [228, 37], [188, 41], [180, 37], [172, 29], [156, 25], [132, 21], [104, 17], [92, 9], [80, 9], [72, 9], [56, 25], [8, 41], [8, 49], [8, 57], [8, 65], [8, 73], [8, 81], [8, 89], [32, 113], [40, 113], [104, 137], [132, 145], [156, 137], [164, 137], [172, 145], [196, 161], [212, 169], [204, 169], [196, 169], [188, 169], [156, 169], [148, 169], [140, 169], [132, 169], [124, 169], [104, 169], [90, 165], [40, 161], [32, 161], [32, 153], [40, 145], [56, 137], [104, 129], [124, 125], [180, 109], [228, 109], [228, 101], [228, 93], [228, 85], [228, 77], [236, 77], [228, 69], [220, 73], [212, 65], [204, 57], [228, 61], [236, 69], [260, 69], [276, 85], [284, 93], [284, 101], [288, 109], [280, 133], [256, 141], [228, 117], [212, 117], [180, 117], [124, 117], [56, 97], [48, 99], [56, 89], [56, 81], [72, 25], [64, 21], [56, 17], [56, 9], [44, 11], [24, 17], [16, 17], [16, 25], [32, 17], [56, 33], [56, 41], [64, 41], [72, 49], [104, 57], [124, 61], [140, 65], [172, 69], [172, 77], [172, 93], [132, 137], [124, 145], [116, 145], [104, 145], [104, 153], [80, 157], [64, 165], [56, 161], [40, 153], [32, 145], [16, 109], [8, 97], [8, 109], [32, 169], [40, 169], [56, 169], [104, 161], [116, 161], [124, 45]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts9673" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts9673'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 31115.680460043088], [400, 15334.904769985365], [800, 12071.182794553366], [1200, 10698.827141318481], [1600, 9802.001624465336], [2000, 9363.246821117898], [2400, 8855.848613389555], [2800, 8549.646103173383], [3200, 7905.687169789544], [3600, 7640.008182252965], [4000, 7516.971538827085], [4400, 7460.390059229863], [4800, 7200.0973510901395], [5200, 7082.845365549378], [5600, 6978.533013510428], [6000, 6907.537885302301], [6400, 6869.699686143468], [6800, 6823.17796232125], [7200, 6674.49522306577], [7600, 6666.380071344395], [8000, 6633.3609340924295], [8400, 6597.376427533433], [8800, 6578.598330585508], [9200, 6556.286960088603], [9600, 6474.420573091844], [10000, 6456.020486728329], [10400, 6429.182170359672], [10800, 6371.598509726626], [11200, 6150.950225917906], [11600, 6137.483276498839], [12000, 6136.817159602187], [12400, 6128.433098194441], [12800, 6122.948394567252], [13200, 6121.990888588202], [13600, 6117.465969468466], [14000, 6108.045086009359], [14400, 6100.530453694365], [14800, 6044.424139457849], [15200, 6007.500448314685], [15600, 5994.222026814483], [16000, 5994.222026814483], [16400, 5994.222026814483], [16800, 5992.902025489408], [17200, 5987.447565187352], [17600, 5952.26454649637], [18000, 5926.7815784881], [18400, 5911.340727488466], [18800, 5903.943969863919], [19200, 5858.274377256338], [19600, 5677.451094165581], [20000, 5590.964423347894], [20400, 5583.820614362352], [20800, 5575.112715619656], [21200, 5564.2937512718345], [21600, 5564.2937512718345], [22000, 5558.186428738796], [22400, 5558.186428738796], [22800, 5558.186428738796], [23200, 5557.263600314162], [23600, 5557.263600314162], [24000, 5557.263600314162], [24400, 5557.263600314162], [24800, 5542.103563167821], [25200, 5538.32778373243], [25600, 5521.673384924751], [26000, 5516.955162350389], [26400, 5455.412913382425], [26800, 5454.581605653756], [27200, 5453.822244440534], [27600, 5453.118269038051], [28000, 5453.118269038051], [28400, 5453.118269038051], [28800, 5453.118269038051], [29200, 5446.960580111209], [29600, 5446.960580111209], [30000, 5443.485499230946], [30400, 5443.485499230946], [30800, 5443.485499230946], [31200, 5443.485499230946], [31600, 5443.485499230946], [32000, 5443.485499230946], [32400, 5443.485499230946], [32800, 5443.485499230946], [33200, 5438.761869151259], [33600, 5200.983199799323], [34000, 5200.983199799323], [34400, 5200.983199799323], [34800, 5200.983199799323], [35200, 5187.678339313514], [35600, 5171.529601838279], [36000, 5171.529601838279], [36400, 5171.529601838279], [36800, 5171.529601838279], [37200, 5171.529601838279], [37600, 5171.529601838279], [38000, 5171.529601838279], [38400, 5171.529601838279], [38800, 5171.529601838279], [39200, 5171.529601838279], [39600, 5171.529601838279], [40000, 5171.529601838279]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="4-2-蚁群算法"><a href="#4-2-蚁群算法" class="headerlink" title="4.2 蚁群算法"></a>4.2 蚁群算法</h2><p>蚁群算法（Ant Colony Optimization ，ACO ）的灵感来源于蚂蚁觅食。蚂蚁觅食是一种群体性行为，蚂蚁在寻找食物时，会在其经过的路径上释放一种信息素，并能够感知其他蚂蚁释放的信息素。信息素浓度的大小体现了路径的远近，因为蚂蚁会以较大的概率优先选择信息素浓度高的路径，并释放一定量的信息素，以增强该路径上的信息素浓度，这形成了一种正反馈，最终使得蚂蚁能够找到一条到食物源的最短路径。这种思路很适合解决旅行商问题，只需要把蚂蚁的行走路径表示为问题的解，每次迭代的过程就是把所有蚂蚁随机放置在不同的位置，根据路径的信息素浓度选择下一个访问的城市，当所有蚂蚁访问完所有的城市后，一个迭代结束。所以信息素的更新和路径的选择策略是蚁群算法的两大核心。</p><p>路径选择：设蚂蚁的数量为 $m$ ，城市的数量为 $n$ ，城市 $i$ 与城市 $j$ 之间的距离为 $d_{ij}$ ， $t$ 时刻城市 $i$ 与城市 $j$ 连接路径上的信息素浓度是 $\tau_{ij}(t)$ ，初始时刻，所有路径上的信息素浓度相同，即 $\tau_{ij}(0)=\tau_0$ 。设 $P_{ij}^k(t)$ 是 $t$ 时刻蚂蚁 $k$ 从城市 $i$ 转移到城市 $j$ 的概率，其计算公式为，</p><script type="math/tex; mode=display">P_{ij}^k(t)=\begin{cases}\frac{[\tau_{ij}(t)]^\alpha\times [\eta_{ij}(t)]^\beta}{\sum_{s\in allow_k}[\tau_{is}(t)]^\alpha\times [\eta_{is}(t)]^\beta} & s\in allow_k \\0 & s\notin allow_k \end{cases}</script><p>其中， $\eta_{ij}(t)$ 为启发函数， $\eta_{ij}(t)=1/d_{ij}$ ，表示蚂蚁从城市 $i$ 转移到城市 $j$ 的期望程度。 $allow_k$ 是蚂蚁 $k$ 待访问城市的集合，分段公式的第二段就表示蚂蚁转移到已经访问过的城市的概率是0。蚂蚁对下一个目的地的选择取决于信息素浓度和启发函数，而这里用的启发函数是距离的倒数，所以可以说蚂蚁的选择兼顾了群体行为留下的信息和当前城市到其他城市的客观距离，两个启发因子 $\alpha$ 和 $\beta$ 就是用来调节这两方面在决策中的重要程度。</p><p>信息素更新：当蚂蚁经过一条路径时，会释放信息素，同时路径上原有的信息素会有一定程度的挥发，设参数 $\rho(0&lt;\rho&lt;1)$ 表示信息素的挥发率，当所有蚂蚁完成一次循环后，各个路径上信息素的更新公式为，</p><script type="math/tex; mode=display">\begin{cases}\tau_{ij}(t+1)=(1-\rho)\tau_{ij}(t)+\Delta \tau_{ij} \\\Delta \tau_{ij}=\sum_{k=1}^n\Delta \tau_{ij}^k\end{cases}</script><p>其中， $\tau_{ij}^k$ 表示第 $k$ 只蚂蚁在城市 $i$ 到城市 $j$ 之间的路径上释放的信息素浓度， $\tau_{ij}$ 就表示所有蚂蚁在城市 $i$ 到城市 $j$ 之间的路径上释放的信息素浓度之和。对于 $\tau_{ij}^k$ 的计算方法，有三种模型：</p><ul><li>1、ant cycle system 模型<script type="math/tex; mode=display">\Delta\tau_{ij}^k=\begin{cases}Q/L_k & 第k只蚂蚁从城市i访问城市j \\0 & 其他\end{cases}</script>其中 $Q$ 为常数，表示蚂蚁循环一次所释放的信息素总量， $L_K$ 表示第 $k$ 只蚂蚁经过路径的长度</li><li>2、ant quantity system 模型<script type="math/tex; mode=display">\Delta\tau_{ij}^k=\begin{cases}Q/d_{ij} & 第k只蚂蚁从城市i访问城市j \\0 & 其他\end{cases}</script></li><li>3、ant density system 模型<script type="math/tex; mode=display">\Delta\tau_{ij}^k=\begin{cases}Q & 第k只蚂蚁从城市i访问城市j \\0 & 其他\end{cases}</script>在上述三种模型中，一般采用ant cycle system 模型，让信息素的浓度随蚂蚁迄今走过的总长度的增加而下降，使得路径上的信息素浓度更包含一种全局性的信息。</li></ul><p>Python3实现如下，迭代次数设为一万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">def ACO():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    maxIter &#x3D; 500</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    minPath &#x3D; []</span><br><span class="line">    # 初始化参数</span><br><span class="line">    antNum &#x3D; len(cities)  </span><br><span class="line">    alpha &#x3D; 1</span><br><span class="line">    beta &#x3D; 5</span><br><span class="line">    rho &#x3D; 0.1</span><br><span class="line">    Q &#x3D; 1000</span><br><span class="line">    # 初始化信息素矩阵</span><br><span class="line">    pheromone &#x3D; [[1 for i in range(len(cities))] for j in range(len(cities))]</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%5&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            print(&quot;aco: &quot;+str(currIter)+&quot; &quot;+str(minDistance))</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        # 初始化行走的路径</span><br><span class="line">        path &#x3D; [[] for j in range(antNum)]</span><br><span class="line">        visit &#x3D; [[0 for i in range(len(cities))] for j in range(antNum)]</span><br><span class="line">        antDis &#x3D; []</span><br><span class="line">        # 随机放置蚂蚁</span><br><span class="line">        arr &#x3D; list(range(len(cities)))</span><br><span class="line">        random.shuffle(arr)</span><br><span class="line">        for i in range(antNum):</span><br><span class="line">            path[i].append(arr[i])</span><br><span class="line">            visit[i][arr[i]] &#x3D; 1</span><br><span class="line">        # 所有蚂蚁都走完一条完整路径时才算一次迭代</span><br><span class="line">        for i in range(antNum):</span><br><span class="line">            while len(path[i])&lt;len(cities):</span><br><span class="line">                # 路径选择概率表</span><br><span class="line">                weight &#x3D; [0 for k in range(len(cities))]</span><br><span class="line">                for k in range(len(cities)):</span><br><span class="line">                    if visit[i][k]&#x3D;&#x3D;0:</span><br><span class="line">                        weight[k] &#x3D; (pheromone[path[i][-1]][k]**alpha)&#x2F;(distance[path[i][-1]][k]**beta+0.0001)</span><br><span class="line">                # 轮盘赌法选下个城市</span><br><span class="line">                totalWeight &#x3D; sum(weight)</span><br><span class="line">                p &#x3D; [w&#x2F;totalWeight for w in weight]</span><br><span class="line">                r &#x3D; random.random()</span><br><span class="line">                sumP &#x3D; 0</span><br><span class="line">                nextCity &#x3D; -1</span><br><span class="line">                while r&gt;sumP:</span><br><span class="line">                    nextCity +&#x3D; 1</span><br><span class="line">                    sumP +&#x3D; p[nextCity]</span><br><span class="line">                path[i].append(nextCity)</span><br><span class="line">                visit[i][nextCity] &#x3D; 1</span><br><span class="line">        for i in path:</span><br><span class="line">            antDis.append(totalDistance(i))</span><br><span class="line">        minDistance &#x3D; min(antDis)</span><br><span class="line">        minPath &#x3D; path[antDis.index(minDistance)]</span><br><span class="line">        # 更新信息素</span><br><span class="line">        delta &#x3D; [[0 for i in range(len(cities))] for j in range(len(cities))]</span><br><span class="line">        for i in range(antNum):</span><br><span class="line">            tau &#x3D; Q&#x2F;antDis[i]</span><br><span class="line">            for j in range(1,len(cities)):</span><br><span class="line">                fromCity &#x3D; path[i][j-1]</span><br><span class="line">                toCity &#x3D; path[i][j]</span><br><span class="line">                delta[fromCity][toCity] +&#x3D; tau</span><br><span class="line">                delta[toCity][fromCity] +&#x3D; tau</span><br><span class="line">        for i in range(len(cities)):</span><br><span class="line">            for j in range(len(cities)):</span><br><span class="line">                pheromone[i][j] &#x3D; pheromone[i][j]*(1-rho)+delta[i][j]</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in minPath]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts580" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts580'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[260, 85], [260, 77], [260, 69], [260, 61], [260, 53], [260, 45], [260, 37], [260, 29], [252, 21], [228, 37], [228, 45], [228, 53], [228, 61], [236, 61], [236, 69], [228, 69], [228, 77], [228, 85], [228, 93], [228, 101], [228, 109], [228, 117], [228, 125], [220, 125], [212, 117], [204, 109], [196, 101], [188, 93], [180, 93], [180, 101], [180, 109], [180, 117], [180, 125], [172, 125], [172, 117], [172, 109], [172, 101], [172, 93], [172, 85], [180, 85], [180, 77], [180, 69], [172, 69], [172, 61], [172, 53], [180, 53], [180, 61], [172, 45], [172, 37], [180, 37], [180, 29], [180, 21], [172, 21], [172, 29], [156, 25], [162, 9], [148, 9], [136, 9], [128, 9], [120, 9], [124, 21], [124, 29], [124, 37], [124, 45], [124, 53], [124, 61], [124, 69], [124, 77], [132, 81], [124, 85], [124, 93], [124, 101], [124, 109], [124, 117], [124, 125], [132, 137], [140, 137], [148, 137], [156, 137], [164, 137], [164, 145], [172, 145], [188, 145], [196, 145], [204, 145], [212, 145], [220, 145], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [270, 133], [280, 133], [288, 129], [288, 149], [256, 157], [246, 157], [236, 169], [228, 169], [228, 161], [220, 169], [212, 169], [204, 169], [196, 169], [196, 161], [188, 169], [172, 169], [164, 169], [156, 169], [148, 169], [140, 169], [132, 169], [124, 169], [116, 161], [104, 153], [104, 161], [104, 169], [90, 165], [80, 157], [64, 157], [64, 165], [56, 169], [56, 161], [56, 153], [56, 145], [56, 137], [56, 129], [56, 121], [56, 113], [56, 105], [56, 97], [56, 89], [56, 81], [48, 83], [40, 83], [40, 73], [32, 73], [32, 81], [32, 89], [32, 97], [40, 99], [48, 99], [40, 113], [32, 113], [32, 121], [32, 129], [40, 129], [40, 137], [40, 145], [40, 153], [40, 161], [40, 169], [32, 169], [32, 161], [32, 153], [32, 145], [32, 137], [40, 121], [16, 109], [8, 109], [8, 97], [16, 97], [24, 89], [8, 89], [8, 81], [8, 73], [8, 65], [8, 57], [8, 49], [8, 41], [16, 25], [16, 17], [24, 17], [32, 17], [32, 25], [24, 25], [32, 41], [32, 49], [32, 57], [32, 65], [40, 63], [48, 63], [56, 65], [56, 57], [56, 49], [56, 41], [64, 41], [72, 41], [72, 49], [88, 49], [80, 41], [80, 25], [80, 25], [72, 25], [64, 21], [56, 17], [56, 9], [44, 11], [44, 27], [44, 35], [44, 43], [48, 51], [40, 51], [24, 45], [16, 57], [56, 73], [48, 73], [56, 33], [56, 25], [72, 9], [80, 9], [92, 9], [104, 17], [104, 25], [104, 33], [104, 41], [104, 49], [104, 57], [104, 65], [104, 73], [104, 81], [104, 89], [104, 97], [104, 105], [104, 113], [104, 121], [104, 129], [104, 137], [104, 145], [116, 145], [124, 145], [132, 145], [140, 145], [148, 145], [156, 145], [148, 85], [164, 81], [172, 77], [140, 65], [132, 61], [132, 21], [188, 41], [180, 45], [196, 49], [204, 57], [212, 65], [220, 73], [236, 77], [236, 85], [236, 93], [236, 101], [252, 101], [260, 109], [268, 97], [260, 93], [276, 93], [276, 85], [276, 77], [276, 69], [284, 69], [284, 77], [284, 85], [284, 93], [284, 101], [276, 101], [280, 109], [288, 109], [276, 61], [284, 61], [284, 53], [276, 53], [236, 29], [228, 29], [228, 21], [236, 21], [236, 37], [236, 45], [236, 53], [252, 125], [260, 85]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下，在几种算法里是效果最好的。因为蚁群算法的原始思想就是找最短路径，从初始化开始就是找最短路径，而不是像其他算法一样要修改成适合旅行商问题的形式，从一个随机初始化的解开始迭代。</p><div id="echarts5115" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts5115'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 3525.323483452664], [5, 3155.9786053991943], [10, 3198.1954305052404], [15, 3187.9624616192996], [20, 3077.925362696013], [25, 3170.7241673705093], [30, 3148.6702846278945], [35, 3111.7258487602144], [40, 3087.8800152281005], [45, 3107.8380050836017], [50, 3140.5883387538834], [55, 3127.0518427781685], [60, 3073.1342139772532], [65, 3129.571863142564], [70, 3077.862464224103], [75, 3080.9757259533485], [80, 3157.1901107704957], [85, 3052.9825087167287], [90, 3133.0425119448], [95, 3128.0609084583507], [100, 2924.095523108582], [105, 3085.9893019859123], [110, 3105.290547210402], [115, 3109.096048032235], [120, 3120.5840641270865], [125, 3041.203053161302], [130, 3070.5996216800936], [135, 3148.0287278021215], [140, 3127.138022828557], [145, 3068.1098045165318], [150, 3100.2402069545506], [155, 3091.7373782438494], [160, 3110.4581133000784], [165, 3052.5760813078714], [170, 3127.176731218702], [175, 3109.4249804651104], [180, 3101.676984024719], [185, 3087.3670212489383], [190, 3113.378413993024], [195, 3111.71731437653], [200, 3073.867193563927], [205, 3008.046745322756], [210, 3102.589946601963], [215, 3127.2554753512845], [220, 3096.04542909826], [225, 3097.964252847144], [230, 3121.037787377663], [235, 3076.706051206151], [240, 3091.0954356958214], [245, 3082.9460006162253], [250, 3104.778830112415], [255, 3051.8581665339666], [260, 3139.3284997306137], [265, 3098.045393805626], [270, 3040.103490383168], [275, 2992.8722260395716], [280, 3091.9427644856764], [285, 3099.0265609494772], [290, 3100.0710885212834], [295, 3099.213863345473], [300, 3152.6969208238816], [305, 3166.1283973949703], [310, 3067.0764321822116], [315, 3096.786127538351], [320, 3126.6943630919727], [325, 2992.5229676594026], [330, 3008.3374290370057], [335, 3116.1989866768076], [340, 3035.9752202551363], [345, 3049.724462504239], [350, 3097.4257992160933], [355, 3079.620375237138], [360, 3103.4251046299005], [365, 3138.3917235807894], [370, 3098.320004367942], [375, 3094.815939495362], [380, 3068.4730594876783], [385, 3102.3050596509356], [390, 3085.0351971959044], [395, 3021.352709120023], [400, 3028.8765272162104], [405, 3031.270448419514], [410, 3064.0751584809655], [415, 3072.4117823811976], [420, 3079.810714105713], [425, 3035.3561260388096], [430, 3115.7594277182284], [435, 3135.3076421918477], [440, 3133.4525449544262], [445, 3051.8050347787002], [450, 3082.2833212674973], [455, 3132.3622626312954], [460, 3118.9943123554644], [465, 3084.9142358320414], [470, 3083.5421423024504], [475, 3048.709322365078], [480, 3056.4137021152496], [485, 3083.4645884663823], [490, 3124.419980076434], [495, 3001.5161365085064], [500, 3070.6424520713927]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="4-3-粒子群算法"><a href="#4-3-粒子群算法" class="headerlink" title="4.3 粒子群算法"></a>4.3 粒子群算法</h2><p>粒子群算法（ Particle Swarm Optimization, PSO）源于对鸟群觅食行为的研究。一群鸟在随机搜索食物，在这个区域里只有一块食物。所有的鸟都不知道食物在那里。但是他们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢。最简单有效的就是搜寻离食物最近的鸟的周围区域。用粒子模拟单个鸟类个体，粒子的位置对应优化问题的一个候选解，粒子的飞行过程即为该个体的解空间搜索过程。粒子的飞行速度可根据粒子历史最优位置和种群历史最优位置进行动态调整。粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。每个粒子单独搜寻的最优解叫做个体极值，粒子群中最优的个体极值作为当前全局极值。不断迭代，更新速度和位置，最终得到满足终止条件的最优解。</p><p>更新规则：粒子群算法的核心就是根据两个极值更新粒子的速度和位置。首先速度的更新公式为，</p><script type="math/tex; mode=display">v_i=\omega\times v_i+c_1\times rand()\times (pbest_i-x_i)+c_2\times rand()\times (gbest-x_i)</script><p>其中， $v_i$ 是粒子 $i$ 的速度， $x_i$ 是粒子 $i$ 的位置， $rand()$ 是介于 $(0,1)$ 的随机数， $pbest_i$ 是粒子 $i$ 的个体极值， $gbest$ 是粒子群的全局极值。组成该式子的三个部分分别叫做记忆项、自身认知项和群体认知项。记忆项代表上次的速度和位置，自身认知项代表了个体自身的历史经验，群体认知项代表了粒子间协同合作和知识共享的结果。 $\omega$ 、 $c1$ 和 $c2$<br>是三个权重因子，用来调节这三部分在粒子速度更新过程中的重要程度。最后，位置的更新公式相对简单， $x_i=x_i+v_i$</p><p>但是粒子群算法的原生公式不适用于旅行商问题，在解决旅行商问题时，要先定义粒子、位置、速度分别代表什么。一般思路是把粒子定义成问题的一个解，也就是城市序列，这个序列同时也代表粒子的位置。粒子移动的本质就是所有粒子向极值靠近，所以序列向序列靠近可以解释成序列片段的复制。这样看来，用粒子群算法解决旅行商问题就变得很像遗传算法的思路，只不过是把父代之间的序列片段交换，变成了粒子和极值之间的交换，三个权重因子也就代表着三次交换的片段的长度。</p><h2 id="4-4-免疫算法"><a href="#4-4-免疫算法" class="headerlink" title="4.4 免疫算法"></a>4.4 免疫算法</h2><p>和遗传算法大同小异，都是优胜劣汰的种群更新思路。</p><h2 id="4-5-鱼群算法"><a href="#4-5-鱼群算法" class="headerlink" title="4.5 鱼群算法"></a>4.5 鱼群算法</h2><h2 id="4-6-人工蜂群算法"><a href="#4-6-人工蜂群算法" class="headerlink" title="4.6 人工蜂群算法"></a>4.6 人工蜂群算法</h2><h2 id="4-7-蛙跳算法"><a href="#4-7-蛙跳算法" class="headerlink" title="4.7 蛙跳算法"></a>4.7 蛙跳算法</h2><h2 id="4-8-烟花算法"><a href="#4-8-烟花算法" class="headerlink" title="4.8 烟花算法"></a>4.8 烟花算法</h2><h2 id="4-9-萤火虫算法"><a href="#4-9-萤火虫算法" class="headerlink" title="4.9 萤火虫算法"></a>4.9 萤火虫算法</h2><h2 id="4-10-细菌觅食算法"><a href="#4-10-细菌觅食算法" class="headerlink" title="4.10 细菌觅食算法"></a>4.10 细菌觅食算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="http://shivakasu.github.io/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Manacher 算法</title>
    <link href="http://shivakasu.github.io/2020/01/15/arg2/"/>
    <id>http://shivakasu.github.io/2020/01/15/arg2/</id>
    <published>2020-01-15T12:14:20.000Z</published>
    <updated>2020-01-15T16:03:34.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、算法背景"><a href="#一、算法背景" class="headerlink" title="一、算法背景"></a>一、算法背景</h1><p>Manacher算法，中文名马拉车算法，用以解决求字符串中的最长回文子串。传统的寻找最长回文子串的方法是从左到右遍历字符串的每个字符，同时以每个字符为回文中心向左右两侧扩散寻找，当字符串中存在大量回文子串，比如在极端情况下 $“aa…aa”$ ，算法的时间复杂度是 $O(N^2)$ 。而Manacher算法能够把寻找最长回文子串的时间复杂度降到 $O(N)$ 。</p><h1 id="二、字符串预处理"><a href="#二、字符串预处理" class="headerlink" title="二、字符串预处理"></a>二、字符串预处理</h1><p>假设要处理的字符串是 $“abbabb”$ ，由于回文串有奇回文和偶回文，比如 $“bab”$ 是奇回文， $“abba”$ 是偶回文，奇回文的对称轴是一个字符，偶回文的对称轴是两个字符，为了消除这种差异，首先要对字符串预处理，在每个字符的两侧都添加占位符，比如 $“\sharp”$ ，原来的字符串就变成了 $“\sharp a\sharp b\sharp b\sharp a\sharp b\sharp b\sharp ”$ 。对于其中的每个回文串，预处理相当于在每个字符的右侧添加占位符，变成偶回文，再在整体回文串的左侧添加一个占位符，变成奇回文。比如上述两个回文串变成了 $“\sharp b\sharp a\sharp b\sharp ”$ 和 $“\sharp a\sharp b\sharp b\sharp a\sharp ”$ ，长度分别是7和9，都是奇回文。</p><h1 id="二、计算最长回文子串半径"><a href="#二、计算最长回文子串半径" class="headerlink" title="二、计算最长回文子串半径"></a>二、计算最长回文子串半径</h1><p>除了对字符串的预处理，算法还需要一个辅助数组 $p$ ，设预处理后的字符串是 $arr$ ，则 $p[i]$ 表示以 $arr[i]$ 为回文中心的最大回文半径。由于所有回文串都是奇回文，所以回文半径可以表示为 $(回文串长度+1)\div 2$ ，也就是包含回文中心的回文串的一半。比如下表中， $p[3]=2$ 表示以 $arr[3]$ 为回文中心的最长回文子串是 $“\sharp b\sharp ”$ ，回文半径是2，即 $“\sharp b”$ 的长度。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i ：</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">arr：</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p ：</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><p>计算数组 $p$ 需要两个辅助变量， $maxright$ 表示遍历至此发现的回文串所能达到的最右边界， $center$ 表示到达最右边界的回文串的回文中心。当遍历到 $arr[i]$ 时，要计算的是以 $arr[i]$ 为回文中心的最大回文半径，由于 $center$ 和 $maxright$ 是当前已知的回文中心和回文边界，所以一定是在之前的步骤算出来的，所以必有 $center&lt;i&lt;maxright$ ，又因为 $arr[center..maxright]$ 是一个回文串的右半部分，所以在 $arr[0..center]$ 中必有 $i$ 的对称点，记为 $i’$ ，以及 $maxright$ 的对称点 $maxright’$ ，至此，可以确定以下数组下标的位置关系：</p><script type="math/tex; mode=display">maxright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow maxright</script><p>Manacher算法的核心就是利用之前步骤算出的 $p$ 数组的值来减少对字符串的遍历。在当前的步骤中就体现在根据 $p[i’]$ 值的情况优化计算 $p[i]$ 的过程，把以 $arr[i]$ 为回文中心的回文串的右边界记为 $iright$ ，关于 $center$ 的对称点记为 $iright’$ ，分为两种情况：</p><p>情况一：$p[i’]&lt;maxright-i$<br>$p[i’]$ 是 $i’$ 到 $iright’$ 的距离，$maxright-i$ 是 $i’$ 到 $maxright’$ 的距离，位置关系如下，</p><script type="math/tex; mode=display">maxright'\rightarrow iright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow iright\rightarrow maxright</script><p>说明以 $arr[i]$ 为回文中心的回文串被完全包含在以 $arr[center]$ 为回文中心的回文串中。必有 $p[i]=p[i’]$ </p><p>情况二：$p[i’]\geq maxright-i$<br>位置关系如下，</p><script type="math/tex; mode=display">iright'\rightarrow maxright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow maxright\rightarrow iright</script><p>说明以 $arr[i]$ 为回文中心的最大回文半径至少是 $maxright-i$ ，而 $maxright’$ 左侧与 $maxright$ 右侧的字符是否匹配还不知道，因为 $maxright$ 就是当前遍历到的最右边界，再右边的字符还没遍历到，所以此时可以把 $maxright’$ 和 $maxright$ 当做左右边界向外扩散匹配，而回文中心 $i$ 到 $maxright$ 之间的字符就不必判断了，因为 $p[i’]$ 保证了这一段一定是能匹配成功的。</p><p>一句话总结， $p$ 数组的计算过程就是利用算过的 $p$ 数组的值优化左右扩散匹配。</p><h1 id="三、最长回文子串起始坐标"><a href="#三、最长回文子串起始坐标" class="headerlink" title="三、最长回文子串起始坐标"></a>三、最长回文子串起始坐标</h1><p>算好了数组 $p$ ，其中最大的值就是最长回文子串的半径，但这里得到的长度和坐标都是基于预处理后的字符串 $arr$ ，获取最长回文子串需要知道他在原字符串 $str$ 里的起始点和半径。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i ：</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">arr：</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p ：</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">str：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td></tr></tbody></table></div><p>在上图的例子中，基于 $arr$ 得到的回文中心是 $arr[7]$ ，回文半径是 $p[7]=6$ ，而在目标字符串中需要找到的回文串是 $str[1..5]$ 。</p><p>回文串在原字符串中的起始坐标是 $index=(i-p[i])\div 2$ ，其中 $i-p[i]$ 是 $arr$ 起点到回文串左边界的距离，在例子中就是 $“\sharp a”$ 这一段，由于最大回文字符串的首尾一定是占位符，所以从 $arr$ 起点到回文左边界这一段中的每个字符只有左侧有占位符，也就是说字符和占位符的数量是相同的，所以式子最后要除以2，才能得到其中所有有效字符的数量，这个去除了占位符的长度就是原字符串 $str$ 中起点到回文左边界的距离。</p><p>$str$ 中的回文半径也容易计算。如果 $arr$ 中的回文中心是有效字符，说明这个回文串预处理前是奇回文，回文串的左半部分中每个字符的左侧都有一个占位符，在例子里也就是 $“\sharp b\sharp b\sharp a”$ ，这时真实的回文半径就是 $p[i]\div 2$ 。如果 $arr$ 中的回文中心是占位符，说明这个回文串预处理前是偶回文，回文串的左半部分中每个字符的左侧都有一个占位符，同时多了回文中心上的一个占位符，这时真实的回文半径就是 $(p[i]-1)\div 2$ 。</p><p>Manacher算法的 $O(N)$ 时间复杂度可以理解成 $maxright$ 从 $arr$ 起点移动到终点的过程， $maxright$ 左侧的字符都是不必重复匹配的，右侧随着匹配过程不断更新 $maxright$ 的位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="http://shivakasu.github.io/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法总结</title>
    <link href="http://shivakasu.github.io/2020/01/11/arg1/"/>
    <id>http://shivakasu.github.io/2020/01/11/arg1/</id>
    <published>2020-01-11T10:41:20.000Z</published>
    <updated>2020-01-16T02:25:17.497Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>输入原字符串(String)和子串(Pattern)，找到子串在原字符串中第一次出现的位置，两个字符串分别命名为 $s$ 和 $p$</p><h1 id="二、暴力检索"><a href="#二、暴力检索" class="headerlink" title="二、暴力检索"></a>二、暴力检索</h1><p>暴力检索(Brute Force)是最简单的匹配方法，首先把 $s$ 和 $p$ 左端对齐，从两个字符串头部开始逐位匹配，匹配失败后将 $p$ 右移一位，从 $p$ 的头部和 $s$ 的对应位置重新匹配。</p><p>最坏情况下，假设 $s=“xx….xy”$ ，长度为 $N$ ， $p=“xx…xy”$ ，长度为 $M$ ，每次匹配都需要比较全部 $M$ 个字符，而只有最后一次匹配才能匹配成功，所以时间复杂度是 $O(M\times N)$</p><h1 id="三、KMP算法"><a href="#三、KMP算法" class="headerlink" title="三、KMP算法"></a>三、KMP算法</h1><p>KMP算法全称是Knuth-Morris-Pratt字符串查找算法，算法的核心思想是利用最大相同前缀后缀长度来减少匹配次数。例如 $ABCAB$ 的前缀有 $A$ 、 $AB$ 、 $ABC$ 、 $ABCA$ 四个，后缀有 $B$ 、 $AB$ 、 $CAB$ 、 $BCAB$ 四个，那么他的最大相同前缀后缀就是 $AB$ ，最大相同前缀后缀长度是2。所以对于字符串 $str[0..n]$ 来说，最大相同前缀后缀长度是 $k$ 就表示 $str[0..k-1]=str[n-k+1..n]$ 但 $str[k]\neq str[n-k]$ </p><p>先默认已经有了记录子串 $p$ 最大相同前缀后缀长度的数组 $F$ ， $F[k]$ 就是 $p[0..k]$ 的最大相同前缀后缀长度。借用<a href="https://www.cnblogs.com/SYCstudio/p/7194315.html" target="_blank" rel="noopener">某篇博客</a>里的例子，</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr></tbody></table></div><p>对于 $p=”abaabbabaab”$ ， $F=[0,0,1,1,2,0,1,2,3,4,5]$</p><p>$i$ 表示 $s$ 的下标， $j$ 表示 $p$ 的下标，第一次匹配如下， $s[5]$ 和 $p[5]$ 匹配失败。查询 $F[5-1]$ ，发现 $F[4]=2$ ，说明 $p[0..4]$ 的前两位和最后两位能够匹配上，又因为 $p[0..4]=s[0..4]$ ，下次匹配子串 $p$ 就不必只后移一位，可以直接让 $p[0..1]$ 和 $s[3..4]$ 对齐，因为最大相同前缀后缀长度是2就说明当 $p[0..1]$ 和 $s[3..4]$ 之前的位置对齐时，最多能匹配两位，在第三位之前一定会匹配失败。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第二次匹配如下，发现 $s[13]$ 和 $p[10]$ 匹配失败，查询得到 $F[9]=4$ ，所以下次直接让 $p[0..3]$ 和 $s[9..12]$ 对齐</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第三次匹配如下，发现 $s[13]$ 和 $p[4]$ 匹配失败，查询得到 $F[3]=1$ ， 所以下次直接让 $p[0]$ 和 $s[12]$ 对齐</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第四次匹配如下，发现 $s[13]$ 和 $p[1]$ 匹配失败，查询得到 $F[0]=0$ ， 所以下次只能老老实实把 $p$ 右移一位</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第五次匹配如下，匹配成功</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>还剩一个问题是如何预先求解数组 $F$ ，一种简单的方法是用两个指针 $i$、$j$ 错位遍历子串 $p$ 。初始化 $i=1$ 、 $j=0$ ，指针 $i$ 用于主循环，每当 $p[i]=p[j]$ 时，指针 $j$ 才加一，如果 $p[i]\neq p[j]$ 就把 $j$ 打回原位 $j=0$ ， $i$ 遍历的同时能够确定 $F[i]$ ，时间复杂度为 $O(N)$ ，随便用python写了一下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">while i&lt;len(a):</span><br><span class="line">    if a[i]!&#x3D;a[j]:</span><br><span class="line">        if j&#x3D;&#x3D;0:</span><br><span class="line">            b.append(0)</span><br><span class="line">        else:</span><br><span class="line">            if a[i]&#x3D;&#x3D;a[0]:</span><br><span class="line">                j&#x3D;1</span><br><span class="line">                b.append(1)</span><br><span class="line">            else:</span><br><span class="line">                j&#x3D;0</span><br><span class="line">                b.append(0)</span><br><span class="line">    else:</span><br><span class="line">        b.append(b[-1]+1)</span><br><span class="line">        j+&#x3D;1</span><br><span class="line">    i+&#x3D;1</span><br></pre></td></tr></table></figure></div><p>KMP算法的确能够减少匹配次数，一般认为其时间复杂度是 $O(M+N)$ ，但是极端情况下时间复杂度依然可以是 $O(M\times N)$ ，一种情况是子串的 $F$ 数组都是0时，完全用不到 $F$ ，就退化成了暴力检索，另一种情况是 $p=“aa…aa”$ ，最大相同前缀后缀分别就是 $p[0,i-1]$ 和 $p[1,i]$ ，利用 $F$ 数组就相当于只后移一位。</p><h1 id="三、RK算法"><a href="#三、RK算法" class="headerlink" title="三、RK算法"></a>三、RK算法</h1><p>RK算法全称Rabin-Karp字符串匹配算法，核心思想是利用字符串的哈希值比较替代逐字符匹配，因为一个足够好的哈希函数能够把不同的字符串映射到不同的哈希值，而把相同的字符串映射到相同的哈希值。对于一个 $N$ 位的字符串 $s$ 和一个 $M$ 位的模式串 $p$ ，依次计算 $s[0..M-1]$ 、 $s[M..2M-1]$ 、… 、 $s[N-M+1..N]$ 的哈希值，并与 $p$ 的哈希值进行比较。</p><p>由于哈希函数多少有一定的错误率，为了确保字符串匹配的准确度，当哈希值相同时，需要用传统的逐字符比较的方法进行验证，一般认为时间复杂度是 $O(M+N)$ ，但实际的时间复杂度与选择的哈希函数有很大关系，一个差的哈希函数也可以使时间复杂度趋近 $O(M\times N)$</p><h1 id="四、BM算法"><a href="#四、BM算法" class="headerlink" title="四、BM算法"></a>四、BM算法</h1><p>BM算法全称Boyer-Moore字符串搜索算法，与其他方法不同的是，BM算法从字符串尾部开始匹配，利用坏字符原则和好后缀原则优化模式串 $p$ 的移动距离。</p><p>坏字符原则：当匹配失败时， $s[i]\neq p[j]$ ，称 $s[i]$ 为坏字符。此时检查 $s[i]$ 是否出现在匹配失败位置的左侧，即 $p[0..j-1]$ 中是否存在 $p[k]$ 使得 $p[k]=s[i] (k&lt;j)$ ，如果存在一个或多个，选择其中最右的 $p[k]$ 与当前的 $s[i]$ 对齐，如果不存在，就把 $p[0..j-1]$ 全部移动到匹配失败位置后面，也就是把 $p[0]$ 和 $s[i+1]$ 对齐。</p><p>好后缀原则：当匹配失败时， $s[i]\neq p[j]$ ，此时检查模式串 $p$ 是否有后缀匹配成功，即 $p[k..m] (k&gt;j)$ 与 $s$ 的相应位置匹配成功，称这样的后缀为好后缀。如果不存在好后缀，就按照朴素方法把 $p$ 后移一位重新匹配。如果存在好后缀，首先检查最长的好后缀是否出现在匹配失败位置之前，即 $p[h..h+m-k]=p[k..m]$ ，如果出现了最长好后缀，就把 $p[h..h+m-k]$ 与当前的 $p[k..m]$ 对齐，如果没有出现，就按照由长到短的顺序依次检查其他好后缀，如果某个好后缀与 $p$ 的某个前缀相等，就把这对前缀后缀对齐。</p><p>匹配失败时，分别按照坏字符原则和好后缀原则计算模式串 $p$ 应该向后移动的距离，取二者的最大值作为实际移动距离。借用Moore教授提供的例子，</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr></tbody></table></div><p>第一次匹配如下，对子串 $p$ 从后往前检查，发现 $s[6]\neq p[6]$ 。根据坏字符原则，由于 $s[6]$ 没有在 $p[0..5]$ 中出现过，所以要把 $p[0..5]$ 全部移到坏字符 $s[6]$ 后面，也就是把 $p[0]$ 和 $s[7]$ 对齐，移动距离是7。根据好后缀原则，由于没有好后缀，只能按照朴素方法把 $p$ 后移一位。相比之下，坏字符原则确定的后移距离更长，所以移动距离是7。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第二次匹配如下，从后往前检查，发现 $s[13]\neq p[6]$ 。根据坏字符原则，由于 $s[13]=p[4]$ ，所以要把 $p[4]$ 和 $s[13]$ 对齐，移动距离是2。根据好后缀原则，由于没有好后缀，只能按照朴素方法把 $p$ 后移一位。相比之下，坏字符原则确定的后移距离更长，所以移动距离是2。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第三次匹配如下，从后往前检查，发现 $s[11]\neq p[2]$ 。根据坏字符原则，由于 $s[11]$ 没有在 $p[0..1]$ 中出现过，所以要把 $p[0..1]$ 全部移到坏字符 $s[11]$ 后面，也就是把 $p[0]$ 和 $s[12]$ 对齐，移动距离是3。根据好后缀原则，发现匹配到 $“mple”$ 、 $“ple”$ 、 $“le”$ 、 $“e”$ 四个好后缀，首先检查最长的好后缀 $“mple”$ 是否出现在匹配失败位置的左侧，发现不存在，然后依次检查其他好后缀是否匹配到子串 $p$ 的前缀，发现 $“e”$ 能够匹配到 $p$ 的前缀，所以把两个 $“e”$ 对齐，也就是把 $p[0]$ 和 $s[15]$ 对齐，移动距离是6。相比之下，好后缀原则确定的后移距离更长，所以移动距离是6。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第四次匹配如下，从后往前检查，发现 $s[21]\neq p[6]$ 。根据坏字符原则， $s[21]=p[4]$ ，所以应该把 $p[4]$ 和 $s[21]$ 对齐，移动距离是2。根据好后缀原则，由于没有好后缀，只能按照朴素方法把 $p$ 后移一位。相比之下，坏字符原则确定的后移距离更长，所以移动距离是2。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第五次匹配如下，匹配成功</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>BM算法是不稳定的贪心算法，最好情况下时间复杂度 $O(N\div M)$ ，最差情况下时间复杂度为 $O(M\times N)$ 。<a href="http://ddrv.cn/a/55208" target="_blank" rel="noopener">某篇文章</a>里对BF、KMP、BM三种算法进行了测试对比，结果表明匹配花费的时间 $BM&lt;BF&lt;KMP$ ，可见KMP只是理论上的优化，实际使用时很难遇到较多的相同前缀后缀，对此复杂的优化操作就变得多余，导致算法效率甚至不如暴力检索。</p><h1 id="五、Horspool-算法"><a href="#五、Horspool-算法" class="headerlink" title="五、Horspool 算法"></a>五、Horspool 算法</h1><p>就是BM算法中的坏字符原则</p><h1 id="六、Sunday-算法"><a href="#六、Sunday-算法" class="headerlink" title="六、Sunday 算法"></a>六、Sunday 算法</h1><p>Sunday 算法从左到右匹配，但每次匹配失败后查看 $s$ 中参与匹配的最后一个字符的下一个字符，在 $p$ 中查找是否存在该字符，也就是当 $p[M-1]$ 与 $s[k]$ 对齐时，查看 $s[k+1]$ 是否在 $p$ 中出现。如果出现一次或多次，把最右的一个与 $s[k+1]$ 对齐，如果没有出现，就把 $p[0]$ 和 $s[k+2]$ 对齐，相当于整个子串跳过 $s[k+1]$ ，举例说明，</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr></tbody></table></div><p>第一次匹配如下，从左到右检查，发现 $s[1]\neq p[1]$ ，此时查看 $p[5]$ 所对应的 $s$ 中的字符的下一个字符，也就是 $s[6]$ 是否出现在 $p$ 中，结果是没有出现，所以直接把 $p[0]$ 和 $s[7]$ 对齐。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table></div><p>第二次匹配如下，从左到右检查，发现 $s[7]\neq p[0]$ ，此时查看 $s[13]$ 是否出现在 $p$ 中，结果 $s[13]=p[3]$，所以把 $p[3]$ 和 $s[13]$ 对齐。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table></div><p>第三次匹配如下，匹配成功。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table></div><p>Sunday算法类似于BM算法，是不稳定的贪心算法，时间复杂度也和BM算法一样，最好情况下时间复杂度 $O(N\div M)$ ，最差情况下时间复杂度为 $O(M\times N)$ 。二者的思路都是在匹配失败时从尾部入手，便于找到一个相对较远的位置，把模式串移动到该位置，同时保证移动到左侧的任何位置时都无法匹配成功，从而有效减少了匹配次数。</p><h1 id="七、AC自动机"><a href="#七、AC自动机" class="headerlink" title="七、AC自动机"></a>七、AC自动机</h1><p>AC自动机全称Aho–Corasick算法，是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法。传统的字符串匹配算法只能同时搜索一个子串 $p$ ，在多模式串匹配任务中只能针对每个子串 $p$ 分别从头到尾扫描一遍母串，效率非常低。AC自动机针使用了Trie树存储所有的子串，树的每个节点表示一个字符，以遍历节点的方式匹配母串，每当匹配失败时，转向当前节点的Fail节点继续匹配，母串也可以从当前位置继续向后匹配而不需要返回头部，如此可以实现只遍历母串一次来匹配所有的子串。以下例子转自<a href="https://www.jianshu.com/p/2ad417a184fd" target="_blank" rel="noopener">别人的转自</a>，</p><p>假设子串集合为 $p={she,he,say,her,shr}$ ，母串是 $yasherhs$ 。首先根据子串的集合构造Trie树(过程简单直接略过)，结果如下。</p><p><a href="https://file.shivakasu.cn/364f6662c4b968167ac6/arg1-0.png" data-fancybox="group" data-caption="Trie树" class="fancybox"><img alt="Trie树" title="Trie树" data-src="https://file.shivakasu.cn/364f6662c4b968167ac6/arg1-0.png" class="lazyload"></a></p><p>注意需要为节点添加一个指针属性，在Trie树构建完毕后，将每个节点的该指针指向他的Fail节点，设置好Fail节点的Trie树如下。假设节点 $i$ 的Fail节点是节点 $j$ ，从根节点到节点 $i$ 的字符串记为 $word[i]$ ，从根节点到节点 $j$ 的字符串记为 $word[j]$ ，那么Fail节点的含义就是 $word[j]$ 是 $word[i]$ 在树中以根节点为起点的最长后缀。例如图中右侧 $she$ 的 $e$ 节点的Fail节点是左侧 $he$ 的 $e$ 节点，表示 $he$ 是 $she$ 在树中的最长后缀。</p><p><a href="https://file.shivakasu.cn/bfcf8fb05a570058e756/arg1-1.png" data-fancybox="group" data-caption="带Fail指针的Trie树" class="fancybox"><img alt="带Fail指针的Trie树" title="带Fail指针的Trie树" data-src="https://file.shivakasu.cn/bfcf8fb05a570058e756/arg1-1.png" class="lazyload"></a></p><p>Fail节点的设置只需要遵循一个原则，一个节点 $i$ 的Fail指针指向他父节点的Fail节点的与 $i$ 同名的子节点。这里涉及了四个节点，举例来说，为图中最右的 $h$ 节点指定Fail节点，他的父节点是 $s$ ， $s$ 的Fail指针指向根节点，根节点的孩子中存在与 $h$ 同名的节点，也就是最左的 $h$ 节点，所以最右的 $h$ 节点的Fail指针应该指向最左的 $h$ 节点。如果不存在这样的节点，就把Fail指针指向根节点，比如图中两个 $r$ 节点。此外，根节点不需要设置Fail指针。在这个过程中，回溯父节点的步骤可以通过递归实现，遍历到子节点的同时把父节点的Fail指针传递给子节点。</p><p>母串 $yasherhs$ 的匹配过程：<br>第一步，当前节点是根节点，查找字符是 $y$ ，发现根节点没有为 $y$ 的子节点，又因为根节点没有Fail节点，所以留在原地，母串索引加一。<br>第二步，当前节点是根节点，查找字符是 $a$ ，发现根节点没有为 $a$ 的子节点，又因为根节点没有Fail节点，所以留在原地，母串索引加一。<br>第三步，当前节点是根节点，查找字符是 $s$ ，因此转到根节点的右子节点 $s$ ，匹配成功，母串索引加一。<br>第四步，当前节点是 $s$ ，查找字符是 $h$ ，因此转到根节点的右子节点 $h$ ，匹配成功，母串索引加一。<br>第五步，当前节点是 $h$ ，查找字符是 $e$ ，因此转到根节点的左子节点 $e$ ，该节点同时是词尾节点，说明子串 $she$ 匹配成功，母串索引加一。<br>第六步，当前节点是 $e$ ，查找字符是 $r$ ，因为当前节点没有子节点，匹配失败，转向他的Fail节点，也就是左侧的 $e$ 节点，发现该节点是词尾节点，说明子串 $he$ 匹配成功，同时该节点的子节点包含目标字符 $r$ ，因此转向左子节点 $r$ ，发现节点 $r$ 也是词尾节点，说明子串 $her$ 匹配成功。母串索引加一。<br>第七步，当前节点是 $r$ ，查找字符是 $h$ ，因为当前节点没有子节点，匹配失败，转向他的Fail节点，也就是根节点，根节点的子节点包含目标字符 $h$ ，因此转向左侧的节点 $h$ ，母串索引加一。<br>第八步，当前节点是 $h$ ，查找字符是 $s$ ，因为当前节点的子节点没有 $s$ ，匹配失败，转向他的Fail节点，也就是根节点，根节点的子节点包含目标字符 $s$ ，因此转向右侧的节点 $s$ ，母串索引到头了，匹配结束。</p><p>整个匹配过程中，母串仅遍历了一次，匹配了多个子串，大大提高了匹配效率。Fail指针的合理性在于指向以根节点为起点的最长后缀，一方面，以根节点为起始说明这个后缀同时也是某个子串的前缀，从Fail节点开始匹配就相当于在默认匹配了某个子串前缀的条件下，从该子串的中间继续匹配。另一方面，指向最长后缀能够保证不会漏掉能够匹配到子串的有效后缀，假如一个节点有两个有效后缀，一定是该节点的Fail指针指向最长后缀，最长后缀的Fail指针指向次长后缀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="http://shivakasu.github.io/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《程序员代码面试指南》阅后简记</title>
    <link href="http://shivakasu.github.io/2020/01/10/arg0/"/>
    <id>http://shivakasu.github.io/2020/01/10/arg0/</id>
    <published>2020-01-09T16:43:20.000Z</published>
    <updated>2020-01-16T02:55:50.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-栈和队列"><a href="#第一章-栈和队列" class="headerlink" title="第一章 栈和队列"></a>第一章 栈和队列</h1><h2 id="1-1-getmin-栈"><a href="#1-1-getmin-栈" class="headerlink" title="1.1  $getmin$ 栈"></a>1.1  $getmin$ 栈</h2><p>用两个栈， $A$ 正常使用， $B$ 在 $A$ 的 $push$ 和 $pop$ 时保持栈顶是 $A$ 的最小值</p><h2 id="1-2-两个栈组成队列"><a href="#1-2-两个栈组成队列" class="headerlink" title="1.2 两个栈组成队列"></a>1.2 两个栈组成队列</h2><p>两个栈方向相反， $A$ 压栈代表入队， $B$ 退栈代表出队，当 $B$ 为空时，把 $A$ 反向导入 $B$ </p><p>问题是不能保证出队 $O(1)$ ？</p><h2 id="1-3-用递归函数和栈逆序一个栈"><a href="#1-3-用递归函数和栈逆序一个栈" class="headerlink" title="1.3 用递归函数和栈逆序一个栈"></a>1.3 用递归函数和栈逆序一个栈</h2><p>两个递归函数， $A$ 递归 $pop$ 栈中所有元素，返回最后一个元素，再把剩下的 $push$ 回去。 $B$ 递归调用 $A$ ，把 $A$ 返回的 $push$ 回去</p><h2 id="1-4-猫狗队列"><a href="#1-4-猫狗队列" class="headerlink" title="1.4 猫狗队列"></a>1.4 猫狗队列</h2><p>一个队列存猫，一个队列存狗，一个数组用01标注存放顺序</p><h2 id="1-5-用一个栈实现另一个栈的排序"><a href="#1-5-用一个栈实现另一个栈的排序" class="headerlink" title="1.5 用一个栈实现另一个栈的排序"></a>1.5 用一个栈实现另一个栈的排序</h2><p>把A栈的依次 $pop$ ，如果比B栈顶大就 $push$ 到 $B$ ，否则把 $B$ $pop$ 并 $push$ 回 $A$ 直到比 $B$ 栈顶大，核心就是利用两个栈来回倒，用一个临时变量做插入排序</p><h2 id="1-6-用栈求解汉诺塔"><a href="#1-6-用栈求解汉诺塔" class="headerlink" title="1.6 用栈求解汉诺塔"></a>1.6 用栈求解汉诺塔</h2><p>递归思路：把 $1\sim N$ 从左移动到右，相当于把 $1\sim(N-1)$ 从左移动到中，再把 $N$ 从左移动到右，再把 $1\sim(N-1)$ 从中移动到右</p><p><span id="jump"></span></p><h2 id="1-7-生成窗口最大值数组"><a href="#1-7-生成窗口最大值数组" class="headerlink" title="1.7 生成窗口最大值数组"></a>1.7 生成窗口最大值数组</h2><p>维护一个最大长度为 $k$ 的队列，保证队头是当前位置往前 $k$ 个数的从大到小的下标，遇到较大值就弃掉前边比他小的</p><h2 id="1-8-maxtree"><a href="#1-8-maxtree" class="headerlink" title="1.8 maxtree"></a>1.8 maxtree</h2><p>对每一个元素，从左边和右边各选择第一个比这个元素大的值，选择值较小的元素作为父节点。证明过程就是先证明结果只有一棵树，再证明数组里每个元素在左右两侧最多分别有一个孩子</p><h2 id="1-9-最大子矩阵"><a href="#1-9-最大子矩阵" class="headerlink" title="1.9 最大子矩阵"></a>1.9 最大子矩阵</h2><p>以每一行为底，算出每行的纵向向上连续高度，根据高度差找最大矩阵</p><h2 id="1-10-最大值减最小值小于等于-num-的子数组数量"><a href="#1-10-最大值减最小值小于等于-num-的子数组数量" class="headerlink" title="1.10 最大值减最小值小于等于 $num$ 的子数组数量"></a>1.10 最大值减最小值小于等于 $num$ 的子数组数量</h2><p>仿照 <a href="#jump">1.7</a> 维护两个队列，分别存储最大值和最小值的下标，若 $a[i,j]$ 满足/不满足条件，她的所有子数组也满足/不满足条件，因此只需要两个 $flag$ 遍历数组， $j$ 向后遍历，遇到不满足的就让 $i+1$ ，再接着遍历 $j$ </p><h1 id="第二章-链表问题"><a href="#第二章-链表问题" class="headerlink" title="第二章 链表问题"></a>第二章 链表问题</h1><h2 id="2-1-打印两个有序链表的公共部分"><a href="#2-1-打印两个有序链表的公共部分" class="headerlink" title="2.1 打印两个有序链表的公共部分"></a>2.1 打印两个有序链表的公共部分</h2><p>因为是有序的，所以就交错遍历，遇到相等就打印</p><h2 id="2-2-在单链表和双向链表中删除倒数第k个节点"><a href="#2-2-在单链表和双向链表中删除倒数第k个节点" class="headerlink" title="2.2 在单链表和双向链表中删除倒数第k个节点"></a>2.2 在单链表和双向链表中删除倒数第k个节点</h2><p>遍历两次</p><h2 id="2-3-删除链表的中间节点"><a href="#2-3-删除链表的中间节点" class="headerlink" title="2.3 删除链表的中间节点"></a>2.3 删除链表的中间节点</h2><p>立个 $flag$ 表示中点，一边遍历一边移动 $flag$ </p><p><span id="jump2"></span></p><h2 id="2-4-反转单向和双向链表"><a href="#2-4-反转单向和双向链表" class="headerlink" title="2.4 反转单向和双向链表"></a>2.4 反转单向和双向链表</h2><p>维护三个指针，每次反转一条边</p><h2 id="2-5-反转部分单向链表"><a href="#2-5-反转部分单向链表" class="headerlink" title="2.5 反转部分单向链表"></a>2.5 反转部分单向链表</h2><p>把中间那段提出来仿照 <a href="#jump2">2.4</a> 反转，再反过来拼接上</p><h2 id="2-6-环形链表的约瑟夫问题"><a href="#2-6-环形链表的约瑟夫问题" class="headerlink" title="2.6 环形链表的约瑟夫问题"></a>2.6 环形链表的约瑟夫问题</h2><p>简单版：模拟过程转圈找   </p><p>进阶版：总结出递归表达式提前算出答案</p><h2 id="2-7-判断链表是否回文"><a href="#2-7-判断链表是否回文" class="headerlink" title="2.7 判断链表是否回文"></a>2.7 判断链表是否回文</h2><p>简单版：遍历两次，空间 $O(N)$   </p><p>进阶版：反转后半部分指向中间节点，从两头同时遍历，空间 $O(1)$ </p><h2 id="2-8-单链表划分成左边小中间相等右边大"><a href="#2-8-单链表划分成左边小中间相等右边大" class="headerlink" title="2.8 单链表划分成左边小中间相等右边大"></a>2.8 单链表划分成左边小中间相等右边大</h2><p>遍历一遍，把链表拆成三段，再把三段拼起来，因为是对原链表的指针操作，所以空间 $O(1)$ </p><h2 id="2-9-复制含有随机指针节点的链表"><a href="#2-9-复制含有随机指针节点的链表" class="headerlink" title="2.9 复制含有随机指针节点的链表"></a>2.9 复制含有随机指针节点的链表</h2><p>简单版：遍历两次，使用哈希表确定节点 </p><p>进阶版：遍历两次，第一次在每个节点后边生成复制节点，第二次复制连接，最后分离原始链表和复制链表，不必使用额外数据结构</p><h2 id="2-10-两个单链表模拟整数相加"><a href="#2-10-两个单链表模拟整数相加" class="headerlink" title="2.10 两个单链表模拟整数相加"></a>2.10 两个单链表模拟整数相加</h2><p>用栈或反转链表，目的是实现低位到高位的计算</p><h2 id="2-11-一个链表是否有环"><a href="#2-11-一个链表是否有环" class="headerlink" title="2.11 一个链表是否有环"></a>2.11 一个链表是否有环</h2><p>快慢指针追逐法，第一次相遇后快指针变慢指针从头跑，两个慢指针会在入环点相遇</p><h2 id="2-12-两个无环链表是否相交"><a href="#2-12-两个无环链表是否相交" class="headerlink" title="2.12 两个无环链表是否相交"></a>2.12 两个无环链表是否相交</h2><p>因为是单链表，所以一旦相交，后续将合并成一个链表，因此只需要对比两个链表的尾结点</p><h2 id="2-13-两个有环链表是否相交"><a href="#2-13-两个有环链表是否相交" class="headerlink" title="2.13 两个有环链表是否相交"></a>2.13 两个有环链表是否相交</h2><p>找到两个入环点，追逐法判断是否是同一个环</p><h2 id="2-14-将单链表每k个节点之间逆序"><a href="#2-14-将单链表每k个节点之间逆序" class="headerlink" title="2.14 将单链表每k个节点之间逆序"></a>2.14 将单链表每k个节点之间逆序</h2><p>计数反转后拼接</p><h2 id="2-15-删除无序单链表中值重复的节点"><a href="#2-15-删除无序单链表中值重复的节点" class="headerlink" title="2.15 删除无序单链表中值重复的节点"></a>2.15 删除无序单链表中值重复的节点</h2><p>方法一：哈希表，遍历一遍，时间空间都是 $O(N)$   </p><p>方法二：从每个节点遍历一遍，时间 $O(N^2)$ ，空间 $O(1)$ </p><h2 id="2-16-单链表删除指定值的节点"><a href="#2-16-单链表删除指定值的节点" class="headerlink" title="2.16 单链表删除指定值的节点"></a>2.16 单链表删除指定值的节点</h2><p>直接遍历，时间 $O(N)$ ，空间 $O(1)$ </p><h2 id="2-17-二叉树转双向链表"><a href="#2-17-二叉树转双向链表" class="headerlink" title="2.17 二叉树转双向链表"></a>2.17 二叉树转双向链表</h2><p>用队列保存中序遍历，再依次出队重连</p><h2 id="2-18-单链表选择排序"><a href="#2-18-单链表选择排序" class="headerlink" title="2.18 单链表选择排序"></a>2.18 单链表选择排序</h2><p>时间 $O(N^2)$ ，空间 $O(1)$ </p><h2 id="2-19-怪异的节点删除方式"><a href="#2-19-怪异的节点删除方式" class="headerlink" title="2.19 怪异的节点删除方式"></a>2.19 怪异的节点删除方式</h2><p>要删除节点 $A$ ，可以先把 $A.next$ 的数据复制到 $A$ ，把 $A$ 指向 $A.next.next$ ，本质上只是复制数据，没有删除节点</p><h2 id="2-20-向有序环形单链表插入新节点"><a href="#2-20-向有序环形单链表插入新节点" class="headerlink" title="2.20 向有序环形单链表插入新节点"></a>2.20 向有序环形单链表插入新节点</h2><p>遍历，插入</p><h2 id="2-21-合并两个有序单链表"><a href="#2-21-合并两个有序单链表" class="headerlink" title="2.21 合并两个有序单链表"></a>2.21 合并两个有序单链表</h2><p>一个插到另一个里，时间 $O(M+N)$ ，空间 $O(1)$ </p><h2 id="2-22-按照左右半区重新组合单链表"><a href="#2-22-按照左右半区重新组合单链表" class="headerlink" title="2.22 按照左右半区重新组合单链表"></a>2.22 按照左右半区重新组合单链表</h2><p>提前知道链表长度，找到左右半区的头节点，交叉拼接</p><h1 id="第三章-二叉树问题"><a href="#第三章-二叉树问题" class="headerlink" title="第三章 二叉树问题"></a>第三章 二叉树问题</h1><h2 id="3-1-非递归二叉树先序遍历"><a href="#3-1-非递归二叉树先序遍历" class="headerlink" title="3.1 非递归二叉树先序遍历"></a>3.1 非递归二叉树先序遍历</h2><p>一个栈，压入头节点，[ 弹，右，左，弹 ] 循环</p><h2 id="3-2-非递归二叉树中序遍历"><a href="#3-2-非递归二叉树中序遍历" class="headerlink" title="3.2 非递归二叉树中序遍历"></a>3.2 非递归二叉树中序遍历</h2><p>一个栈，循环压左到 $null$ ，弹出栈顶节点并转到他的右节点，这两步循环</p><h2 id="3-3-非递归二叉树后序遍历"><a href="#3-3-非递归二叉树后序遍历" class="headerlink" title="3.3 非递归二叉树后序遍历"></a>3.3 非递归二叉树后序遍历</h2><p>两个栈， $A$ 栈中，弹，左，右循环，弹出到 $B$ 栈，最后 $B$ 全部弹出</p><h2 id="3-4-打印二叉树边界节点"><a href="#3-4-打印二叉树边界节点" class="headerlink" title="3.4 打印二叉树边界节点"></a>3.4 打印二叉树边界节点</h2><p>得到二叉树每层的左右边界：遍历得到树的高度 $h$ ，建立二维数组 $edge[h][2]$ ，递归先序遍历，数组第一位保存每层最先遍历到的节点，也就是左边界，每遍历到新的节点就更新数组的第二位，最终保存的就是右边界  </p><h2 id="3-5-直观打印二叉树"><a href="#3-5-直观打印二叉树" class="headerlink" title="3.5 直观打印二叉树"></a>3.5 直观打印二叉树</h2><p>右中左遍历并打印，因为纵向看，每一个节点都可以占单独的一列，无脑输出换行就行</p><h2 id="3-6-二叉树的序列化和反序列化"><a href="#3-6-二叉树的序列化和反序列化" class="headerlink" title="3.6 二叉树的序列化和反序列化"></a>3.6 二叉树的序列化和反序列化</h2><p>先序遍历+分隔符，把 $null$ 也记录下，方便计算子树在字符串中的范围。核心思想是用 $null$ 占位变成满二叉树，节点位置就可以计算了</p><h2 id="3-7-遍历二叉树的神级方法"><a href="#3-7-遍历二叉树的神级方法" class="headerlink" title="3.7 遍历二叉树的神级方法"></a>3.7 遍历二叉树的神级方法</h2><p>$Morris$ 遍历法，不使用递归和栈结构保存历史，让每个节点的左子树的最右节点指向该节点，核心思想是修改 $null$ 指针实现遍历时的回溯</p><h2 id="3-8-在二叉树中找到累加和为指定值的最长路径长度"><a href="#3-8-在二叉树中找到累加和为指定值的最长路径长度" class="headerlink" title="3.8 在二叉树中找到累加和为指定值的最长路径长度"></a>3.8 在二叉树中找到累加和为指定值的最长路径长度</h2><p>先序遍历二叉树，对每条路径应用 <a href="#jump5">8.11</a> 的方法，但是从左子树转到右子树时要把左子树在哈希表的记录删除，可以通过在哈希表记录节点的所在层次判断</p><h2 id="3-9-找到二叉树中的最大搜索二叉子树"><a href="#3-9-找到二叉树中的最大搜索二叉子树" class="headerlink" title="3.9 找到二叉树中的最大搜索二叉子树"></a>3.9 找到二叉树中的最大搜索二叉子树</h2><p>递归后序遍历，遍历完左右子树后，如果都是搜索二叉树，那么最大搜索二叉树要么是包括父节点的整棵树，要么是左右子树里节点多的那个，通过比较节点值可以确定</p><h2 id="3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构"><a href="#3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构" class="headerlink" title="3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构"></a>3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构</h2><p>自顶向下法：以每个节点为头节点往下找，满足条件就计数，时间 $O(N^2)$  </p><p>自底向上法：后序遍历，记录左右子树对父节点能贡献多少个满足条件的节点，空间 $O(N)$ ，根据树的形状，时间最优 $O(N)$ 最差 $O(NlogN)$ ，证明懒得看</p><h2 id="3-11-二叉树按层打印和-zigzag-打印"><a href="#3-11-二叉树按层打印和-zigzag-打印" class="headerlink" title="3.11 二叉树按层打印和 $zigzag$ 打印"></a>3.11 二叉树按层打印和 $zigzag$ 打印</h2><p>按层打印：使用队列，根据当前层的末尾标记出队，出队的时候把其子节点入队，入队同时更新标记下层的最后一个节点，也就是用两个末尾标记实现在队列里区分层次  </p><p>$zigzag$ 打印：双端队列，头进尾出和尾进头出交替进行</p><h2 id="3-12-调整搜索二叉树中两个错误节点"><a href="#3-12-调整搜索二叉树中两个错误节点" class="headerlink" title="3.12 调整搜索二叉树中两个错误节点"></a>3.12 调整搜索二叉树中两个错误节点</h2><p>中序遍历，如果降序一次，错的就是降序的两个节点，如果降序两次，错的是第一次的大节点和第二次的小节点。交换两个节点时要考虑各种连接情况</p><h2 id="3-13-判断-t1-树是否包含-t2-树全部的拓扑结构"><a href="#3-13-判断-t1-树是否包含-t2-树全部的拓扑结构" class="headerlink" title="3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构"></a>3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构</h2><p>把所有头节点与 $t2$ 相同的子树都匹配一遍，时间 $O(M\times N)$ </p><h2 id="3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树"><a href="#3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树" class="headerlink" title="3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树"></a>3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树</h2><p>方法一同上，方法二遍历成字符串，看 $t2$ 是不是 $t1$ 子串，时间 $O(M+N)$ </p><h2 id="3-15-判断二叉树是否是平衡二叉树"><a href="#3-15-判断二叉树是否是平衡二叉树" class="headerlink" title="3.15 判断二叉树是否是平衡二叉树"></a>3.15 判断二叉树是否是平衡二叉树</h2><p>后序遍历，记录遍历深度，递归检验左右子树是否是平衡二叉树</p><h2 id="3-16-根据后序数组重建搜索二叉树"><a href="#3-16-根据后序数组重建搜索二叉树" class="headerlink" title="3.16 根据后序数组重建搜索二叉树"></a>3.16 根据后序数组重建搜索二叉树</h2><p>后序遍历头节点都在末尾，比值确定前面左右子树分界</p><h2 id="3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树"><a href="#3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树" class="headerlink" title="3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树"></a>3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树</h2><p>搜索二叉树：中序遍历一遍   </p><p>完全二叉树：按层遍历，节点不够时判断是否时靠左排的叶节点</p><h2 id="3-18-通过有序数组生成平衡搜索二叉树"><a href="#3-18-通过有序数组生成平衡搜索二叉树" class="headerlink" title="3.18 通过有序数组生成平衡搜索二叉树"></a>3.18 通过有序数组生成平衡搜索二叉树</h2><p>数组中间的节点就是头节点，再递归处理左右子树</p><h2 id="3-19-在二叉树中找到一个节点中序遍历的后继节点"><a href="#3-19-在二叉树中找到一个节点中序遍历的后继节点" class="headerlink" title="3.19 在二叉树中找到一个节点中序遍历的后继节点"></a>3.19 在二叉树中找到一个节点中序遍历的后继节点</h2><p>先找右子树，再回溯父节点</p><h2 id="3-20-在二叉树中找到两个节点的最近公共祖先"><a href="#3-20-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="3.20 在二叉树中找到两个节点的最近公共祖先"></a>3.20 在二叉树中找到两个节点的最近公共祖先</h2><p>后序遍历，遍历左右子树后返回是否有目标节点，当左右子树都各找到一个目标节点是，当前节点就是最近祖先</p><h2 id="3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题"><a href="#3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题" class="headerlink" title="3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题"></a>3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题</h2><p>单独写</p><h2 id="3-22-二叉树节点间的最大距离"><a href="#3-22-二叉树节点间的最大距离" class="headerlink" title="3.22 二叉树节点间的最大距离"></a>3.22 二叉树节点间的最大距离</h2><p>最大距离有三种可能：左子树最大距离，右子树最大距离，左子树深度+1+右子树深度。后序遍历一次，同时记录子树最大距离和深度，比值得出结果</p><h2 id="3-23-先中后序数组两两结合重构二叉树"><a href="#3-23-先中后序数组两两结合重构二叉树" class="headerlink" title="3.23 先中后序数组两两结合重构二叉树"></a>3.23 先中后序数组两两结合重构二叉树</h2><p>先后序数组根节点在两端，代入中序数组可以区分左右子树。  </p><p>只有先后序时，由于左右可以混淆，如果有任一节点只有一个子节点，都无法重构原二叉树，先序中根节点之后就是左子树根节点，后序数组中左子树根节点之前的就是左子树，因此利用先后序数组可以区分左右子树。</p><h2 id="3-24-通过先序和中序数组生成后序数组"><a href="#3-24-通过先序和中序数组生成后序数组" class="headerlink" title="3.24 通过先序和中序数组生成后序数组"></a>3.24 通过先序和中序数组生成后序数组</h2><p>用先序数组确定后序数组最右的值，再利用中序数组分离出左右子树的先中序数组，重复这两步，把后序数组从右到左填满</p><h2 id="3-25-统计和生成所有不同的二叉树"><a href="#3-25-统计和生成所有不同的二叉树" class="headerlink" title="3.25 统计和生成所有不同的二叉树"></a>3.25 统计和生成所有不同的二叉树</h2><p>中序遍历为 $1\sim N$ 的一定是搜索二叉树，找规律，如果 $i$ 是头节点，则左子树有 $i-1$ 个节点，右子树有 $N-i$ 个节点，所以 $num(N)=\sum_{i=1}^Nnum(i-1)*num(N-i)$ </p><h2 id="3-26-统计完全二叉树的节点数"><a href="#3-26-统计完全二叉树的节点数" class="headerlink" title="3.26 统计完全二叉树的节点数"></a>3.26 统计完全二叉树的节点数</h2><p>一直向左遍历可以得到树的深度，因为完全二叉树叶节点靠左排列，所以遍历一个节点的右子树的最左节点，得到右子树的深度，如果等于整个树的深度，说明左子树节点是满的，循环这个步骤遍历右子树，如果深度小于树的深度，说明在这个深度下右子树节点是满的，循环这个步骤遍历左子树</p><h1 id="第四章-递归和动态规划"><a href="#第四章-递归和动态规划" class="headerlink" title="第四章 递归和动态规划"></a>第四章 递归和动态规划</h1><p>优化思路：压缩空间，枚举简化</p><h2 id="4-1-求斐波那契第N项"><a href="#4-1-求斐波那契第N项" class="headerlink" title="4.1 求斐波那契第N项"></a>4.1 求斐波那契第N项</h2><p>递归向下算，时间 $O(2^N)$   </p><p>从左向右依次算每一项，时间 $O(N)$   </p><p>用通项公式直接算，时间 $O(logN)$   </p><h2 id="4-2-斐波那契求奶牛数量"><a href="#4-2-斐波那契求奶牛数量" class="headerlink" title="4.2 斐波那契求奶牛数量"></a>4.2 斐波那契求奶牛数量</h2><p>$C(n)=C(n-1)+C(n-3)$ ，上一年的都活下来，三年前出生的都生一头小的，状态矩阵是三阶的</p><p><span id="jump3"></span></p><h2 id="4-3-矩阵的最小路径和"><a href="#4-3-矩阵的最小路径和" class="headerlink" title="4.3 矩阵的最小路径和"></a>4.3 矩阵的最小路径和</h2><p>动态规划，从左上角算到右下角，时间空间都是 $O(M\times N)$ ，只维护一行(列)空间时，向右或向下滚动更新，可以把空间压缩到 $O(min(M,N))$ ，之所以不用维护两行(列)是因为从前到后更新就相当于维护了两行(列)<br>P.S.：一般动态规划问题都可以用压缩空间的优化方法</p><h2 id="4-4-换钱的最少货币数"><a href="#4-4-换钱的最少货币数" class="headerlink" title="4.4 换钱的最少货币数"></a>4.4 换钱的最少货币数</h2><p>货币无限+面值不重复：维护二维数组，货币种类数*目标钱数，数组元素表示使用前 $i$ 种货币组成 $j$ 钱数需要的最少张数，遍历到 $dp[i][j]$ 时，枚举所有可能的 $k\geq0$ ，选择使用 $k$ 张当前货币时，最少张数的子问题。   </p><p>货币仅一张+面值可重复：和上面一样，只用做一次选择就够了，不用遍历所有 $k$ 。</p><h2 id="4-5-换钱的方法数"><a href="#4-5-换钱的方法数" class="headerlink" title="4.5 换钱的方法数"></a>4.5 换钱的方法数</h2><p>暴力搜索： $i$ 张第一+ $j$ 张第二+ $k$ 张第三……，时间最差 $O(aim^N)$  </p><p>带记忆的暴力搜索：避免重复计算，时间 $O(N\times aim^2)$     </p><p>经典动态规划：和上题一样，把值换成方法数，时间 $O(N\times aim^2)$   </p><p>时间复杂度一样是因为记忆搜索和经典动态规划的本质都是避免重复计算   </p><p>优化的动态规划(上题也可以用)：枚举所有可能的 $k\geq0$ 可以分成两部分，不用和必用当前货币，不用就是 $dp[i-1][j]$ ，必用本质上是 $dp[i][j-当前货币值]$ ，所以枚举的过程可以省去。时间 $O(N\times aim)$ </p><h2 id="4-6-最长递增子序列"><a href="#4-6-最长递增子序列" class="headerlink" title="4.6 最长递增子序列"></a>4.6 最长递增子序列</h2><p>经典： $dp[i]$ 表示以 $arr[i]$ 结尾的最长递增子序列长度，枚举前面所有结尾比 $arr[i]$ 小的 $dp[k]$ ，最后根据 $arr$ 和 $dp$ 数组得出序列， $O(N^2)$   </p><p>优化：建立辅助数组，记录长度为k的递增子序列最小结尾数，把枚举转化为在此数组上二分查找， $O(NlogN)$ </p><h2 id="4-7-汉诺塔"><a href="#4-7-汉诺塔" class="headerlink" title="4.7 汉诺塔"></a>4.7 汉诺塔</h2><p>递归， $n-1$ 左右中， $1$ 左中右， $n-1$ 中左右，每次在两个柱子间移动要考虑第三个柱子是为了递归的时候变换柱子的位置</p><h2 id="4-8-判断给的状态是不是汉诺塔最优过程中的某个状态"><a href="#4-8-判断给的状态是不是汉诺塔最优过程中的某个状态" class="headerlink" title="4.8 判断给的状态是不是汉诺塔最优过程中的某个状态"></a>4.8 判断给的状态是不是汉诺塔最优过程中的某个状态</h2><p>通过 $n$ 的位置可以知道进行到三个步骤中的哪个，然后递归检查 $n-1$ ，最后一定能确定具体步骤</p><h2 id="4-9-最长公共子序列"><a href="#4-9-最长公共子序列" class="headerlink" title="4.9 最长公共子序列"></a>4.9 最长公共子序列</h2><p>$dp[i][j]$ 表示 $str1[:i]$ 与 $str2[:j]$ 的最长公共子序列长度，取值为 $max{dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1(当前两个字符相同时)}$ ，获取序列要从右下角回溯，选择了三个值的哪一个就移动到他的位置，如果选择了 $dp[i-1][j-1]+1$ 就把当前字符放进结果</p><h2 id="4-10-最长公共子串"><a href="#4-10-最长公共子串" class="headerlink" title="4.10 最长公共子串"></a>4.10 最长公共子串</h2><p>经典： $dp[i][j]$ 表示以 $str1[i]$ 与 $str2[j]$ 结尾的最长公共子串长度，要么是 $0$ ，要么是 $dp[i-1][j-1]+1$ ，根据最大的 $dp$ 值直接得到子串，空间 $O(M\times N)$   </p><p>压缩：由于 $dp[i][j]$ 只和左上角的值有关，可以从左上到右下按斜线更新，一次更新一个，空间 $O(1)$ </p><h2 id="4-11-最小编辑代价"><a href="#4-11-最小编辑代价" class="headerlink" title="4.11 最小编辑代价"></a>4.11 最小编辑代价</h2><p>$dp[i][j]$ 表示 $str1[0,i-1]$ 编辑成 $str2[0,j-1]$ 的最小代价，第一行和第一列是全添和全删，中间的 $dp[i][j]$ 有四种取值： $dp[i-1][j]+删$ ，表示删去 $str1[i-1]$ 后把 $str1[0,i-2]$ 编辑成 $str2[0,j-1]$ ， $dp[i][j-1]+添$ ，表示把 $str1[0,i-1]$ 编辑成 $str2[0,j-2]$ 后添加 $str2[j-1]$ ， $dp[i-1][j-1]+改$ ，表示把 $str1[0,i-2]$ 编辑成 $str2[0,j-2]$ 后修改最后一个字符， $dp[i-1][j-1]$ ，表示当前两个字符正好相等   </p><p>压缩：因为可取值太多，要维护两行(列)</p><h2 id="4-12-字符串的交错组成"><a href="#4-12-字符串的交错组成" class="headerlink" title="4.12 字符串的交错组成"></a>4.12 字符串的交错组成</h2><p>$dp[i][j]$ 表示 $aim[0,i+j-1]$ 能否被 $str1[0,i-1]$ 和 $str2[0,j-1]$ 交错组成，第一行和第一列就是和两个字符串单独比较，中间的 $dp[i][j]=true$ 有两种情况： $str1[i-1]=aim[i+j-1]$ 且 $dp[i-1][j]=true$ ， $str2[j-1]=aim[i+j-1]$ 且 $dp[i][j-1]=true$ ，其余情况都是 $false$ </p><h2 id="4-13-龙与地下城"><a href="#4-13-龙与地下城" class="headerlink" title="4.13 龙与地下城"></a>4.13 龙与地下城</h2><p>和 <a href="#jump3">4.3</a> 一样，求的是最大值</p><h2 id="4-14-数字字符串转换为字母组合的种数"><a href="#4-14-数字字符串转换为字母组合的种数" class="headerlink" title="4.14 数字字符串转换为字母组合的种数"></a>4.14 数字字符串转换为字母组合的种数</h2><p>$dp[i]$ 表示前 $k$ 位不可变时的组合数，从后往前算， $dp[N]=1$ ，当 $str[i+1]=0$ 时 $dp[i]=0$ ，当 $str[i,i+1]$ 可转换时， $dp[i]=dp[i+1]+dp[i+2]$ ，否则 $dp[i]=dp[i+1]$ </p><h2 id="4-15-表达式得到期望结果的组合种数"><a href="#4-15-表达式得到期望结果的组合种数" class="headerlink" title="4.15 表达式得到期望结果的组合种数"></a>4.15 表达式得到期望结果的组合种数</h2><p>表达式 $express$ 一定是数字符号交错组成的，每一个奇数位上的符号把式子分成两部分，维护两个 $dp$ 二维数组分别表示 $express[i,j]$ 为 $true$ 和 $false$ 的组合种数， $dp[0,N]=\sum op_k(dp[0,k],dp[k,N-1])$ ，相当于在每个符号做一次分割，这种大分割产生的两组括号是唯一的，所以不同分割下不会出现重复的情况</p><h2 id="4-16-排成一条线的纸牌博弈问题"><a href="#4-16-排成一条线的纸牌博弈问题" class="headerlink" title="4.16 排成一条线的纸牌博弈问题"></a>4.16 排成一条线的纸牌博弈问题</h2><p>维护两个二维 $dp$ ， $dp_1[i][j]$ 表示面对 $s[i,j]$ 先拿的人最终能得到多少分， $dp_2[i][j]$ 表示后拿的人最终能得到多少分，只剩一张牌时 $dp_1[k][k]=arr[k]$ ， $dp_2[k][k]=0$ ，从右下往左上算， $dp_1[i][j]$ 可取值有 $arr[i]+dp_2[i+1][j]$ 和 $arr[j]+dp_2[i][j-1]$ ， $dp_2[i][j]$ 可取值有 $dp_1[i+1][j]$ 和 $dp_1[i][j-1]$ ，时间 $O(N^2)$  </p><h2 id="4-17-跳跃问题"><a href="#4-17-跳跃问题" class="headerlink" title="4.17 跳跃问题"></a>4.17 跳跃问题</h2><p>从左到右遍历一遍，维护三个临时变量， $jump$ 表示步数， $cur$ 表示以当前为起点能去的最远处， $next$ 表示以遍历过程中的点为起点能去的最远处，当遍历到 $cur$ 时，把 $cur$ 更新成 $next$ ，同时 $jump+1$ </p><h2 id="4-18-数组中的最长连续序列"><a href="#4-18-数组中的最长连续序列" class="headerlink" title="4.18 数组中的最长连续序列"></a>4.18 数组中的最长连续序列</h2><p>每次遍历一个数，先使用哈希表去重，然后保存在一个列表里，当列表里出现连续对时，合并成表示范围的二元组 $(left,right)$ ，由于能查询哈希表，检测连续时不需要遍历列表，所以最终时间空间都是 $O(N)$ </p><h2 id="4-19-N-皇后问题"><a href="#4-19-N-皇后问题" class="headerlink" title="4.19  $N$ 皇后问题"></a>4.19  $N$ 皇后问题</h2><p>暴力搜索：为减小空间复杂度，递归函数维护一维数组， $record[i]$ 表示第 $i$ 行放置的列数，遍历 $N$ 个列时实时检查该列能不能放</p><p>优化：利用位运算加速，用两个 $N$ 位二进制数表示当前哪些位置受列和斜线的影响不能放置，其实只加速了检查的操作</p><h1 id="第五章-字符串问题"><a href="#第五章-字符串问题" class="headerlink" title="第五章 字符串问题"></a>第五章 字符串问题</h1><p>子串是连续的，子序列是可以分散的</p><h2 id="5-1-判断两个字符串是否互为变形词"><a href="#5-1-判断两个字符串是否互为变形词" class="headerlink" title="5.1 判断两个字符串是否互为变形词"></a>5.1 判断两个字符串是否互为变形词</h2><p>建一个字符集大小的数组计数</p><h2 id="5-2-字符串中数字子串的求和"><a href="#5-2-字符串中数字子串的求和" class="headerlink" title="5.2 字符串中数字子串的求和"></a>5.2 字符串中数字子串的求和</h2><p>从左到右遍历，用几个变量标记</p><h2 id="5-3-去掉字符串中连续出现k个0的子串"><a href="#5-3-去掉字符串中连续出现k个0的子串" class="headerlink" title="5.3 去掉字符串中连续出现k个0的子串"></a>5.3 去掉字符串中连续出现k个0的子串</h2><p>从左到右遍历，用一个变量标记0的个数</p><h2 id="5-4-判断两个字符串是否互为旋转词"><a href="#5-4-判断两个字符串是否互为旋转词" class="headerlink" title="5.4 判断两个字符串是否互为旋转词"></a>5.4 判断两个字符串是否互为旋转词</h2><p>把两个 $str2$ 拼在一起，检查 $str1$ 是否是子串，方法同 $KMP$ 算法</p><h2 id="5-5-将整数字符串转成整数值"><a href="#5-5-将整数字符串转成整数值" class="headerlink" title="5.5 将整数字符串转成整数值"></a>5.5 将整数字符串转成整数值</h2><p>从左到右遍历</p><h2 id="5-6-替换字符串中连续出现的指定字符串"><a href="#5-6-替换字符串中连续出现的指定字符串" class="headerlink" title="5.6 替换字符串中连续出现的指定字符串"></a>5.6 替换字符串中连续出现的指定字符串</h2><p>从左到右遍历</p><h2 id="5-7-字符串的统计字符串"><a href="#5-7-字符串的统计字符串" class="headerlink" title="5.7 字符串的统计字符串"></a>5.7 字符串的统计字符串</h2><p>从左到右遍历</p><h2 id="5-8-判断字符数组中是否所有的字符都只出现过一次"><a href="#5-8-判断字符数组中是否所有的字符都只出现过一次" class="headerlink" title="5.8 判断字符数组中是否所有的字符都只出现过一次"></a>5.8 判断字符数组中是否所有的字符都只出现过一次</h2><p>使用哈希保存遍历结果，时间空间都是 $O(N)$   </p><p>原地排序，遍历检查，时间 $O(NlogN)$ ，空间 $O(1)$ </p><h2 id="5-9-在有序但含有空的数组中查找字符串"><a href="#5-9-在有序但含有空的数组中查找字符串" class="headerlink" title="5.9 在有序但含有空的数组中查找字符串"></a>5.9 在有序但含有空的数组中查找字符串</h2><p>二分查找</p><h2 id="5-10-字符串的调整与替换"><a href="#5-10-字符串的调整与替换" class="headerlink" title="5.10 字符串的调整与替换"></a>5.10 字符串的调整与替换</h2><p>从左到右遍历一遍，算出替换后的长度，再从右到左遍历，从尾部更新</p><h2 id="5-11-翻转字符串"><a href="#5-11-翻转字符串" class="headerlink" title="5.11 翻转字符串"></a>5.11 翻转字符串</h2><p>翻转单词：先整体逆序，再逐单词逆序   </p><p>翻转片段：先逐片段逆序，再整体逆序</p><h2 id="5-12-数组中两个字符串的最小距离"><a href="#5-12-数组中两个字符串的最小距离" class="headerlink" title="5.12 数组中两个字符串的最小距离"></a>5.12 数组中两个字符串的最小距离</h2><p>遍历一遍，找到 $str2$ 和他前后最近的两个 $str1$ 。进阶问题查询时间 $O(1)$ 就是先花时间做个查询表，mdzz</p><h2 id="5-13-添加最少字符使字符串整体都是回文字符串"><a href="#5-13-添加最少字符使字符串整体都是回文字符串" class="headerlink" title="5.13 添加最少字符使字符串整体都是回文字符串"></a>5.13 添加最少字符使字符串整体都是回文字符串</h2><p>动态规划， $dp[i][j]$ 表示使 $str[i,j]$ 回文需要添加的最少字符数， $dp[i][j]$ 有三种取值：长度为 $1$ 时 $dp$ 是 $0$ ，长度为 $2$ 时 $dp$ 是 $0$ 或 $1$ ，长度大于 $2$ 时，首尾相等 $dp[i][j]=dp[i+1][j-1]$ ，首尾不等时 $dp[i][j]=min{dp[i+1][j],dp[i][j-1]}+1$ ，从对角线向两侧更新 $dp$ ，最后新建长为 $N+dp[0][N-1]$ 的空字符串，从 $dp[0][N-1]$ 回溯填充得到回文串，时间 $O(N^2)$ </p><h2 id="5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"><a href="#5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串" class="headerlink" title="5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"></a>5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串</h2><p>新建空字符串，长度为原字符串长度两倍减去回文子序列长度，从原字符串两端同时搜索回文子序列，每搜到一对就把两侧经过的其他字符拼接填充在左侧，逆序后再填充到右侧，时间 $O(N)$ ，回文子序列位置有混淆也不影响，因为最终遍历的回文对数是不变的</p><h2 id="5-15-括号字符串的有效性和最长有效长度"><a href="#5-15-括号字符串的有效性和最长有效长度" class="headerlink" title="5.15 括号字符串的有效性和最长有效长度"></a>5.15 括号字符串的有效性和最长有效长度</h2><p>有效性：从左到右遍历计数，右括号始终不能多于左括号且最终相等   </p><p>最长有效长度：动态规划， $dp[i]$ 表示以 $str[i]$ 结尾的最长有效长度， $dp[0]=0$ ， $str[i]$ 是左括号时 $dp[i]=0$ ， $str[i]$ 是右括号时，如果 $str[i-1]$ 是左括号直接配对， $dp[i]=dp[i-2]+2$ ，如果 $dp[i-1]$ 不是 $0$ 且 $str[i-dp[i-1]-1]$ 是左括号， $dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]$ ，其余情况 $dp[i]=0$ </p><h2 id="5-16-公式字符串求值"><a href="#5-16-公式字符串求值" class="headerlink" title="5.16 公式字符串求值"></a>5.16 公式字符串求值</h2><p>数值栈+符号栈，遇到右括号和乘除尝试计算</p><h2 id="5-17-0-左边必有-1-的二进制字符串数量"><a href="#5-17-0-左边必有-1-的二进制字符串数量" class="headerlink" title="5.17  $0$ 左边必有 $1$ 的二进制字符串数量"></a>5.17  $0$ 左边必有 $1$ 的二进制字符串数量</h2><p> $dp[i]$ 表示满足条件的 $i$ 位字符串数量，一个满足条件的字符串后面可以补 $1$ ，但是只有末尾为 $1$ 时可以补 $0$ ，所以 $dp[i+1]=dp[i]+dp_1[i]$ ，而第 $i$ 位为 $1$ 时表示第 $i-1$ 位随意，所以 $dp_1[i]=dp[i-1]$ ，所以 $dp[i+1]=dp[i]+dp[i-1]$ ，是斐波那契数列，最优时间 $O(logN)$ </p><h2 id="5-18-拼接所有字符串产生字典顺序最小的大写字符串"><a href="#5-18-拼接所有字符串产生字典顺序最小的大写字符串" class="headerlink" title="5.18 拼接所有字符串产生字典顺序最小的大写字符串"></a>5.18 拼接所有字符串产生字典顺序最小的大写字符串</h2><p>如果 $A+B$ 的字典序小于 $B+A$ ， $A$ 就应该在 $B$ 前边，照这个思路选择排序。</p><p>$\color{red}{不理解这个为什么算贪心算法？为什么需要证明？}$</p><h2 id="5-19-找到字符串的最长无重复字符子串"><a href="#5-19-找到字符串的最长无重复字符子串" class="headerlink" title="5.19 找到字符串的最长无重复字符子串"></a>5.19 找到字符串的最长无重复字符子串</h2><p>哈希表记录，标记子串头，从左到右遍历，时间 $O(N)$ ，空间 $O(M)$ ， $M$ 是字符集大小</p><h2 id="5-20-找到被指的新类型字符"><a href="#5-20-找到被指的新类型字符" class="headerlink" title="5.20 找到被指的新类型字符"></a>5.20 找到被指的新类型字符</h2><p> $str[k-1]$ 小写则结果从 $str[k]$ 开始， $str[k-1]$ 大写时，向左找有几个连续的大写，有偶数个大写则结果从 $str[k]$ 开始，反之结果从 $str[k-1]$ 开始</p><h2 id="5-21-最小包含子串的长度"><a href="#5-21-最小包含子串的长度" class="headerlink" title="5.21 最小包含子串的长度"></a>5.21 最小包含子串的长度</h2><p>哈希表记录，左右边界设在起点，右边界向右找到子串，左边界向右缩小范围，得到备选子串，循环该过程不断从右边界重新遍历，选所有备选子串里最短的，时间 $O(N)$ </p><h2 id="5-22-回文最少分割数"><a href="#5-22-回文最少分割数" class="headerlink" title="5.22 回文最少分割数"></a>5.22 回文最少分割数</h2><p>动态规划， $dp[i]$ 表示 $str[0,i]$ 的最少分割数，从 $0$ 到 $i$ 找到第一个使 $str[j,i]$ 回文的 $j$ ， $dp[i]=dp[j]+1$ ，判断回文的过程可优化</p><h2 id="5-23-字符串匹配问题"><a href="#5-23-字符串匹配问题" class="headerlink" title="5.23 字符串匹配问题"></a>5.23 字符串匹配问题</h2><p>正则匹配原理：有限状态机+递归匹配</p><h2 id="5-24-字典树的实现"><a href="#5-24-字典树的实现" class="headerlink" title="5.24 字典树的实现"></a>5.24 字典树的实现</h2><p>简单粗暴，节点属性有共用数、词尾数、子节点集合</p><h1 id="第六章-大数据和空间限制"><a href="#第六章-大数据和空间限制" class="headerlink" title="第六章 大数据和空间限制"></a>第六章 大数据和空间限制</h1><p>降低精度或增加时间从而减少空间</p><h2 id="6-1-布隆过滤器"><a href="#6-1-布隆过滤器" class="headerlink" title="6.1 布隆过滤器"></a>6.1 布隆过滤器</h2><p>创建一个巨大的长为 $m$ 的 $bit$ 数组，对每条数据使用 $k$ 个哈希函数，分别对 $m$ 取余，把 $bit$ 数组的 $k$ 个 $bit$ 置为 $1$ 。使用时如果输入对应的 $k$ 个位置都为 $1$ 就过滤，只会误杀不会漏杀</p><p><span id="jump4"></span></p><h2 id="6-2-找到出现最多的数"><a href="#6-2-找到出现最多的数" class="headerlink" title="6.2 找到出现最多的数"></a>6.2 找到出现最多的数</h2><p>读文件不会把整个文件放进内存，但是查哈希表是把整个表放进内存。 把 $N$ 个数的文件用哈希函数分配到 $k$ 个哈希表里，哈希函数能保证相同的数都在同一个表里，每次查找只把一个表放进内存，查完所有表后对比各自频次最多的数，把大的集合分组不仅能减少内存占用，还能减少哈希表里表示键值的比特长度</p><h2 id="6-3-找到没出现的数"><a href="#6-3-找到没出现的数" class="headerlink" title="6.3 找到没出现的数"></a>6.3 找到没出现的数</h2><p>只考虑出现与否不需要计数，可以使用 $bit$ 数组减少内存占用，再优化还可以分组统计，每次只检查 $k$ 个数出现与否，但每组都要遍历一遍原文件</p><h2 id="6-4-找到所有重复的-url"><a href="#6-4-找到所有重复的-url" class="headerlink" title="6.4 找到所有重复的 $url$"></a>6.4 找到所有重复的 $url$</h2><p>同 <a href="#jump4">6.2</a> ，大文件拆成多个小文件</p><h2 id="6-5-统计词汇-top-k"><a href="#6-5-统计词汇-top-k" class="headerlink" title="6.5 统计词汇 $top_k$"></a>6.5 统计词汇 $top_k$</h2><p>同 <a href="#jump4">6.2</a> ，大文件拆成多个小文件，每个小文件 $top_k$ 再排序</p><h2 id="6-6-找到出现两次的数"><a href="#6-6-找到出现两次的数" class="headerlink" title="6.6 找到出现两次的数"></a>6.6 找到出现两次的数</h2><p>双倍 $bit$ 数组，每个数用两个 $bit$ 统计出现 $0$ 次、 $1$ 次、 $2$ 次和多次</p><h2 id="6-7-找中位数"><a href="#6-7-找中位数" class="headerlink" title="6.7 找中位数"></a>6.7 找中位数</h2><p>先分好 $k$ 个区间，遍历一遍文件得到中位数出现的区间，再遍历一遍在目标区间里接着找，空间不够可以继续分区间</p><h2 id="6-8-一致性哈希算法"><a href="#6-8-一致性哈希算法" class="headerlink" title="6.8 一致性哈希算法"></a>6.8 一致性哈希算法</h2><p>环形分配可以减小增删机器时数据迁移的代价，虚拟节点可以减小机器较少时的负载不均衡</p><h1 id="第七章-位运算"><a href="#第七章-位运算" class="headerlink" title="第七章 位运算"></a>第七章 位运算</h1><h2 id="7-1-不用额外变量交换两个整数的值"><a href="#7-1-不用额外变量交换两个整数的值" class="headerlink" title="7.1 不用额外变量交换两个整数的值"></a>7.1 不用额外变量交换两个整数的值</h2><p>$a=a\oplus b$ , $b=a\oplus b$ , $a=a\oplus b$ ，第一步把 $a$ 和 $b$ 信息不同的比特位标为 $1$ ，第二步当信息不同且 $b$ 是 $0$ 时结果是 $1$ ，信息相同 $b$ 是 $1$ 是返回 $1$ ，所以结果就是原来的 $a$ ，第三步当信息不同且 $b$ (原来的 $a$ )是 $0$ 时结果是 $1$ ，信息相同 $b$ 是 $1$ (原来的 $a$ )是返回 $1$ ，所以结果就是 $a$ (原来的 $b$ )</p><h2 id="7-2-不用任何比较判断找出两个数中较大的数"><a href="#7-2-不用任何比较判断找出两个数中较大的数" class="headerlink" title="7.2 不用任何比较判断找出两个数中较大的数"></a>7.2 不用任何比较判断找出两个数中较大的数</h2><p>二进制最高位是符号位， $1$ 是负数， $0$ 是非负，查看 $a$ 、 $b$ 和 $a-b$ 的符号， $a$ 和 $b$ 符号相反直接返回非负的， $a$ 和 $b$ 符号相同则 $a-b$ 不会溢出，根据 $a-b$ 符号返回结果</p><h2 id="7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出"><a href="#7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出" class="headerlink" title="7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)"></a>7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)</h2><p>加法：只相加不进位时 $a+b=a^b$ ，向前进位的序列是 $(a\&amp;b)\ll 1$ ，再以异或序列和进位序列不断循环前两步，直到进位序列全是 $0$   </p><p>减法： $a-b=a+(-b)$ ， $b$ 的相反数是把 $b$ 取反加一得到补码，再和 $a$ 做上述加法  </p><p>乘法： $a\times b$ 本质是 $a$ 循环累加，把 $b$ 按位拆分，最低位是 $1$ 时结果加 $a$ ，高位都代表 $2$ 的乘方，通过对 $a$ 向左移位可以实现，最终 $a\times b=a\times b<em>0+\sum</em>{i=1}^n(a\ll i)\times b_i$ ，因为 $b_i$ 是 $0$ 或 $1$ ，所以式子里的乘法只是形式上的， $b$ 是负数也成立  </p><p>除法： $a\div b$ 本质是 $a$ 循环减去 $b$ ，因此可以对 $b$ 移位比大小得到比 $a$ 小的最大的数。如果 $a$ 、 $b$ 中有负数要先转成非负，最后再考虑符号。一个特例是， $int$ 的最小值的绝对值比最大值大 $1$ ，所以 $int$ 的最小值不能转成正数，当不能直接判断出结果，也就是最小值必须参与计算时，可以把最小值拆成几段分开算，最后用余数再算一次</p><h2 id="7-4-整数的二进制表达中有多少个-1"><a href="#7-4-整数的二进制表达中有多少个-1" class="headerlink" title="7.4 整数的二进制表达中有多少个 $1$"></a>7.4 整数的二进制表达中有多少个 $1$</h2><p>方法一：循环 $n=n\And(n-1)$ 或 $n-=n\And(1-n)$ 直到 $n=0$ ，这个操作本质上是去掉 $n$ 最右边的 $1$ ，两个式子右边一个返回去掉末尾 $1$ 的 $n$ ，一个直接返回末尾 $1$  </p><p>方法二：平行算法，统计 $1$ 的个数不用把整个二进制序列当成一个数，同时在每个bit上操作既提高了效率又排除了序列里高低位的影响，平行算法采用归并的思路，依次算出每 $2^k$ 位里有多少个 $1$ ，最后一步的结果就是整个序列里有多少个 $1$<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int function(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    n &#x3D; (n &amp; 0x55555555) + ((n&gt;&gt; 1) &amp; 0x55555555); #每2bit为一组相加 </span><br><span class="line">    n &#x3D; (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333); #每4bit为一组相加 </span><br><span class="line">    n &#x3D; (n &amp; 0x0f0f0f0f) + ((n&gt;&gt; 4) &amp; 0x0f0f0f0f); #每2bit为一组相加   </span><br><span class="line">    n &#x3D; (n &amp; 0xff00ff) + ((n&gt;&gt; 8) &amp; 0xff00ff); #每16bit为一组相加      </span><br><span class="line">    n &#x3D; (n &amp; 0xffff) + ((n&gt;&gt; 16) &amp; 0xffff) ; #每32bit为一组相加         </span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="7-5-在其他数都出现偶数次的数组中找到出现奇数次的数"><a href="#7-5-在其他数都出现偶数次的数组中找到出现奇数次的数" class="headerlink" title="7.5 在其他数都出现偶数次的数组中找到出现奇数次的数"></a>7.5 在其他数都出现偶数次的数组中找到出现奇数次的数</h2><p>一个数奇数次： $n\oplus0=n,n\oplus n=0$ ，所以只要用一个 $0$ 把所有数都异或一遍，剩下的值就是奇数次那个数  </p><p>两个数奇数次：用 $0$ 异或一遍结果是 $a\oplus b$ ，两个数不相等结果必有个第 $k$ 位是 $1$ ，再用 $0$ 与第 $k$ 位是 $1$ 的所有数异或一遍，得到的就是 $a$ 或 $b$ </p><h2 id="7-6-在其他数都出现-k-次的数组中找到只出现一次的数"><a href="#7-6-在其他数都出现-k-次的数组中找到只出现一次的数" class="headerlink" title="7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数"></a>7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数</h2><p>$k$ 个相同的 $k$ 进制的数无进位相加结果是 $0$ ，因为结果每一位都是 $(k\times a)\%k$ ，所以把所有数转为 $k$ 进制累加，得到的结果就是只出现一次的数</p><h1 id="第八章-数组和矩阵问题"><a href="#第八章-数组和矩阵问题" class="headerlink" title="第八章 数组和矩阵问题"></a>第八章 数组和矩阵问题</h1><h2 id="8-1-转圈打印矩阵"><a href="#8-1-转圈打印矩阵" class="headerlink" title="8.1 转圈打印矩阵"></a>8.1 转圈打印矩阵</h2><p>就是从外到内逐层打印，用每一圈的四个角的坐标判断</p><h2 id="8-2-将正方形矩阵顺时针旋转-90-deg"><a href="#8-2-将正方形矩阵顺时针旋转-90-deg" class="headerlink" title="8.2 将正方形矩阵顺时针旋转 90&deg;"></a>8.2 将正方形矩阵顺时针旋转 90&deg;</h2><p>方阵里一个数顺时针旋转 90&deg; 就是沿着他所在的一圈顺时针走一条边的距离，和上题一样逐圈操作</p><h2 id="8-3-之字形打印矩阵"><a href="#8-3-之字形打印矩阵" class="headerlink" title="8.3 之字形打印矩阵"></a>8.3 之字形打印矩阵</h2><p>算坐标，碰到边界再判断怎么移动</p><h2 id="8-4-找到无序数组中最小的-k-个数"><a href="#8-4-找到无序数组中最小的-k-个数" class="headerlink" title="8.4 找到无序数组中最小的 $k$ 个数"></a>8.4 找到无序数组中最小的 $k$ 个数</h2><p>$O(Nlogk)$ 方法：维护一个 $k$ 个节点的大根堆，遍历数组，如果元素小于堆顶就插入堆，其中遍历 $O(N)$ ，堆插入 $O(logk)$    </p><p>$O(N)$ 方法： $BFPRT$ 算法可以从数组中找到第 $k$ 小的数，把原数组每五个数分一组，分别求中位数，再递归求中位数的中位数，最终得到一个中位数 $x$ ，用 $x$ 划分原数组中大于 $x$ 和小于 $x$ 的数，在其中一边继续用中位数方法划分，最终能得到 $x$ 在数组中的位置是第 $k$ ，可以用数学证明该过程时间复杂度是 $O(N)$ ，大概意思就是用中位数划分数组效率高，所以能收敛到 $O(N)$ ，所以找到 $k$ 个最小的数总的时间复杂度也是 $O(N)$ </p><h2 id="8-5-需要排序的最短子数组长度"><a href="#8-5-需要排序的最短子数组长度" class="headerlink" title="8.5 需要排序的最短子数组长度"></a>8.5 需要排序的最短子数组长度</h2><p>从左到右、从右到左分别遍历，找边界</p><h2 id="8-6-在数组中找到出现次数大于-N-K-的数"><a href="#8-6-在数组中找到出现次数大于-N-K-的数" class="headerlink" title="8.6 在数组中找到出现次数大于 $N/K$ 的数"></a>8.6 在数组中找到出现次数大于 $N/K$ 的数</h2><p>遍历一遍数组，循环排除 $K$ 个不同的数，直到剩下的不足 $K$ ，剩下的就是出现次数大于 $N/K$ 的数。具体实现是建立两个长度为 $K-1$ 的数组， $A$ 数组存数组里的数， $B$ 数组存出现次数，当遍历到的 $x$ 与 $A$ 里的都不同时， $B$ 数组都减一同时遍历下一个，就相当于排除了 $K$ 个不同的数，次数归零时用遍历到的数补位，最终时间复杂度 $O(N\times K)$ ，空间复杂度 $O(K)$ </p><h2 id="8-7-在行列都排好序的矩阵中找数"><a href="#8-7-在行列都排好序的矩阵中找数" class="headerlink" title="8.7 在行列都排好序的矩阵中找数"></a>8.7 在行列都排好序的矩阵中找数</h2><p>$M\times N$ 的矩阵中，每个以对角线上一点为右下角的一行和一列的组合里，对角线上这个点都是最大的，相当于从左上角到右下角沿着对角线剥洋葱，遍历的最大长度是对角线+一行+一列，时间 $O(M+N)$ </p><h2 id="8-8-最长的可整合子数组的长度"><a href="#8-8-最长的可整合子数组的长度" class="headerlink" title="8.8 最长的可整合子数组的长度"></a>8.8 最长的可整合子数组的长度</h2><p>可整合数组就是元素不重复，最大值-最小值+1是元素个数的数组，从左到右以每个元素为起点遍历一次，时间 $O(N^2)$ </p><h2 id="8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><a href="#8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组" class="headerlink" title="8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组"></a>8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组</h2><p>二元组：一个左指针一个右指针向中间遍历，时间 $O(N)$   </p><p>三元组：从左到右遍历，每遍历到一个元素，就把他后面的当成一个二元组问题求解，时间 $O(N^2)$ </p><h2 id="8-10-未排序正数数组中累加和为给定值的最长子数组长度"><a href="#8-10-未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="8.10 未排序正数数组中累加和为给定值的最长子数组长度"></a>8.10 未排序正数数组中累加和为给定值的最长子数组长度</h2><p>左右两个指针从数组头遍历，变量 $sum$ 存两个指针标记的子数组累加和，变量 $len$ 存 $sum$ 为给定值 $k$ 时的最长子数组长度，右指针向右遍历， $sum\geq k$ 时左指针加一</p><p><span id="jump5"></span></p><h2 id="8-11-未排序数组中最长子数组系列问题"><a href="#8-11-未排序数组中最长子数组系列问题" class="headerlink" title="8.11 未排序数组中最长子数组系列问题"></a>8.11 未排序数组中最长子数组系列问题</h2><p>累加和为 $k$ ： $s[i]$ 表示子数组 $arr[0,i]$ 的累加和，则 $arr[j,i]$ 的累加和就是 $s[i]-s[j-1]$ ，从左到右遍历数组计算累加和，建立哈希表， $key$ 是累加和， $value$ 是最先产生该累加和的数组下标，若 $s[i]=k$ ，就得到了一个满足条件的子数组，若 $s[i]&gt;k$ ，就在表中查找 $s[i]-k$   </p><p>正数与负数个数相等：正数变 $1$ ，负数变 $-1$ ，相当于求累加和为 $0$ </p><p>数组里只有 $0$ 和 $1$ ，子数组 $0$ 和 $1$ 个数相等： $0$ 变 $-1$ ，求累加和为 $0$ </p><h2 id="8-12-未排序数组中累加和小于或等于给定值的最长子数组长度"><a href="#8-12-未排序数组中累加和小于或等于给定值的最长子数组长度" class="headerlink" title="8.12 未排序数组中累加和小于或等于给定值的最长子数组长度"></a>8.12 未排序数组中累加和小于或等于给定值的最长子数组长度</h2><p>建立数组 $s$ 记录累加和，建立数组 $h$ 记录 $s[0,i]$ 之间的最大值，遍历一遍原数组 $O(N)$ ，每遍历一个元素，如果 $s[i]\leq k$ 就更新最长子数组长度，反之就在 $0\sim i$ 之间搜索是否存在 $s[i]-s[j-1]\leq k$ ，即 $s[j-1]\geq s[i]-k$ ，由于 $h$ 是递增数组，结合数组 $s$ 可以实现 $O(logN)$ 的二分查找，最终时间 $O(NlogN)$ ， 空间 $O(N)$ </p><h2 id="8-13-计算数组的小和"><a href="#8-13-计算数组的小和" class="headerlink" title="8.13 计算数组的小和"></a>8.13 计算数组的小和</h2><p>在归并排序的过程中计算小和，因为每一步操作的两个数组都是排好序的，所以节省了遍历的时间，对于 $s_1[i]$ ，只要找到第一个 $s_1[i]&lt;s_2[j]$ ，直接给总数组小和加上 $s_1[i]*(len(s_2)-j+1)$ ，时间 $O(NlogN)$ ，空间 $O(N)$ </p><h2 id="8-14-自然数数组的排序"><a href="#8-14-自然数数组的排序" class="headerlink" title="8.14 自然数数组的排序"></a>8.14 自然数数组的排序</h2><p>前提是已经知道了一个数应该放在哪里，从左到右遍历，如果一个位置上的数不对，就把他放到正确的位置，替换掉那个位置上的数，然后循环修正替换下来的数，最后会回到原来遍历中止的位置，继续往后遍历</p><h2 id="8-15-奇数下标都是奇数或者偶数下标都是偶数"><a href="#8-15-奇数下标都是奇数或者偶数下标都是偶数" class="headerlink" title="8.15 奇数下标都是奇数或者偶数下标都是偶数"></a>8.15 奇数下标都是奇数或者偶数下标都是偶数</h2><p>两个指针从左到右分别遍历数组的奇数和偶数位置，循环检查数组最后一个数，放在相应指针标记的位置，把该位置替换下来的数放在数组尾部，对应指针加二</p><h2 id="8-16-子数组的最大累加和问题"><a href="#8-16-子数组的最大累加和问题" class="headerlink" title="8.16 子数组的最大累加和问题"></a>8.16 子数组的最大累加和问题</h2><p>从左到右累加，累加和变成负数就从下个数重新累加，用一个变量记录累加和的最大值</p><h2 id="8-17-子矩阵的最大累加和问题"><a href="#8-17-子矩阵的最大累加和问题" class="headerlink" title="8.17 子矩阵的最大累加和问题"></a>8.17 子矩阵的最大累加和问题</h2><p>把矩阵的 $k$ 行累加成一行，转化成子数组的最大累加和问题，结果就是以这 $k$ 行为基础搜索矩阵的列找到的子矩阵，从上到下以每行为起点遍历所有行数的矩阵，搜索最大累加和的子矩阵，最终时间 $O(N^3)$ ，空间 $O(N)$  </p><h2 id="8-18-在数组中找到一个局部最小的位置"><a href="#8-18-在数组中找到一个局部最小的位置" class="headerlink" title="8.18 在数组中找到一个局部最小的位置"></a>8.18 在数组中找到一个局部最小的位置</h2><p>先判断首尾有没有，没有就二分查找，如果 $arr[mid]&gt;arr[mid-1]$ ，因为左半边肯定不单调，所以一定存在局部最小，如果 $arr[mid]&gt;arr[mid+1]$ 就在右半边找，最终时间 $O(logN)$ </p><h2 id="8-19-数组中子数组的最大累乘积"><a href="#8-19-数组中子数组的最大累乘积" class="headerlink" title="8.19 数组中子数组的最大累乘积"></a>8.19 数组中子数组的最大累乘积</h2><p>从左到右遍历，分别求以每个 $arr[i]$ 结尾的最大累乘积 $max[i]$ 和最小累乘积 $min[i]$ ，通过比较 $max[i-1]\times arr[i]$ 、 $min[i-1]\times arr[i]$ 和  $arr[i]$ 三个数确定最大最小累乘积，再用一个变量保存整个过程中的最大累乘积，时间 $O(N)$ ，空间 $O(1)$ </p><h2 id="8-20-打印-N-个数组整体最大的-topK"><a href="#8-20-打印-N-个数组整体最大的-topK" class="headerlink" title="8.20 打印 $N$ 个数组整体最大的 $topK$"></a>8.20 打印 $N$ 个数组整体最大的 $topK$</h2><p>维护一个大根堆，因为数组都是有序的，取 $N$ 个数组的最大值建堆，时间 $O(N)$ ，每次把堆顶加入 $topK$ 并把堆顶元素所在数组的下一个最大值插入堆，每次插入 $O(logN)$ ，插入总时间 $O(KlogN)$ </p><h2 id="8-21-边界都是-1-的最大正方形大小"><a href="#8-21-边界都是-1-的最大正方形大小" class="headerlink" title="8.21 边界都是 $1$ 的最大正方形大小"></a>8.21 边界都是 $1$ 的最大正方形大小</h2><p>以每个点为正方形的左上角，对于所有可能的边长，检查正方形的四条边，时间 $O(N^4)$ ，空间 $O(1)$ 。可以通过预处理矩阵把检查四条边的时间变成 $O(1)$ ，预先生成两个矩阵，用来记录每个点向右和向下有多少个连续的 $1$ ，从右下角开始算，每次利用之前计算出的结果，可以把预处理时间降到 $O(N^2)$ ，优化后的总时间是 $O(N^3)$ ，空间 $O(N^2)$ </p><h2 id="8-22-不包含本位置值的累乘数组"><a href="#8-22-不包含本位置值的累乘数组" class="headerlink" title="8.22 不包含本位置值的累乘数组"></a>8.22 不包含本位置值的累乘数组</h2><p>使用除法：用总乘积除以每一位</p><p>不使用除法：创建两个数组分别存储从左到右和从右到左的累乘，不包含一个数的累乘相当于他的左累乘和右累乘的乘积；或者用异或代替除法</p><h2 id="8-23-数组的-partition-调整"><a href="#8-23-数组的-partition-调整" class="headerlink" title="8.23 数组的 $partition$ 调整"></a>8.23 数组的 $partition$ 调整</h2><p>从左到右遍历，交换数值，相当于用一个左指针把数组分成两个区，遍历过程中在区之间做交换。更复杂的问题可以用一个左指针一个右指针把数组分成三个区</p><h2 id="8-24-求最短通路值"><a href="#8-24-求最短通路值" class="headerlink" title="8.24 求最短通路值"></a>8.24 求最短通路值</h2><p>广度优先遍历，时间 $O(M\times N)$ </p><h2 id="8-25-数组中未出现的最小正整数"><a href="#8-25-数组中未出现的最小正整数" class="headerlink" title="8.25 数组中未出现的最小正整数"></a>8.25 数组中未出现的最小正整数</h2><p>理想情况是数组里存着 $1\sim N$ ，当发现不属于这个范围的数或有重复数时，说明坑位不够了。初始化 $l=0$ 和 $r=N$ 标记空余位置的范围。循环遍历范围头部：<br>若 $arr[l]=l+1$ ，说明正好占对了最左边的坑， $l++$<br>若 $arr[l] &lt; l$ 或 $arr[l]&gt;r$ ，说明有范围外的占坑了，把 $arr[r-1]$ 保存到 $arr[l]$ ，同时 $r—$ ，表示删除一个坑位<br>若 $arr[arr[l]-1]=arr[l]$ ，说明 $arr[l]$ 是合法范围内的数，但是他应该在的位置 $arr[l]-1$ 上已经有相同的数了，说明出现了重复，把 $arr[r-1]$ 保存到 $arr[l]$ ，同时 $r—$ ，表示删除一个坑位<br>若以上错误都没出现，说明 $arr[l]$ 是合法范围内的数，把他和 $arr[l]-1$ 位置上的数交换<br>最终左右指针相遇， $l+1$ 就是未出现的最小正整数</p><h2 id="8-26-数组排序之后相邻数的最大差值"><a href="#8-26-数组排序之后相邻数的最大差值" class="headerlink" title="8.26 数组排序之后相邻数的最大差值"></a>8.26 数组排序之后相邻数的最大差值</h2><p>遍历一次找到最大最小值，做桶排序，时间 $O(N)$ </p><h1 id="第九章-其他题目"><a href="#第九章-其他题目" class="headerlink" title="第九章 其他题目"></a>第九章 其他题目</h1><h2 id="9-1-从-5-随机到-7-随机及其扩展"><a href="#9-1-从-5-随机到-7-随机及其扩展" class="headerlink" title="9.1 从 $5$ 随机到 $7$ 随机及其扩展"></a>9.1 从 $5$ 随机到 $7$ 随机及其扩展</h2><p>$rand1to5$ 实现 $rand1to7$ ：独立调用两次 $rand1to5$ ， $res=(rand1to5-1)\times 5+(rand1to5-1)$ 等概率随机生成 $0\sim 24$ 之间的数，当结果在 $0\sim 20$ 之间时， $res\%7+1$ 就等概率随机生成 $0\sim 27$ 之间的数 </p><p>$rand01p$ 实现 $rand1to6$ ：由于 $rand01p$ 生成 $01$ 和 $10$ 的概率都是 $p(1-p)$ ，所以先通过调用两次 $rand01p$ 实现等概率产生 $0$ 和 $1$ 的 $rand01$ 。 $rand0to3=rand01\times 2+rand01$ 等概率随机生成 $0\sim 3$ ， $res=rand0to3\times 4+rand0to3$ 等概率随机生成 $0\sim 15$ ，当结果在 $0\sim 11$ 之间时， $res\%6+1$ 就等概率随机生成 $0\sim 6$ 之间的数 </p><p>$rand1toM$ 实现 $rand1toN$ ：如果 $M&gt;N$ ，调用一次直接筛选 $res$ ，如果 $M&lt;N$ ，调用多次拼接成一个多位的 $M$ 进制数，再筛选 $res$ </p><h2 id="9-2-一行代码求两个数的最大公约数"><a href="#9-2-一行代码求两个数的最大公约数" class="headerlink" title="9.2 一行代码求两个数的最大公约数"></a>9.2 一行代码求两个数的最大公约数</h2><p>辗转相除法， $gcd(a,b)=gcd(b,a\%b)$ </p><h2 id="9-3-有关阶乘的两个问题"><a href="#9-3-有关阶乘的两个问题" class="headerlink" title="9.3 有关阶乘的两个问题"></a>9.3 有关阶乘的两个问题</h2><p>阶乘末尾 $0$ 的数量：遍历 $1\sim N$ 的所有数，累计每个数的因子 $5$ 的个数，遍历过程可以优化，一个数有多少 $5^k$ 的因子，就能提供多少个 $5$ ，所以因子 $5$ 总数为： $\sum_{k=1} N/5^k$ </p><p>阶乘的二进制表示中最右边的 $1$ 的位置：末尾 $0$ 的数量是因子 $2$ 的个数 $\sum_{k=1} N/2^k$ </p><h2 id="9-4-判断一个点是否在矩形内部"><a href="#9-4-判断一个点是否在矩形内部" class="headerlink" title="9.4 判断一个点是否在矩形内部"></a>9.4 判断一个点是否在矩形内部</h2><p>比较坐标位置；或者看横纵直线和矩形的交点，一个点在凸多边形的内部，从这个点引出的横纵两条直线与多边形的四个交点一定分布在这个点的上下左右</p><h2 id="9-5-判断一个点是否在三角形内部"><a href="#9-5-判断一个点是否在三角形内部" class="headerlink" title="9.5 判断一个点是否在三角形内部"></a>9.5 判断一个点是否在三角形内部</h2><p>同上</p><h2 id="9-6-折纸问题"><a href="#9-6-折纸问题" class="headerlink" title="9.6 折纸问题"></a>9.6 折纸问题</h2><p>找规律，每次折叠产生的新折痕都是在上次折叠新产生的每一条折痕前后生成下折痕和上折痕<br>第一次折叠：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;下<br>第二次折叠：&emsp;&emsp;&emsp;下&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;上<br>第三次折叠：&emsp;下&emsp;&emsp;&emsp;上&emsp;&emsp;&emsp;下&emsp;&emsp;&emsp;上<br>第四次折叠：下&emsp;上&emsp;下&emsp;上&emsp;下&emsp;上&emsp;下&emsp;上<br>中序遍历的结果就是折痕顺序</p><h2 id="9-7-蓄水池算法"><a href="#9-7-蓄水池算法" class="headerlink" title="9.7 蓄水池算法"></a>9.7 蓄水池算法</h2><p>前 $k$ 个球直接放入，对于第 $i(i&gt;k)$ 个球，以 $k/i$ 的概率决定放入，如果放入了就随机扔掉袋子里的一个球，可以数学证明每个球最终留在袋子里的概率都是 $k/N$ </p><h2 id="9-8-设计有-setAll-功能的哈希表"><a href="#9-8-设计有-setAll-功能的哈希表" class="headerlink" title="9.8 设计有 $setAll$ 功能的哈希表"></a>9.8 设计有 $setAll$ 功能的哈希表</h2><p>给每个值附加一个时间戳，创建一个 $key=setAll$ 的条目，每次调用 $setAll$ 方法就更新 $setAll$ 条目的值和时间戳，当查询的值的时间比 $setAll$ 早时，返回 $setAll$ 条目的值，从查询结果看是重置了所有值，其实只是把查询重定向了</p><h2 id="9-9-最大的-leftMax-与-rightMax-之差的绝对值"><a href="#9-9-最大的-leftMax-与-rightMax-之差的绝对值" class="headerlink" title="9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值"></a>9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值</h2><p>方法一：创建两个数组，从左到右和从右到左各遍历一遍，记录 $leftMax$ 和 $rightMax$ ，最后再遍历一次直接出结果，时间 $O(N)$ ，空间 $O(N)$ </p><p>方法二：遍历一遍找到数组最大值，再和数组首尾两个元素分别算差值，因为当最大值在一侧时，另一侧最小的最大值就是只有一个元素的情况，时间 $O(N)$ ，空间 $O(1)$ </p><h2 id="9-10-设计可以变更的缓存结构"><a href="#9-10-设计可以变更的缓存结构" class="headerlink" title="9.10 设计可以变更的缓存结构"></a>9.10 设计可以变更的缓存结构</h2><p>双向队列实现节点的排序，头部存旧节点，尾部存最近访问的节点，当一个节点被访问时就移到尾部，要淘汰节点时直接从头部删除，用哈希表映射节点实现 $O(1)$ 的时间复杂度</p><h2 id="9-11-设计-RandomPool-结构"><a href="#9-11-设计-RandomPool-结构" class="headerlink" title="9.11 设计 $RandomPool$ 结构"></a>9.11 设计 $RandomPool$ 结构</h2><p>数据只有 $key$ 没有 $value$ ，所以可以用哈希表给 $key$ 一个 $index$ ，一个哈希表的索引是 $key$ ，另一个的索引是 $index$ ， $getRandom$ 就是在 $0\sim index$ 之间生成一个随机数</p><h2 id="9-12-调整-0-x-区间上的数出现的概率"><a href="#9-12-调整-0-x-区间上的数出现的概率" class="headerlink" title="9.12 调整 $[0,x)$ 区间上的数出现的概率"></a>9.12 调整 $[0,x)$ 区间上的数出现的概率</h2><p>分别调用 $k$ 次 $random$ 函数，返回最大的值，因为只要有一次不在 $[0,x)$ 内，结果就不在 $[0,x)$ 内，说明随机到 $[0,x)$ 内的概率是 $x^k$ </p><h2 id="9-13-路径数组变为统计数组"><a href="#9-13-路径数组变为统计数组" class="headerlink" title="9.13 路径数组变为统计数组"></a>9.13 路径数组变为统计数组</h2><p>从左到右遍历 $path$ ，如果不是首都就跳到他指向的城市，最终要么跳到首都要么跳到一个已经遍历过的节点，然后反向跳回去，同时设置每一步到首都的距离，遍历一遍后 $path[i]$ 就表示城市 $i$ 到首都的距离。再从左到右遍历 $path$ ，还是用跳跃的方法赋值，先 $path[path[0]]=1$ ，对替换下来的 $path[path[0]]$ 再 $path[path[path[0]]]=1$ ，遍历完后 $path[i]$ 就表示到首都距离为 $i$ 的城市数。两次遍历期间可以用数值的正负来区分数值代表的含义</p><h2 id="9-14-正数数组的最小不可组成和"><a href="#9-14-正数数组的最小不可组成和" class="headerlink" title="9.14 正数数组的最小不可组成和"></a>9.14 正数数组的最小不可组成和</h2><p>动态规划，对数组求一次总和 $sum$ ，把 $dp$ 长度设成 $sum$ ， $dp[i]$ 表示存在子数组累加和是 $i$ ，从左到右遍历数组，对于每一个元素 $k$ ，遍历 $dp[i]=1$ 使 $dp[i+k]=1$ ，最后再扫一遍 $dp$ 找最小不可组成和，时间 $O(N\times sum)$ ，空间 $O(sum)$ </p><p>已知数组中有 $1$ 时：数组排序，遍历一遍求每个位置 $i$ 的 $range$ ，表示 $[1,range]$ 能够被 $arr[0,i-1]$ 表示，初始 $range=1$ ，如果 $arr[i]&gt;range+1$ ，说明 $range+1$ 无法组成，直接返回结果，如果 $arr[i]\leq range+1$ ，说明 $[1,range+arr[i]]$ 能够被 $arr[0,i]$ 表示，让 $range+=arr[i]$ ，时间 $O(NlogN)$ ，空间 $O(1)$ </p><p>$\color{red}{没明白已知有1到底影响了什么}$</p><h2 id="9-14-一种字符串和数字的对应关系"><a href="#9-14-一种字符串和数字的对应关系" class="headerlink" title="9.14 一种字符串和数字的对应关系"></a>9.14 一种字符串和数字的对应关系</h2><p>数字转字符串：把字符串看成是伪 $k$ 进制数，每位的范围是 $1\sim k$ ，先用目标数依次减去 $k$ 、 $k^2$ 、 $k^3$ 等，算出字符串需要的位数，再用剩下的数从高位到低位依次赋值</p><p>字符串转数字：第 $i$ 位的值表示有多少个 $k^i$ ，所有位求和</p><h2 id="9-15-1-到-n-中-1-出现的次数"><a href="#9-15-1-到-n-中-1-出现的次数" class="headerlink" title="9.15  $1$ 到 $n$ 中 $1$ 出现的次数"></a>9.15  $1$ 到 $n$ 中 $1$ 出现的次数</h2><p>找规律，分别算每一位上 $1$ 出现的次数，取右数第 $i$ 位左边的数字(没有就是0)，乘以 $10^{i−1}$ ，得到基础值 $a$ ，取第 $i$ 位数字，计算修正值：<br>如果大于 $1$ ，则结果为 $a+10^{i−1}$<br>如果小于 $1$ ，则结果为 $a$<br>如果等 $1$ ，则取第 $i$ 位右边数字，设为 $b$ ，最后结果为 $a+b+1$   </p><h2 id="9-16-从-N-个数中等概率打印-M-个数"><a href="#9-16-从-N-个数中等概率打印-M-个数" class="headerlink" title="9.16 从 $N$ 个数中等概率打印 $M$ 个数"></a>9.16 从 $N$ 个数中等概率打印 $M$ 个数</h2><p>随机打印 $[0,N-1]$ 的一个位置 $a$ 上的 $arr[a]$ ，把 $arr[a]$ 和 $arr[N-1]$ 交换，再随机打印 $[0,N-2]$ 的一个位置 $b$ 上的 $arr[b]$ ，循环该过程直到打印出 $N$ 个数，可以推出来每个数打印的概率都是 $1/N$ </p><h2 id="9-17-判断一个数是否是回文数"><a href="#9-17-判断一个数是否是回文数" class="headerlink" title="9.17 判断一个数是否是回文数"></a>9.17 判断一个数是否是回文数</h2><p>左右比较，剥洋葱法</p><h2 id="9-18-在有序旋转数组中找到最小值"><a href="#9-18-在有序旋转数组中找到最小值" class="headerlink" title="9.18 在有序旋转数组中找到最小值"></a>9.18 在有序旋转数组中找到最小值</h2><p>递增数组旋转过的数组中间有断点，如果子数组左小右大说明不包含断点，左大右小说明一定包含断点，左右相等时不确定，如 $[3,1,2,3]$ ，此时需要对子数组进行查找，整个过程尽量使用二分查找，最优情况 $O(logN)$ ，最坏情况 $O(N)$  </p><h2 id="9-19-在有序旋转数组中找到一个数"><a href="#9-19-在有序旋转数组中找到一个数" class="headerlink" title="9.19 在有序旋转数组中找到一个数"></a>9.19 在有序旋转数组中找到一个数</h2><p>二分查找，根据子数组左中右的值，判断断点可能的位置以及需要继续搜索的子数组</p><h2 id="9-20-数字的英文表达和中文表达"><a href="#9-20-数字的英文表达和中文表达" class="headerlink" title="9.20 数字的英文表达和中文表达"></a>9.20 数字的英文表达和中文表达</h2><p>英文三位一组(个十百)，中文四位一组(个十百千)</p><h2 id="9-21-分糖果问题"><a href="#9-21-分糖果问题" class="headerlink" title="9.21 分糖果问题"></a>9.21 分糖果问题</h2><p>从左到右遍历，每找到一个上下坡的组合就开始赋值，两个坡最低处都是 $1$ ，两侧上坡都是递增加一，直到两个坡交汇，交汇处的值由坡长的一侧决定</p><h2 id="9-22-一种消息接受并打印的结构设计"><a href="#9-22-一种消息接受并打印的结构设计" class="headerlink" title="9.22 一种消息接受并打印的结构设计"></a>9.22 一种消息接受并打印的结构设计</h2><p>创建长度为 $N$ 的数组，接受的数字对号入座，当打印到 $k$ 时就把 $k+1$ 当做下一次打印的标志，一旦接收到就向后打印连续区间值</p><h2 id="9-23-设计一个没有扩容负担的堆结构"><a href="#9-23-设计一个没有扩容负担的堆结构" class="headerlink" title="9.23 设计一个没有扩容负担的堆结构"></a>9.23 设计一个没有扩容负担的堆结构</h2><p>二叉树</p><h2 id="9-24-随时找到数据流的中位数"><a href="#9-24-随时找到数据流的中位数" class="headerlink" title="9.24 随时找到数据流的中位数"></a>9.24 随时找到数据流的中位数</h2><p>一个大根堆存较小的一半数，一个小根堆存较大的一半数，新的数通过比较堆顶决定加入哪个堆，每次插入后平衡两个堆的大小，保证中位数只和两个堆顶有关</p><h2 id="9-25-在两个长度相等的排序数组中找到上中位数"><a href="#9-25-在两个长度相等的排序数组中找到上中位数" class="headerlink" title="9.25 在两个长度相等的排序数组中找到上中位数"></a>9.25 在两个长度相等的排序数组中找到上中位数</h2><p>两个数组分别二分查找，结果是分成了四段数组，比较 $arr1[mid]$ 和 $arr2[mid]$ ，如果二者相等说明 $arr[mid]$ 就是合并后数组的上中位数，如果 $arr1[mid]&gt;arr2[mid]$ ，说明合并后的数组中， $arr1[mid:right]$ 在最右边， $arr2[left:mid]$ 在最左边，把这两部分排除，对 $arr1[left:mid]$ 和 $arr2[mid:right]$ 继续做二分查找，最终时间 $O(logN)$  </p><h2 id="9-26-在两个排序数组中找到第-K-小的数"><a href="#9-26-在两个排序数组中找到第-K-小的数" class="headerlink" title="9.26 在两个排序数组中找到第 $K$ 小的数"></a>9.26 在两个排序数组中找到第 $K$ 小的数</h2><p>仿照上题，看第 $K$ 小的数出现在哪部分里，每次对新的子数组二分查找要让 $K$ 减去左边排除掉的部分，最终时间 $O(log(min{M,N}))$ ，因为分别在两个数组上二分查找，复杂度由短的决定</p><h2 id="9-27-两个有序数组间相加和的-TOPK-问题"><a href="#9-27-两个有序数组间相加和的-TOPK-问题" class="headerlink" title="9.27 两个有序数组间相加和的 $TOPK$ 问题"></a>9.27 两个有序数组间相加和的 $TOPK$ 问题</h2><p>维护一个大根堆，先把 $arr1[M-1]+arr2[N-1]$ 插入堆，重复以下操作，弹出堆顶，假设是 $arr1[i]+arr2[j]$ ，同时把 $arr1[i-1]+arr2[j]$ 和 $arr1[i]+arr2[j-1]$ 插入堆，也就是每次从堆里弹出一个元素，同时保证还在堆里的元素是数组间相加和最大的几个，每次堆的大小加一，最终大小是 $K$ ，堆插入时间是 $O(logK)$ ，所以总时间 $O(KlogK)$ </p><h2 id="9-28-出现次数的-TOPK-问题"><a href="#9-28-出现次数的-TOPK-问题" class="headerlink" title="9.28 出现次数的 $TOPK$ 问题"></a>9.28 出现次数的 $TOPK$ 问题</h2><p>先用哈希表统计词频，再建立小根堆，堆的节点存储字符串和出现次数，遍历哈希表，依次把每条记录插入堆，当堆的大小是 $K$ 时，只有出现次数比堆顶元素多时才插入，最终堆里的元素就是出现次数 $TOPK$ ，时间 $O(NlogK)$  </p><p>没有数组，字符串动态添加，实时打印：也是维护一个大小为 $K$ 的小根堆，用一个哈希表 $A$ 存储字符串和节点的映射，再用一个哈希表 $B$ 存储节点到堆中位置的映射，每次添加字符串时，先更新 $A$ 中节点的频次属性，如果是新节点直接插入堆，否则然后通过 $B$ 找到节点在堆中的位置，更新节点的频次属性，调整节点的位置，期间保证哈希表和堆的修改同步，最终添加操作 $O(logK)$ ，打印操作直接按位置顺序打印，时间 $O(K)$  </p><h2 id="9-29-Manacher-算法"><a href="#9-29-Manacher-算法" class="headerlink" title="9.29  $Manacher$ 算法"></a>9.29  $Manacher$ 算法</h2><p>单独写</p><h2 id="9-30-KMP-算法"><a href="#9-30-KMP-算法" class="headerlink" title="9.30  $KMP$ 算法"></a>9.30  $KMP$ 算法</h2><p>单独写</p><h2 id="9-31-丢棋子问题"><a href="#9-31-丢棋子问题" class="headerlink" title="9.31 丢棋子问题"></a>9.31 丢棋子问题</h2><p>方法一： $P(N,K)$ 表示 $N$ 层楼有 $K$ 个棋子在最差情况下扔的最少次数，显然 $P(0,K)=0$ ， $P(N,1)=N$ ，一般情况时，当在第 $i$ 层扔下，如果碎了，结果就是 $1+P(i-1,K-1)$ ，如果没碎，结果就是 $1+P(N-i,K)$ ，最差情况是二者的最大值，所以用递归的方法， $P(N,K)=min{max{P(i-1,K-1),P(N-i,K)}}(1\leq i\leq N)+1$ ，时间复杂度 $O(N!)$</p><p>方法二：动态规划， $dp[i][j]=P(i,j)$ ，遍历数组时间 $O(N\times K)$ ，求 $min-max$ 过程 $O(N)$ ，所以总时间 $O(N^2\times K)$   </p><p>优化一：压缩空间， $P(N,K)$  的子问题只遍历 $N$ ，所以对于每个 $dp[i][j]$ 只需要维护左边一列和上边一行空间</p><p>优化二：用四边形不等式优化枚举，楼层数相同时，棋子少越少，第一个棋子扔的层数就越高，棋子数相同时，楼层数越多，第一个棋子扔的层数就越高，所以第一个棋子扔的位置可以作为边界来减少枚举</p><p>$\color{red}{四边形不等式的原理没太看懂}$</p><p>最优解： $map[i][j]$ 表示 $i$ 个棋子扔 $j$ 次最多能判断多高的楼层，第一行第一列直接赋值，扔了第一个棋子后，如果碎了就剩 $i-1$ 个棋子扔 $j-1$ 次，如果没碎就剩 $i$ 个棋子扔 $j-1$ 次，再加上第一次扔的这层，有 $map[i][j]=map[i-1][j-1]+map[i][j-1]+1$ ，之所以不需要 $min-max$ 的过程是因为 $map$ 表示能力的上限，第一次扔完以后要么只向下搜索要么只向上搜索，所以能力值应该是两个方向上的总和，而 $P(N,K)$ 表示运气最差的一种情况，所以必须要通过遍历确定唯一的子问题。在棋子数给定时，只需遍历 $map$ 的一行就能搜索到答案</p><h2 id="9-32-画匠问题"><a href="#9-32-画匠问题" class="headerlink" title="9.32 画匠问题"></a>9.32 画匠问题</h2><p>方法一： $dp[i][j]$ 表示 $i$ 个画家画 $j$ 幅画的最少时间，有 $dp[i][j]=min{max{dp[i-1][k]+sum[k+1..j]}}(0\leq k\leq j)$ ，时间 $O(N^2\times K)$ </p><p>优化：四边形不等式减少枚举，时间 $O(N^2)$  </p><p>最优解：规定每个画匠最大工作时间 $limit$ ，遍历一遍数组可以知道至少需要几个画匠， $limit$ 的范围是 $[0,sum(arr)]$ ，比较 $limit$ 限定下画匠人数与题目给出的人数，用二分法确定 $limit$ 的大小，时间 $O(NlogSum(arr))$   </p><h2 id="9-33-邮局选址问题"><a href="#9-33-邮局选址问题" class="headerlink" title="9.33 邮局选址问题"></a>9.33 邮局选址问题</h2><p>方法一：假设 $arr[i,j]$ 上只能建一个邮局，一定是建在中点上总距离最小， $w[i][j]$ 表示这个总距离，因为 $arr[i,j-1]$ 变成 $arr[i,j]$ 后中点位置不变，所以有 $w[i][j]=w[i][j-1]+arr[j]-arr[(i+j)/2]$ ，多的就是新增的点到中点的距离。 $dp[i][j]$ 表示在 $arr[0,j]$ 上建 $i+1$ 个邮局的最小总距离，首先有 $dp[0][j]=w[0][j]$ ，一般情况下 $dp[i][j]=min{dp[i-1][k]+w[k+1][j]}(0\leq k\leq N)$ ，表示在 $arr[0,k]$ 建 $i-1$ 个，在 $arr[k+1,j]$ 建 $1$ 个，枚举所有情况选择总距离最小的，时间 $O(N^2\times Num)$   </p><p>优化：四边形不等式，时间 $O(N^2)$ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://shivakasu.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 7：函数装饰器和闭包</title>
    <link href="http://shivakasu.github.io/2019/02/10/fpy4/"/>
    <id>http://shivakasu.github.io/2019/02/10/fpy4/</id>
    <published>2019-02-09T17:56:20.000Z</published>
    <updated>2020-01-15T10:52:15.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、python中的函数装饰器(Function decorator)用来“标记函数”，以某种方式增强函数的行为，其实就是一种语法糖(syntactic sugar)，用来简化复杂的代码。如下：</p><p><a href="https://file.shivakasu.cn/8c1032b5313113d9b58d/fpy4-0.png" data-fancybox="group" data-caption="fpy4-0" class="fancybox"><img alt="fpy4-0" title="fpy4-0" data-src="https://file.shivakasu.cn/8c1032b5313113d9b58d/fpy4-0.png" class="lazyload"></a></p><p>可以用装饰器实现函数的替换，虽然这么做没什么意义：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def deco(func):</span><br><span class="line">...     def inner():</span><br><span class="line">...print(&#39;running inner()&#39;)</span><br><span class="line">...     return inner #1</span><br><span class="line">&gt;&gt;&gt; @deco</span><br><span class="line">... def target(): #2</span><br><span class="line">...     print(&#39;running target()&#39;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; target() #3</span><br><span class="line">running inner()</span><br><span class="line">&gt;&gt;&gt; target #4</span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at 0x10063b598&gt;</span><br></pre></td></tr></table></figure></div></p><p>还可以用作注册函数，对于新增的函数，只需要添加装饰器，而不用手动进行注册：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">registry &#x3D; []</span><br><span class="line"></span><br><span class="line">def register(func):</span><br><span class="line">  print(&#39;running register(%s)&#39; % func) </span><br><span class="line">    registry.append(func)</span><br><span class="line">  return func</span><br><span class="line"></span><br><span class="line">@register</span><br><span class="line">def f1():</span><br><span class="line">    print(&#39;running f1()&#39;)</span><br><span class="line"></span><br><span class="line">@register</span><br><span class="line">def f2():</span><br><span class="line">    print(&#39;running f2()&#39;)</span><br><span class="line"></span><br><span class="line">def f3():</span><br><span class="line">    print(&#39;running f3()&#39;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&#39;running main()&#39;) </span><br><span class="line">    print(&#39;registry -&gt;&#39;, registry) </span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line">    </span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;: </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div></p><p>装饰器在函数定义后立即运行，这通常是在导入(import)时，例如上面代码的执行结果是：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python3 registration.py</span><br><span class="line">running register(&lt;function f1 at 0x100631bf8&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x100631c80&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x100631bf8&gt;, &lt;function f2 at 0x100631c80&gt;] running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure></div></p><p>单独执行import操作，得到的结果是：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import registration</span><br><span class="line">running register(&lt;function f1 at 0x10063b1e0&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x10063b268&gt;)</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;2、闭包(closures)指的是嵌套函数的作用于问题，如图，内层函数可以直接使用上层函数定义的变量，这种变量又叫做自由变量。</p><p><a href="https://file.shivakasu.cn/1a649177761a4cfd26cd/fpy4-1.png" data-fancybox="group" data-caption="fpy4-1" class="fancybox"><img alt="fpy4-1" title="fpy4-1" data-src="https://file.shivakasu.cn/1a649177761a4cfd26cd/fpy4-1.png" class="lazyload"></a></p><p>但自由变量只能使用，如果对自由变量进行赋值，就会被解释器当做局部变量而抛出“变量未定义”的异常，如下，这是由于python不要求像C一样先声明变量再使用变量，所以遇到对非全局变量的赋值操作会直接看作局部变量。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    total &#x3D; 0</span><br><span class="line">    def averager(new_value):</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        total +&#x3D; new_value</span><br><span class="line">        return total &#x2F; count</span><br><span class="line">    return averager</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; avg &#x3D; make_averager()</span><br><span class="line">&gt;&gt;&gt; avg(10)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">UnboundLocalError: local variable &#39;count&#39; referenced before assignment</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></div></p><p>这种情况下不能使用<code>global</code>关键字，因为没有涉及全局变量，而是嵌套函数中因为层次关系产生的相对外层的变量，这时候就要用<code>nonlocal</code>关键字，用法和<code>global</code>一样。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    total &#x3D; 0</span><br><span class="line">    def averager(new_value):</span><br><span class="line">        nonlocal count, total</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        total +&#x3D; new_value</span><br><span class="line">        return total &#x2F; count</span><br><span class="line">    return averager</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;3、functools模块有两个实用的装饰器。<code>lru_cache</code>用来缓存函数的中间结果，LRU即Least Recently Used，如下，在计算斐波那契数的递归过程中，计算过的值会保存在缓存中，减少重复计算。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">@functools.lru_cache()</span><br><span class="line">def fibonacci(n):</span><br><span class="line">    if n&lt;2:</span><br><span class="line">        return n</span><br><span class="line">    return fibonacci(n-2) + fibonacci(n-1)</span><br></pre></td></tr></table></figure></div></p><p><code>singledispatch</code>装饰器用来生成泛函数(generic function)，指的是根据函数参数的类型以不同方式执行操作。由于<code>singledispatch</code>只根据函数第一个参数，所以称作单分派泛函数，与之对应的是多分派(multiple-dispatch)。用法如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from functools import singledispatch</span><br><span class="line">from collections import abc</span><br><span class="line">import numbers</span><br><span class="line">import html</span><br><span class="line"></span><br><span class="line">@singledispatch</span><br><span class="line">def htmlize(obj):</span><br><span class="line">    content &#x3D; html.escape(repr(obj))</span><br><span class="line">    return &#39;&lt;pre&gt;&#123;&#125;&lt;&#x2F;pre&gt;&#39;.format(content)</span><br><span class="line"></span><br><span class="line">@htmlize.register(str) </span><br><span class="line">def _(text):        </span><br><span class="line">    content &#x3D; html.escape(text).replace(&#39;\n&#39;, &#39;&lt;br&gt;\n&#39;)</span><br><span class="line">    return &#39;&lt;p&gt;&#123;0&#125;&lt;&#x2F;p&gt;&#39;.format(content)</span><br><span class="line"></span><br><span class="line">@htmlize.register(numbers.Integral)</span><br><span class="line">def _(n):</span><br><span class="line">    return &#39;&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;&#x2F;pre&gt;&#39;.format(n)</span><br><span class="line"></span><br><span class="line">@htmlize.register(tuple)</span><br><span class="line">@htmlize.register(abc.MutableSequence)</span><br><span class="line">def _(seq):</span><br><span class="line">    inner &#x3D; &#39;&lt;&#x2F;li&gt;\n&lt;li&gt;&#39;.join(htmlize(item) for item in seq)</span><br><span class="line">    return &#39;&lt;ul&gt;\n&lt;li&gt;&#39; + inner + &#39;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;&#39;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;4、闭包是静态作用域(static scope)下的概念，与之相对的是动态作用域(dynamic scope)。静态作用域又叫做词法作用域(lexical scope)，C、C++、Python、Java等大多数现在程序设计语言都是采用静态作用域规则，指的是变量的作用域是确定的，词法分析时不会逐层检查函数的调用链，而是检查函数定义时的外部环境，从当前作用域由内而外寻找最近的该变量的定义。动态作用域完全相反，变量的作用域是不确定的，根据函数的调用层次确定变量的定义，也就是说只要在调用函数之前在当前环境重新定义变量，函数就能使用新定义的变量，不关注结构上的层次。个人理解动态作用域的缺点就是变量随意覆盖可能引起意外bug，而且代码中一个变量有多个版本也会大大降低可读性吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 5：一等函数</title>
    <link href="http://shivakasu.github.io/2019/02/10/fpy3/"/>
    <id>http://shivakasu.github.io/2019/02/10/fpy3/</id>
    <published>2019-02-09T16:45:20.000Z</published>
    <updated>2020-01-15T10:51:40.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、在python中，函数是一等对象(first-class object)，一等对象的特征有：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ul><p>接受函数为参数或把函数作为结果返回的函数又叫高阶函数(higher-order function)，常见的高阶函数例如python内置的<code>sorted</code>，其接收一个参数key，当想根据长度排序时，可以写成<code>sorted(xxx,key=len)</code>，这就是把<code>len()</code>函数作为参数传给<code>sorted()</code>。在函数式编程范式中，常用的高阶函数有<code>map</code>、<code>filter</code>、<code>reduce</code>和<code>apply</code>，然而在python中不常用这些函数，因为已经有了更简单的替代方式。</p><ul><li><code>map</code>函数用来求一个序列或者多个序列进行函数映射之后的值，<code>filter</code>函数用来过滤掉序列中不符合函数条件的元素，二者完全可以用列表推导式替代，对应for循环和if条件判定。</li><li><code>reduce</code>函数用来对一个序列进行压缩运算，在python3中已经移到了functools模块，该方法最常用于序列求和，因此可以用python内置的<code>sum</code>函数替代。</li><li><code>apply(func [, args [, kwargs ]])</code>函数用于当函数参数已经存在于一个元组或字典中时，间接地调用函数。因为python本来就支持函数定义中包含不定量参数，所以<code>apply</code>函数反而多此一举，python3中已经移除了。但在第三方库例如pandas中还在使用。</li></ul><p>&emsp;&emsp;2、python中能使用调用符号“()”的对象称为可调用对象(Callable Objects)，有7种可调用对象：</p><ul><li>用户用<code>def</code>或<code>lambda</code>定义的函数</li><li>内置函数：使用C语言实现的函数，如<code>len</code>或<code>time.strftime</code></li><li>内置方法：使用C语言实现的方法，如<code>dict.get</code></li><li>方法：在类的定义体中定义的函数</li><li>类：由于python没有new函数，所以创建实例时直接调用类</li><li>类的实例：如果类定义了<code>__call__</code>方法，它的实例就可以作为函数调用</li><li>生成器函数：使用<code>yield</code>关键字的函数或方法</li></ul><p>&emsp;&emsp;3、有必要理解一下关键字、方法、函数的区别：</p><ul><li>关键字：内置的、具有特殊意义的表示符，使用时不加“()”</li><li>方法：封装了独立的功能，需要用对象调用，对象.方法名(参数)</li><li>函数：也是封装了独立的功能，直接调用或使用模块名调用</li></ul><p>&emsp;&emsp;4、operator模块提供了对函数式编程的支持。例如在使用<code>reduce</code>函数对序列求和时，需要传入一个函数，因此不能直接使用“+”，所以需要另外定义表示加减乘除这类运算的函数，operator模块内置了这些函数，所以就没必要自己定义了。</p><p>&emsp;&emsp;operator模块的<code>itemgetter</code>和<code>attrgetter</code>函数可用于替代从序列中取出元素或读取对象属性的lambda表达式，如下：</p><p><a href="https://file.shivakasu.cn/40f22754538470b8b094/fpy3-0.png" data-fancybox="group" data-caption="fpy3-0" class="fancybox"><img alt="fpy3-0" title="fpy3-0" data-src="https://file.shivakasu.cn/40f22754538470b8b094/fpy3-0.png" class="lazyload"></a></p><p>&emsp;&emsp;5、第六章讲的是用一等函数实现设计模式，思想很简单，因为函数也能作为参数，所以就可以简化代码，不必为了实现特定功能而创建一个类，再用类的实例调用方法，而是可以直接定义函数，把函数作为参数传进方法里调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 3：字典和集合</title>
    <link href="http://shivakasu.github.io/2019/02/07/fpy2/"/>
    <id>http://shivakasu.github.io/2019/02/07/fpy2/</id>
    <published>2019-02-07T07:35:20.000Z</published>
    <updated>2020-01-15T10:51:17.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、collections.abc模块中有Mapping和MutableMapping两个抽象基类，它们的作用是为dict和其他类似的类型定义形式接口。</p><p><a href="https://file.shivakasu.cn/0f9a7c1e0a2a1f236e69/fpy2-0.png" data-fancybox="group" data-caption="fpy2-0" class="fancybox"><img alt="fpy2-0" title="fpy2-0" data-src="https://file.shivakasu.cn/0f9a7c1e0a2a1f236e69/fpy2-0.png" class="lazyload"></a></p><p>&emsp;&emsp;2、标准库里的所有映射类型都是利用dict实现的，只有可散列(hashable)的数据类型才能用作这些映射里的键。如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现<code>__hash__()</code>方法进行散列，也要实现<code>__eq__()</code>方法进行键的比较。python的原子不可变类型(str、bytes和数值类型)是可散列的，一个元组是可散列的当且仅当其包含的元素都是可散列的。所以严格来说不可变类型不都是可散列的，元组不一定。</p><p>&emsp;&emsp;3、和列表推导式类似，字典也有推导构建法：</p><p><a href="https://file.shivakasu.cn/e836fd38437371f66c90/fpy2-1.png" data-fancybox="group" data-caption="fpy2-1" class="fancybox"><img alt="fpy2-1" title="fpy2-1" data-src="https://file.shivakasu.cn/e836fd38437371f66c90/fpy2-1.png" class="lazyload"></a></p><p>&emsp;&emsp;4、处理字典可能找不到键的情况：</p><ul><li>使用<code>setdefault()</code>方法，如下图。这样做的好处是减少了查询字典的次数，如果键不存在，不使用<code>setdefault()</code>就需要查三次字典。</li></ul><p><a href="https://file.shivakasu.cn/46667e1b2d7ac26c5a89/fpy2-2.png" data-fancybox="group" data-caption="fpy2-2" class="fancybox"><img alt="fpy2-2" title="fpy2-2" data-src="https://file.shivakasu.cn/46667e1b2d7ac26c5a89/fpy2-2.png" class="lazyload"></a></p><ul><li><p>使用<code>collections.defaultdict</code>字典，提供一个可调用对象作为参数。例如当用语句<code>index = collections.defaultdict(list)</code>创建字典后，执行<code>index[&#39;new_key&#39;]</code>找不到键，则会自动调用<code>list()</code>方法生成空列表，并以<code>new_key</code>为键添加到字典中，最后返回该列表的引用。</p></li><li><p>上述两种方法的原理都是实现了<code>__missing__</code>方法，字典使用<code>__getitem__</code>方法进行查询，当找不到键时，如果实现了<code>__missing__</code>方法，<code>__getitem__</code>会直接调用，否则抛出异常。原始的dict没有实现<code>__missing__</code>方法，但它知道有了<code>__missing__</code>方法就可以用。所以第三种方法是创建dict的子类，实现<code>__missing__</code>方法。</p></li></ul><p>&emsp;&emsp;5、types模块有一个封装类MappingProxyType，用于返回一个字典的不可变的视图，这个视图是动态的，原字典改变视图也会随之改变，所以如果不想字典在使用过程中被修改，可能会用到这个类。</p><p><a href="https://file.shivakasu.cn/abfb07d5347032214e78/fpy2-3.png" data-fancybox="group" data-caption="fpy2-3" class="fancybox"><img alt="fpy2-3" title="fpy2-3" data-src="https://file.shivakasu.cn/abfb07d5347032214e78/fpy2-3.png" class="lazyload"></a></p><p>&emsp;&emsp;6、python的集合类型有set和frozenset，集合中的元素必须是可散列的，set本身是不可散列的，但frozenset是可散列的。</p><p>&emsp;&emsp;7、set集合除了可以从列表生成，还可以使用集合字面量(set literals)定义。比如<code>s=set([1,2,3])</code>和<code>s={1,2,3}</code>是等价的，但字面量方式更高效。需要注意，空集只能用<code>s=set()</code>生成，字面量形式的<code>s={}</code>是生成空字典。此外，frozenset不支持字面量操作，所以只能从列表生成。由于支持字面量定义，set集合还能用推导式生成，和列表推导式类似，只不过两端是大括号。</p><p>&emsp;&emsp;8、集合类的继承关系如下：</p><p><a href="https://file.shivakasu.cn/86d91f935448abd03439/fpy2-4.png" data-fancybox="group" data-caption="fpy2-4" class="fancybox"><img alt="fpy2-4" title="fpy2-4" data-src="https://file.shivakasu.cn/86d91f935448abd03439/fpy2-4.png" class="lazyload"></a></p><p>&emsp;&emsp;9、dict是用散列表实现的，理论上只要字典不超过内存大小，查询操作耗费的时间都能忽略不计。散列表的查询流程如下，其中bucket指的是散列表中的单元，即表元，dict的每个键值对占用一个表元。由于流程中使用散列值的一部分进行匹配，可能会发生匹配部分相同但整体键不相等，这就叫散列冲突(hash collision)，这时就会取散列值的另一部分再进行匹配。虽然看似效率低下，但散列函数的特性是不相等的对象散列值差别很大，所以实际上发生散列冲突的概率非常小。</p><p><a href="https://file.shivakasu.cn/bdf6d1f9ffd1823a2b1e/fpy2-5.png" data-fancybox="group" data-caption="fpy2-5" class="fancybox"><img alt="fpy2-5" title="fpy2-5" data-src="https://file.shivakasu.cn/bdf6d1f9ffd1823a2b1e/fpy2-5.png" class="lazyload"></a></p><p>&emsp;&emsp;10、字典提供了无视数据量大小的快速访问，代价是空间效率低下，因为散列表必须是稀疏的，需要占用大量空间。此外，不能对字典同时进行迭代和修改，如果往字典里添加新键，解释器可能会做出为字典扩容的决定，将当前散列表迁移到更大的散列表中，在这个过程中对字典进行迭代，可能会出现问题。</p><p>&emsp;&emsp;11、set和frozenset集合也是基于散列表实现的，只不过表元是对单个元素的引用。所以集合类型也有时间效率高、空间效率低的特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 2：序列构成的数组</title>
    <link href="http://shivakasu.github.io/2019/02/06/fpy1/"/>
    <id>http://shivakasu.github.io/2019/02/06/fpy1/</id>
    <published>2019-02-06T15:13:20.000Z</published>
    <updated>2020-01-15T10:49:51.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、python标准库用C实现了丰富的序列类型：</p><ul><li>容器序列(Container sequences)：list、tuple、collections.deque这些序列能存放不同类型数据。</li><li>扁平序列(Flat sequences)：str、bytes、bytearray、memoryview、array.array这些序列只能容纳一种类型。</li><li>可变序列(Mutable sequences)：list、bytearray、array.array、collections.deque、memoryview这些序列可以原地修改。</li><li>不可变序列(Immutable sequences)：tuple、str、bytes这些序列不能原地修改。</li></ul><p>&emsp;&emsp;下图是序列对象的继承关系，箭头从子类指向父类，可以看到可变对象之所以能够修改是因为实现了<code>__setitem__</code>、<code>__delitem__</code>等方法。</p><p><a href="https://file.shivakasu.cn/30693800bf9c8aaec269/fpy1-0.png" data-fancybox="group" data-caption="fpy1-0" class="fancybox"><img alt="fpy1-0" title="fpy1-0" data-src="https://file.shivakasu.cn/30693800bf9c8aaec269/fpy1-0.png" class="lazyload"></a></p><p>&emsp;&emsp;2、python会忽略代码里[]、()、{}中的换行，所以写列表推导时直接回车换行，不用加续行符“\”。</p><p>&emsp;&emsp;3、当使用“*”对序列进行复制时，要保证序列里没有对其他可变对象的引用，引用只能浅复制，当修改其中一个引用时，其他的也会改变。如下：</p><p><a href="https://file.shivakasu.cn/5c7b7afa5830505936ad/fpy1-1.png" data-fancybox="group" data-caption="fpy1-1" class="fancybox"><img alt="fpy1-1" title="fpy1-1" data-src="https://file.shivakasu.cn/5c7b7afa5830505936ad/fpy1-1.png" class="lazyload"></a></p><p>&emsp;&emsp;4、不要把可变对象放到元组里，修改元组里的可变对象虽然会抛出异常，但对象可能会真的被修改。</p><p>&emsp;&emsp;5、<code>list.sort()</code>原地排序，<code>sorted()</code>创建新列表排序并返回。</p><p>&emsp;&emsp;6、如果需要一个只包含数字的列表，使用array.array比list更高效，因为list将数字存成python的整形和浮点型，而array.array把数字直接存成机器翻译，也就是字节表述。道理是这样，用的时候还是对比一下速度吧，list、array和numpy的array。</p><p>&emsp;&emsp;7、python内置的排序函数使用了Timsort排序算法。Timsort混合了插入排序和归并排序，因为真实世界中的数据往往带有一定的顺序，所以根据输入的特点进行分区，分区内插入排序，分区间归并排序。</p><p><a href="https://file.shivakasu.cn/07961a9a7b4f7d22bf62/fpy1-2.png" data-fancybox="group" data-caption="fpy1-2" class="fancybox"><img alt="fpy1-2" title="fpy1-2" data-src="https://file.shivakasu.cn/07961a9a7b4f7d22bf62/fpy1-2.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 1：Python 数据模型</title>
    <link href="http://shivakasu.github.io/2019/02/04/fpy0/"/>
    <id>http://shivakasu.github.io/2019/02/04/fpy0/</id>
    <published>2019-02-04T07:08:20.000Z</published>
    <updated>2020-01-15T10:49:04.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;这一章写的是python的特殊方法(special method)，又叫作魔术方法(magic method)。最常见的就是面向对象编程时的初始化方法<code>__init__</code>，这类方法的特点有：</p><ul><li>方法名首尾有两个下划线。</li><li>所有特殊方法都是python内置的，使用时只需要在类里重写，最好不要自己定义新的特殊方法。</li><li>特殊方法都与特殊操作绑定，不需要显式调用。如<code>__init__</code>与对象初始化绑定，<code>__len__</code>与<code>len()</code>方法绑定，<code>__add__</code>与<code>+</code>运算绑定。</li></ul><p>&emsp;&emsp;部分特殊方法如下，首先是与运算符无关的特殊方法：<br><a href="https://file.shivakasu.cn/8836120fad62e60bb92d/fpy0-0.png" data-fancybox="group" data-caption="fpy0-0" class="fancybox"><img alt="fpy0-0" title="fpy0-0" data-src="https://file.shivakasu.cn/8836120fad62e60bb92d/fpy0-0.png" class="lazyload"></a></p><p>然后是与运算符有关的特殊方法：<br><a href="https://file.shivakasu.cn/f0816f76a0187e1073fd/fpy0-1.png" data-fancybox="group" data-caption="fpy0-1" class="fancybox"><img alt="fpy0-1" title="fpy0-1" data-src="https://file.shivakasu.cn/f0816f76a0187e1073fd/fpy0-1.png" class="lazyload"></a></p><p>&emsp;&emsp;<code>__repr__</code>和<code>__str__</code>都是用于定义对象的字符串表示形式。区别是前者用于在命令行直接输入一个对象时返回的字符串，后者是调用<code>str()</code>方法或<code>print()</code>时返回的字符串。如果只想实现其中一个特殊方法，就实现<code>__repr__</code>，因为没有<code>__str__</code>时解释器会自动调用<code>__repr__</code>。</p><p>&emsp;&emsp;<code>__bool__</code>用于定义一个对象的真值，如果对象需要参与条件判定的话，可以用<code>bool()</code>方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 6：文档-语言及属性</title>
    <link href="http://shivakasu.github.io/2019/02/03/mir4/"/>
    <id>http://shivakasu.github.io/2019/02/03/mir4/</id>
    <published>2019-02-02T18:20:20.000Z</published>
    <updated>2020-01-15T10:57:35.651Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-文本相似度"><a href="#1-文本相似度" class="headerlink" title="1 文本相似度"></a>1 文本相似度</h2><p>&emsp;&emsp;文本的相似度依靠距离函数度量，距离函数应该是对称的，即不受参数顺序影响，并且应该满足三角不等式：</p><script type="math/tex; mode=display">distance(a,c)\leq distance(a,b)+distance(b,c)</script><p>&emsp;&emsp;常见的距离函数如下：</p><ul><li>海明距离(Hamming distance)：对于相同长度的字符串，定义它们之间的距离为他们拥有不同字符的位置的个数。</li><li>编辑距离(Edit distance)：使两个字符串相同而在其中任何一个字符串上进行字符插入、删除和替换操作的最少次数。如“color”和“colour”的编辑距离是1。编辑距离是处理语法错误的首选模型。</li><li>最长公共子序列(longest common subsequence, LCS)：如“survey”和“surgery”的最长公共子序列是“surey”。</li><li>余弦相似度：第三章提到过。</li><li>类似度(resemblance)：两个文档词汇表的重合度。定义 <script type="math/tex">W(d_j)</script> 是 <script type="math/tex">d_j</script> 中所有不同词的集合，两个文档的类似度定义为：<script type="math/tex; mode=display">R(d_i,d_j)=\frac{|W(d_i)\cap W(d_j)|}{|W(d_i)\cup W(d_j)|}</script></li></ul><p>&emsp;&emsp;任何在 <script type="math/tex">[0,1]</script> 范围内的相似度度量都可以通过以下方式方便地转换为距离函数：</p><script type="math/tex; mode=display">D(d_i,d_j)=1-Sim(d_i,d_j)</script><h2 id="2-文档预处理"><a href="#2-文档预处理" class="headerlink" title="2 文档预处理"></a>2 文档预处理</h2><p>&emsp;&emsp;文档预处理阶段的逻辑视图如下，主要分为五个步骤：<br><a href="https://file.shivakasu.cn/655c2c17308c95635b27/mir4-0.png" data-fancybox="group" data-caption="mir4-0" class="fancybox"><img alt="mir4-0" title="mir4-0" data-src="https://file.shivakasu.cn/655c2c17308c95635b27/mir4-0.png" class="lazyload"></a></p><h3 id="2-1-词汇分析"><a href="#2-1-词汇分析" class="headerlink" title="2.1 词汇分析"></a>2.1 词汇分析</h3><p>&emsp;&emsp;词汇分析(Lexical analysis)是将字符流转化为单词流的过程，就是分词。主要考虑以下几种情况：</p><ul><li>空格(Space)：最常见的分词符。</li><li>数字(Numbers)：根据上下文确定数字代表的意义，如量化数值、时间点，或是“512B.C.”这样的混合词。</li><li>连字符(Hyphens)：要不要拆，像“state-of-the-art”可拆可不拆，像表示序号的“A-3”最好不要拆。</li><li>标点符号(Punctuation marks)：区别对待句间分隔符、词间分隔符和词内分隔符。</li><li>大小写：要不要区分单词大小写，通常会影响到一些专有名词，如人名、地名、组织名。</li></ul><h3 id="2-2-去除停用词"><a href="#2-2-去除停用词" class="headerlink" title="2.2 去除停用词"></a>2.2 去除停用词</h3><p>&emsp;&emsp;停用词(Stopwords)通常是出现频率较多的词，被认为没有什么区分度，常见的是冠词、介词和连词。去除停用词可以减少索引结构的大小，但也会造成召回率的降低，也就是把一些相关的文本删到识别不出。所以有些Web搜索引擎会采用全文检索，不去除停用词。</p><h3 id="2-3-词干提取"><a href="#2-3-词干提取" class="headerlink" title="2.3 词干提取"></a>2.3 词干提取</h3><p>&emsp;&emsp;词干(stem)提取就是所谓的词形还原，把名词复数、动词过去式等还原。我觉得比较靠谱的方法也就是根据语法规则和查词表两种，但是词干提取对检索性能是否有帮助仍然存在争论。</p><h3 id="2-4-关键词选择"><a href="#2-4-关键词选择" class="headerlink" title="2.4 关键词选择"></a>2.4 关键词选择</h3><p>&emsp;&emsp;和全文索引相对立，只选取文本中一部分代表性的词作为索引项，因此这种索引项也叫作关键词。关键词通常都是名词或者名词组，因为名词能够携带更多的信息。</p><h3 id="2-5-同义词典"><a href="#2-5-同义词典" class="headerlink" title="2.5 同义词典"></a>2.5 同义词典</h3><p>&emsp;&emsp;好像没什么用。</p><h2 id="3-组织文档"><a href="#3-组织文档" class="headerlink" title="3 组织文档"></a>3 组织文档</h2><p>&emsp;&emsp;顾名思义，就是文档的组织方式。主要有分类体系法(Taxonomies)和分众分类法(Folksonomies)。</p><p>&emsp;&emsp;分类体系法的核心是层次化，需要有一个清晰的分类层次，也需要对文档的类别有准确的描述，如下图：<br><a href="https://file.shivakasu.cn/8deff9e5f5b1bae97655/mir4-1.png" data-fancybox="group" data-caption="mir4-1" class="fancybox"><img alt="mir4-1" title="mir4-1" data-src="https://file.shivakasu.cn/8deff9e5f5b1bae97655/mir4-1.png" class="lazyload"></a></p><p>&emsp;&emsp;分众分类法的核心是扁平化，最常见的是标签云，如下图。因为不能准确、完全地描述文档，所以只提取一些用户感兴趣的关键词作为标签。<br><a href="https://file.shivakasu.cn/492e5812293591e5228f/mir4-2.png" data-fancybox="group" data-caption="mir4-2" class="fancybox"><img alt="mir4-2" title="mir4-2" data-src="https://file.shivakasu.cn/492e5812293591e5228f/mir4-2.png" class="lazyload"></a></p><h2 id="4-文本压缩"><a href="#4-文本压缩" class="headerlink" title="4 文本压缩"></a>4 文本压缩</h2><p>&emsp;&emsp;文本压缩的目的是减少空间开销、输入/输出开销和通信时延。选择压缩方法时需要考虑的因素有：</p><ul><li>压缩比，即压缩后大小与压缩前大小之比。</li><li>压缩和解压缩的速度，通常解压缩的速度更重要，因为只有在存储文档的时候需要压缩，而后续每次访问文档时都需要进行解压。</li><li>压缩文本是否支持搜索，即检索过程可以直接在压缩文档上进行，不需要预先解压缩，直接搜索压缩文档的速度会更快。</li></ul><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>&emsp;&emsp;文本压缩有两个通用方法：统计方法(statistical)和基于字典的方法(dictionary based)。统计方法估计每个文本符号出现的概率，根据出现概率将文本符号转换为二进制编码。字典方法从文档中识别出一系列可以被引用的短语，短语的集合称为字典，压缩的过程就是把文本中的短语替换成相应字典条目的指针。虽然压缩分为无损压缩和有损压缩，但在文档存储和检索的任务中，使用的基本都是无损压缩。</p><h3 id="4-2-统计方法"><a href="#4-2-统计方法" class="headerlink" title="4.2 统计方法"></a>4.2 统计方法</h3><p>&emsp;&emsp;统计方法定义为两个任务的组合：建模和编码。前者估计每个后续字符的概率，后者把后续符号编码成模型分配给他的概率函数，把每个符号表示成码字(codeword)。统计方法的理论基础是香农的信息论，信息压缩的下界是信息熵，文本的熵定义为：</p><script type="math/tex; mode=display">E=\sum p_ilog_2\frac{1}{p_i}</script><p>也就是出现概率为 <script type="math/tex">p_i</script> 的符号至少需要长度为 <script type="math/tex">log_2\frac{1}{p_i}</script> 的码字表示，由于码字通常是整数个编码单元，实际长度往往会大于这个理论值。同时，编码需要给出现概率高的符号尽可能短的码字，这样才能保证较低的压缩率。</p><h3 id="4-3-统计方法：建模"><a href="#4-3-统计方法：建模" class="headerlink" title="4.3 统计方法：建模"></a>4.3 统计方法：建模</h3><p>&emsp;&emsp;压缩模型分为自适应模型(adaptive model)、静态模型(static model)和半静态模型(semi-static model)。</p><ul><li>自适应模型：不需要关于文本的先验知识，只需要处理文本一遍，在处理过程中根据读入的新文档动态调整字符的概率分布。有两个缺点，一是速度慢，因为需要动态更新，二是只能从压缩文档的开头进行解压，因为关于分布的信息数据实在文件中增量存储的。</li><li>静态模型：对所有输入的文本假设一个分布，只需要处理文本一遍，对所有要压缩的文本都使用这个分布。缺点是不使用，假设的分布在新的文档上往往效果很差。</li><li>半静态模型：不需要假设分布，但是要处理文本两遍。第一遍学习字符的概率分布，第二遍进行压缩，优缺点也很明显。</li></ul><p>&emsp;&emsp;模型的阶(order)指的是用来估计下一个符号的概率而使用的前面符号的个数。 <script type="math/tex">0</script> 阶模型就是所谓的上下文无关模型，每个符号概率的计算都是独立的。高阶模型压缩效果更好，但是需要更大的空间存储和运行，此外，任一位置的解压都需要知道前面 <script type="math/tex">k</script> 个符号，所以高阶模型只能从开头进行解压，不支持随机访问。</p><p>&emsp;&emsp;除了基于字符的模型，还有基于词的模型，也就是直接对单词进行编码。词模型的理论基础是两个统计法则。一是 <script type="math/tex">Heaps</script> 法则，指出 <script type="math/tex">n</script> 个词的自然语言文本的词汇表大小 <script type="math/tex">V</script> 的增长是 <script type="math/tex">V=O(n^\beta)</script> ，其中 <script type="math/tex">\beta <1</script> 是一个依赖于特定文本的常数。第二个法则是 <script type="math/tex">Zipf</script> 法则，指出最常出现的第 <script type="math/tex">i</script> 个单词出现 <script type="math/tex">O(n/i^\alpha)</script> 次，其中 <script type="math/tex">\alpha >1</script> 是依赖于文本的常数。这两个法则保证了基于词的模型不会产生量级的爆炸，同时概率分布具有良好的偏斜性。</p><h3 id="4-4-统计方法：编码"><a href="#4-4-统计方法：编码" class="headerlink" title="4.4 统计方法：编码"></a>4.4 统计方法：编码</h3><p>&emsp;&emsp;霍夫曼编码(Huffman coding)是基于二叉树的前缀无关编码，通常使用霍夫曼树的规范树(canonical tree)形式，规范树规定任何结点的右子树不能高于他的左子树，因此给出有序的叶节点可以方便地还原规范树的结构。霍夫曼编码的缺点是只能从开头解码，因此不支持随机检索，例如考虑以下编码：A(0)、B(10)、C(110)、D(111)，若随机检索到编码片段 “11110”，就无法确定是“DB”还是开头少了一个1的“DC”，也就是两个码字的结合包含了第三个码字。更严谨的说法是不支持从任意位置解码，支持从任意码字的开头进行解码，虽然这么说没什么意义吧。</p><p>&emsp;&emsp;字节霍夫曼编码(Byte-Huffman coding)是基于词的模型，使用字节代替位进行编码，因此编码树不是二叉树，而是256叉树。好像用的不是很多。</p><p>&emsp;&emsp;密集编码(Dense coding)也是基于字节的编码，如下图，其中“<128>”指的是该字节的值是128。密集编码比字节霍夫曼编码更简单，在各个方面都优于字节霍夫曼编码，更重要的是密集编码支持从任意位置解码。因为密集编码可以很好地区分码头和码尾，整个字节的识别是很简单的，而观察到密集编码的结束字节值是在128到255之间的，这种属性称作自同步(self-synchronizing)，结束的字节称为停止符，之前的所有字节都称为持续符。更广义的密集编码记作 <script type="math/tex">(s,c)</script> 密集编码，不把128作为持续符和停止符的界限，只要保证 <script type="math/tex">s+c=256</script> ，可以修改为 <script type="math/tex">c</script> 个持续符和 <script type="math/tex">s</script> 个停止符，选择最优的组合。<br><a href="https://file.shivakasu.cn/041fc0ed18d81d8d73cc/mir4-3.png" data-fancybox="group" data-caption="mir4-3" class="fancybox"><img alt="mir4-3" title="mir4-3" data-src="https://file.shivakasu.cn/041fc0ed18d81d8d73cc/mir4-3.png" class="lazyload"></a></128></p><p>&emsp;&emsp;算术编码，只写了一段，细节太少，没看懂。</p><h3 id="4-5-字典方法"><a href="#4-5-字典方法" class="headerlink" title="4.5 字典方法"></a>4.5 字典方法</h3><p>&emsp;&emsp;字典方法就不区分建模和编码的环节了，核心就是查字典而已。唯一需要考虑的问题是如何选择字典条目，同样也分成静态、半静态和自适应的方法，缺点也和上面说的类似。静态方法泛化性差，自适应方法的代表是 Ziv-Lempel 算法，字典随着压缩过程动态创建，问题就是不支持随机访问，半静态的方法最好，代表是 Re-Pair 算法。 Re-Pair 算法的核心简单说就是消除所有的重复符号对，首先给每个符号赋予一个整数，如果有重复的整数对“AB”，就用新的整数“C”替换“AB”，替换规则也可以嵌套，比如“CD”又重复了，就用“E”替换“CD”。缺点其实就是半静态方法的缺点，慢。</p><h3 id="4-6-压缩预处理"><a href="#4-6-压缩预处理" class="headerlink" title="4.6 压缩预处理"></a>4.6 压缩预处理</h3><p>&emsp;&emsp;文本压缩的最新趋势是压缩前的预处理，比较著名的方法是 Burrows-Wheeler 变换，简称BWT。流程就看下面两张图，原始字符串是“mississippi$”，其中“$”是可以是别的特殊终结符。首先列出原始字符串循环移位的矩阵，矩阵的每一行是上一行左移一位后的字符串。然后根据矩阵第一列按字典序排序，排序后矩阵的最后一列就是变换后的字符串。BWT的优点有两个，一是可逆，根据变换后的字符串可以还原出原始字符串，二是能够保证原始字符串中重复出现的字符可以在变换后的字符串中连续出现或至少离得比较近，图中的例子不太明显，比如“SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES”经过变换后成了“TEXYDST.E.IXIXIXXSSMPPS.B..E.S.EUSFXDIIOIIIT”，就很明显了。<br><a href="https://file.shivakasu.cn/e409e20e6c49f4193eca/mir4-4.png" data-fancybox="group" data-caption="mir4-4" class="fancybox"><img alt="mir4-4" title="mir4-4" data-src="https://file.shivakasu.cn/e409e20e6c49f4193eca/mir4-4.png" class="lazyload"></a><br><a href="https://file.shivakasu.cn/a900368af7421d8f37f4/mir4-5.png" data-fancybox="group" data-caption="mir4-5" class="fancybox"><img alt="mir4-5" title="mir4-5" data-src="https://file.shivakasu.cn/a900368af7421d8f37f4/mir4-5.png" class="lazyload"></a></p><h3 id="4-7-压缩方法的比较"><a href="#4-7-压缩方法的比较" class="headerlink" title="4.7 压缩方法的比较"></a>4.7 压缩方法的比较</h3><p><a href="https://file.shivakasu.cn/566ac26954b7e304e60d/mir4-6.png" data-fancybox="group" data-caption="mir4-6" class="fancybox"><img alt="mir4-6" title="mir4-6" data-src="https://file.shivakasu.cn/566ac26954b7e304e60d/mir4-6.png" class="lazyload"></a></p><h3 id="4-8-结构化文本压缩"><a href="#4-8-结构化文本压缩" class="headerlink" title="4.8 结构化文本压缩"></a>4.8 结构化文本压缩</h3><p>&emsp;&emsp;结构化文本就是XML一类的文本，区分属性、元素这种层次。压缩方法其实就是根据文本的结构修改或者组合上面提到的这些方法，本质上没什么特别的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 4：检索评价</title>
    <link href="http://shivakasu.github.io/2019/02/01/mir3/"/>
    <id>http://shivakasu.github.io/2019/02/01/mir3/</id>
    <published>2019-02-01T10:09:20.000Z</published>
    <updated>2020-01-15T10:56:03.630Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>&emsp;&emsp;检索评价针对信息检索系统响应用户查询的返回结果，系统化地给出了一个量化的指标。这个指标应该和检索结果与用户的相关性直接联系。计算这个指标的通常方法是，对于给定的一组查询，比较由系统产生的结果和由人产生的结果。这里的检索评价仅针对检索系统的结果质量，不考虑界面设计、系统性能等因素的影响。</p><h2 id="2-检索指标"><a href="#2-检索指标" class="headerlink" title="2 检索指标"></a>2 检索指标</h2><h3 id="2-1-精度和召回率"><a href="#2-1-精度和召回率" class="headerlink" title="2.1 精度和召回率"></a>2.1 精度和召回率</h3><p>&emsp;&emsp;精度(Precison)是检出文档中相关文档的比例，召回率(Recall)是相关文档集中被检出的比率。将相关文档集记作 <script type="math/tex">R</script> ，系统得出的结果集为 <script type="math/tex">A</script> ，则：</p><script type="math/tex; mode=display">精度=p=\frac{|R\cap A|}{|A|}</script><script type="math/tex; mode=display">召回率=r=\frac{|R\cap A|}{|R|}</script><p>以横坐标为召回率，纵坐标为精度可绘制精度-召回率曲线，曲线下面积(Area Unser the Curve, AUC)可用于评估不同答案集的质量，面积越大表明质量越好。</p><p>&emsp;&emsp;缺点：</p><ul><li>召回率无法准确估计。</li><li>精度和召回率是相关联的指标，将二者结合为单一指标会更合适。</li><li>只能度量批处理状态下对一组查询进行处理的结果。</li><li>对于只需要弱偏序关系的系统来说，精度和召回率可能不适合。(?)</li></ul><h3 id="2-2-单值总结"><a href="#2-2-单值总结" class="headerlink" title="2.2 单值总结"></a>2.2 单值总结</h3><p>&emsp;&emsp;(1) 前 <script type="math/tex">n</script> 平均精度 <script type="math/tex">P@n</script> ：大部分搜索不需要高的召回率，绝大部分用户只需要顶部的几篇相关文档，通常计算前5篇或前10篇文档的平均精度(不管是相关还是不相关)， <script type="math/tex">P@n</script> 提供了可靠的指标来评价Web搜索引擎的用户是否在排序的顶部得到了相关文档。</p><p>&emsp;&emsp;(2) 平均精度均值(Mean Average Precision, MAP)：通过对每个新观察到的相关文档计算精度并做平均来得到关于排序的总结性的单一指标。查询 <script type="math/tex">q_i</script> 的平均精度定义为：</p><script type="math/tex; mode=display">MAP_i=\frac{1}{|R_i|}\sum_{k=1}^{|R_i|}P(R_i[k])</script><p>其中 <script type="math/tex">R_i</script> 是 <script type="math/tex">q_i</script> 对应的相关文档的集合， <script type="math/tex">P(R_i[k])</script> 是从头遍历结果集的排序队列直到观察到 <script type="math/tex">R_i</script> 中第 <script type="math/tex">k</script> 篇文档时的精度，如果没有观察到就记作0。此外，在一组查询上的平均精度均值定义为：</p><script type="math/tex; mode=display">MAP=\frac{1}{|N_q|}\sum_{i=1}^{|N_q|}MAP_i</script><p>其中 <script type="math/tex">N_q</script> 是查询的总数目。</p><p>&emsp;&emsp;(3) <script type="math/tex">R</script> 精度：设当前查询的相关文档集 <script type="math/tex">R</script> 的容量为 <script type="math/tex">n</script> ，取排序队列的前 <script type="math/tex">n</script> 篇文档计算精度，简单粗暴。但是对于一组查询，计算每个查询的 <script type="math/tex">R</script> 精度再取平均效果可能不好。</p><p>&emsp;&emsp;(4) 精度直方图：核心思想就是对于一组查询，可以分别比较每个查询在不同算法上的 <script type="math/tex">R</script> 精度，来比较两个算法的检索质量，废话。</p><p>&emsp;&emsp;(5) 平均排序倒数：适用于QA系统、特定主页查询等任务，更关注第一个正确的结果，而不是整个排序的结果集。设 <script type="math/tex">R_i</script> 是相对于查询 <script type="math/tex">q_i</script> 的排序， <script type="math/tex">S_{correct}(R_i)</script> 函数返回在 <script type="math/tex">R_i</script> 中第一个正确答案的位置，给定一个排序位置阈值 <script type="math/tex">S_h</script> ， <script type="math/tex">R_i</script> 的排序倒数定义为：</p><script type="math/tex; mode=display">\begin{cases}\frac{1}{S_{correct}(R_i)} & S_{correct}(R_i)\leq S_h \\0 & otherwise\end{cases}</script><p>对于由 <script type="math/tex">N_q</script> 个查询组成的集合 <script type="math/tex">Q</script> 来说，平均排序倒数(Mean Reciproach Rank, MRR)是所有排序倒数的均值，即：</p><script type="math/tex; mode=display">MRR(Q)=\frac{1}{N_q}\cdot\sum_{i=1}^{N_q}\frac{1}{S_{correct}(R_i)}</script><script type="math/tex; mode=display">MRR$$ 是倾向于那些第一个正确的结果出现在排序顶部的指标。&emsp;&emsp;(6) E值：结合精度和召回率，公式为：$$E(j)=1-\frac{1+b^2}{\frac{b^2}{r(j)}+\frac{1}{P(j)}}</script><p>其中 <script type="math/tex">r(j)</script> 是在排序中第 <script type="math/tex">j</script> 个位置的召回率， <script type="math/tex">P(j)</script> 是在排序中第 <script type="math/tex">j</script> 个位置的精度， <script type="math/tex">b(b\geq 0)</script> 是用户定义的参数。</p><p>&emsp;&emsp;(7) F值：同样是结合精度和召回率，公式为：</p><script type="math/tex; mode=display">F(j)=\frac{2}{\frac{1}{r(j)}+\frac{1}{P(j)}}</script><p>注意到，当E值的 <script type="math/tex">b=1</script> 时， <script type="math/tex">F(j)=1-E(j)</script> 。</p><p>&emsp;&emsp;(8) 摘要统计表：就是把查询数、文档数等统计特征列个表，没什么用。</p><h3 id="2-3-面向用户的指标"><a href="#2-3-面向用户的指标" class="headerlink" title="2.3 面向用户的指标"></a>2.3 面向用户的指标</h3><p>&emsp;&emsp;在相关文档集 <script type="math/tex">R</script> 和结果集 <script type="math/tex">A</script> 之外，考虑用户的认知范围，即用户已知的文档 <script type="math/tex">K</script> ，如下图：<br><a href="https://file.shivakasu.cn/33c0aa6ab8cd06c8bce7/mir3-0.png" data-fancybox="group" data-caption="mir3-0" class="fancybox"><img alt="mir3-0" title="mir3-0" data-src="https://file.shivakasu.cn/33c0aa6ab8cd06c8bce7/mir3-0.png" class="lazyload"></a></p><p>定义覆盖率为：</p><script type="math/tex; mode=display">coverage=\frac{|K\cap R\cap A|}{|K\cap R|}</script><p>定义新颖率为：</p><script type="math/tex; mode=display">novelty=\frac{|(R\cap A)-K|}{|K\cap R|}</script><p>高覆盖率表明系统找到了用户期望看到的大部分相关文档，高新颖率表明系统向用户展示了许多之前未知的新的相关文档。</p><h3 id="2-4-折扣累计增益"><a href="#2-4-折扣累计增益" class="headerlink" title="2.4 折扣累计增益"></a>2.4 折扣累计增益</h3><p>&emsp;&emsp;上述基于相关文档集和结果集计算的指标只考虑文档与查询的相关与否，而没有考虑到相关性的强弱。当检查查询的结果时，可以观察到两个重要的现象：</p><ul><li>在排序的顶部我们更希望是高度相关的文档，而不是轻度相关的文档。</li><li>出现在排序底部的相关文档的价值不高。</li></ul><p>&emsp;&emsp;针对第一个现象，赋予每个相关文档相关性强度，0表示不相关，值越大表示相关性越强，对系统返回的排序列表，增益向量(gain vector) <script type="math/tex">G</script> 定义为其中每个元素的相关性强度组成的向量，如：</p><script type="math/tex; mode=display">G=(1,0,1,0,0,3,0,0,0,2,0,0,0,0,3)</script><p>累计增益(Cumulated Gain) $CG$ 定义为：</p><script type="math/tex; mode=display">CG[i]=\begin{cases}G[1] & i=1 \\G[i]+CG[i-1] & i>1\end{cases}</script><p>则对于上面的增益向量：</p><script type="math/tex; mode=display">CG=(1,1,2,2,2,5,5,5,5,7,7,7,7,7,10)</script><p>&emsp;&emsp;针对第二个问题，按照文档在排序列表中的位置进行价值衰减，定义折扣累计增益(Discounted Cumulated Gain) $DCG$ 为：</p><script type="math/tex; mode=display">DCG[i]=\begin{cases}G[1] & i=1 \\\frac{G[i]}{log_2i}+DCG[i-1] & i>1\end{cases}</script><p>则对于上面的增益向量：</p><script type="math/tex; mode=display">DCG=(1.0,1.0,1.6,1.6,1.6,2.8,2.8,2.8,2.8,3.4,3.4,3.4,3.4,3.4,4.2)</script><p>同理，对于由多个查询组成的集合，可计算平均累计增益 <script type="math/tex">\overline{CG}</script> 和平均折扣累计增益 <script type="math/tex">\overline{DCG}</script> 。</p><p>&emsp;&emsp;由于累计增益没有参照，定义理想 <script type="math/tex">CG</script> 和 <script type="math/tex">DCG</script> 为最优排序列表得到的结果，即文档相关性强度从大到小排列，记作 <script type="math/tex">ICG</script> 和 <script type="math/tex">IDCG</script> 。将原始的 <script type="math/tex">CG</script> 和 <script type="math/tex">DCG</script> 进行归一化：</p><script type="math/tex; mode=display">NCG[i]=\frac{\overline{CG[i]}}{\overline{ICG[i]}}</script><script type="math/tex; mode=display">NDCG[i]=\frac{\overline{DCG[i]}}{\overline{IDCG[i]}}</script><p>得到了在区间 <script type="math/tex">[0,1]</script> 上的累计增益指标，可用于不同排序算法之间的比较。</p><h3 id="2-5-二元偏好"><a href="#2-5-二元偏好" class="headerlink" title="2.5 二元偏好"></a>2.5 二元偏好</h3><p>&emsp;&emsp;Todo</p><h3 id="2-6-排序相关性测度"><a href="#2-6-排序相关性测度" class="headerlink" title="2.6 排序相关性测度"></a>2.6 排序相关性测度</h3><p>&emsp;&emsp;当没有参照或没有评测人员时，很难计算出上述指标，则可以直接度量两个排序函数产生的结果的相关性，若对其中一个排序函数有一定的了解，就可以根据二者的相关性分析另一个排序函数的优劣。</p><p>&emsp;&emsp;斯皮尔曼系数(Spearman coefficient)根据相同文档在不同排序中的位置差值计算相关性。设 <script type="math/tex">s_{1,j}</script> 是文档 <script type="math/tex">d_j</script> 在排序 <script type="math/tex">R_1</script> 中的位置， <script type="math/tex">s_{2,j}</script> 是文档 <script type="math/tex">d_j</script> 在排序 <script type="math/tex">R_2</script> 中的位置，则位置差值是 <script type="math/tex">|s_{1,j}-s_{2,j}|</script> ，或计算差值平方和 <script type="math/tex">(s_{1,j}-s_{2,j})^2</script> 。如果有K篇排序文档，对排序差值求平方和，则差值平方和的最大值是 <script type="math/tex">\frac{K\times(K^2-1)}{3}</script> ，即两个排序互为反序。使用该最大值进行差值平方和的归一化，即：</p><script type="math/tex; mode=display">\frac{\sum_{j=1}^K(s_{1,j}-s_{2,j})^2}{\frac{K\times(K^2-1)}{3}}</script><p>将该分式乘2，再用1减去结果，就得到了在区间 <script type="math/tex">[-1,1]</script> 上的斯皮尔曼系数：</p><script type="math/tex; mode=display">S(R_1,R_2)=1-\frac{6\times\sum_{j=1}^K(s_{1,j}-s_{2,j})^2}{K\times(K^2-1)}</script><p>值越大表明相关性越强。然而，通常两个排序文档集的大小和内容是不同的，这时的做法是取并集，将 <script type="math/tex">R_2</script> 中不属于 <script type="math/tex">R_1</script> 的文档添加在 <script type="math/tex">R_1</script> 尾部，同时将 <script type="math/tex">R_1</script> 中不属于 <script type="math/tex">R_2</script> 的文档添加在 <script type="math/tex">R_2</script> 尾部，之后再对这两个增广排序计算斯皮尔曼系数。</p><p>&emsp;&emsp;肯德尔系数(Kendall Tau coefficient)比斯皮尔曼系数代数结构简单，有更清楚和直观的解释。给定两篇文档 <script type="math/tex">d_j</script> 和 <script type="math/tex">d_k</script> ，若在两个排序列表 <script type="math/tex">R_1</script> 和 <script type="math/tex">R_2</script> 中， <script type="math/tex">s_{1,j}-s_{1,k}</script> 和 <script type="math/tex">s_{2,j}-s_{2,k}</script> 同号，那么就说文档二元组 <script type="math/tex">[d_j,d_k]</script> 在这两个排序中是协调的，反之则是不协调的。如果有K篇排序文档，则共有 <script type="math/tex">K(K-1)</script> 个文档二元组，肯德尔系数定义为：</p><script type="math/tex; mode=display">\tau(R_1,R_2)=1-\frac{2\times\Delta(R_1,R_2)}{K(K-1)}</script><p>和斯皮尔曼系数的形式是几近相同的，当两个排序文档集不同时，也可以用相同的方式增广排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 3：信息检索建模</title>
    <link href="http://shivakasu.github.io/2019/01/24/mir2/"/>
    <id>http://shivakasu.github.io/2019/01/24/mir2/</id>
    <published>2019-01-24T05:40:20.000Z</published>
    <updated>2020-01-15T10:55:43.840Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-信息检索模型"><a href="#1-信息检索模型" class="headerlink" title="1 信息检索模型"></a>1 信息检索模型</h2><p>&emsp;&emsp;信息检索模型是一个四元组 <script type="math/tex">[D,Q,F,R(q_i,d_i)]</script> 。其中D(Document)是文档表示的集合，Q(Query)是查询表示的集合，F(Framework)是对文档、查询及其关系建模的框架，例如布尔框架、线性框架，R(Ranking)是排序函数，对于查询表达式 <script type="math/tex">q_i\in Q</script> 和文档表达式 <script type="math/tex">d_i\in D</script> ，函数返回文档 <script type="math/tex">d_i</script> 关于查询<script type="math/tex">q_i</script>的文档次序。</p><p>&emsp;&emsp;信息检索主要基于文本，文本模型也细分为是否考虑文本结构，所谓考虑文本结构就是区别对待标题、段落等文档不同结构处的内容。在web中，由于文档数量巨大，还需要考虑网页之间的链接，如今的web排序函数结合了经典的信息检索模型和基于链接模型的特征来提高检索性能。信息检索还可基于图像、音频等多媒体数据，检索策略更复杂。信息检索模型的分类体系见下图：<br><a href="https://file.shivakasu.cn/648d8d4d85d3f6ed9f89/mir2-0.png" data-fancybox="group" data-caption="mir2-0" class="fancybox"><img alt="mir2-0" title="mir2-0" data-src="https://file.shivakasu.cn/648d8d4d85d3f6ed9f89/mir2-0.png" class="lazyload"></a></p><h2 id="2-经典信息检索"><a href="#2-经典信息检索" class="headerlink" title="2 经典信息检索"></a>2 经典信息检索</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><ul><li>索引项(index term)：文档里的一个词或一组连续的词，主要是名词，因为名词相比于形容词、副词等往往能包含更多信息，具体的选择策略因人而异。</li><li>词汇表(vocabulary)： <script type="math/tex">V=(k_1,k_2,\cdots ,k_t)</script> ，其中 <script type="math/tex">t</script> 是文档集中索引项的数量， <script type="math/tex">k_i</script> 是某个索引项。</li><li>文档表示：就是简单的词袋方法，表示成和词汇表一样长的向量，其中每个元素是0或1，0表示对应的索引项在文档中未出现，1表示对应的索引项在文档中出现。</li><li>查询表示：和文档表示相同，每个元素表示相应索引项是否在查询中出现。</li><li>项-文档矩阵：行数是索引项个数，列数是文档个数，元素 <script type="math/tex">f_{i,j}</script> 表示第 <script type="math/tex">i</script> 个索引项在第 <script type="math/tex">j</script> 个文档中出现的频数。显然，在词袋方法中是0-1矩阵。</li><li>文档的逻辑视图：大概就是表示文档的方式。通常是把文档全文转变成索引项集合，流程如下图：<br><a href="https://file.shivakasu.cn/4433d3fae9363c920f64/mir2-1.png" data-fancybox="group" data-caption="mir2-1" class="fancybox"><img alt="mir2-1" title="mir2-1" data-src="https://file.shivakasu.cn/4433d3fae9363c920f64/mir2-1.png" class="lazyload"></a></li></ul><h3 id="2-2-布尔模型"><a href="#2-2-布尔模型" class="headerlink" title="2.2 布尔模型"></a>2.2 布尔模型</h3><p>&emsp;&emsp;使用词袋方法表示文档，用析取范式(disjunct normal form)表示查询。例如对于词汇表 <script type="math/tex">V=(k_a,k_b,k_c,k_d)</script> 和查询 <script type="math/tex">q=k_a\wedge (k_b\vee k_c)</script> ，用析取范式表示查询为：</p><script type="math/tex; mode=display">q_{DNF}=(1,1,1,0)\vee(1,1,1,1)\vee(1,1,0,0)\vee(1,1,0,1)\vee(1,0,0,0)\vee(1,0,0,1)</script><p>文档与查询的相关度定义为析取范式中是否有一项与文档表示相同，因此也是二值的。</p><p>&emsp;&emsp;布尔模型的优点是简单，缺点是不支持排序。因为相关度是二值的，只能表示相关与否，而不能表示相关的程度。</p><h3 id="2-3-项权重"><a href="#2-3-项权重" class="headerlink" title="2.3 项权重"></a>2.3 项权重</h3><p>&emsp;&emsp;提高检索质量的一个方法是给每个索引项设置权重，通常根据索引项在整个文档集中出现的频次设置权重。如果不假设索引项之间相互独立，还要考虑索引项之间的相关性，因为索引项之间的关联往往会反映文档之间的关联，一种计算项间相关性的方法是项-文档矩阵乘他的转置矩阵，如下图：<br><a href="https://file.shivakasu.cn/0149fd92db89c2e04630/mir2-2.png" data-fancybox="group" data-caption="mir2-2" class="fancybox"><img alt="mir2-2" title="mir2-2" data-src="https://file.shivakasu.cn/0149fd92db89c2e04630/mir2-2.png" class="lazyload"></a><br>假设项间相互独立可以简化模型、提高计算效率，而利用项间相关性提高排序水平也是十分复杂的工作，考虑了项间相关性并不能保证排序水平的提高，因此是否假设项间相互独立没有固定的标准。</p><h3 id="2-4-TD-IDF"><a href="#2-4-TD-IDF" class="headerlink" title="2.4 TD-IDF"></a>2.4 TD-IDF</h3><p>&emsp;&emsp;TF-IDF是一个常用的计算项权重的指标，其中TF(Term frequency)表示项频，IDF(Inverse document frequency)表示反比文档频率。</p><p>&emsp;&emsp;使用项频是基于Luhn假设，即高频项对描述文档的关键主题是重要的。可以直接将索引项的频次作为TF权重，即 <script type="math/tex">tf_{i,j}=f_{i,j}</script> ，但考虑到要与IDF权重结合，而IDF使用了对数运算，因此通常使用TF权重的一个变种：</p><script type="math/tex; mode=display">tf_{i,j}=\begin{cases}1+log_2f_{i,j} & f_{i,j}>0 \\0 & otherwise\end{cases}</script><p>&emsp;&emsp;TF权重倾向于给频次高的索引项更大的权重，但也要考虑索引项的区分度，即索引项特异性(term specificity)。如果一个索引项在每个文档中都出现，虽然出现频次高，但是对于文档排序等任务没有太大帮助，最常见的就是a、the这样的冠词、连词和介词。因此不仅要考虑高频项，还要考虑区分度大的索引项。IDF权重考虑的就是某个索引项在多少个文档中出现，即相对文档频率 <script type="math/tex">n_i/N</script> ， <script type="math/tex">IDF_i=log_2\frac{N}{n_i}</script> ，其中 <script type="math/tex">N</script> 是文档集中的文档数量， <script type="math/tex">n_i</script> 是出现索引项 <script type="math/tex">k_i</script> 的文档数量，因为相对文档频率越小的索引项区分度越大，所以IDF使用了相对文档频率的倒数，称作反比文档频率。</p><p>&emsp;&emsp;TF-IDF将二者结合起来，计算方法如下：</p><script type="math/tex; mode=display">w_{i,j}=\begin{cases}(1+log_2f_{i,j})*log_2\frac{N}{n_i} & f_{i,j}>0 \\0 & otherwise\end{cases}</script><p>&emsp;&emsp;TF、IDF和TF-IDF有多种变体。TF变体如下：<br><a href="https://file.shivakasu.cn/6a3557149d63d9d07c8d/mir2-3.png" data-fancybox="group" data-caption="mir2-3" class="fancybox"><img alt="mir2-3" title="mir2-3" data-src="https://file.shivakasu.cn/6a3557149d63d9d07c8d/mir2-3.png" class="lazyload"></a></p><p>IDF变体如下：<br><a href="https://file.shivakasu.cn/9b5b06f2b588a7e7566c/mir2-4.png" data-fancybox="group" data-caption="mir2-4" class="fancybox"><img alt="mir2-4" title="mir2-4" data-src="https://file.shivakasu.cn/9b5b06f2b588a7e7566c/mir2-4.png" class="lazyload"></a></p><p>TF-IDF变体如下：<br><a href="https://file.shivakasu.cn/4a396f3ce65a26f1b49a/mir2-5.png" data-fancybox="group" data-caption="mir2-5" class="fancybox"><img alt="mir2-5" title="mir2-5" data-src="https://file.shivakasu.cn/4a396f3ce65a26f1b49a/mir2-5.png" class="lazyload"></a></p><p>&emsp;&emsp;通过下图可以分析出TF-IDF的性质。TF和IDF权重表现出的幂律特性会相互平衡，高TF权重趋于和低IDF权重结合，低TF权重趋于和高IDF权重结合，结果是TF-IDF权重最高的索引项往往具有中等TF和IDF权重，而项频太高的项和文档频率太低的项经过平衡后都具有较低的TF-IDF权重。妙啊！<br><a href="https://file.shivakasu.cn/ded9527fd90145d96807/mir2-6.png" data-fancybox="group" data-caption="mir2-6" class="fancybox"><img alt="mir2-6" title="mir2-6" data-src="https://file.shivakasu.cn/ded9527fd90145d96807/mir2-6.png" class="lazyload"></a></p><h3 id="2-5-文档长度归一化"><a href="#2-5-文档长度归一化" class="headerlink" title="2.5 文档长度归一化"></a>2.5 文档长度归一化</h3><p>&emsp;&emsp;对于给定的查询，较长的文档仅仅因为包含更多的索引项而更可能被检出，为了消除这一影响，可以把文档的排序除以其长度，这个过程称为文档长度归一化，如何计算文档长度取决于文档的表示形式。</p><h3 id="2-6-向量模型"><a href="#2-6-向量模型" class="headerlink" title="2.6 向量模型"></a>2.6 向量模型</h3><p>&emsp;&emsp;布尔模型使用析取范式的每一项和文档表示进行严格匹配，难以得到理想的结果。向量模型将文档和查询表示为向量形式，使用向量夹角的余弦值衡量相似度，成功将相似度量化为可用于比较和排序的数值，基于相似度的排序可以理解为一种部分匹配策略。文档的向量表示为 <script type="math/tex">\vec{d_j}=(w_{1,j},w_{2,j},\cdots,w_{t,j})</script> ，其中 <script type="math/tex">t</script> 是索引项总个数， <script type="math/tex">w_{i,j}</script>是项-文档对 <script type="math/tex">(k_i,d_j)</script> 的权重，一般采用TF-IDF权重，查询的向量表示为 <script type="math/tex">\vec{q}=(w_{1,q},w_{2,q},\cdots,w_{t,q})</script> , <script type="math/tex">w_{i,q}</script>是项-查询对 <script type="math/tex">(k_i,q)</script> 的权重。文档-查询余弦相似度公式为：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{\vec{d_j}\cdot\vec{q}}{|\vec{d_j}|\times|\vec{q}|}</script><p>注意到余弦公式分母的向量范数恰好也起到了文档长度归一化的作用。</p><h3 id="2-7-概率模型"><a href="#2-7-概率模型" class="headerlink" title="2.7 概率模型"></a>2.7 概率模型</h3><p>&emsp;&emsp;概率模型的目标是估计文档与查询相关的概率，他假定这种相关性仅依赖于文档和查询本身的表示，并假定存在一个理想答案集，仅包含所有与查询相关的文档，因此能够最大化与用户相关的总体概率。显然，这种假设是对真实情况的简化，所以必然会存在一些缺陷。</p><p>&emsp;&emsp;概率模型计算相关度的公式是：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{P(R|\vec{d_j})}{P(\overline{R}|\vec{d_j})}</script><p>其中 <script type="math/tex">R</script> 是与查询 <script type="math/tex">q</script> 相关的文档的集合， <script type="math/tex">\overline{R}</script> 是与查询 <script type="math/tex">q</script> 不相关的文档的集合， <script type="math/tex">P(R|\vec{d_j})</script>是文档 <script type="math/tex">d_j</script> 与查询 <script type="math/tex">q</script> 相关的概率， <script type="math/tex">P(\overline{R}|\vec{d_j})</script>是文档 <script type="math/tex">d_j</script> 与查询 <script type="math/tex">q</script> 不相关的概率。根据贝叶斯公式：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{P(\vec{d_j}|R,q)\times P(R,q)}{P(\vec{d_j}|\overline{R},q)\times P(\overline{R},q)}\sim\frac{P(\vec{d_j}|R,q)}{P(\vec{d_j}|\overline{R},q)}</script><p>其中 <script type="math/tex">P(\vec{d_j}|R,q)</script> 表示从查询 <script type="math/tex">q</script> 的相关文档集 <script type="math/tex">R</script> 中随机选择的一偏文档表示为 <script type="math/tex">\vec{d_j}</script> 的概率， <script type="math/tex">P(R,q)</script> 表示从整个文档集中随机选择的文档和查询 <script type="math/tex">q</script> 相关的概率， <script type="math/tex">P(\vec{d_j}|\overline{R},q)</script> 和 <script type="math/tex">P(\overline{R},q)</script> 的含义是相似且互补的。概率模型中不考虑项权重，所以 <script type="math/tex">\vec{d_j}</script> 是一个二值向量，如果假设索引项间的独立性，即所谓的二值独立假设，可以得到：</p><script type="math/tex; mode=display">sim(d_j,q)\sim\frac{(\prod_{k_i|w_{i,j}=1}p_{iR})\times(\prod_{k_i|w_{i,j}=0}(1-p_{iR}))}{(\prod_{k_i|w_{i,j}=1}q_{iR})\times(\prod_{k_i|w_{i,j}=0}(1-q_{iR}))}</script><p>其中 <script type="math/tex">p_{iR}</script> 表示索引项 <script type="math/tex">k_i</script> 出现在从查询 <script type="math/tex">q</script> 的相关文档集 <script type="math/tex">R</script> 中随机选择的一偏文档内的概率， <script type="math/tex">q_{iR}</script> 表示索引项 <script type="math/tex">k_i</script> 出现在从查询 <script type="math/tex">q</script> 的不相关文档集 <script type="math/tex">\overline{R}</script> 中随机选择的一偏文档内的概率。使用对数函数只改变数值而不改变排序结果，所以可以进一步简化为：</p><script type="math/tex; mode=display">sim(d_j,q)\sim\sum_{k_i\in q\wedge k_i\in d_j}log(\frac{p_{iR}}{1-p_{iR}})+log(\frac{1-q_{iR}}{q_{iR}})</script><p>得到了相似度公式，接下来就是如何计算 <script type="math/tex">p_{iR}</script> 和 <script type="math/tex">q_{iR}</script> 。</p><p>&emsp;&emsp;一种计算方法是使用索引项出现列联表，如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">相关文档数</th><th style="text-align:center">不相关文档数</th><th style="text-align:center">总文档数</th></tr></thead><tbody><tr><td style="text-align:center">包含 $k_i$ 的文档</td><td style="text-align:center">$r_i$</td><td style="text-align:center">$n_i-r_i$</td><td style="text-align:center">$n_i$</td></tr><tr><td style="text-align:center">不包含 $k_i$ 的文档</td><td style="text-align:center">$R-r_i$</td><td style="text-align:center">$N-n_i-(R-r_i)$</td><td style="text-align:center">$N-n_i$</td></tr><tr><td style="text-align:center">所有文档</td><td style="text-align:center">$R$</td><td style="text-align:center">$N-R$</td><td style="text-align:center">$N$</td></tr></tbody></table></div><p>那么可以得到，</p><script type="math/tex; mode=display">p_{iR}=\frac{r_i}{R}\quad, \quad q_{iR}=\frac{n_i-r_i}{N-R}</script><script type="math/tex; mode=display">sim(d_j,q)\sim\sum_{k_i\in q\wedge k_i\in d_j}log(\frac{(r_i+0.5)(N-n_i-R+r_i+0.5)}{(R-r_i+0.5)(n_i-r_i+0.5)})</script><p>之所以给每个包含 <script type="math/tex">r_i</script> 的项加0.5，是为了减小极端情况下过小的 <script type="math/tex">r_i</script> 对 <script type="math/tex">log</script> 计算的影响。这种方法需要人工估计 <script type="math/tex">r_i</script> 和 <script type="math/tex">R</script> 值，所以不实用，同时缺少文档长度归一化的操作，使得排序效果也不是很好。</p><p>&emsp;&emsp;另一种方法是在避免人工估计的条件下，基于几条假设来自动更新 <script type="math/tex">r_i</script> 和 <script type="math/tex">R</script> 值，个人认为这里的假设太牵强，理解不了。</p><p>&emsp;&emsp;概率模型的优点是能按照相关概率进行排序，但其认为相关性仅与文档和查询的内容有关，所以实际应用时效果难以保证。此外，概率模型不可避免地要做初始估计将文档分为相关和不相关集合，不太好操作。观察上面计算 <script type="math/tex">sim(d_j,q)</script> 的公式，与IDF权重的公式是相似的，从这个角度看，概率模型的另一个缺点是没有用到TF特征，也没有进行文档长度归一化。</p><h2 id="3-其他集合论模型"><a href="#3-其他集合论模型" class="headerlink" title="3 其他集合论模型"></a>3 其他集合论模型</h2><h3 id="3-1-基于集合的模型"><a href="#3-1-基于集合的模型" class="headerlink" title="3.1 基于集合的模型"></a>3.1 基于集合的模型</h3><p>&emsp;&emsp;基于集合的模型不考虑单独的索引项，而是考虑索引项之间的相互依赖性，通过引入项集的概念表示索引项之间的关联。</p><p>&emsp;&emsp;项集(Termset)：项集 <script type="math/tex">S_i=\{k_a,k_b,\cdots,k_n\}</script> 是文档集中索引项的子集。若 <script type="math/tex">S_i</script> 中所有的索引项都出现在文档 <script type="math/tex">d_j</script> 中，就称项集 <script type="math/tex">S_i</script> 出现在 <script type="math/tex">d_j</script> 中。</p><p>&emsp;&emsp;显然，若文档集中有 <script type="math/tex">t</script> 个索引项，则理论上有 <script type="math/tex">2^t</script> 个项集，但实际数据集中一般仅包含部分项集。同时，用项集表示替代索引项表示就需要把项的词汇表改为项集的词汇表，即 <script type="math/tex">V_S=\{S_1,S_2,\cdots,S_{2^t}\}</script> 。</p><p>&emsp;&emsp;频繁项集(Frequent termsets)：由 <script type="math/tex">n</script> 个项构成的项集称为 <script type="math/tex">n</script> 项集，如果包含某个 <script type="math/tex">n</script> 项集的文档数 <script type="math/tex">\mathcal{N}_i</script> 高于某个给定的阈值，那么这个 <script type="math/tex">n</script> 项集 <script type="math/tex">S_i</script> 称为是频繁的。显然，一个 <script type="math/tex">n</script> 项集是频繁的当且仅当他的所有 <script type="math/tex">(n-1)</script> 项集都是频繁地。</p><p>&emsp;&emsp;在TF-IDF中，计算的权重是项-文档矩阵的元素，在集合模型中与之类似，计算的权重是项集-文档矩阵的元素。对于 <script type="math/tex">(S_i,d_j)</script> ，令 <script type="math/tex">N</script> 是文档集中文档总数，<script type="math/tex">\mathcal{F}_{i,j}</script> 是项集 <script type="math/tex">S_i</script> 在文档 <script type="math/tex">d_j</script> 中的原始出现频率，赋予项集权重：</p><script type="math/tex; mode=display">\mathcal{W}_{i,j}=\begin{cases}(1+log_2\mathcal{F}_{i,j})*log_2(1+\frac{N}{\mathcal{N}_i}) & \mathcal{F}_{i,j}>0 \\0 & otherwise\end{cases}</script><p>同理， <script type="math/tex">\vec{d_j}=(\mathcal{W}_{1,j},\mathcal{W}_{2,j},\cdots,\mathcal{W}_{2^t,j})</script> ， <script type="math/tex">\vec{q}=(\mathcal{W}_{1,q},\mathcal{W}_{2,q},\cdots,\mathcal{W}_{2^t,q})</script>，相似度计算公式为：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{\vec{d_j}\cdot\vec{q}}{|\vec{d_j}|\times|\vec{q}|}=\frac{\sum_{S_i}\mathcal{W}_{i,j}\times\mathcal{W}_{i,q}}{|\vec{d_j}|\times|\vec{q}|}</script><p>由于项集空间是项空间的指数级大小，所以相似度的计算十分复杂，需要进行计算简化。例如在计算向量范数时只考虑 <script type="math/tex">1</script> 项集。或是进一步缩小项集的范围，只考虑频繁闭项集，闭项集(Closed termset)就是项集的闭包，比如项集 <script type="math/tex">\{k_1\}</script> 、 <script type="math/tex">\{k_2\}</script> 、 <script type="math/tex">\{k_1,k_2\}</script>出现在相同的文档子集中，那么可以只计算 <script type="math/tex">\{k_1,k_2\}</script>，大大减小了计算量，除了频繁闭项集，还可选择最大频繁集，即添加任何索引项都不能使其保持频繁性。从项集数目上看，频繁项集&gt;频繁闭项集&gt;最大频繁集，需要注意的是，减少计算必然伴随着信息的损失，因此需要根据实际情况进行权衡。</p><h3 id="3-2-扩展布尔模型"><a href="#3-2-扩展布尔模型" class="headerlink" title="3.2 扩展布尔模型"></a>3.2 扩展布尔模型</h3><p>&emsp;&emsp;用向量模型的特征扩展布尔模型，狗尾续貂？</p><h3 id="3-3-模糊集模型"><a href="#3-3-模糊集模型" class="headerlink" title="3.3 模糊集模型"></a>3.3 模糊集模型</h3><p>&emsp;&emsp;模糊集模型基于模糊集理论，对于每一个索引项 <script type="math/tex">k_i</script> ，为其分配一个模糊集(fuzzy set) <script type="math/tex">D_i</script> ，模糊集为每一个文档 <script type="math/tex">d_j</script> 分配一个介于区间 <script type="math/tex">[0,1]</script> 之间的隶属度(degree of membership)  <script type="math/tex">\mu_{i,j}</script> ，若 <script type="math/tex">\mu_{i,j}\sim 1</script> 表明 <script type="math/tex">k_i</script> 是 <script type="math/tex">d_j</script> 的良好模糊索引项，若 <script type="math/tex">\mu_{i,j}\sim 0</script> 表明 <script type="math/tex">k_i</script> 不是 <script type="math/tex">d_j</script> 的良好模糊索引项。隶属度可以通过项间相关性矩阵 <script type="math/tex">C</script> 来计算，索引项 <script type="math/tex">k_i</script> 和 <script type="math/tex">k_l</script> 的相关性计算公式为：</p><script type="math/tex; mode=display">c_{i,l}=\frac{n_{i,l}}{n_i+n_l-n_{i,l}}</script><p>其中 <script type="math/tex">n_i</script> 是含有索引项 <script type="math/tex">k_i</script> 的文档数， <script type="math/tex">n_l</script> 是含有索引项 <script type="math/tex">k_l</script> 的文档数， <script type="math/tex">n_{i,l}</script> 是同时含有这两个索引项的文档数，这种相关性度量被广泛应用在聚类算法中。有了相关性度量，就可以计算隶属度：</p><script type="math/tex; mode=display">\mu_{i,j}=1-\prod_{k_l\in d_j}(1-c_{i,l})</script><p>这其实就是在考虑 <script type="math/tex">k_i</script> 和 <script type="math/tex">d_j</script> 中每一个索引项的相关性，可以看出，只要 <script type="math/tex">d_j</script> 中至少有一个索引项 <script type="math/tex">k_l</script> 与 <script type="math/tex">k_i</script> 关系密切(即 <script type="math/tex">c_{i,l}\sim 1</script> )，则 <script type="math/tex">\mu_{i,j}\sim 1</script> 。此外，采用代数和的方式计算而不是对所有相关性使用 <script type="math/tex">max</script> 函数，可以使 <script type="math/tex">\mu_{i,j}</script> 的值变得平滑。</p><p>&emsp;&emsp;有了文档相对索引项的隶属度，就可以进一步计算文档相对于查询的隶属度，因为借鉴布尔模型的方法，查询可以表示成索引项组成的逻辑表达式。例如对于查询 <script type="math/tex">q=k_a\wedge (k_b\vee\neg k_c)</script> ，可以写成析取范式 <script type="math/tex">\vec{q}_{dnf}=(1,1,1)\vee(1,1,0)\vee(1,0,0)</script> ，设 <script type="math/tex">D_a</script> 、 <script type="math/tex">D_b</script> 、 <script type="math/tex">D_c</script> 分别是 <script type="math/tex">k_a</script> 、 <script type="math/tex">k_b</script> 、 <script type="math/tex">k_c</script> 的模糊集，查询的模糊集 <script type="math/tex">D_q</script> 可以从下图理解：<br><a href="https://file.shivakasu.cn/3d166e41cb81bea90ac8/mir2-7.png" data-fancybox="group" data-caption="mir2-7" class="fancybox"><img alt="mir2-7" title="mir2-7" data-src="https://file.shivakasu.cn/3d166e41cb81bea90ac8/mir2-7.png" class="lazyload"></a><br>其中， <script type="math/tex">cc_1=\mu_{a,j}\mu_{b,j}\mu_{c,j}</script> 、 <script type="math/tex">cc_2=\mu_{a,j}\mu_{b,j}(1-\mu_{c,j})</script> 、 <script type="math/tex">cc_3=\mu_{a,j}(1-\mu_{b,j})(1-\mu_{c,j})</script> ，则：</p><script type="math/tex; mode=display">\mu_{q,j}=1-\prod_{i=1}^3(1-cc_i)</script><p>同样，采用代数和的方式计算而不是对所有相关性使用 <script type="math/tex">max</script> 函数，可以使<script type="math/tex">\mu_{q,j}</script> 的值变得平滑。</p><h2 id="4-其他代数模型"><a href="#4-其他代数模型" class="headerlink" title="4 其他代数模型"></a>4 其他代数模型</h2><h3 id="4-1-广义向量空间模型"><a href="#4-1-广义向量空间模型" class="headerlink" title="4.1 广义向量空间模型"></a>4.1 广义向量空间模型</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 2：用户搜索界面</title>
    <link href="http://shivakasu.github.io/2019/01/19/mir1/"/>
    <id>http://shivakasu.github.io/2019/01/19/mir1/</id>
    <published>2019-01-19T09:26:20.000Z</published>
    <updated>2020-01-10T04:09:24.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="人们如何搜索"><a href="#人们如何搜索" class="headerlink" title="人们如何搜索"></a>人们如何搜索</h3><ul><li><p>信息查找(information lookup)类似于事实检索或问题回答，只需要简短而离散的信息。</p></li><li><p>探索式搜索(exploratory search)分为学习和调查两类，需要花费更长的时间并整合更多内容。</p></li><li><p>信息搜寻过程是由一系列相互关联但又不完全相同的搜索所组成的，搜索带来的主要价值体现在搜索过程中持续的学习和所获得的信息，而不只是最后的搜索结果。</p></li><li><p>信息搜寻过程的经典模型：明确问题-&gt;表达信息需求-&gt;构造查询-&gt;评价结果。经典模型假设用户的信息需求是静态的，最近的模型强调搜索过程的动态性，认为用户会根据搜索结果动态调整信息需求，这种动态过程有时称为搜索的采摘模型(berry picking model)。例如，用户给出一个快速、不精确的查询，近似得到信息空间的一部分内容，再进行一系列本地导航操作，从而获得更贴近用户兴趣的信息。有些搜索模型关注搜索策略，对搜索策略建模，预测用户的搜索行为。</p></li><li><p>除了传统的搜索框查询，还可以使用导航界面，让用户通过浏览导航和点击链接搜寻信息。</p></li></ul><h3 id="现今的搜索界面"><a href="#现今的搜索界面" class="headerlink" title="现今的搜索界面"></a>现今的搜索界面</h3><ul><li><p>启动搜寻：通常使用Web搜索引擎。导航网站逐渐被淘汰，一是因为网络规模变大，无法手动构造目录，二是因为Web搜索的精度提高。</p></li><li><p>查询描述：解析查询项，Web排序</p></li><li><p>查询描述界面：搜索框placeholder提示，自动补全建议列表。根据用户搜索历史或其他用户的热门搜索。</p></li><li><p>检索结果显示：文档摘要，查询项高亮。</p></li><li><p>查询重构：拼写校对或建议，相关查询项推荐。</p></li><li><p>组织搜索结果：分类和聚类。区别在于是否需要人工组织层次结构。</p></li></ul><p>(这章真的是看不下去了，一个搜索界面说了这么多废话，太无聊了)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 1：引言</title>
    <link href="http://shivakasu.github.io/2019/01/18/mir0/"/>
    <id>http://shivakasu.github.io/2019/01/18/mir0/</id>
    <published>2019-01-18T08:36:26.000Z</published>
    <updated>2020-01-15T10:53:20.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>信息检索涉及对文档、网页、联机目录、结构化和半结构化记录及多媒体对象等信息项的表示、存储、组织和访问。信息项的表示和组织必须便于用户访问他们感兴趣的信息。</p></li><li><p>信息检索发展的关键阶段：书籍-&gt;图书馆-&gt;索引-&gt;计算机-&gt;排序技术和搜索引擎等现代研究内容</p></li><li><p>信息检索系统的主要目标是检出所有和用户查询相关的文档，并且把检出的不相关文档控制在最低限度。相关性的概念对信息检索至关重要。对相关性的评估没有固定标准，不存在能在任何时间给任何用户提供完美答案的检索系统。</p></li><li><p>检索任务可分为浏览和搜索，浏览是探索式检索，目标不太明确，搜索则相反。</p></li><li><p>信息检索系统的高层软件架构：<br><a href="https://file.shivakasu.cn/6ffe81624404da41f82a/mir0-0.png" data-fancybox="group" data-caption="mir0-0" class="fancybox"><img alt="mir0-0" title="mir0-0" data-src="https://file.shivakasu.cn/6ffe81624404da41f82a/mir0-0.png" class="lazyload"></a></p></li><li><p>文档的索引、检索和排序过程：<br><a href="https://file.shivakasu.cn/69f58a9d8db7b0682f6e/mir0-1.png" data-fancybox="group" data-caption="mir0-1" class="fancybox"><img alt="mir0-1" title="mir0-1" data-src="https://file.shivakasu.cn/69f58a9d8db7b0682f6e/mir0-1.png" class="lazyload"></a></p></li><li><p>Web流行的根源：出版自由。</p></li><li><p>Web对搜索的影响：网页爬取新技术，海量文档集和海量查询流量，相关性预测更复杂，从文字搜索转向结构化数据搜索，垃圾信息泛滥。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>解决 anaconda3 安装 xgboost：/usr/lib/libstdc++.so.6：version &#39;GLIBCXX_3.4.14&#39; not found问题</title>
    <link href="http://shivakasu.github.io/2017/07/01/bugfix0/"/>
    <id>http://shivakasu.github.io/2017/07/01/bugfix0/</id>
    <published>2017-07-01T15:00:20.000Z</published>
    <updated>2020-01-10T04:11:29.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda install libgcc</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda中关于Qt的bug</title>
    <link href="http://shivakasu.github.io/2016/10/27/bugfix3/"/>
    <id>http://shivakasu.github.io/2016/10/27/bugfix3/</id>
    <published>2016-10-27T12:59:20.000Z</published>
    <updated>2020-01-10T04:11:10.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先安装了anaconda，可以使用。<br>之后使用conda命令安装了Orange，由于Orange会安装Qt，可能会导致与anaconda自带的Qt冲突，然后我惊喜的发现anaconda-navigator打不开了，报出以下错误：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;bin&#x2F;anaconda-navigator&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    import anaconda_navigator.app.main</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#x2F;anaconda_navigator&#x2F;app&#x2F;main.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    from anaconda_navigator.widgets.dialogs.splash import SplashScreen</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#x2F;anaconda_navigator&#x2F;widgets&#x2F;__init__.py&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    from anaconda_navigator.utils.analytics import GATracker</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#x2F;anaconda_navigator&#x2F;utils&#x2F;analytics.py&quot;, line 33, in &lt;module&gt;</span><br><span class="line">    from qtpy.QtCore import QT_VERSION_STR, QObject, QThread, QTimer, Signal</span><br><span class="line">ImportError: cannot import name &#39;QT_VERSION_STR&#39;</span><br></pre></td></tr></table></figure></div><p>参照了<a href="https://github.com/ContinuumIO/anaconda-issues/issues/1095的解决方法成功修复，具体方法是：" target="_blank" rel="noopener">https://github.com/ContinuumIO/anaconda-issues/issues/1095的解决方法成功修复，具体方法是：</a><br>打开 /anaconda3/pkgs/anaconda-navigator-1.2.3-py35_0/lib/python3.5/site-packages/anaconda_navigator/utils/analytics.py<br>把</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from qtpy.QtCore import QT_VERSION_STRING , QObject, QThread, QTimer, Signal</span><br></pre></td></tr></table></figure></div><p>改成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from qtpy.QtCore import __version__ as qt_version , QObject, QThread, QTimer, Signal</span><br></pre></td></tr></table></figure></div><p>把</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.info &#x3D; &#123;&#39;python&#39;: python_version, &#39;language&#39;: self.get_language(),</span><br><span class="line">             &#39;os&#39;: operating_system, &#39;version&#39;: app_version,</span><br><span class="line">             &#39;platform&#39;: self.api.conda_platform(),</span><br><span class="line">             &#39;qt&#39;: QT_VERSION_STR, &#39;pyqt&#39;: pyqt_version,</span><br><span class="line">             &#39;conda&#39;: conda_version&#125;</span><br></pre></td></tr></table></figure></div><p>改成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.info &#x3D; &#123;&#39;python&#39;: python_version, &#39;language&#39;: self.get_language(),</span><br><span class="line">             &#39;os&#39;: operating_system, &#39;version&#39;: app_version,</span><br><span class="line">             &#39;platform&#39;: self.api.conda_platform(),</span><br><span class="line">             &#39;qt&#39;: qt_version, &#39;pyqt&#39;: pyqt_version,</span><br><span class="line">             &#39;conda&#39;: conda_version&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下安装scrapy遇到的问题及解决过程</title>
    <link href="http://shivakasu.github.io/2016/10/07/bugfix2/"/>
    <id>http://shivakasu.github.io/2016/10/07/bugfix2/</id>
    <published>2016-10-06T16:13:20.000Z</published>
    <updated>2020-01-10T04:11:16.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用 pip install scrapy 来安装scrapy时，遇到以下输出：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collecting cffi&gt;&#x3D;1.4.1 (from cryptography&gt;&#x3D;1.3.4-&gt;pyOpenSSL-&gt;scrapy)</span><br><span class="line">  Downloading cffi-1.8.3-cp27-cp27mu-manylinux1_x86_64.whl (386kB)</span><br><span class="line">    100% |████████████████████████████████| 389kB 454kB&#x2F;s </span><br><span class="line">Collecting pycparser (from cffi&gt;&#x3D;1.4.1-&gt;cryptography&gt;&#x3D;1.3.4-&gt;pyOpenSSL-&gt;scrapy)</span><br><span class="line">  Downloading pycparser-2.14.tar.gz (223kB)</span><br><span class="line">    100% |████████████████████████████████| 225kB 609kB&#x2F;s </span><br><span class="line">Building wheels for collected packages: Twisted, PyDispatcher, cryptography, zope.interface, pycparser</span><br><span class="line">  Running setup.py bdist_wheel for Twisted ... done</span><br><span class="line">  Stored in directory: &#x2F;home&#x2F;shiva&#x2F;.cache&#x2F;pip&#x2F;wheels&#x2F;0e&#x2F;53&#x2F;62&#x2F;e7b4cea7df9113fb2818b224eb5d143be981568d9c43057a0a</span><br><span class="line">  Running setup.py bdist_wheel for PyDispatcher ... done</span><br><span class="line">  Stored in directory: &#x2F;home&#x2F;shiva&#x2F;.cache&#x2F;pip&#x2F;wheels&#x2F;86&#x2F;02&#x2F;a1&#x2F;5857c77600a28813aaf0f66d4e4568f50c9f133277a4122411</span><br><span class="line">  Running setup.py bdist_wheel for cryptography ... error</span><br><span class="line">  Complete output from command &#x2F;usr&#x2F;bin&#x2F;python -u -c &quot;import setuptools, tokenize;__file__&#x3D;&#39;&#x2F;tmp&#x2F;pip-build-UDAHL4&#x2F;cryptography&#x2F;setup.py&#39;;exec(compile(getattr(tokenize, &#39;open&#39;, open)(__file__).read().replace(&#39;\r\n&#39;, &#39;\n&#39;), __file__, &#39;exec&#39;))</span><br></pre></td></tr></table></figure></div><p>可以看到是在安装cryptography时出的问题，报错信息为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;temp.linux-x86_64-2.7&#x2F;_openssl.c:433:30: fatal error: openssl&#x2F;opensslv.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure></div><p>于是又可以追踪到是openssl的问题，通过百度安装过程，发现执行以下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libssl-dev</span><br></pre></td></tr></table></figure></div><p>即可解决报错问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决安装rails时出现 ERROR：Failed to build gem native extension. 的问题</title>
    <link href="http://shivakasu.github.io/2016/10/03/bugfix1/"/>
    <id>http://shivakasu.github.io/2016/10/03/bugfix1/</id>
    <published>2016-10-03T10:36:20.000Z</published>
    <updated>2020-01-10T04:11:22.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>执行 gem install rails 时出现了错误，错误信息如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Fetching: pkg-config-1.1.7.gem (100%)</span><br><span class="line">Successfully installed pkg-config-1.1.7</span><br><span class="line">Fetching: nokogiri-1.6.8.gem (100%)</span><br><span class="line">Building native extensions.  This could take a while...</span><br><span class="line">ERROR:  Error installing rails:</span><br><span class="line">ERROR: Failed to build gem native extension.</span><br><span class="line"></span><br><span class="line">    current directory: &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;nokogiri-1.6.8&#x2F;ext&#x2F;nokogiri</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby2.3 -r .&#x2F;siteconf20161003-4423-1bf9irh.rb extconf.rb</span><br><span class="line">Using pkg-config version 1.1.7</span><br><span class="line">checking if the C compiler accepts ... yes</span><br><span class="line">Building nokogiri using packaged libraries.</span><br><span class="line">Using mini_portile version 2.1.0</span><br><span class="line">checking for gzdopen() in -lz... no</span><br><span class="line">zlib is missing; necessary for building libxml2</span><br><span class="line">*** extconf.rb failed ***</span><br><span class="line">Could not create Makefile due to some reason, probably lack of necessary</span><br><span class="line">libraries and&#x2F;or headers.  Check the mkmf.log file for more details.  You may</span><br><span class="line">need configuration options.</span><br><span class="line"></span><br><span class="line">Provided configuration options:</span><br><span class="line">--with-opt-dir</span><br><span class="line">--without-opt-dir</span><br><span class="line">--with-opt-include</span><br><span class="line">--without-opt-include&#x3D;$&#123;opt-dir&#125;&#x2F;include</span><br><span class="line">--with-opt-lib</span><br><span class="line">--without-opt-lib&#x3D;$&#123;opt-dir&#125;&#x2F;lib</span><br><span class="line">--with-make-prog</span><br><span class="line">--without-make-prog</span><br><span class="line">--srcdir&#x3D;.</span><br><span class="line">--curdir</span><br><span class="line">--ruby&#x3D;&#x2F;usr&#x2F;bin&#x2F;$(RUBY_BASE_NAME)2.3</span><br><span class="line">--help</span><br><span class="line">--clean</span><br><span class="line">--use-system-libraries</span><br><span class="line">--enable-static</span><br><span class="line">--disable-static</span><br><span class="line">--with-zlib-dir</span><br><span class="line">--without-zlib-dir</span><br><span class="line">--with-zlib-include</span><br><span class="line">--without-zlib-include&#x3D;$&#123;zlib-dir&#125;&#x2F;include</span><br><span class="line">--with-zlib-lib</span><br><span class="line">--without-zlib-lib&#x3D;$&#123;zlib-dir&#125;&#x2F;lib</span><br><span class="line">--enable-cross-build</span><br><span class="line">--disable-cross-build</span><br><span class="line"></span><br><span class="line">To see why this extension failed to compile, please check the mkmf.log which can be found here:</span><br><span class="line"></span><br><span class="line">  &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;extensions&#x2F;x86_64-linux&#x2F;2.3.0&#x2F;nokogiri-1.6.8&#x2F;mkmf.log</span><br><span class="line"></span><br><span class="line">extconf failed, exit code 1</span><br><span class="line"></span><br><span class="line">Gem files will remain installed in &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;nokogiri-1.6.8 for inspection.</span><br><span class="line">Results logged to &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;extensions&#x2F;x86_64-linux&#x2F;2.3.0&#x2F;nokogiri-1.6.8&#x2F;gem_make.out</span><br></pre></td></tr></table></figure></div><p>可以看出是在安装nokogiri时遇到了问题，此时执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libxml2-dev libxslt-dev</span><br></pre></td></tr></table></figure></div><p>即可解决问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Rails" scheme="http://shivakasu.github.io/tags/Rails/"/>
    
  </entry>
  
</feed>
