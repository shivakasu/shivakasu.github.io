<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHIVAKASU</title>
  <icon>https://www.gravatar.com/avatar/db3726c77acefe0355d29843a28e9ca4</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shivakasu.github.io/"/>
  <updated>2020-02-18T11:21:02.189Z</updated>
  <id>http://shivakasu.github.io/</id>
  
  <author>
    <name>w.k.x.</name>
    <email>wkx1996@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《西方哲学史》2：中世纪时期(更新中)</title>
    <link href="http://shivakasu.github.io/2020/02/18/phi1/"/>
    <id>http://shivakasu.github.io/2020/02/18/phi1/</id>
    <published>2020-02-18T11:17:20.000Z</published>
    <updated>2020-02-18T11:21:02.189Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1 概论"></a>1 概论</h1><h1 id="2-新柏拉图主义"><a href="#2-新柏拉图主义" class="headerlink" title="2 新柏拉图主义"></a>2 新柏拉图主义</h1><h1 id="3-教父哲学"><a href="#3-教父哲学" class="headerlink" title="3 教父哲学"></a>3 教父哲学</h1><h1 id="4-经院哲学"><a href="#4-经院哲学" class="headerlink" title="4 经院哲学"></a>4 经院哲学</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="网课笔记" scheme="http://shivakasu.github.io/categories/%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哲学" scheme="http://shivakasu.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《西方哲学史》1：古希腊罗马时期</title>
    <link href="http://shivakasu.github.io/2020/02/05/phi0/"/>
    <id>http://shivakasu.github.io/2020/02/05/phi0/</id>
    <published>2020-02-04T16:24:20.000Z</published>
    <updated>2020-02-18T10:57:24.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>课程地址：<a href="https://www.bilibili.com/video/av14582263" target="_blank" rel="noopener">https://www.bilibili.com/video/av14582263</a></li></ul><h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><ul><li>雅斯贝斯在《历史的起源与目标》中提出了轴心时代的概念，是指公元前500年前后同时出现在中国、西方和印度等地区的人类文化突破现象，诞生了一批伟大的思想家，奠定了此后几千年文明生存与发展的根本。</li><li>中国文明主要在中国内部，地域大民族少，而西方文明涉及到欧洲、美洲的多个国家，地域小民族多，所以西方文明的体系要比中国文明复杂。</li><li>中国文明的传统是以夏变夷，以不变应万变，因为早期周边地区都是文明水平比中国低的国家，所以中国能够用自己的文明同化和融合周边地区(东夷西戎北狄南蛮)的文明，来一个融合一个，中国文明因此没有断过线。但中国文明也因此相当保守，难以自我更新，到鸦片战争时期，遇到了强大的西方文明，就无法同化了。</li><li>西方文明的传统是融合更新，因为周边是两河文明、埃及文明等强大的文明，不存在类似夏夷的明显强弱局势，所以西方文明不像中国一样悠然自得，而是更有发展的内驱力，发展历程也比中国更复杂。</li><li>philosophy是两个希腊语的结合，philo是爱，sophia是智慧，所以philosophy本身是爱智慧的意思。</li><li>中国哲学重现世、尚事功、学以致用。西方哲学重超越、尚思辨、学以致知。西方哲学就是为学而学，没有功利性，所以是更纯粹的知识，但也因此容易脱离现实变成玄学。</li><li>陈秀斋提出“哲学无定论”，哲学的终极问题都是没有定论的问题，但是热衷于思考这些问题是人的本性。</li><li>罗素认为哲学介于神学和科学之间。哲学与神学的区别是立足点，哲学基于理性思考，神学基于神圣权威思考。哲学和科学的区别是研究内容，哲学主要思考无定论的问题，科学研究确定性的早晚会有答案的问题。</li><li>哲学是不断批判与怀疑的思维过程，并不是一种刻板的知识体系，而是一种看问题的方式和思考问题的素养。</li><li>黑格尔认为哲学就是哲学史，因为哲学是传承的、发展的，每个阶段的哲学思想都是现今哲学思想的一部分，所以哲学史是一个整体，所有的哲学体系构成了真理全体。</li><li>西方哲学的发展分成四个阶段：最初的哲学问题就是关于世界的本原(arch)，古希腊时期的哲学基本都是以世界本原为核心。古希腊后期哲学转向对人本身的思考，到中世纪时期，主要研究起人的主观精神，贫瘠的现实让人们把个人精神放大，把自我异化成了神圣的形象，所以神是中世纪时期的哲学背景。 古希腊研究客观现实，中世纪研究主观精神，到了近代就开始了对二者关系的研究，自觉地探讨主客观世界的关系，通过这种认识论使人们能够掌握自然世界的力量。现代哲学研究人的主观能动性，因为人类不断把客观世界主观化，人的主观能动性在改变自然中不断提升。</li></ul><h1 id="2-古希腊哲学的背景及发展梗概"><a href="#2-古希腊哲学的背景及发展梗概" class="headerlink" title="2 古希腊哲学的背景及发展梗概"></a>2 古希腊哲学的背景及发展梗概</h1><h2 id="2-1-古希腊哲学的背景"><a href="#2-1-古希腊哲学的背景" class="headerlink" title="2.1 古希腊哲学的背景"></a>2.1 古希腊哲学的背景</h2><ul><li>第一时期在环爱琴海周边到处开花，出现各种哲学流派，四大流派分布两东两西。第二时期雅典崛起，主流哲学家都是雅典人或在雅典成名，雅典成为哲学交流和发展的中心。第三时期城邦集体衰落，马其顿雄起，希腊哲学由盛转衰，放弃探讨世界本原，开始立足现实思考人的问题。</li><li>古希腊哲学发展的根基是城邦制，城邦制国家具有分离主义的政治模式和自由主义的生活态度。</li><li>希腊的民族背景是哲学，中国的民族背景是伦理，印度的民族背景是宗教。哲学是希腊的专利，所以哲学概念放在其他文明里会很模糊。亚里士多德认为哲学的起因是惊异和闲暇，也就是吃饱了撑的胡思乱想，但这解释不了哲学没在东方发展起来。</li><li>中国文明的传统是中央集权，是靠血缘、宗族统治的，人民的地位很低。但希腊时期完成了君主制到僭主制到民主制的转变，在民主制里最高权力不属于少数人，而是由全体公民直接统治国家，公民有了极高的地位，并逐渐形成以公民法为权威的统治模式。法律的概念让希腊人民开始相信世界背后有一种超越现实的、任何个体都无法反抗的绝对力量，这种力量在希腊神话里表现为命运女神，在哲学里就表现为必然性和普遍性，所以对客观世界背后的普遍性的思考使希腊成为了哲学的发源地。</li></ul><h2 id="2-2-古希腊哲学的发展"><a href="#2-2-古希腊哲学的发展" class="headerlink" title="2.2 古希腊哲学的发展"></a>2.2 古希腊哲学的发展</h2><ul><li>第一时期也叫做自然哲学阶段，第二时期是自然哲学转向形而上学的阶段，第三时期是伦理学与人生哲学的阶段。</li><li>自然哲学阶段主要是四大学派，分为自然哲学(唯物)和形而上学源端(唯心)两个阵营。自然哲学派研究事物的物质性本质，比如泰勒斯的水和阿那克西米尼的气，形而上学研究事物的非物质性本质，比如赫拉克利特的逻各斯和毕达哥拉斯的数。各学派纷纷对世界的本原问题提出自己的观点，这导致了一批“后现代主义”哲学家(智者派)的出现，他们认为前人之所以对客观世界有不同的观点是因为主观意识的作用，于是人成了万物的尺度，哲学重心从客观转移到了主观，开始研究人本身。</li><li>第二阶段把自然哲学派推向了更高水平，开始思考早期所谓的世界本原背后的更小的本原物质，寻找到了空间上最小的结构，也就是原子，从看得见的水火土气到看不见的原子，从这个角度看自然哲学开始变得形而上。而形而上学一派逐渐成熟，开始思考更深刻、更抽象的概念，比如苏格拉底追问事物的定义，以及柏拉图继承发展了概念论。自然哲学派走向极致的物质结构，形而上学派走向了极致的抽象内涵，亚里士多德整合了这两种对立的观点，指出事物有质料和形式两个方面。</li><li>第三阶段的背景是城邦制的衰落以及亚历山大帝国的崛起，以自由精神为基础的希腊哲学不复存在，人们的眼界不再开阔，对世界本原的问题也不再感兴趣，人们开始悲观地思考在这个全然不同的世界里如何活得幸福，于是伦理学和人生哲学就取代了自然哲学和形而上学。这种悲观的哲学而后与以神为寄托的基督教哲学合流，古希腊哲学功成身退。</li></ul><h1 id="3-古希腊哲学的第一-早期-阶段"><a href="#3-古希腊哲学的第一-早期-阶段" class="headerlink" title="3 古希腊哲学的第一(早期)阶段"></a>3 古希腊哲学的第一(早期)阶段</h1><ul><li>希腊哲学诞生的背景是以希腊神话为主流思想的时代，这些神话包括荷马的《伊利亚特》、《奥德修纪》和赫西俄德的《神谱》。</li><li>四大学派中，位于东边的米利都学派和艾菲斯学派偏自然哲学，研究方法是还原，对事物进行时间和空间上的还原，也就是事物的起源和构成。位于西边的毕达哥拉斯学派和艾利亚学派偏形而上学，研究方法是抽象，是思考事物背后看不见的共性。东部产生自然哲学可能是因为东部地区相对繁荣、商业发达，人们眼界开阔，对客观事物更有好奇心。西部产生形而上学可能是因为西部地区相对落后、农业为主，人们研究比较局限，同时宗教氛围和神秘主义比较浓厚。</li></ul><h2 id="3-1-米利都学派"><a href="#3-1-米利都学派" class="headerlink" title="3.1 米利都学派"></a>3.1 米利都学派</h2><h3 id="泰勒斯"><a href="#泰勒斯" class="headerlink" title="泰勒斯"></a>泰勒斯</h3><ul><li>泰勒斯，与雅典的立法者梭伦等人并称古希腊七贤，鼎盛年公元前585年。被誉为(自然)哲学之父，是因为表述了“水是万物的本原”的观点。亚里士多德的一种解释是该观点是泰勒斯观察发现的结果，因为种子起源于湿润，而水是湿润的源头，所以他会认为水是万物本原。另一种解释从神话的角度考虑，因为水神是希腊神话中最古老的神，比如《神谱》中的天神和海神是大地女神盖亚最先孕育出的神，所以水是万物本原。</li><li>丹皮尔的《科学史》里指出，泰勒斯的重要意义在于摆脱了神话思维的束缚，开始独立地用自然物质来解释万物的本原。因为在神话思维里自然界的事物与现象都有着对应的神，用神的生殖繁衍来解释世界。</li><li>泰勒斯还提出了“万物有灵论”，但他所谓的“灵”是水的湿气，认为湿气是万物构成的原因。</li><li>泰勒斯没有把万物的质料因(物质性本原是什么)和动力因(本原构成万物的动力是什么)区分开，简单地把质料和动力都归结到水。后期的希腊哲学区分了质料因和动力因，因为物质性本原是惰性的、被动的，而本原构成万物需要一种能动性的驱动力，他们将其归结于精神力量。唯物主义似乎不擅长思考动力因，只会耍赖，比如“运动是事物的本性”，或者强行定义不需要证明的公理。</li></ul><h3 id="阿那克西曼德"><a href="#阿那克西曼德" class="headerlink" title="阿那克西曼德"></a>阿那克西曼德</h3><ul><li>阿那克西曼德，是泰勒斯的朋友和学生，鼎盛年公元前570年。最早提出了“本原”的概念，他认为泰勒斯把水看做本原是因为水在可见物里是无定形的，从这个角度考虑，火土水气都是无定形的，所以万物本原应该是一个比水更无定形的终极无定形物质。他没有具体解释这种物质是什么，只是起了个名字“阿派朗”(古希腊语里，阿是否定词，派朗是指定形)。用有形不能把握无形，所以一切对“阿派朗”的讨论都是无意义又无结果的。</li><li>黑格尔认为，阿派朗把绝对本质定义成一个否定形态，是哲学的进步和思维境界的提高。因为所有东西都是本原构成的，所以本原只可能不是个东西，他就必须只具有否定概念。正如道家的“道可道非常道”，道也是个不是东西的东西。又如新柏拉图主义提出的“太一”。(给无中生有赋予了哲学意义，哈哈)</li><li>阿派朗内部有冷热、干湿两组对立的机能，阿派朗生成万物的动力因就是内部冷热干湿的分离(矛盾产生斥力？)，比如冷和湿分离出来形成水、冷和干分离出来形成土、热和湿分离出来形成气、热和干分离出来形成火，而水土火气又进一步构成其他物质。同理，冷热干湿的聚合又使得万物归于阿派朗。</li><li>辛普里丘在介绍阿那克西曼德的哲学思想时写道：“万物由之产生的东西，万物又消灭而复归于它，这是命运规定了的。因为万物在时间的秩序中不公正，所以受到惩罚，并且彼此互相补充。”这是他以颇带诗意的语言说出的话，暗含了命运的决定论思想。</li><li>阿那克西曼德还提出了朴素的进化论的思想，认为人是鱼进化而来的，因为人在胚胎状态很像鱼。</li></ul><h3 id="阿那克西米尼"><a href="#阿那克西米尼" class="headerlink" title="阿那克西米尼"></a>阿那克西米尼</h3><ul><li>阿那克西米尼，是阿那克西曼德的学生，鼎盛年公元前546年。提出了气是万物本原，是两位前辈思想的折中，因为气既是客观存在的具体的物质，又具有阿派朗的无定形的特点，既超越了泰勒斯的局限性又有了阿那克西曼德不具备的肯定性。</li><li>阿那克西曼德的另一个学生毕达哥拉斯，没有选择妥协性的折中思想，而是极端地把阿派朗上升到更抽象、更理性的概念，也就是数，同时数的概念也把感性上的无定形变成了理性(思想)上的有定形。此外，冷热干湿的组合蕴含了一种量化的思想，所以冥冥中注定了阿那克西曼德之后必然会有人提出数的概念。</li><li>阿那克西米尼取消了干湿属性，认为气只有冷热属性。万物形成的动力因就是气在冷热作用下的凝聚和扩张，变化的逻辑可以理解为：火←气→风→云→水→土→石，其中往左是扩张往右是凝聚。但阿那克西米尼的逻辑漏洞在于，火比气更无定形，那么火更应该是本原，所以自然而然有了赫拉克利特的观点。气的凝聚扩张也是浓厚稀薄程度的不同，所以也蕴含了量化的思想。</li></ul><h2 id="3-2-毕达哥拉斯学派"><a href="#3-2-毕达哥拉斯学派" class="headerlink" title="3.2 毕达哥拉斯学派"></a>3.2 毕达哥拉斯学派</h2><ul><li>毕达哥拉斯，是泰勒斯和阿那克西曼德的学生，鼎盛年公元前531年。提出了数是万物的本原。他颠覆了前人的思想，认为本原不应该是无定形的，而应该是一种能被认知到的有定形的东西，既然通过感官无法找到本原，就应该用思想去把握它，从形而下上升到形而上。</li><li>毕达哥拉斯的抽象方法尚未成熟，他的数并没有完全脱离形体，“1”是数的第一本原，“1”的形表现为点，“1”构成“2”的形体表现是点构成面，再到面构成体、体构成水土火气，最后水土火气构成万物。</li><li>毕达哥拉斯有神秘主义和宗教的背景，所以他又认为数具有特殊的象征意义，1代表灵魂(最基本)，2代表意见(摇摆不定)，5代表爱情(第一个奇数加第一个偶数)，等等。再如，他从奇偶对立中引申出十对基本范畴(迷信10代表和谐完满)，包括奇对偶、有形对无形、一对多、左对右、阴对阳、静对动、直对曲、明对暗、善对恶、正方对长方(明显凑数)。再如，只观察到九个天体，非要杜撰出一个想象的天体凑个整。</li><li>埃及由于工程需要最早发明了几何学，但毕达哥拉斯最先从具体的几何图形中抽象出数学定理，他从直角三角形抽象出毕达哥拉斯定理，蕴含了一种数比形更有本质意义的思想。而后因为毕达哥拉斯定理引出的无理数危机(有时根据直角边算不出斜边的值，非奇也非偶)，加强了人们对数形分离的观念(直到笛卡尔的解析几何才实现了数形的统一)。数形分离的思想让数超越了感官知觉，培养出一种形而上学的倾向，也就是把超现实的抽象存在当做万物本原。</li><li>形而上的翻译源自《易经》中的“形而上者谓之道，形而下者谓之器”。中国传统思想是重经验的，讲究眼见为实，但形而上学相信眼见为虚、抽象为真，所以后面芝诺会提出一些超出人们经验认知、看起来很荒唐的悖论，因为他相信看起来真的东西不一定为真。</li><li>罗素对毕达哥拉斯有负面评价，认为他的数学思想是后期种种形而上学谬误和神秘主义信仰的根源。而黑格尔认同毕达哥拉斯的形而上，认为它是实在论哲学到理性哲学的过渡，也由此发展出西方哲学一脉相承一直到黑格尔的一种“本质决定存在”的本质主义的形而上学体系。与之相对的海德格尔和萨特所代表的“存在决定本质”的存在主义的形而上学体系，存在主义尊重人的自由和价值，认为本质主义只适用于物，对于人而言是存在先于物质的，因为本质主义有上帝按图施工创造世界的宿命感，所以要想肯定人的自由和主动性，必须要承认人的本质是人自己创造的，而不是高于人类存在的上帝之类的东西。</li><li>古希腊的传统宗教是现实主义、重肉体的，灵魂要依靠肉体存在，体现在希腊神话里就是神都拥有人的形象。而毕达哥拉斯从奥尔弗斯宗教继承了灵魂不死、轮回转世的灵肉分离思想，通过苏格拉底、柏拉图影响到了后期的基督教神学，体现在基督教里摆脱肉体的天国的概念。</li></ul><h2 id="3-3-艾菲斯学派"><a href="#3-3-艾菲斯学派" class="headerlink" title="3.3 艾菲斯学派"></a>3.3 艾菲斯学派</h2><ul><li>赫拉克利特，退隐山林的艾菲斯王子，鼎盛年公元前504-前501年。离群索居导致他的哲学语言和思想极度晦涩，连晦涩大佬黑格尔都觉得他晦涩。晚年得了水肿病不得不出山，因为交流障碍不治身亡。</li><li>提出了火本原说，一方面是受阿那克西米尼气本原说的影响，另一方面在希腊神话中火神地位很高。火与万物的转化就是燃烧与熄灭，燃烧又叫上升的道路，表现为稀薄化的倾向，如水→气→火，熄灭又叫下降的道路，表现为浓厚化的倾向，如气→水→土。从整个转化过程来看，上升和下降只是同一条路的不同方向，这就蕴含了辩证法对立统一的思想。</li><li>提出了逻格斯(logos，希腊语原意是话语)，有尺度、规律、命运、必然性的意思，到柏拉图就发展成理念和概念，概念的连接构成判断，判断的连接又构成推理，所以逻格斯是西方哲学一脉相承最重要的基本概念。命运就是一种必然性，所以赫拉克利特认为命运就是逻格斯，是贯穿宇宙的尺度。</li><li>赫拉克利特把世界分裂成理智世界的逻格斯和感观世界的万物，正是逻格斯控制着火与万物之间转化的分寸(又是耍赖的动力因)，所谓“一切是一，一也是一切”。与毕达哥拉斯不同的是，数只体现量的必然性，而逻格斯还体现了质的必然性。逻格斯既有客观规律的含义，又有主观理性的含义，主观与客观在赫拉克利特这里是统一的，因为理性或智慧就是对客观规律的认识和把握。赫拉克利特之所以鄙视荷马、赫西俄德、毕达哥拉斯，就是认为他们没有把握住自己的逻格斯，他们的思维不是理性和智慧的。</li><li>赫拉克利特认为“智慧就在于说出真理”，因为现实中很难只依靠感官的直观感受，我们生活在语言的世界，我们了解的世界是别人通过语言告诉我们的，逻格斯本意是话语，就是要用语言表达出来的。</li><li>赫拉克利特是辩证法的奠基人。毕达哥拉斯仅仅提出了奇偶、善恶这些对立的概念，而赫拉克利特开始在对立中寻求统一。他的辩证法思想有三点。第一点是一切事物都处于流变之中，“人不能两次走入同一条河流”(变化也可以看做存在与不存在的对立统一)，是发展变化的观点。第二点是一切事物都是对立统一的，对立导致和谐，相反才能向成，正如坏使好舒服、饿使饱舒服。第三点是事物的相对性和不同的评价标准，不同的人可以对同一事物有不同的认知。但辩证法容易发展成诡辩，赫拉克利特的弟子克拉底鲁只承认绝对运动不承认相对静止，提出了“人一次也不能踏入同一条河流”，这就等于承认因为世事在变化所以我们什么也把握不住，把哲学的路堵死了。</li></ul><h2 id="3-4-艾利亚学派"><a href="#3-4-艾利亚学派" class="headerlink" title="3.4 艾利亚学派"></a>3.4 艾利亚学派</h2><h3 id="克塞诺芬尼"><a href="#克塞诺芬尼" class="headerlink" title="克塞诺芬尼"></a>克塞诺芬尼</h3><ul><li>克塞诺芬尼，游吟诗人，鼎盛年公元前540年。最早对希腊神话进行解构、颠覆、怀疑和批判，这种反传统、犯众怒的人命运往往比较悲惨。针对神与人同形同性的特点，他认为不是神创造了人，而是人按照自己的形象创造了神，所以不同地域的人会有不同形象的神，而神也继承了人类恶劣的一面，如偷盗、奸淫。</li><li>克塞诺芬尼总结了前人思想(赫拉克利特的一，毕达哥拉斯的1)，认为万物的本原是“一”，“一”才是真正的全知全能的神(类似基督教的上帝)。这个神只是抽象的概念，不具有任何形体，不受任何限定。克塞诺芬尼第一次用朴素的归谬法论证了神是不生不灭的：假设神不是永恒的，神就只能是被派生出的，要么从存在中产生，要么从不存在中产生，二者最终都会推出矛盾。前人只是简单地断言，因为当时还没有逻辑推理的概念，到亚里士多德才奠定逻辑学。克塞诺芬尼也由此奠定了艾利亚学派注重论证的传统。</li></ul><h3 id="巴门尼德"><a href="#巴门尼德" class="headerlink" title="巴门尼德"></a>巴门尼德</h3><ul><li>巴门尼德，鼎盛年公元前500年，克塞诺芬尼的学生，但真正影响他的是毕达哥拉斯学派，同时也了解米利都学派，批判过赫拉克利特学派，所以对前面三个学派有继承和交汇。</li><li>巴门尼德提出了“存在者存在，非存在不存在”，但这里的概念与传统的经验相反，他认为感官认知的世界是非存在，抽象的理性世界是存在，实际上他颠覆了存在的概念。赫拉克利特的思想中也隐约暗含着这种观点，他持一种精英主义，认为逻格斯是存在，火与万物是非存在，所以一般人只能认识到非存在的表象，自己这么牛逼的人才能把握存在或本质。但巴门尼德只是把存在当做概念直接使用，没有指出存在具体是什么(其实就是抽象世界)，由此导致了后世的争论。</li><li>亚里士多德指出，四大学派的问题就在于只讨论什么是存在而忽视了存在是什么，也就是只断言诸如水土火气是存在、感官世界是存在、逻格斯是存在，但没有思考如何界定存在与非存在。</li><li>在巴门尼德看来，米利都学派的错误在于认为“非存在存在，而存在不存在”，也就是只看表象不看抽象，而赫拉克利特学派的错误在于认为“存在和非存在都存在”，因为赫拉克利特认为感官世界和逻格斯都存在，只是一个真实一个虚假。其实赫拉克利特不把话说死是因为他追求存在与非存在的对立统一，但是巴门尼德没有辩证的思想，一定要把二者严格对立，从这个角度看，赫拉克利特层次更高。</li><li>巴门尼德认为存在有四个特点：不生不灭(时间上永恒)、独一无二(不可分割)、不变不动、像一个滚圆的球体(空间上有限)。前三点是总结的克塞诺芬尼的观点，根据这三点可以推理出什么是存在，因为感官认知的一切事物都是不永恒、不独一、可变动的，所以存在自然就是抽象世界的。后来的理念论和原子论打破了存在的独一性，理念和原子遍地都是，相当于砸碎了的存在，大概是因为存在不独一能更好地解释世界。</li><li>因为找不到一个概念能归纳存在与非存在的共性，所以对万物本原的追溯会停止在存在上。巴门尼德的局限性在于只承认存在，而不承认非存在的存在性，到黑格尔就突破了这种局限，他从存在走向非存在，并讨论了存在与非存在的辩证关系。</li><li>巴门尼德认为存在是滚圆的球体，这是受毕达哥拉斯学派的影响，认为无定形是有缺陷的，连自己都定不了形怎么能产生定形的东西，所以存在一定是定形的，而球体被认为是最和谐、最完满的形状。</li><li>17世纪德国经院学者P·戈科列尼乌斯将这种关于存在的学问称为“本体论”(Ontology)，On是存在的意思，tology是学科的意思。所以本体论是哲学最基本、最重要的理论，然后再有认识论、方法论。</li><li>哲学的基本问题是思维与存在的关系。第一个问题是何者为第一性，由此区分出唯心和唯物，以及认为两者独立的二元论。第二个问题是思维与存在有没有同一性，由此区分出可知论和不可知论。巴门尼德是第一个提出思维与存在(这里指抽象)同一性的哲学家，也就是能被思想和表述的必定是存在，同时又没有不基于存在的思想和语言。</li><li>海德格尔认为巴门尼德把西方哲学引到了错误的方向上，过分关注抽象的思想而忽视了活生生的感性世界(没理解海德格尔的意思)，但从现在来看巴门尼德也确实对哲学的发展起到了相当大的积极的作用，抽象思维创造了认知发展的捷径。</li><li>巴门尼德虽然严格区分了真理(抽象思维)和意见(感官知觉)，但还是承认了意见对真理的积极意义，他说“意见虽然不含真理，你仍然要加以体验，因为必须通过全面的彻底研究，才能制服那种虚幻之见”，这其实是站在抽象世界角度的一种知己知彼的高傲态度。</li></ul><h3 id="芝诺"><a href="#芝诺" class="headerlink" title="芝诺"></a>芝诺</h3><ul><li>芝诺，巴门尼德最喜爱的学生，鼎盛年公元前468年，性情孤傲，积极参与政治斗争，最后因反对僭主被僭主打死。哲学思想上没什么建树，主要成就是论证老师的观点。</li><li>巴门尼德继承了克塞诺芬尼的归谬法来证明存在是不生不灭、独一无二的，芝诺则用归谬法补充论证了存在是不变不动、独一无二的，用悖论的形式说明运动和杂多会产生矛盾。</li><li>否定运动的悖论有二分法、阿客琉斯追龟、飞矢不动、运动场。亚里士多德对这些悖论做出了批评：二分法的错误在于对有限的距离做无限的分割导致与有限的时间产生数量上的不匹配。阿客琉斯追龟的错误在于对领先的时间做无限的分割导致与有限的距离产生数量上的不匹配。飞矢不动的错误在于承认时间的离散型而不承认其连续性。运动场的错误在于把一个运动物体经过另一运动物体所花的时间，看作等同于以相同速度经过相同大小的静止物体所花的时间。</li><li>否定多的悖论有大小论证、数的论证、地点的论证、谷粒的论证。也都是源于对有限与无限、连续与离散等概念的错误认识。</li><li>芝诺引领了一种不好的风气，只注重逻辑推理，而对事实视而不见。因为当时关于逻辑推理的思想不成熟，所以论证中会带有些许诡辩的色彩。但芝诺的论证中也含有深刻的辩证成分，所以亚里士多德把芝诺称为辩证法的创始人(赫拉克利特是奠基人)。</li></ul><h3 id="麦里梭"><a href="#麦里梭" class="headerlink" title="麦里梭"></a>麦里梭</h3><ul><li>麦里梭，巴门尼德的学生，鼎盛年公元前441年。他修改了巴门尼德的观点，认为存在在空间上也是无限的，因为如果空间有限，在它之外一定有别的东西，存在就不是独一的，就会产生先有谁后有谁的问题。</li><li>麦里梭没有像芝诺一样极端地否定运动与多，而是认为感性世界的运动与多是存在的，只不过是不真实的存在，相对于抽象世界里那个永恒的存在不过是过眼云烟。只有“虚空”才是不存在的，后来柏拉图就走的这条路。</li></ul><h1 id="4-古希腊哲学的第二-鼎盛-阶段"><a href="#4-古希腊哲学的第二-鼎盛-阶段" class="headerlink" title="4 古希腊哲学的第二(鼎盛)阶段"></a>4 古希腊哲学的第二(鼎盛)阶段</h1><h2 id="4-1-智者派"><a href="#4-1-智者派" class="headerlink" title="4.1 智者派"></a>4.1 智者派</h2><ul><li>四大学派的分歧就在于感性世界与理性世界的本原性和存在性问题，智者派大彻大悟、另辟蹊径，颠覆性地认为所谓本原可能并不存在，或者这些问题本来就是因人而异、见仁见智的问题。于是从本体论发展到怀疑论，研究重点从客观转移到了人的主观。</li><li>四大学派并不是完全意义上的的唯物与唯心的对立，他们是在承认世界有客观本原的基础上，讨论本原是一种物质的还原物还是思维的抽象物，其实都是对客观的追问，大同小异。而怀疑论是对当时自然哲学和形而上学两派思想的根本的颠覆，真正把客观问题转移到主观，认为本原是什么、客观是怎样无关紧要，重要的是世界对人来说是怎样的。但怀疑主义在哲学史的地位只是小憩，它主要深刻地解构和攻击别的思想，却不能形成自己的一套哲学体系，因为没有根基，所以看上去充满智慧、无懈可击，所以怀疑主义注定不能长久，说明既要大彻大悟也应该执迷不悟，既要解构也应该要建构。</li><li>智者派是古希腊哲学早期阶段与鼎盛阶段的过渡，解构前人启发后人。因为当时艾利亚学派影响比较大，所以智者派的攻击主要针对的是艾利亚学派的观点。</li><li>早期四大学派的分布都不在雅典，希波战争以后，雅典崛起，它所实行的民主制鼓励公民积极参与政治、表达思想，所以吸引了众多思想家的拜访，逐渐形成古希腊哲学中心。在这种鼓励思想碰撞的潮流下，辩术与修辞学变得尤为重要，于是出现了传授论辩技巧的智者派，作为以解构和攻击为己任的怀疑论者，他们所擅长的正是表达的技巧。这种表达技巧高于表达内容的风气，在芝诺与麦里梭时期就已经初露端倪，只不过雅典的民主制起到了积极助长的作用。这种论辩之风对古希腊后期发展出形式逻辑与辩证法起到了关键作用。所以智者派其实不是一个学派，而是雅典城中从事这样职业的一批人，他们自称智者(sophist)。</li><li>苏格拉底和亚里士多德等人鄙视智者派，他们认为重要的是说的内容而不是怎么说，智者的技术是一种似是而非的智慧，所以苏格拉底不屑与之为伍，他更愿意自称爱智慧(philosopher)。但罗素认为他们的贬低只是因为嫉妒智者的智慧，同行是冤家。</li></ul><h3 id="普罗泰格拉"><a href="#普罗泰格拉" class="headerlink" title="普罗泰格拉"></a>普罗泰格拉</h3><ul><li>普罗泰格拉是第一个自称智者的人，也是第一个传授论辩技术的人。他提出了人是万物的尺度，把哲学从天上拉到了人间，古罗马思想家西塞罗则认为是苏格拉底把哲学从天上拉到了人间，因为苏格拉底讨论了人的道德问题。因为智者派擅长的就是与人谈话和辩论，所以普罗泰格拉也是第一个采用辩证法，即后世所谓“苏格拉底式讨论方法”的人(不同于黑格尔那种独白式的辩证法)。</li><li>普罗泰格拉认为一切均以每个人的立场为转移，其实就是把所谓的“逻格斯”、“存在”从一打碎成多，变成每个人心里都有个一，从客观的一元主义变成了主观的多元主义，这种一变多的思想也被后来的原子论、理念论所继承，所以他们都被叫做打碎了的巴门尼德的理论。</li><li>普罗泰格拉也是第一个语言学家，对希腊语法进行了总结与修正，可能他认识到了语言的重要性，因为20世纪里海德格尔的存在主义、胡塞尔的现象学已经以一种不可知论的立场告诉我们，我们无法认识客观世界，我们存在的世界其实是我们用语言构造出的世界。从这个角度看，表达技巧其实也决定了表达的内容。</li><li>因为把一切都归结到每个人，普罗泰格拉也就成了相对主义者，提出了“一切理论都有其对立的说法”。然而普罗泰格拉把相对主义如此贯彻到底，就导致了“绝对的相对主义”悖论，也就是“一切都是相对的”这句话反而变成了绝对的，让普罗泰格拉在攻击别人的同时又产生了自我矛盾。</li><li>普罗泰格拉最高提出了社会契约的思想，他不承认有绝对的、客观的规则，自然规则见仁见智，社会秩序本质上也是人们约定俗成的一种普遍的主观性。这种普遍的主观性就是我们以为的社会意义上的客观性。</li></ul><h3 id="高尔吉亚"><a href="#高尔吉亚" class="headerlink" title="高尔吉亚"></a>高尔吉亚</h3><ul><li>高尔吉亚是芝诺的学生，杰出的辩论(诡辩)家，青出于蓝胜于蓝，用艾利亚学派的归谬法攻击艾利亚学派(杠精的祖宗)。</li><li>高尔吉亚提出了三个论点：“无物存在”、“即使有物存在，也无法认识”、“即使认识了，也无法告诉别人”。他同时否定了存在性、存在与思维的同一性、语言对存在的表述作用，这相当于全面推翻了老祖宗巴门尼德的理论。</li><li>“无物存在”的归谬论证：<script type="math/tex; mode=display">有物存在\begin{cases}该物是存在物\begin{cases}该存在物是永恒的(永恒意味着空间上无限)\begin{cases}该存在物大于它所在的地方(矛盾，无处存放了)\\\\该存在物等于它所在的地方(矛盾，既是地方又是物了，属于诡辩)\\\\该存在物小于它所在的地方(矛盾，它就不是无限了)\\\end{cases}\\\\该存在物是派生的(矛盾，存在物不能由存在物产生，又不能无中生有)\\\\该存在物既是永恒的又是派生的(矛盾，永恒与派生是严格对立的)\\\end{cases}\\\\该物是非存在物(矛盾，非存在物不能存在)\\\\该物既是存在物又是非存在物(矛盾，存在与非存在是严格对立的)\\\end{cases}</script></li><li>高尔吉亚论证得出的虚无主义结论呼应了普罗泰格拉的相对主义，因为“一切都真”必然会造成“一切都假”，因为已经无所谓真假了，整个世界说有就有说没就没，所以后世苏格拉底做的工作之一就是拯救本质。</li><li>高尔吉亚对存在、思维、语言三者的否定也揭示了两千年后的现代哲学研究的问题，传统的认识论认为语言表述思维、思维承载存在，只看到了三者的联系而忽视了三者之间的鸿沟。首先，有可能我们只是过度沉浸在思维世界里自以为我们能反映存在，但实际上思维或许永远无法触及真实的存在，或者思维对存在有遮蔽和扭曲的作用。比如康德认为存在与思维是绝对对立的，而黑格尔认为思维需要经历一系列辩证的过程才能进展到存在。其次，思维是不能用语言完全表达的，我们交流的是语言化的思维而不是思维本身，语言系统的不完善以及不同语言系统的差异也一定会遮蔽、扭曲思维。</li><li>高尔吉亚把路堵死了，所以后世的自然哲学和形而上学跳过了智者派，还是承接早期的四大学派继续发展。</li></ul><h2 id="4-2-原子论"><a href="#4-2-原子论" class="headerlink" title="4.2 原子论"></a>4.2 原子论</h2><ul><li>智者派把客观的一打碎成主观的多，而原子论是把客观的一打碎成客观的多。</li></ul><h3 id="恩培多克勒"><a href="#恩培多克勒" class="headerlink" title="恩培多克勒"></a>恩培多克勒</h3><ul><li>恩培多克勒综合了早期自然哲学的观点，提出了四根说，认为世界的本原是水火土气四种基本元素。但这不是对前人思想的简单总结，而是从寻找时间上的开端变成寻找空间上的元素。早期自然哲学中从本原到万物有一个转化链，比如气变成风，风再变成云，他们要找的本原其实是这个转化链的开端，也就是时间上的还原。恩培多克勒则认为万物不是转化而来的，而是四种元素不同比例混合直接构成的，水火土气都是永恒不变的一，他们不能互相转化只能混合组合。时间上的还原有相当大的风险和想象成分，但空间上的分解可以更大程度地基于观察。时间很难回溯，但空间分解是可操作的，能切到多小本原就有多小，这是一种兼具科学性和发展性的观点。</li><li>《心理学与生活》第13章提到的古希腊的希波克拉底提出人体有血液、粘液、黑胆汁、黄胆汁四种基本体液，个体人格是由体内何种体液占主导决定的。这种理论是受到了恩培多克勒的影响。</li><li>恩培多克勒认为四元素构成万物的动力因是另外两个独立的动力本源，爱和恨。爱是组合的力量，恨是分解的力量。恩培多克勒并没有把爱和恨归为纯粹的精神力量，他说过“爱的长和宽是相等的”，说明还是有一定物质性，因为当时希腊还没有明确的灵肉分离的思想，到阿那克萨戈拉才指出了精神和物质的区别。早期的自然哲学派都把动力因归结于质料因内部的属性或作用，比如气的收放、冷热的斥力，但恩培多克勒首次提出了独立于质料因之外的动力因。</li><li>恩培多克勒是第一个创立较为系统的认识论的哲学家，提出了流射说和同类相知说。他认为客观事物发出一种流射，作用于人的感官，组成感官的四元素能感知到客观事物的相同元素，正是同类元素的相通性使认识成为可能。这显然是相当朴素的观点。</li></ul><h3 id="阿那克萨戈拉"><a href="#阿那克萨戈拉" class="headerlink" title="阿那克萨戈拉"></a>阿那克萨戈拉</h3><ul><li>阿那克萨戈拉是第一个把哲学引入雅典的人，也是政治家伯利克里和悲剧家欧里庇得斯的老师。虽然雅典是民主制，人们还是很信仰希腊神话，阿那克萨戈拉被伯利克里反对派指控不敬神灵，最后被驱逐出境在流浪中死去，苏格拉底也是这么被迫害死的。因为古希腊的偏形而上学的哲学逐渐走向完善的过程中，会表现出与一般民众的神话、宗教观念格格不入，所以这一派哲学家在世时都比较惨，但是却成为了后世基督教文化的先驱，被基督教借鉴了很多思想。</li><li>阿那克萨戈拉提出了种子说，把恩培多克勒对本原的一分为四进一步发展成一分为无限。每个事物都各有自己的本原，称为“种子”或“同类的部分”。种子就是构成事物最小的微粒，种子的种类和数量无限多，体积无限小，性质永远不变如一，但不同的种子性质各异(原子论则强调数量不强调种类)。恩培多克勒的四发展到阿那克萨戈拉的无限是必然的，因为他对本原种类的限制没有解释，而本原种类越多方便解释的事物也就越多。但是推广到无限解释无限以后的问题在于，说了等于没说。</li><li>把本原分成无限后，事物之间看上去就只有对立而没有联系了，因此就需要解释事物之间的关系，以及事物之间是如何转化的。阿那克萨戈拉在《论自然》里提出，宇宙最初是混沌的状态，不同种子混杂在一起，通过一种旋涡运动，不同类种子逐渐分离，同类种子逐渐聚集，但是分离得不纯粹，所以事物本质上包含了多种种子，其中数量占主导的种子决定了事物的本性。因此事物之间的转化可以解释为内部某类不占主导的种子因为某种原因数量激增，改变了事物的本性(吃啥补啥的完美解释，哈哈)。</li><li>恩培多克勒和阿那克萨戈拉“化一为多，寓一于多”(就种子的概念而言，其实还是一)，把前人有形物的转化，发展成无形物对有形物的构造。这种思想对原子论有启发意义，是原子论的先驱，因为只要把种子的异质性改成同质性，就能把质料意义上的多变成构造形式上的多，就变成了原子论。其实种子的概念就相当于现在的分子，原子论是往前推进了一步。从这个角度想，阿那克西曼德是有大智慧的，他早就想明白任何有定形的物质都无法作为本原，只好提出了阿派朗。</li><li>阿那克萨戈拉还提出了心灵(nous，又译作努斯)，与赫拉克利特的逻格斯形成一组对立统一的概念。逻格斯象征着规律性、必然性，努斯就象征着自由和一种冲破规律的浪漫主义，二者相反相成，使世界既有一定规则又能不断超越、建立新的规则，形成一个辩证的发展的过程。</li><li>种子从混沌走向有序的动力因是一种旋涡运动，这种旋涡运动就是由心灵支配的。心灵与种子相反，种子是多心灵是一，种子异质心灵同质，种子是质料(物质)心灵是形式(精神)。恩培多克勒的爱和恨还遗留着一定的物质性，但阿那克萨戈拉的心灵是独立的、自为的和能动的，从外部推动宇宙，也就是独立于种子构成的物质宇宙之外，在物质之外显然就是指的精神。</li><li>心灵的提出造成了西方哲学史上唯物主义长久以来的困窘，因为阿那克萨戈拉已经把能动性归于精神方面，让后世形成了思维定式，认为物质没有能动性，这就使得唯物主义无法解释事物何以会运动。之后的原子论和现在的辩证唯物主义都是避开了这个问题，上来就说原子本来就能动、物质本来就能动，当成了不需要解释的法则，这也是唯物主义的思维定式。所以哲学里一些没有解释的、让人疑惑的东西，大概可以理解成那个时代的思维定式。</li><li>亚里士多德把他之前的哲学发展总结成四个因素：第一种是质料因，即形成物体的主要物质，比如水火土气。第二种是形式因，即背后的规律性，比如数、逻格斯。第三种是动力因，即为万物变化的动力。第四种是目的因，即让万物变化的目的。就是从心灵的概念里开始有了隐晦的目的因，因为心灵是一种精神性的东西，精神操纵物质一定是需要目的的，这与逻格斯不同，逻各斯是万物被动遵守的规则，不存在所谓的能动性，而心灵是要主动地产生改变，所以需要目的，可惜阿那克萨戈拉没有对这一点展开讨论。</li></ul><h3 id="留基波"><a href="#留基波" class="headerlink" title="留基波"></a>留基波</h3><ul><li>德谟克利特的老师，据说原子论是留基波最先提出的，但德谟克利特将其发扬光大。</li></ul><h3 id="德谟克利特"><a href="#德谟克利特" class="headerlink" title="德谟克利特"></a>德谟克利特</h3><ul><li>德谟克利特，是留基波和阿那克萨戈拉的学生，古希腊最博学的百科全书式人物。罗素认为德谟克利特代表了一种科学的方向，但当时的主流哲学过分强调了人，又出现了偏重思维世界的柏拉图大佬，所以德谟克利特的思想被掩盖了，直到2000年后才被西方学者发掘，可惜那时的科学已经远远超过德谟克利特的思想。</li><li>德谟克利特是古希腊自然哲学的顶峰，柏拉图是古希腊形而上学的顶峰，亚里士多德对两派观点进行了综合。</li><li>德谟克利特提出宇宙是由原子和虚空构成的，希腊语里原子的本意是不可分割。古代人不喜欢无限的概念，所以认为存在不可分割的最小微粒，其实物质能不能无限分割到现在也没研究明白。原子的特点有：不可分且不可入、数量无限而性质相同(只是形状次序位置不同)、在虚空中做直线运动、不生不灭。</li><li>种子和原子的概念就像现在的分子和原子，分子的不同体现在原子排列组合的数量近乎无限，原子的相同体现在原子种类的有限性(所谓性质相同不是绝对的相同)。德谟克利特的思想很超前，因为从现代物理学的角度看，基本粒子构成万物其实就只是数量的差别。</li><li>德谟克利特认为原子做直线运动，不同方向运动的原子碰撞产生漩涡并构成万物。这是为了避免偶然性，让原子受限于绝对的直线，体现出自然万物背后的必然性。后来的伊壁鸠鲁提出原子还有偏斜运动，马克思的博士论文就是从伊壁鸠鲁的偏斜运动谈到了自由意志的问题。</li><li>德谟克利特的原子和现代的原子概念上有不同，德谟克利特模糊了原子的物质性，有形而上的倾向，他认为原子的本原性在于构成万物而不属于万物，因为凡是我们能找到的物质都是无数原子构成的，原子更像是事物背后的一种必然性、规律性。原子论也因此被柏拉图、亚里士多德鄙视，原子什么都不是凭什么能构成万物。原子和万物的关系就像巴门尼德存在与非存在的关系，原子和巴门尼德存在的区别在于，原子是多而存在是一，原子永动而存在静止，从这个角度看，柏拉图的理念更接近砸碎了的存在。</li><li>原子论和理念论的分歧本质上是质料与形式的分歧，亚里士多德综合了这两点，就像现实的桌子是木头根据桌子的概念做成的，质料和形式缺一不可。</li><li>德谟克利特认为原子是存在，虚空是非存在，但与巴门尼德不同的是，他认为非存在是存在的，因为虚空是原子运动的场所，所以虚空必须是存在的。可是大家关于存在和非存在的定义都不一样，放在一起比较好像不太合适，亚里士多德的一个牛逼之处就是发现了这个问题。</li><li>德谟克利特奠定了到牛顿再到现在的人们最习以为常的时空观，世界是个无边无际的大罩子，有原子有虚空，我们在虚空里运动。其他的时空观还有笛卡尔的充实空间理论，没有虚空，世界是被物质充满的，事物在其他物质中的运动就像鱼在水中运动一样。还有爱因斯坦开创的更高级的相对论时空观。还有康德的主观时空观，他认为时空是我们人类主观感受世界的一种结果，不是客观存在的东西，比如人和狗看到的世界可能不一样。</li><li>德谟克利特认为原子的能动性是不需要解释的固有属性，同时也不需要像努斯一样的外部助力，所以他回避了动力因和目的因。但是原子既有能动性又不得不遵守直线运动的规则，就让人觉得背后一定有一种神秘的力量事先注定了这一切，所以绝对的必然性就变成了一个最大的偶然性，因为一次注定了一切的规则。当后世遇到这种绝对必然性的情况时，就提出了上帝的存在，指出世界就是上帝创造的偶然的奇迹。这个问题在我们的文化背景看来，就是必然和偶然的辩证关系。</li><li>德谟克利特还提出了比流射说更科学的影像说，物体发出与自身形状相似的影响，通过空气的作用进入人的感官，形成感觉和思想。这是唯物主义的反映论的首次明确的表达。同时他认为感觉是因人而异的，感觉获得的知识是暗昧的知识，理性获得的知识才是真理性的知识。</li></ul><h2 id="4-3-苏格拉底"><a href="#4-3-苏格拉底" class="headerlink" title="4.3 苏格拉底"></a>4.3 苏格拉底</h2><ul><li>苏格拉底一生述而不作，主要靠他的两个学生克塞诺芬尼(不是之前那个克塞诺芬尼)和柏拉图记载思想言行，前者侧重于记录生平事迹，后者侧重于记录思想。一般认为，柏拉图的早期著作真实地反映了苏格拉底的思想，而后期的著作是借苏格拉底之口表述柏拉图自己的思想。</li></ul><h3 id="认识你自己"><a href="#认识你自己" class="headerlink" title="认识你自己"></a>认识你自己</h3><ul><li>苏格拉底认为人不配拥有真正的智慧，只有神才拥有智慧，而人们普遍都没有认识到这一点，人们认为苏格拉底有智慧其实是因为他认识到了自己的无知。所以他一生都用一种批判的态度探寻智慧，对自称有智慧的人(特别是智者)进行揭露，因而得罪了不少人。因为人没有智慧，而他认为认识自然是需要智慧的，所以他进而认为人是不可能认识自然的，也就是否定了早期的自然哲学一派，觉得他们企图认识自然的行为太狂妄无知了。苏格拉底号召人们不要再去研究自然，而要把眼光拉回到人，人只应该也只能认识自己，所以西塞罗才认为苏格拉底把哲学从天上拉回了人间。</li><li>虽然普罗泰格拉也算是把哲学拉到人间，但他是把人理解成一个个独立的个体，强调人的独立性而忽视了人的联系，强调一切都是因人而异的，所以导致了相对主义。但苏格拉底思考的人是人之所以为人的本质，也就是道德伦理，所以苏格拉底被西方认为是道德哲学之父。</li></ul><h3 id="神学目的论"><a href="#神学目的论" class="headerlink" title="神学目的论"></a>神学目的论</h3><ul><li>之前的哲学家只明确探讨了质料因和动力因，苏格拉底并不满足，就像努斯安排了万物，但为什么会安排成这样。一般认为人是由两个部分构成的，即肉体和灵魂。苏格拉底关注人的这两部分就分别得出了两个结论：神学目的论和道德哲学。</li><li>通过观察人的身体构造，苏格拉底认为神的用意就表现在人的器官的某种目的性，因为他还没有进化论的高级思想，他认为人是生来如此的，人的身体构造能适应自然环境一定是因为神有目的的创造。这种论证成为了西方思想史上关于上帝存在的设计论证明的最初雏形。</li><li>我们觉得目的因荒谬是因为我们的思维定式里不承认目的因或回避了目的因，目的因很像因果论，可我们既不知道原因又不能确定结果，所以现代科学里习惯用动力因来解释现象，不考虑最初的目的也就不需要寻找最终的结果，所以可以把当前状态当做一个暂时的结果，研究动力因与当前状态的关系。</li><li>因为相信神创造人类的目的性，所以苏格拉底认为人认识自己其实是为了认识神。苏格拉底的神不同于希腊神话里的神，他认为那些与人同形同性的神都是傀儡，真正的神一定是超越它们的东西。他用一个灵异的神取代了传统的有血有肉的神，用一种理想主义和浪漫主义的生活观取代了传统的现实主义的生活观，比如他说“追求好的生活远过于活”，还认为死亡是比生活更高的境界，因为死后灵魂与神为伴，但民众的传统思想里认为好死不如赖活。苏格拉底的死就是对他这种思想的践行，他认为如果自己做了错事，“灵异”一定会出来阻止他，所以他没有做错拒不认罪。</li><li>苏格拉底的思想导致了后世基督教一脉相承的向死而生的唯灵主义，认为死后上天堂是比活着更好的境界。这与中国传统的儒家思想不同，儒家思想是现实主义的、入世的哲学，认为“未知生焉知死”、“子不语怪力乱神”，对神是存而不谈的。</li><li>毕达哥拉斯提出了灵魂转世的思想，认为肉体是灵魂的驿站，灵魂转世的本质是换个驿站，可见他认为灵魂还不能摆脱肉体。而到了苏格拉底，灵魂可以脱离肉体升华到更高的境界，肉体反而成了困住灵魂的囚牢。再到柏拉图，就进一步认为肉体有双重的罪过，一个是困住灵魂让我们道德败坏，一个是妨碍灵魂认识真理。</li></ul><h3 id="美德即知识"><a href="#美德即知识" class="headerlink" title="美德即知识"></a>美德即知识</h3><ul><li>人的另一方面是心灵，苏格拉底认为心灵的内在原则就是美德，因此美德问题是他关注的主要对象。这一点和中国的传统思想相同，《孟子》里有“人之所以异于禽兽者几希；庶民去之，君子存之。舜明于庶物，察于人伦，由仁义行，非行仁义也”，意思是人和禽兽的区别就在于伦理道德。</li><li>一般认为，知识论解决“真”的问题，道德沦解决“善”的问题，但苏格拉底第一次把两者统一，提出美德即知识。苏格拉底认为行为的善恶是相对的，因为人们评价善行恶行是看结果，对行为的理解因人而异，但他没有像普罗泰格拉一样钻牛角尖，而是跳出行为的层面，指出善的概念是一种绝对的、普遍的知识，真正的善行是人基于对善的概念的掌握做出的，不知道善的概念就只是盲目的伪善。美德是关于善的知识，同理，勇敢是关于勇敢的概念的知识，正义是关于正义的概念的知识。他还认为没有人会有意作恶，因为作恶往往会伤害自己，而人不会自己害自己，所以作恶的人都是因为无知，即“知识即美德，无知即罪恶”。这种把美德与知识等同起来的观点开创了西方伦理学中的一个重要思想流派，即唯智主义伦理学，也就是用概念的逻辑代替事物的逻辑。</li><li>后来基督教提出了一种相反的观点，认为知识反而是使人堕落、丧失道德的根源，人只要怀着纯洁的、虔诚的信仰就可以拥有道德，正如亚当夏娃的堕落就是因为偷食了知识之果。所以基督教认为最重要的三种道德是信(信仰)、望(对另外一个世界的希望)、爱，三者都与知识无关。</li><li>到了17、18世纪，经历了启蒙运动、文艺复兴、科学发展，西方文明又对知识充满了信心，认为知识就是力量，用知识可以征服自然，随着知识的增长，人不仅越来越幸福，道德水平也会提高。同时代也出现了相反的悲观主义观点，比如卢梭认为知识让人邪恶，反而是原始时期的人最淳朴善良。</li><li>苏格拉底一方面强调美德是心灵的内在原则，又认为美德作为一种知识是可以通过教育获得的。但这就面临一个问题和悖论：道德知识是人生而有之的还是后天习而得之的？如果是生而有之的就不用学了，如果是生而未知的就不知道从何学起，也就是人既不能学习已知的道德知识又不能学习未知的道德知识(别的知识还是可以学的)。</li><li>在道德知识的问题上苏格拉底得到一个悖论，后来柏拉图把它明确成知识论里的回忆说，认为理念一类的知识介于已知和未知之间，它们是灵魂生而具有的，但灵魂进入肉体时被肉体蒙蔽了以至于人们忘记了，通过后天不断地刺激与回忆又可以想起来，所以说这类知识既不是已知也不是未知。</li></ul><h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h3><ul><li>苏格拉底杠精式的对话被称为“苏格拉底式讨论方法”，也被称为“辩证法”(dialectic，希腊语原意是对话、论辩)。亚里士多德认为苏格拉底最大的贡献是归纳推理和普遍定义，因为不断提问、不断诘难的过程就是一个去伪存真、归纳定义、逐渐接近事物本质的过程。苏格拉底自称是“精神助产士”，意思是帮助别人发现他们心中隐藏的真理。这种方法可以不断深入问题，不断逼近答案，但不一定能得到答案，因为给事物下定义是很困难的。</li><li>智者派对前人思想进行解构，从相对主义走到虚无主义，走上了一条死路。原子论和苏格拉底摆脱了智者派留下的烂摊子，重新建构起一套新的哲学体系，重新建构万物的普遍本质。但苏格拉底找到的普遍性还停留在主观的精神世界、道德层面里，到了柏拉图才推而广之，寻找所有事物背后的一般性、普遍性，把主观的本质变成一种能独立于头脑的客观存在，成为了典型的唯心主义，即理念论。</li></ul><h3 id="小苏格拉底学派"><a href="#小苏格拉底学派" class="headerlink" title="小苏格拉底学派"></a>小苏格拉底学派</h3><ul><li>苏格拉底死后，学生们分散到希腊各处，形成了彼此不同的几个小学派。</li><li>麦加拉派，代表人物欧几里得、欧布里得，他们把苏格拉底的善和巴门尼德的存在结合起来，认为善是宇宙的普遍原则。欧布里得研究论辩术，提出了许多悖论，包括“说谎者悖论”、“蒙面人悖论”、“谷堆悖论”等，这其实也是像芝诺一样为了支持巴门尼德的思想，说明只有存在(善)才是绝对真实的，非存在会使人陷入思维困境。</li><li>昔尼克派(犬儒学派)，代表人物安提斯泰尼、第欧根尼，宣扬人应该像狗一样采取简单粗陋的生活方式，主张放浪形骸、我行我素的生活作风。其实就是让灵魂尽量摆脱客观世界的束缚，回归天然状态。</li><li>昔勒尼派，主张善就是快乐，对后世伊壁鸠鲁的伦理学产生了影响。</li></ul><h2 id="4-4-柏拉图"><a href="#4-4-柏拉图" class="headerlink" title="4.4 柏拉图"></a>4.4 柏拉图</h2><ul><li>柏拉图，苏格拉底的弟子，古希腊唯心主义的最高峰。政途屡屡受挫而在哲学教育上有所成就，创立了讲学的学园(Academy)，所以柏拉图一派的思想又称学园派。柏拉图的思想通过他的学生传承了下去，后来又成为了基督教神学的根基，与此相对的德谟克利特的唯物主义思想，由于没什么学生传承，又和主流的柏拉图思想相背，所以原子论的命运比较悲惨。</li><li>苏格拉底的哲学和他的人生是紧密相关的，但柏拉图政途受挫只能潜心做学问，所以他的生平经历不是很重要。</li></ul><h3 id="理念论"><a href="#理念论" class="headerlink" title="理念论"></a>理念论</h3><ul><li>柏拉图早年求学于赫拉克利特的学生克拉底鲁，克拉底鲁极端地承认绝对运动而否定相对静止，他认为语言无法表述事物，因为话说出口事物已经变了。这里的事物就是巴门尼德的非存在，柏拉图认为语言虽然不能表述非存在，但可以表述存在，也就是感官只能捕捉现象，思想只能把握本质。</li><li>从存在论的角度看，世界分为感性世界和本质，米利都学派只谈感性世界(水火土气)，毕达哥拉斯主要谈本质(数)，赫拉克利特两者都涉及(火和逻格斯)，巴门尼德把本质叫存在把感性世界叫非存在。从认识论的角度看，感性世界是感官的对象，本质是思想的对象，从毕达哥拉斯开始，普遍认为思想把握到的东西是更重要的，苏格拉底的一般定义也是关于本质的定义。思维的工具就是语言，所以语言不能表述事物是因为不再一条认识途径上，本质、思维、语言是一条线上的，所以到了柏拉图，存在、思维和语言三者就统一了。前人一脉相承的这种思想在发展中逐渐清晰，所以到了柏拉图就能够明确地将本质表述为理念论。</li><li>柏拉图的理念与苏格拉底的定义有两点区别。第一点，苏格拉底的定义局限于人的主观精神世界，他对自然界的客观事物不感兴趣，而柏拉图把理念扩展到整个宇宙，认为所有自然物和人造物也有自己的理念。第二点，苏格拉底对客观世界不感兴趣，所以他的定义仅仅是寓于事物之中的一种抽象概念，他并没有深入探讨这种概念本身是不是独立的客观存在，而柏拉图把理念实体化和客观化，理念既独立于客观事物又可以脱离大脑存在，他甚至认为万事万物的理念共同构成了一个独立于自然界的理念世界，所以列宁对此评论“原始的唯心主义认为：一般(概念、观念)是单个存在物。这看起来是野蛮的，骇人听闻的(确切些说：是幼稚的)荒谬的”。理念的人格化就是所谓的上帝，就像上帝是万事万物的根本，但上帝不属于万事万物也不属于人的精神世界，所以柏拉图的理念世界就相当于一个没有人格化的上帝但是客观存在的上帝头脑中的威望(因为上帝是根据头脑中的概念创造世界)。由于承认理念世界的客观性，所以柏拉图是客观唯心主义。</li><li>柏拉图认为具体事物是对理念的摹仿和分有，具体事物的形象是对原始理念摹仿的结果，虽然摹仿出的形象各不相同(大小长短等形态上不同)，但他们都或多或少分有了原始理念的一部分(再丑的人也是人)。又因为摹仿是不完美的，所以具体事物相比于完美的理念一定存在或大或小的缺陷，理念是具体事物追求而不可到达的目标。然而柏拉图并没有解释摹仿和分有具体是如何实现的，提出了一种解释却狡猾地回避了可实现性，因此亚里士多德在《形而上学》里对此评价“只不过是说空话,打诗意的比方而已”，罗素也认为柏拉图是浪漫主义的热情而亚里士多德是实证主义的审慎。</li><li>柏拉图把理念世界由低到高分成几个层次：<ul><li>自然物的理念：人、马、花、草等。</li><li>人造物的理念：桌子椅子等。</li><li>数学意义上的理念：三角形、圆、大于小于等，因为古希腊对数学比较感兴趣。</li><li>范畴意义上的理念：存在与非存在、静止与运动等。</li><li>道德和审美领域的理念：美、勇敢、正义等。</li><li>“善”的理念：终极理念，所有理念共同追求的最高目标，比苏格拉底的善更高级。</li></ul></li></ul><h3 id="“善”的理念与神创世界"><a href="#“善”的理念与神创世界" class="headerlink" title="“善”的理念与神创世界"></a>“善”的理念与神创世界</h3><ul><li>柏拉图把世界分成理念世界、感性世界和原始物质三个层面，原始物质通过对理念的摹仿与分有，形成了感性世界里的具体事物。巴门尼德把理念世界叫做存在，把感性世界和原始物质叫做非存在，而柏拉图在此基础上进行了细分，理念世界是存在，原始物质是非存在，中间的感性世界叫做虚假的存在。理念不仅赋予了客观事物以实在性，也就是让原始物质成为感性世界的事物，同时还赋予了我们主观上认识的能力，我们从理念世界抽离出理念到头脑中从而认识感性世界的事物。所以在柏拉图看来，人的主观世界和自然的客观世界不是简单的反映与映射的关系，而是在更高层的理念世界的协调下得以用主观精神认识客观事物，这种包含客观精神、客观事物和主观精神的三分世界的思想在近代哲学中有很多人支持，比如笛卡尔、斯宾诺莎、莱布尼茨。</li><li>从四因说的角度看，原始物质是质料，理念赋予了质料以形式，感性世界为了追求终极的“善”而进行摹仿和分有，所以“善”又是目的因，终极的“善”就像磁铁一样吸引底层理念和万事万物追求自己，所以“善”还是创造世界的根本动力。因此理念世界集形式、目的、动力三因素于一体，相对的是原始物质的质料因，这就是柏拉图的创世说，又叫做巨匠说，因为创造万事万物是需要原材料的，也就是把原始物质加工成具体事物。相比之下，基督教的创世说就不需要原材料，一切都是上帝凭空创造的。</li><li>柏拉图对创世说的表述是：“让我们来看一看造物主为什么要创造这个生灭变化的世界。他是善的，而善的东西就不会嫉妒任何东西。既然他是不会嫉妒的，因此他愿意使一切东西尽可能和他相像。这就是我们可以完全正确地从有智慧的人那里学来的宇宙变化的最高原则。”可见，“善”是创世的终极目的和动力。</li></ul><h3 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h3><ul><li>回忆说是柏拉图的认识论，正如理念论是柏拉图的存在论，认识论和存在论是一一对应的，所以我们的知识是对应的理念世界的东西。柏拉图的回忆说有三个重点。第一点，灵魂在进入肉体前居住在理念世界里，因此灵魂已经具有了关于各种理念的知识，但在进入肉体后受到肉体的遮蔽而暂时忘记了关于理念的知识，需要感觉经验的刺激才能回忆起来。因此在回忆说中，客观精神、主观精神、客观事物三者缺一不可，认识的过程就是客观事物刺激主观精神回忆起理念世界的知识，这就是典型的“先验论”，也就是在经验之前已经有了知识。第二点，回忆的内容是理念的知识，是事物的本质，而不是对某个具体事物的回忆，比如我们看到各种颜色各种形状的花，在这种刺激下回忆起的是抽象的花的概念，而不是某种特定形象的花。第三点，回忆是一个顺着理念的层次不断上升的过程，需要调动灵魂的主体能动性，能动性越强，回忆到达的层次就越接近终极的“善”，所以教育的目的也是为了提高能动性，进而提高人的认识(回忆)能力。</li><li>柏拉图用“洞喻”表述了认识的过程就是灵魂的不断“转向”，从洞壁转向洞口，从洞口转向外界，最后转向天上的太阳，所谓“转向”就是一个不断反思、不断超越假象，一步步走向事物本质的过程。整体上呈现为一个线性的上升过程，所以柏拉图又用“线喻”表述这个上升的过程，把一条线段分成三个部分表示知识的不同阶段，这三部分在存在论意义上表示原始物质、可见世界和可知世界，与之对应的认识论意义上的表示为无知(原始物质不具有知识)、意见(分为低级的想象和高级的信念)和真理(分为低级的理智和高级的理性)。</li><li>因此线性上升的认识过程就是：想象→信念→理智→理性。其中，可见世界的事物是对理念的摹仿和分有，所以从可见世界得到的想象和信念是低级的知识，比如马是对马的理念的摹仿，从马得到的知识是信念，马的画像是对马的摹仿，从马的画像得到的知识是想象，所以二者都是低级知识，而想象比信念更低级。可知世界的知识虽然是直接的理念，但由于理念也分六个层次，理念的知识也就有理智和理性两个层次， 像自然物、人造物、图形、大小关系，并不是彻底抽象的东西，还或多或少关联于所衍生出的具体事物，比如马的理念不能完全脱离马，所以理智相对低级，而范畴、道德和“善”三个层次的理念可以完全脱离具体事物讨论，所以理性相对高级，柏拉图又把理性叫做辩证法。(关于理智和理性的区别没完全理解，留坑)</li></ul><h3 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h3><ul><li>柏拉图的辩证法是一种研究纯粹理念的逻辑联系与相互转化的学说，不涉及抽象概念与具体事物之间的关系，所以不涉及低级的理智知识，探讨的对象是存在与非存在、动与静、一与多这类更抽象的范畴。之前的哲学家只强调这些范畴的对立而忽视统一，正如巴门尼德承认存在否定非存在，芝诺承认静否定动，柏拉图则发现这些纯粹哲学范畴有向对立面转化的内在必然趋势。比如在考察“一”的时候，“一是一”其实就包含了“一”和“是”两个范畴，因为“是”不是“一”，所以也就得到了两个范畴，也就是“多”，这就是“一”到“多”的转化。再如考察“无”的时候，一旦我们提到“无”，就已经承认有了“无”，那么“无”就变成了“有”。</li><li>对立范畴之间永无休止地转换，这与赫拉克利特所谓的变是一样的，都是消极的观点。柏拉图更进一步提出了“通种论”，把对立范畴的矛盾统一到第三者上，也就是用一个更普遍的“种”的概念统一对立双方。比如有无之间的转换都属于“变”，动静之间的转换都属于“存在”。在对立冲突中产生积极的观点，这就是黑格尔所谓的“积极的辩证说”。</li></ul><h3 id="理想国"><a href="#理想国" class="headerlink" title="理想国"></a>理想国</h3><ul><li>柏拉图出身于雅典贵族，在苏格拉底死后，他对雅典的民主政治充满了失望和仇恨，他在《国家篇》(又译作《理想国》)中提出了自己的政治观点，认为整个世界是由“善”的理念所统辖的秩序井然的体系，因此掌握了“善”的知识的人(哲学家)应当成为一个等级森严的国家的主宰，也因此他鄙视雅典的民主政治，崇尚斯巴达的寡头政治。</li><li>柏拉图认为国家是放大了的个人，人的灵魂由三部分构成，理性、意志和欲望，这三个部分各有其德性，即理性追求智慧，意志追求勇敢，欲望追求节制，当三个部分都恪守自己的德性时，整个灵魂也就到达了自然和谐，从而实现了最高的德性，即正义。灵魂的三部分对应国家的三个阶级，统治者、保卫者和劳动者，当三个阶级各司其职时，整个国家也就变成了遵循“正义”原则的“理想国”。其中，统治者是靠智慧统治国家，所以哲学家和统治者融为一体，成为一种“哲学王”。</li></ul><h2 id="4-5-亚里士多德"><a href="#4-5-亚里士多德" class="headerlink" title="4.5 亚里士多德"></a>4.5 亚里士多德</h2><ul><li>亚里士多德，柏拉图的学生，亚历山大的老师，因为常常与学生们一边散步一边教学，他的学派被人们称为“逍遥学派”。关于和亚历山大的关系，黑格尔认为“亚历山大的精神和事业的伟大乃是来自亚里士多德深刻的形而上学”，而罗素认为亚里士多德对亚历山大的影响是零，亚历山大不愿意接受教育，他对待亚里士多德就只能是认为他是一个迂腐的没有趣味的老头。</li><li>亚里士多德注重科学、理性、逻辑，所以当中世纪早期基督教兴起后，亚里士多德的哲学在西方沉寂了很久，反而在北非的埃及等地被伊斯兰教发扬光大，公元十二世纪后因为十字军东征等原因才传回西方。</li></ul><h3 id="对理念论的批判"><a href="#对理念论的批判" class="headerlink" title="对理念论的批判"></a>对理念论的批判</h3><ul><li>“吾爱吾师，吾更爱真理”，亚里士多德从科学的角度对理念论进行了批判。</li><li>第一点，理念只能寓于具体事物中，因为理念作为具体事物的本质，不可能独立于具体事物存在并与具体事物相对立，同时在时间上、逻辑上又先于具体事物存在。</li><li>第二点，柏拉图论证理念存在的方法站不住脚，它们或是缺乏必然性的推论，或是推出了一些没有与之对应的东西的理念。比如“否定了的东西”、“缺乏”也有其理念，但本来就没有的东西怎么可能会有对应的理念。再比如理念是具体事物追求的目标，按理说应该比具体事物更完美、更完善，但脏东西也有其理念，它的理念应该在某种意义上比脏东西更脏，所以此时理念的完美变成了一种贬义反而仍能吸引脏东西追求它，这种动力显然是荒谬的。再比如将具体事物与理念分离必然会导致“第三者”的出现，“大”的理念在大人和大树上的体现不同，说明大人和大树不是摹仿的同一个“大”的理念，所以原始的“大”的理念和大人大树之间一定存在着类似大动物和大植物的事物，大人摹仿大动物而大树摹仿大植物，这种第三者的存在会无限推下去。总之意思到了就行，因为柏拉图没提到摹仿和分有的实现过程，所以可批判的漏洞太多了。</li><li>第三点，亚里士多德认为“分有”只能是对“实体”的分有，“非实体”的东西也具有理念就和“分有”矛盾了。其次，“摹仿”是无稽之谈，不论人的理念是否存在，现实里的人都是该生生该死死。最后，如果事物是对理念的摹仿，那么人本身既是对动物的摹仿，同时又是每个个体摹仿的对象，所以人本身既是原本又是摹本，就矛盾了。</li><li>第四点，理念对于认识事物没有任何意义，它只是下断言而没有解释性。理念本身是不变不动的，所以不能成为具体事物运动的原因。其次，摹仿和分有不能解释事物生成的过程，理念的存在反而让人们需要认识的东西变多了。</li><li>亚里士多德解决这些问题的方法是有机论，也叫生成论。事物之所以会运动是因为有内在的目的性在驱使它，事物就像一个生命体，具有一个内在物让它顽强地生长成它所要趋向的东西，而不需要对外在物的摹仿和分有。</li></ul><h3 id="第一哲学及存在论"><a href="#第一哲学及存在论" class="headerlink" title="第一哲学及存在论"></a>第一哲学及存在论</h3><ul><li>亚里士多德更像一个讲逻辑、有科学精神的哲学家，而柏拉图更像一个诗人。</li><li>亚里士多德认为哲学是一切科学的总汇，分为理论科学、实践科学和艺术三大部分，其中理论科学又分为第一哲学(即形而上学，形而上是后人起的名字)、物理学或自然哲学，以及作为方法论的逻辑学，实践科学则包括伦理学和政治学。柏拉图鄙视艺术，但是亚里士多德比较认同艺术。</li><li>后人编纂亚里士多德的著作时，认为第一哲学的名字奇怪，但又不好分门别类，所以编在物理学后边，起了个暂时的名字metaphysic，meta是指在…之后，physic是指物理学。其他学科探讨的是作为某种特殊物的存在，比如作为自然界的存在、作为道德的存在、作为艺术的存在，但第一哲学是关于存在本身的学科，也就是关于存在的存在。亚里士多德把第一哲学作为哲学的根本可能是受柏拉图的影响，柏拉图就认为具体事物背后的理念比事物本身更重要，所以亚里士多德会认为研究存在本身是最重要的。metaphysic这个词汇本身没什么特殊意义，但因为指代第一哲学所以地位很高，后世把它等同于本体论(Ontology，又叫做存在论)，所以可以说本体论就是形而上学的核心。后来西方哲学先传到日本，由于日本受中国哲学影响较深，所以明治时期著名哲学家井上哲次郎根据metaphysic指代的意思，并结合中国《周易》里的“形而上者谓之道，形而下者谓之器”，最终将metaphysic翻译为“形而上学”(严复翻译成“玄学”，意思也差不多，因为“玄”就是高深的意思)。而到了黑格尔的时代，形而上学反而成了与辩证法相对的一种包含贬义的哲学，以至于影响了马克思，扭曲了形而上学的本意，使得我们认为形而上学是指片面的、孤立的、静止的思维方式。</li><li>亚里士多德认为定义是最首要的问题，“是什么”比其他问题更重要，之所以把第一哲学作为根本，就是因为第一哲学是对存在本身的理解。反观前人，巴门尼德虽然提出了存在，但没有解释存在是什么。苏格拉底虽然开始对本质进行追问，但仅仅局限在人的伦理道德上。柏拉图虽然把本质推广到万事万物，但理念只是存在砸碎成多的结果，他还是没有解释存在本身是什么。</li><li>前人都在探讨什么是存在，亚里士多德开始探讨存在是什么，就像前人一直在思考本原是什么，却没有对本原有一个清晰、严谨的定义，所以出现了分歧。亚里士多德从逻辑学出发，逻辑学里传统的下定义的方法是“定义=属+种差”，其中“属”是大类，比如人是动物属，“种差”是与同属的其他种类事物的差别，比如人和其他动物的差别是理性，所以人可以定义为“人=动物+理性”。然而对存在下定义不能用这个方法，因为没有比存在更高的“属”，所以亚里士多德换了个角度，考虑存在往下能分成几类，他认为可以分成两类：偶然的属性和必然的本质。偶然的属性即偶性，它不影响事物本质所以不重要，比如人的好坏不影响作为人的事实。必然的本质即范畴，是事物必须具有的东西，包括实体、性质、数量、关系、时间等，在这些范畴上有改变，事物的本质也就变了，比如人有两个头就不算人了。这些范畴中，最重要的就是实体，所以实体就是必然本质里的核心范畴，“存在是什么”的问题也就转化为“实体是什么”，第一哲学也因此又叫做实体哲学(研究不了整体就研究里面最重要的部分？两者没有差别么？)。</li></ul><h3 id="实体是什么-狭义的实体学说"><a href="#实体是什么-狭义的实体学说" class="headerlink" title="实体是什么(狭义的实体学说)"></a>实体是什么(狭义的实体学说)</h3><ul><li>实体(希腊语略，拉丁语substance)是作为哲学最基本的范畴是第一性和独立存在的。亚里士多德在《范畴篇》中对它的定义为：“实体，在最严格、最原始、最根本的意义上说，是既不述说一个主体，也不依存于一个主体的东西，如个别的人、个别的马”。这句话是从逻辑学的角度分析的，亚里士多德认为逻辑和存在是对应的，逻辑是对存在的一种抽象的、理性的概括，所以逻辑学的表述其实也是用一种抽象的、经验的方式表述的客观事实。在亚里士多德以后，逻辑才越来越形式化，形式逻辑逐渐重视形式而忽视内容，变成脱离现实的纯粹的概念之间的推演。但从发生学的角度看，形式逻辑的概念判断推理都是源于对现实世界、对真实存在事物之间关系的一种理论概括。</li><li>回到实体的定义，“不述说一个主体”，从逻辑学上解释，是指实体不能在一个陈述句里作为谓语来述说主语，我们可以说“苏格拉底是人”，其中人作为谓语修饰苏格拉底，所以人不是实体，我们不能反过来说“人是苏格拉底”，所以苏格拉底是实体，以实体作谓语的陈述句都是不合理的，比如“苏格拉底是苏格拉底”这句话是没有意义的，所以亚里士多德举的实体例子里都有“个别的”。“不依存于一个主体”，是指实体必须独立存在。简言之，实体就是独立存在的个别的东西。</li><li>实体有四个特点。第一，实体是具体的、个别的东西，这就与柏拉图的思想相反，柏拉图的理念不是“个别的”，而是一般、普遍的东西，他认为普遍的东西比个别的东西更具有实在性。第二，实体不同于属性，它没有与之相反的东西，比如冷热、大小是彼此相反的，但是没有与“苏格拉底”相反的东西(当时还没有反物质的概念)。第三，实体没有程度上的差别，也就是实体没有可比性，不能说一个实体比另一个实体更怎样。第四，实体是变中之不变，实体承载的具体属性可以变化，但作为实体本身是不变的。</li><li>亚里士多德虽然更爱真理，但也是爱老师的，后来他又倒向了柏拉图，提出了“第二实体”的概念，之前定义的实体就成了“第一实体”。第二实体就是“种”和“属”的概念，与第一实体的区别就在于可以述说主体，不再是“个别的”，所以“人”可以是第二实体，一般性的“理念”也是第二实体，虽然第二实体没有客观具体的指代对象，但在逻辑上是可以独立存在的概念。第二实体让亚里士多德部分回到了理念论，但他从此陷入了自相矛盾，实体是没有可比性的，而第一实体却明显比第二实体更实体，这种矛盾在某种意义上代表着强调个别事物的唯物主义与强调普遍概念的唯心主义之间的矛盾。</li></ul><h3 id="实体的原因是什么-四因说"><a href="#实体的原因是什么-四因说" class="headerlink" title="实体的原因是什么(四因说)"></a>实体的原因是什么(四因说)</h3><ul><li>亚里士多德在总结前人思想的基础上提出了四因说：质料因、形式因、动力因和目的因。正如水火土气是质料，数和逻格斯是形式，爱和恨是动力，努斯一直到苏格拉底又蕴含着目的。</li><li>亚里士多德认为四因在人造物中是彼此区别的，但在自然物中，形式因、动力因和目的因是合一的。比如做一个桌子，木料是质料因，桌子的形象是形式因，工匠的手艺是动力因，桌子的用途就是目的因。如果在自然界中也这样考虑四因，就需要引入一个类似工匠的外在的神，但亚里士多德不承认外在的神，动力和目的不能是世界之外的神提供的，所以就把动力因和目的因都归于形式因，形式因既是使质料成为事物的动力，同时又是质料要趋向的目的。在这个角度上，四因又可以归结为质料因和形式因这两个最基本的原因。</li><li>亚里士多德持一种生成论的思想，而不是机械论。他的父亲是医生，所以他在父亲的影响下倾向于把世界看做一个生命体。质料不是把事物分割成不可分的微粒，而是事物生长的起点，比如树的质料因是种子，而不是把树碾碎得到的粉末，树的形式因就是种子要长成的那个大树的形象，正是这个形式驱动着种子朝着目标不断发展(因为石头没有生命，所以石头的质料才是粉末)。这与目的论的区别就在于动力和目的是外部施加的力量，还是质料内部具有的内驱力。</li><li>任何实体都是质料与形式的统一，二者缺一不可，这就相当于把德谟克利特和柏拉图两派思想统一了起来。但亚里士多德又认为，形式因比质料因更重要。比如人的质料可以长成任何人的样子，但只有形式能让人长成特别的个体。形式代表一个实体的个别性，因而比具有无定形的普遍性的质料更是实体。形式才是使一个实体之成为“这一个”实体的东西，即作为本质的实体。</li><li>事物的形式与质料是相对的概念，对于低一级的事物是形式的东西，对于高一级的事物就成了质料。比如砖瓦既是泥土的形式又是房子的质料，房子既是砖瓦的形式又是街道的质料。这就成了一种辩证的观点，整个宇宙就变成一个从质料到形式交替上升的统一序列。但这个序列不是无限长的，无限的话就成了哲学家们讨厌的相对主义，所以一定存在一个最下端的不能作为形式的“纯质料”，以及一个最顶端的不能作为质料的“纯形式”，这是逻辑上的需要。在柏拉图的理论里，理念世界就是“纯形式”，原始物质就是“纯质料”，中间的部分就是感性世界，但亚里士多德的高明之处就在于把中间的部分解释成一个动态的、自底向上生长的序列关系，所以亚里士多德不需要引入神，因为这种向上生长的趋势就是动力与目的，而柏拉图只能提出神创世界。但是亚里士多德没有再继续解释形成这种生长关系的原因是什么，好像他觉得不需要解释，就像进化论没有解释为什么要进化一样。</li></ul><h3 id="实体是如何生成的-潜能与实现"><a href="#实体是如何生成的-潜能与实现" class="headerlink" title="实体是如何生成的(潜能与实现)"></a>实体是如何生成的(潜能与实现)</h3><ul><li>亚里士多德立足于目的论，提出了潜能与实现，其实就是上面的形式与质料对立统一的思想。任何事物都由质料和形式构成，形式看似是后于质料的结果，其实是先于质料的内在动机，当质料尚未获得该形式时，就叫做处于潜能状态，当获得该形式时，就叫做实现。潜能和实现是同一事物的两种不同的存在状态，实体的生成过程就是从潜能向实现的转化过程，这个转化过程就是运动。</li><li>潜能和实现也是相对的概念，比如人活的每一天都是相对于昨天更进一步的实现，同时又具有实现明天的状态的潜能，所以万事万物永远在运动。结合质料与形式的转化链，“纯质料”就是绝对潜能，“纯形式”就是绝对实现，二者之间的就是潜能与实现的不断转化。</li></ul><h3 id="认识论-1"><a href="#认识论-1" class="headerlink" title="认识论"></a>认识论</h3><ul><li>哲学的传统就是重理性轻感性，认为感官体验到的世界是不可靠的，但亚里士多德的认识论表现出一种折中与调和的特点。一方面，他表现出经验主义的倾向，承认感觉的重要性，我们对第一实体(个别事物)的认识只能从感觉开始，然后才能通过这种感觉经验上升我们的认识，这就不像之前的哲学家对感觉经验有明显的鄙视的态度。另一方面，他又表现出唯理主义的倾向，认为感觉只能感受事物的形式而不能把握其本质，他提出了“蜡块说”，把人的感性灵魂比作蜡块，事物在蜡块上只能留下形状的印记，所以我们的感觉只能认识到事物的表象，此外，通过感觉只能认识个别的事物，而不能把握一般性、普遍性的东西，因为普遍的东西是内在于理性灵魂之中的。</li><li>感觉是个别性知识的直接来源，而普遍性的知识内在于理性灵魂，感觉经验只是普遍知识的触媒，这就类似柏拉图的回忆说，回忆也是内在于灵魂的普遍性知识，需要在外界刺激下才能回忆起的。亚里士多德把理性灵魂分为两个部分：一部分是受到肉体遮蔽的消极被动的理性灵魂，它以外界事物为对象，建立在感觉、记忆和经验的基础之上，随着肉体的死亡而消失。另一部分是积极能动的理性灵魂，它摆脱了肉体束缚，只以自身为对象，只思维不涉及任何质料的“纯形式”，他不随肉体死亡而消失，而是以一种神秘的方式进入其他的肉体里，这一部分就类似柏拉图的理智和理性，都是真理，但是理智不能摆脱外在事物，而理性是彻底抽象的。亚里士多德还持有一种精英主义的观点，他认为积极能动的理性灵魂只存在于自由人身上，奴隶只有消极被动的理性灵魂。</li></ul><h3 id="逻辑学"><a href="#逻辑学" class="headerlink" title="逻辑学"></a>逻辑学</h3><ul><li>亚里士多德是形式逻辑的开创者，他创建了范畴表和谓词表。</li><li>谓词表是对谓词的分类。逻辑最重要的三个因素是概念、判断和推理，从判断的角度来说，一个判断句中的谓语比主语更重要，也就是“A是B”中的“B”判断性更强。所以他只对谓词做了分类，首先可以分为两大类，即属于定义的部分和不属于定义的部分，前者是对事物本质的规定，比如“桌子是木制品”，后者仅仅表示事物的某种性质，比如“桌子是圆的”或“人在动”。其次根据谓词所表述的内容又可以细分成五类，包括属、种差、定义、属性和偶性(有的地方把属和种反过来了，是翻译的问题，总之大的类是genus，小的类是species)，以人作主语为例子，“动物”是属，“有理性”是种差，“有理性的动物”是定义，这三类谓词是对本质的规定，属于定义的部分，“能学习语法”是属性，“白种人”是偶性，这两类谓词是关于性质的表述，不属于定义的部分。</li><li>范畴表是亚里士多德对客观存在进行归纳和抽象的基础上提出的十个范畴，分别是实体、数量、性质、关系、地点、时间、姿态、状态、动作和遭受，后来又增加了与事物变化相关的五个范畴，分别是对立、先于、同时、运动和所有。</li><li>在判断理论上，亚里士多德把判断分成了四类，包括“质”的判断、“量”的判断、“关系”的判断和“模态”判断。“质”的判断包括肯定判断和否定判断，也就是“是”和“不是”。“量”的判断包括全称判断和单称判断，也就是“所有…都…”、“某些…都…”和“某个…是…”。“关系”的判断包括简单判断和复合判断，复合判断就是多个判断构成的总的判断。“模态”判断即实然的、必然的和可能的判断。</li><li>亚里士多德在推理上的成就是制定了演绎三段论推理法则。从形式逻辑的角度可以把推理分成演绎推理和归纳推理，演绎推理是从一般到特殊，归纳推理是从特殊到一般。他针对三段论提出了4个格和24个式。都是逻辑学里的东西，略。</li><li>亚里士多德还提出了三段论演绎的三条公理，即同一律(真的判断永远为真)、矛盾律(互相矛盾的判断不能同时为真)和排中律(两个互相矛盾的命题之间不能有居中者)。</li><li>归纳是经验方法，演绎是纯逻辑推导方法，因为演绎法不能穷尽所有可能的情况，所以亚里士多德重演绎而轻归纳，导致他在自然科学方面有很多错误的观点，比如被伽利略证伪的铁球落地的结论。到了16、17世纪，近代实验科学和经验论之父弗朗西斯·培根开始注重归纳推理，他针对亚里士多德的《工具篇》写了《新工具》，强调经验归纳，反对单纯的演绎和证明。</li></ul><h3 id="伦理学"><a href="#伦理学" class="headerlink" title="伦理学"></a>伦理学</h3><ul><li>亚里士多德反对苏格拉底把美德等同于知识(即道德知识)的观点，他把美德分成了心智方面的知德和道德方面的行德。知德与道德知识有关，知识越多则心智上的美德越多，这种美德体现在人的理性沉思活动中，能从中获得悠闲自适且持久不变的愉悦，也就是有知识的人内心世界丰富，能自得其乐。行德与道德知识无关，亚里士多德对此提出“中庸”学说，把灵魂分成了激情、官能和性格状况三个部分，其中激情和官能谈不上美德，只有性格状况才存在美德和恶行的问题，道德上的美德就是以中庸之道对待激情。</li><li>中庸有以下特点：第一，中庸不是一个绝对的居间者，而是要具体情况具体判断。第二，中庸是与过度、不足这两端相对立的，因此它不是一个量的概念，而是性质上的概念。第三，中庸既与过度对立又与不足对立，所以可以理解成中庸就是“非两端”，因此中庸本身内部就不能再有过度和不足这种极端的概念。</li><li>基于中庸的观点，亚里士多德提出了他的政治观点，认为社会应该由不强不弱、不富不贫的中产阶级来统治。</li></ul><h1 id="5-古希腊哲学的第三-衰颓-阶段"><a href="#5-古希腊哲学的第三-衰颓-阶段" class="headerlink" title="5 古希腊哲学的第三(衰颓)阶段"></a>5 古希腊哲学的第三(衰颓)阶段</h1><ul><li>亚亚里士多德之后，古希腊城邦时代被亚历山大终结，建立了亚历山大帝国，开创了希腊化时代，希腊化是指希腊文化随着亚历山大帝国的扩张影响到埃及、西亚等地的文化。而后大帝国分裂成马其顿王国、托勒密王国和塞琉西王国。在城邦的时代，公民是自己的主人，城邦兴衰匹夫有责，所以人们关心国家、宇宙这种宏大主题，当帝国把自由的公民变成了臣民，表面上是空前的繁荣，实际上也是公民地位的丧失，国家和人民的命运基本掌握在强权的手中，人们对社会逐渐失望，没有了思考形而上的动力，变得只关心个人的安身立命，注重肉体的享乐。哲学堕落成伦理学，由引导人们追求真理的火炬变成了跟在生存斗争后面收拾病弱伤残的救护车。</li><li>这个时期的三大学派的特点是，对世界不感兴趣，在一个没有希望的世界里追问人如何活得幸福。这种消极的哲学而后导致了基督教哲学的出现，既然在这个世界了无希望，人们就把眼光投入到另一个世界(天国)。三大学派在某种意义上也算是后现代主义，对前人的宏大的哲学体系进行解构，像智者派一样认为本原、形而上之类的问题都不重要，一切都是因人而异的，人的感觉才最重要。</li></ul><h2 id="5-1-伊壁鸠鲁学派"><a href="#5-1-伊壁鸠鲁学派" class="headerlink" title="5.1 伊壁鸠鲁学派"></a>5.1 伊壁鸠鲁学派</h2><ul><li>伊壁鸠鲁认为哲学的目的是“寻求生活宁静之道”，哲学就是通过论辩和讨论的方式来获得幸福的一种活动。他把人们心灵不得宁静的原因归结为三点，一是自然灾害，二是对死亡的恐惧，三是人际矛盾与冲突。针对这三点，伊壁鸠鲁分别提出了原子论的宇宙观、感觉主义的认识论，以及快乐论的伦理学。</li><li>伊壁鸠鲁继承和发扬了德谟克利特的原子论，德谟克利特认为原子有形状、次序、位置等差异，伊壁鸠鲁认为原子还有重量上的区别。原子运动的原因有二，一是自身重量使原子在虚空中垂直下落，二是下落过程中产生偏斜导致原子相互碰撞，碰撞形成旋涡运动，从而构成万事万物。伊壁鸠鲁把这种偏斜的原因归结为偶然性，这就突破了德谟克利特强调原子运动必然性所导致的宿命论观点，马克思在博士论文中指出原子的偏斜运动体现了个体的能动性和自由意志。</li><li>伊壁鸠鲁认为宇宙间存在着许多彼此相似的世界，神存在于世界之间的缝隙中，它微不足道，并不能影响世界。自然灾害是原子运动导致的纯自然现象，因此不值得恐惧，也没必要谈神论鬼。</li><li>伊壁鸠鲁在认识论上倡导感觉主义，主张永远要以感觉以及感触作根据。感觉具有真理性，因此感觉本身是不会错的，错误只能源于理性对感觉的误判。</li><li>伊壁鸠鲁认为灵魂也是原子构成的，灵魂的主要功能就是感觉。人死后，构成灵魂的原子就消散了，也就丧失了感觉的能力。因此死亡不值得恐惧，生前感觉不到死亡的痛苦，死后也不能感觉到痛苦。(但是从生到死的过程是痛苦的呀！)</li><li>伊壁鸠鲁在伦理学上倡导快乐论。他认为社会是通过社会契约构成的，人们应该通过法律或契约尽可能维护这个社会，实在维护不了至少可以洁身自好、独善其身。伊壁鸠鲁的快乐主义又叫享乐主义，他所追求的快乐是肉体上的淡泊和精神上的安宁。然而，当西塞罗把哲学传到罗马时，推崇斯多葛学派，贬低伊壁鸠鲁学派，误导人们把快乐主义理解成了纵欲主义，败坏了伊壁鸠鲁的名声。</li><li>后人把伊壁鸠鲁的伦理学概括为医治心灵的四药方，即神不足惧、死不足忧、乐于行善、安于忍恶。秉持着这种宁静淡泊的生活态度，人际矛盾与冲突自然就不成问题了，这其实有点消极避世的态度。</li></ul><h2 id="5-2-斯多葛学派"><a href="#5-2-斯多葛学派" class="headerlink" title="5.2 斯多葛学派"></a>5.2 斯多葛学派</h2><ul><li>后人把伊壁鸠鲁学派理解成纵欲主义，与之相对的是代表禁欲主义的斯多葛学派。伦理学自此分成两派，伊壁鸠鲁主义认为幸福是快乐，斯多葛主义认为幸福是美德，道德主义自然就是禁欲的，而快乐主义也容易被理解成纵欲。</li><li>斯多葛学派的创始人是芝诺(不是之前那个芝诺)，他受到赫拉克利特、苏格拉底、犬儒等学派的影响，融会贯通形成了斯多葛学派。斯多葛学派分早期和晚期，早期是希腊化时代，晚期是罗马时代，哲学思想越到后期越表现得阴郁、悲观。</li><li>早期的斯多葛主义思想体现在自然哲学和伦理学。</li><li>早期的斯多葛主义把赫拉克利特的火和逻格斯加以神秘化，认为火是有灵魂的东西或能思想的火气，逻格斯是神圣的火的理性，即世界理性。人就是一副承载着灵魂的尸体，灵魂是人之为人的根本，这个灵魂作为理性灵魂其实是世界理性的一点火花。人人都是世界理性的火花，所以他们主张天下大同、人人平等、四海之内皆兄弟，这与当时的奴隶主义相背。</li><li>早期的斯多葛主义把苏格拉底的思想和逻格斯结合，提出了决定论色彩的伦理学，认为一切都是注定的、不可更改的，所以我们在命运面前只能逆来顺受。他们认为善就是顺应逻格斯，他们理解的自由不是随心所欲，而是认识并服从世界的必然性，这种自由观和后世斯宾诺莎的观点相近，斯宾诺莎也认为自由是对自然规律和社会规律的认识和服从。到了后期，斯多葛主义把这种思想总结为“顺应自然，服从命运”。</li><li>罗马共和国时期，西塞罗把斯多葛主义和柏拉图主义传到罗马，斯多葛主义成了罗马的主流哲学，相对立的伊壁鸠鲁主义就成了罗马人鄙视的对象。所以罗马时期的哲学家大多是斯多葛主义。</li><li>晚期的斯多葛学派目睹了罗马帝国的暴戾恣睢，采取了一种越来越偏激的禁欲主义姿态。晚期斯多葛主义代表人物有塞涅卡、爱比克泰德和马可·奥勒留。</li><li>塞涅卡是罗马大臣，也是暴君尼禄的老师。他明确提出了“顺应自然，服从命运”，主张面对一切欲望和激情的骚扰采取“不动心”的态度。但他本人没有践行禁欲主义，反而聚敛钱财享尽荣华，最终被尼禄嫉妒而赐死。</li><li>爱比克泰德是奴隶，因为才华出众被主人释放。奴隶的经历让它产生一种宿命论的观点，认为我们要服从命运，对苦难逆来顺受。他认为引起人们恐惧的不是灾难本身，而是人们对灾难的态度，如果面对灾难泰然处之，就不会感到痛苦了。宗教强大的改造力就在于让人面对苦难不畏惧，相信有上帝在保佑自己。(作为奴隶，能改变的也只有心态了)</li><li>马可·奥勒留是罗马帝国一位热爱哲学的帝王，著有《沉思录》。虽然地位极高，但是态度比前人更加阴郁和悲观，感慨人的渺小和命运的不可违(sb)。</li><li>斯多葛学派悲观透顶，最终成为基督教神学的重要思想来源，因为悲观的人渴望得到上帝的拯救。</li></ul><h2 id="5-3-怀疑主义"><a href="#5-3-怀疑主义" class="headerlink" title="5.3 怀疑主义"></a>5.3 怀疑主义</h2><ul><li>怀疑主义不像其他两派有自己独断的主张，他们认为导致心灵纷扰的根本原因在于人们在认识方面的独断论态度，因此他们保持中立，对一切观点采取怀疑的态度，不发表自己的意见和判断。正因为不做判断，所以怀疑主义者始终彷徨，这也是一种悲观。</li><li>早期怀疑主义创始人是皮浪，他的基本思想就是不做任何决定、悬置判断。他认为人不幸福的根源就是喜欢自以为是地下判断、妄作主张。“万物一致而不可分别”，我们把握不了任何事物。(认真你就输了？)</li><li>晚期怀疑主义者主要有埃奈西徳谟、阿格里帕和塞克斯都·恩披里克。他们把早期的怀疑主义思想进一步深化，并把怀疑的对象从感觉转向了理性本身。埃奈西徳谟在皮浪悬置判断的基础上提出了怀疑感觉可靠性的十个“老论式”，大概意思就是不同的人、不同的条件下产生的感觉不同。塞克斯都·恩披里克提出了怀疑理性可靠性的五个“新论式”，大概意思就是哲学家的分歧说明世界是不可知的，所谓的理论只能是建立在假设和断言上，所以理性也是不可靠的。总之，感觉和理性都不可靠(他们眼里只有绝对的可靠，否认了相对可靠性)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="网课笔记" scheme="http://shivakasu.github.io/categories/%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="哲学" scheme="http://shivakasu.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《社会心理学》(更新中)</title>
    <link href="http://shivakasu.github.io/2020/02/03/psy1/"/>
    <id>http://shivakasu.github.io/2020/02/03/psy1/</id>
    <published>2020-02-02T17:40:20.000Z</published>
    <updated>2020-02-18T10:56:56.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Part-1：社会思维"><a href="#Part-1：社会思维" class="headerlink" title="Part 1：社会思维"></a>Part 1：社会思维</h1><h2 id="chapter-1：-社会心理学导论"><a href="#chapter-1：-社会心理学导论" class="headerlink" title="chapter 1： 社会心理学导论"></a>chapter 1： 社会心理学导论</h2><ul><li>社会心理学是一门研究人们如何看待他人、如何互相影响，以及如何与他人互相关联的科学，是心理学和社会学的一门交叉学科</li><li>社会心理学关注的核心问题：<ul><li>我们如何构建我们的世界。</li><li>我们的社会直觉如何指引或误导我们。</li><li>我们的社会行为如何受他人、我们自己的态度和性格以及生物性的影响</li><li>社会心理学原理如何应用于日常生活和研究领域。</li></ul></li><li>社会心理学的结论看似是显而易见的，是因为人们的认知往往有后见之明偏差，也就是如果之前有过与该结论相似或相关的模糊体验，会误以为自己已经知道了这个结论。</li></ul><h2 id="chapter-2：-社会中的自我"><a href="#chapter-2：-社会中的自我" class="headerlink" title="chapter 2： 社会中的自我"></a>chapter 2： 社会中的自我</h2><ul><li>焦点效应(spotlight effect)是指人们往往会把自己看做一切的中心，并且直觉地高估别人对我们的关注程度。透明度错觉(illusion of transparency)是指人们高估自己的个人心理状态被他人知晓的程度。这种现象表明了自我感觉与社会、他人是相互影响的。</li><li>自我图式(self-schemas)是自我概念构成要素以及定义自我的那些特殊信念，图式是指我们组织自己所处世界的心理模板。可能自我是指想象中的自我。</li><li>自我效能理论是指对自己能力与效率的乐观信念可以获得很大的回报，也就是乐观自信的人勇于面对逆境，更容易成功。</li><li>自尊是对自我价值的整体认识，影响我们如何评价自己的特点和能力。一种观点认为自尊是一种内驱力，指导我们通过行动来发展自我，寻求社会接纳和认同。另一种观点认为自尊的动机不仅是社会认同，也是为了追求生命的意义，来克服人必将死亡这一事实所带来的恐惧。</li><li>自我服务偏差包括自我服务归因(功劳都是自己的)、自我恭维比较(自己比别人优秀)、盲目乐观、虚假普遍性、虚假独特性。<ul><li>自我服务归因是指把好的结果归因于自己，而把坏的结果归因于他人，自我服务归因能激活与奖赏和愉悦相关的脑区。主观行为维度如(自律性)比客观行为维度(如守时性)更容易引发自我服务偏差，也就是越不依赖于客观基础，人就越容易盲目自信。</li><li>悲观主义的人容易遭受挫折，乐观主义的人更能增强自我效能感、促进健康和幸福感，防御性悲观主义(如居安思危)则可以避免盲目乐观。</li><li>虚假普遍性效应是指我们过高地估计别人对我们观点的赞成度以支持自己的立场，也就是高估自己想法的普遍性。虚假独特性效应是指我们把自己的才智和品德看成超乎寻常的以完善自己的自我形象，也就是高估自己能力的独特性。</li></ul></li><li>自我服务偏差可以帮助我们避免抑郁、缓解压力，但高估自己也让我们容易责怪别人和欲求不满。</li><li>人们有时会自我挫败和自我妨碍，这是出于对失败的恐惧，人们主动制造外因来避免自己在失败后自责，比如大考之前玩游戏，如果考砸了就可以归因于游戏而不是自己笨。</li><li>自我表露是指我们想要向外在的观众(别人)和内在的观众(自己)展现一种受赞许的形象，因为我们总是渴望被社会接纳。</li></ul><h2 id="chapter-3：-社会信念和判断"><a href="#chapter-3：-社会信念和判断" class="headerlink" title="chapter 3： 社会信念和判断"></a>chapter 3： 社会信念和判断</h2><ul><li>人的记忆系统是一个相互联结的网络，启动(priming)是指唤醒或者激活其中的某些特定联结。人们之所以无法客观、如实地对现实进行反应，就是因为现实的刺激容易诱发启动效应，使人们无意识地根据自己的信念和回忆有倾向性地解释现实。</li><li>信念固着(belief perseverance)现象是指人们一旦对某项事物建立了某种信念，尤其是为它建立了一个理论支持体系，那么就很难打破人们的这一看法，即使是相反的证据与信息出现时他们也往往视而不见。纠正信念固着的唯一方法是解释相反的观点，也就是换位思考。</li><li>启动效应说明事前的经验会影响人们对现实的认知，信念固着说明事后的判断也会影响对现实的认知。</li><li>人的记忆系统不能完美地存储过去的事实，我们的记忆是在回忆的过程中重构的，重构会受到主观情感、态度的影响，可能会把误导性信息整合到记忆中。</li><li>人的思维包括受控制加工和自动化加工两部分，直觉是自动化思维，受到图式、情绪反应、专业知识、无意识思维等的影响。</li><li>过度自信(overconfidence)是指人们在解释自己的经历和构建记忆时，有时会忽略记忆中的错误，一方面是因为人们倾向于把过去模糊的错误判断回忆成正确的，另一方面是因为有验证性误差，也就是人们更愿意寻找证据证明自己的直觉，而不是去证伪。纠正过度自信也是要从这两方面入手。</li><li>启发式判断(heuristics)是一种简单高效的思维策略，人们为了减少信息加工的时间，会根据以往的经验形成印象、做出决定和生成解释，但可能产生错误。<ul><li>代表性启发式判断是指对某个事物进行评价时，根据其与过去经验的相似程度来进行判断或预测，也就是基于相似性来预测可能性。比如我们认为鬼鬼祟祟的人更可能是坏人。</li><li>易得性启发式判断是指根据客体或事件在知觉或记忆中的可得性程度来进行判断或预测，也就是基于可得性来预测可能性，越容易回想起来的事情越有可能是真的。比如我们认为以k开头的单词比第三个字母是k的单词更多，</li></ul></li><li>反事实思维(counterfactual thinking)是指否定过去发生的事实，对可能的结果进行心理模拟。比如常见的“如果当初…就好了”和“幸亏…了”两种心理。反事实思维和情绪相关，事件本身越重要，反事实思维的强度越大。</li><li>错觉相关(illusory of correlation)是指当我们发现某种重要的联系时，很容易将各随机事件联系起来。控制错觉(illusion of control)是指认为各种随机事件受我们的影响，比如赌博时相信自己的手气。</li><li>归因理论(attribution theory)描述了我们怎样来解释人们的行为，包括内部原因和外部原因。归因理论先驱哈罗德·凯利提出了归因的三要素：<ul><li>一致性：个体在这种情境下出现类似行为的一致性。高一致性倾向于因果关系，低一致性倾向于偶然关系。</li><li>区别性：个体的这种行为是否具体对应于该特定情境。高区别性倾向于外因，低区别性倾向于内因。</li><li>共同反应：其他人在这种情境下出现类似行为的可能性如何。高共同反应倾向于外因，低共同反应倾向于内因。</li></ul></li><li>基本归因错误(fundamental attribution error)是指个体在归因时低估情境因素的作用，比如我们看到人摔倒会觉得他笨拙而不是去考虑路好不好走。情境因素也包括社会约束，比如拥有社会权力的人往往会导致人们高估他们的知识和智力水平，就像学生高估老师的智商。基本归因错误的原因一方面是人们注意力的习惯，当作为观察者时更注重活动的人而忽视环境，另一方面也受文化环境的影响，东西方文化对于环境作用的重视程度有差异。</li><li>自我实现预言是指信念能够导向自我实现，也就是我们的社会信念会引导我们以证实自己的方式去行动。社会期望可以表现成自我实现预言，当我们对某件事的结果有所期待时，自己的行为就可能无意识地受到影响。</li><li>人的理性是有局限的，我们无法避免社会思维中的错误，但是可以训练自己对思维错误的敏感度。</li></ul><h2 id="chapter-4：-态度和行为"><a href="#chapter-4：-态度和行为" class="headerlink" title="chapter 4： 态度和行为"></a>chapter 4： 态度和行为</h2><ul><li>态度(attitude)是个体对人或事物的积极或消极的评价性反应，通常根植于个体的信念，表现于个体的感受或者行为倾向中。态度ABC理论的三个维度是：情感(affect)、行为倾向(behavior tendency)和认知(cognition)。</li><li>很难通过态度预测行为是因为二者之外还有其他的影响因素。三种情况下态度可以较好地预测行为：<ul><li>把其他因素的影响最小化，比如大数据去噪声。</li><li>态度与行为紧密相关，比如根据爱不爱吃肉预测会不会吃肉，简单粗暴。</li><li>态度是强有力的，比如洗脑洗出的态度。</li></ul></li><li>每个人都在扮演特定的社会角色，这个社会对社会角色的规定行为影响了人们的态度。</li><li>人们的言语行为会以加深信念的方式影响态度。</li><li>登门槛现象是指先请人帮一个小忙再请他帮个大忙，会比直接请他帮个大忙成功率高，说明对小行为的承诺可以让人们更愿意做更大的事。</li><li>目前有三种理论解释为什么行为能影响态度：<ul><li>自我表露理论：我们表现出与自己行为一致的态度，是为了不让自己看起来自我矛盾。</li><li>认知失调(自我辩解)理论：行为和态度矛盾会给人压力，所以我们会努力说服自己改变态度，或者无意识地忽略掉让自己矛盾的信息。</li><li>自我知觉理论：当我们摇摆不定或态度不明确时，会站在局外人的角度观察自己的行为，来坚定自己的信念。登门槛现象就可以解释成在决定帮不帮大忙的时候，帮个小忙可以加强信念，以为自己很热心助人。衍生出的一个结论是过度合理化效应，付给人们报酬让他们做自己喜欢的事，能将他们的这种乐事变成苦差，因为得到报酬的行为会让自己觉得做事是因为有报酬而不是因为喜欢。</li></ul></li><li>自我表露理论仅仅解释了行为怎样影响表面态度。认知失调理论和自我知觉理论解释了行为怎样影响真实态度，一个是让态度迁就行为，一个是让行为坚定态度，两者同时起作用。当行为与态度明显冲突时更倾向于自我辩解，当态度模糊不定时更倾向于自我知觉。</li></ul><h1 id="Part-2：社会影响"><a href="#Part-2：社会影响" class="headerlink" title="Part 2：社会影响"></a>Part 2：社会影响</h1><h2 id="chapter-5：-基因、文化与性别"><a href="#chapter-5：-基因、文化与性别" class="headerlink" title="chapter 5： 基因、文化与性别"></a>chapter 5： 基因、文化与性别</h2><ul><li>人的共性体现在生物相似性，人们由相同的祖先进化而来，为了适应环境进化出相似的生理和心理偏好。进化心理学基于达尔文的进化论，研究自然选择如何影响人们有利于适应环境的生理特征、心理特征和社会行为。</li><li>人类进化出了学习能力和创造力，所以能超越生理基础的限制形成不同的文化环境。不同文化环境的社会规范既有差异性也有相似性(文化交流的结果？)。</li><li>女性解读他人情绪的能力更强，女性更擅长以非言语的方式表达情绪。男性更容易表现出社会支配性和攻击性，更渴望性行为。但都是实验结果，没有理论解释。</li><li>演化学家根据人类演化历程推理两性差异的原因。但批评者认为根据结果推理出解释属于倒推的机能主义，事后推测高估了事实的重要性，应该从不同角度看问题，考虑到没有发生的各种发展情况，况且并没有实际证据证明演化学家的推测。</li><li>生理因素和文化因素是相辅相成的，基因是心理活动和社会活动的基础，文化环境中的社会规范又能强化基因导致的外显差异。</li><li>这一章相当空洞，生理学家领域新研究难所以没结论，社会学家有实验结论但相对浅显。和初中课本的知识量差不多~</li></ul><h2 id="chapter-6：-从众和服众"><a href="#chapter-6：-从众和服众" class="headerlink" title="chapter 6： 从众和服众"></a>chapter 6： 从众和服众</h2><ul><li>从众(conformity)是指根据他人而做出的行为或信念的改变，有三种形式：<ul><li>顺从(compliance)：由外部力量施压而违心的从众行为，比如礼仪。</li><li>服从(obedience)：由明确命令引起的从众行为，属于顺从的一种，比如军队。</li><li>接纳(acceptance)：发自内心真诚的从众行为，比如洗脑。</li></ul></li><li>影响从众的因素。<ul><li>群体规模：抱团的人越多，越不敢有异议。</li><li>一致性：越没有其他人提出异议，自己就越不敢有异议。</li><li>凝聚力：群体凝聚力越强，越不敢有异议。</li><li>地位：群体成员地位越强，越不敢有异议。</li><li>公开反应：越是公共场合，越不敢表现出不合群。</li><li>事前承诺：当先前有过公开承诺或决定时，就不容易反悔。</li></ul></li><li>影响个体从众的原因。<ul><li>规范影响：个体倾向于获得群体的接纳或免遭拒绝，因为偏离群体要付出情感代价(压力、痛苦)。</li><li>信息影响：当自己态度不坚定、不确定时倾向于从众，把他人视作指导行为的信息来源，因为经验告诉我们多数人的选项往往是对的。</li></ul></li><li>对社会形象的关注容易产生规范影响，希望自己行事正确容易产生信息影响。</li><li>逆反(reactance)理论指出，企图限制个体的自由会引起事与愿违的反从众行为，也就是从众的不自由感超过了不从众的压力。</li></ul><h2 id="chapter-7：-说服"><a href="#chapter-7：-说服" class="headerlink" title="chapter 7： 说服"></a>chapter 7： 说服</h2><ul><li>说服的两种路径。<ul><li>中心路径说服：当人们积极主动，全面系统地思考问题时，就可能接受中心路径说服，也就是论据有力而令人信服，结果是人们态度的变化相对持久，甚至影响行为。比如学校的教育。</li><li>当人们不仔细思考，没时间仔细推敲信息的意义时，就可能接受外周路径说服，也就是关注那些能令人不假思索就接受的外部线索，而不关注论据，结果是只能导致肤浅而短暂的态度转变。比如拼多多的洗脑广告。</li></ul></li><li>说服的四要素：说服者，说服内容，说服渠道，说服对象。</li><li>说服者可信度越高，说服力越强，可信度体现在地位的权威性，比如中央发布的信息，也体现在表面上的可靠性，比如说话看起来有自信、没有顾虑等。</li><li>说服者的吸引力越高，说服力越强，比如舔狗相信女神的话。</li><li>说服信息使人心情愉快，则说服力更强。说服信息能引起人的消极情绪反应，则说服力更强，比如用烟鬼的肺宣传禁烟。</li><li>说服信息与说服对象已有观念的差异对说服效果的影响，取决于说服者的可信度。可信度越高，大差异观点的说服力越强。比如医生容易说服人严格戒烟，但是少抽烟的建议往往容易被忽视，而家人完全相反，少抽烟的建议往往更有效。</li><li>如果说服对象已经有了赞成的观点，那么相同观点的说服信息更有效。如果说服对象心思缜密或立场不确定，那么包含正反两方面的说服信息更有效。</li><li>首因效应是指最先呈现的信息更有说服力，也就是先发制人的看起来更强势。首因效应的影响随时间递减，同时产生近因效应，也就是后面呈现的信息更有说服力。</li><li>如果信息简单，面对面说服更有效，如果信息复杂，书面表达说服力更强。</li><li>年轻人比老人更容易说服。</li><li>邪教洗脑原理。<ul><li>登门槛效应：先让新成员承诺参加小活动，再循循善诱，逐渐提出更过分的要求，让新成员不忍拒绝。</li><li>说服者有人格魅力，容易让人轻信。</li><li>说服信息不断渲染温暖、救赎。</li><li>说服对象基本都是年轻人，三观还在形成中，态度不坚定，容易动摇。</li><li>把成员封闭在群体中，加强成员对群体的认同感和依赖感。</li></ul></li></ul><h2 id="chapter-8：-群体影响"><a href="#chapter-8：-群体影响" class="headerlink" title="chapter 8： 群体影响"></a>chapter 8： 群体影响</h2><ul><li>群体(group)是两个或更多的人在较长时间里进行互动，并以某种方式相互影响，将他们自己视为“我们”。</li><li>群体的社会助长作用是指他人在场能提高某些任务的准确性，社会阻抑作用是指他人在场能降低某些任务的准确性。扎荣茨把这两个相反的理论综合了起来：他人在场会引起唤醒状态，而唤醒状态能增强任何优势反应的趋势，优势反应是指学习得相当熟练能够不假思索做的的反应。在简单任务中，优势反应往往就是正确答案，比如不需要动脑的体力劳动，唤醒促进了优势反应，所以效率得到了提高。在复杂任务中，优势反应往往不是正确答案，比如解数学题，唤醒促进了优势反应，使得我们倾向于用直觉解题而不是深入思考，所以降低了效率。</li><li>置身于拥挤的人群同样会引起唤醒和促进优势反应。</li><li>唤醒的本质是减少脑力思考，更多地依赖本能反应。他人在场引起唤醒的原因就是让我们不得不减少精力思考的原因，主要有三个：<ul><li>评价顾忌：不管是否与他人交流，只要知道有观察者在场，我们就会想要知道别人怎么评价我们，引发我们的自我关注。</li><li>分心：在群体中我们会考虑别人的反应，这种注意他人和注意任务之间的冲突，会使认知系统负荷过重。</li><li>纯粹在场：即使不考虑评价顾忌和分心，仅仅是他人纯粹在场的状态也能一定程度地引发唤醒。</li></ul></li><li>群体的社会懈怠是指成员在集体任务中会减少自己的努力程度，主要原因是受到搭便车的诱惑。当自己成为群体的焦点时会提高评价顾忌，比如演讲，所以会引发社会助长作用。而当自己只是集体活动平凡的一部分时就会减少评价顾忌，比如拔河，所以会引发社会懈怠。</li><li>减少社会懈怠的方法是让个体作业成绩可识别，虽然每个个体都不是群体的焦点，但工作结果是可以被别人看到的，就会提高评价顾忌。此外，当工作目标本身具有吸引力时也能减少社会懈怠，比如比赛胜利有奖金，团队的每个人都会努力想得到奖金。</li><li>去个体化(deindividuation)是指在群体中成员抛弃道德约束、忘却个人身份而顺从于群体规范。这是因为社会助长和社会懈怠同时起作用，成员既被引发了唤醒而降低思考力，又降低了评价顾忌和分散了责任，导致成员隐蔽在群体中体验到匿名感和无自我感，结果是引发群体失控，比如摇滚音乐会上的群体发狂叫喊，又比如网络暴力。</li><li>群体极化又称“风险转移”，是指群体决策往往比个人决策更冒险，比如有人陪同时更可能鲁莽驾车。因为群体讨论能够加强群体原先的主导观点，无论是激进的观点还是保守的观点，比如大屠杀就是成员相互怂恿的极化结果。</li><li>群体极化的原因有两方面已经被证实：<ul><li>信息影响：群体讨论产生的大多数观点都和主导观点一致，在讨论中主导观点通过言语重复容易使成员转变态度。</li><li>规范影响：个体倾向于认为自己的意见更好更合理，在群体讨论中人们会通过社会比较发现自己其实并没有很出众，于是纷纷省悟，主动向群体主导观点靠拢。</li></ul></li><li>群体思维(groupthink)是指在群体决策中人们为了维护群体和睦而压制异议。症状表现有：<ul><li>无懈可击的错觉：成员过分自信，看不到群体的漏洞或弱点。</li><li>群体道义毋庸置疑：成员接受群体的内在道义，忽视了伦理和道德问题。</li><li>合理化：以集体投票的方式将决策合理化来减少挑战。</li><li>对对手的刻板印象：成员以为自己的群体很强大，低估对手实力。</li><li>从众压力：对群体中提出异议的人施加压力。</li><li>自我审查：成员为了维护群体一致性而抑制自我审查。</li><li>一致同意的错觉：都不敢提出异议，容易形成表面上的一致同意。</li><li>心理防御：成员保护群体不受质疑。</li></ul></li><li>预防群体思维的方法就是鼓励群体成员积极思考、交流观点、畅所欲言，更开放、全面地做决策。避免了群体思维的结果就是群体的问题解决，往往比个体决策更正确。因为群体内部的头脑风暴能产生更多观点，不同观点的碰撞可以消除认知偏见，从而产生更多的好点子。</li><li>立场坚定的少数派可以动摇多数派的态度，少数派的存在打破了群体的一致同意错觉，迫使多数派重新审视自己的观点，即使少数派的观点没有被采纳，整个群体的最终决策也会更优。</li></ul><h1 id="Part-3：社会关系"><a href="#Part-3：社会关系" class="headerlink" title="Part 3：社会关系"></a>Part 3：社会关系</h1><h2 id="chapter-9：-偏见"><a href="#chapter-9：-偏见" class="headerlink" title="chapter 9： 偏见"></a>chapter 9： 偏见</h2><ul><li>偏见(prejudice)的本质是对一个群体及其成员负面的预先判断。偏见的标志是负面评价，负面评价来自于刻板印象。刻板印象是一种概括性的看法，当过度概括或明显不对时，就会引发负面评价。</li><li>偏见证明了我们有双重态度系统，即我们对同一个目标可以同时拥有完全不同的外显态度和内隐态度。所以偏见也分为公开的、有意识的外显偏见和微妙的、无意识地内隐偏见。现代社会中内隐偏见比外显偏见涉及面更广。</li><li>偏见起源于不平等的社会经济地位以及其他社会原因，包括我们习得的价值观和态度。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="心理学" scheme="http://shivakasu.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《心理学与生活》</title>
    <link href="http://shivakasu.github.io/2020/01/29/psy0/"/>
    <id>http://shivakasu.github.io/2020/01/29/psy0/</id>
    <published>2020-01-29T08:46:20.000Z</published>
    <updated>2020-02-18T10:56:50.146Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-生活中的心理学"><a href="#1-生活中的心理学" class="headerlink" title="1 生活中的心理学"></a>1 生活中的心理学</h1><ul><li>心理学(psychology)是关于个体的行为及心智过程的科学研究。心理学的目标是观察、解释、预测和控制行为。观察的核心是客观性，解释的核心是想象力，预测的核心是精确可检验，预测和控制都是对解释的证明。</li><li>研究方法的争论：结构主义(structuralism)认为人类所有心理经验都可以作为基本成分的组合来理解，通过分析组成个体心理生活的感受及其他经验的构成元素，进而揭示人类心理的基础结构。机能主义(functionalism)认为意识是流动的，心理的特征是与环境持续进行相互作用，重要的是心理过程的行为和机能，而不是心理的内容。结构主义研究心理内容是什么，强调科学方法、精确测量以及数据统计分析，机能主义研究行为的目的和原因，强调创造性的解释而不是科学实验方法。</li><li>心理学家的观点决定了他们研究行为和心理过程的方式，书中介绍了七种观点，但是心理学家往往不会局限在单个观点上。<ul><li>心理动力学观点(psychodynamic perspective)：又称精神动力学或精神分析学，认为行为是由强大的内部力量驱使或激发的。人的行为是从先天的本能和生物驱动中产生的，而且试图解决个人需要和社会要求之间的冲突。代表人物弗洛伊德。</li><li>行为主义观点(behaviorist perspective)：寻求理解特定环境刺激如何控制特定类型的行为，研究重点是行为而不是意识。研究方法就是先改变环境再观察行为变化，使用严格的实验和定义变量，而不使用内省法。代表人物约翰·华生、B.F.斯金纳。</li><li>人本主义观点(humanistic perspective)：强调人的能动性以及人自身的发展，在人的认命历程中寻找行为模式。代表人物卡尔·罗杰斯、亚伯拉罕·马斯洛。</li><li>认知观点(cognitive perspective)：研究人的思维以及所有的认识过程，将思维同时视为外在行为的原因和结果，个体不是对物质的客观世界做出反应，而是对个体思维和想象的内在世界的主观现实做出反应。代表人物诺姆·乔姆斯基、让·皮亚杰。</li><li>生物学观点(biological perspective)：在基因、大脑、神经系统以及内分泌系统中寻找行为的原因，认为心理现象与社会现象能够最终依据生物化学过程加以解释。</li><li>进化论观点(evolutionary perspective)：结合了当代心理学与进化论，试图用进化的观点对人的心理的起源和本质以及一些社会现象进行深入的探讨和研究。</li><li>社会文化观点(sociocultural perspective)：研究行为的原因和结果中的跨文化差异，强调文化因素对心理学观点普遍性的影响。</li></ul></li></ul><h1 id="2-心理学的研究方法"><a href="#2-心理学的研究方法" class="headerlink" title="2 心理学的研究方法"></a>2 心理学的研究方法</h1><ul><li>观察者偏见(observer bias)是由于观察者个人的动机和预期导致的错误，减小观察者偏见的方法是标准化。对概念含义进行标准化的策略称为操作化，操作性定义是根据可观察、可测量、可操作的特征来界定变量含义的方法。</li><li>实验法要求操纵自变量观察因变量，但实验者会不自觉得引入混淆变量。有两种几乎存在于所有实验中的混淆变量(confounding variable)，一种是期望效应(expectancy effects)，实验者对实验对象的阐述包含了他对实验结果的预期，这种预期影响了实验对象的行为，另一种是安慰剂效应(placebo effects)，实验环境使实验对象对结果产生了某种预期，影响了实验对象的行为。</li><li>实验者消除混淆的策略称为控制程序，是使所有变量和条件保持恒定的方法。一种方法是双盲控制(double-blind control)，使实验助手和参与者都不知道哪些参与者接受了哪种处理。一种方法是安慰剂控制(placebo control)，引入无效的实验条件做对比实验，来解释安慰剂效应对实验的影响。</li><li>实验法的缺陷：人为实验环境与真实自然环境有区别，参与者往往知道自己在参与试验，某些研究问题受到伦理约束而不可能实施。</li><li>要确定两个变量、特质或者属性之间的关联程度时，需要基于相关法，计算两者的相关系数，判断是正相关、负相关还是不相关。</li><li>心理测量的目标是产生可靠而又有效的发现。信度(reliability)是指心理测验或实验研究得到的行为数据具有一致性或可靠性，效度(validity)是指研究或测验得到的信息准确地测量了研究者想要测量的心理变量或品质。书中介绍了两种数据收集的方法：<ul><li>针对参与者内部的心理状态和不适合现场观察的外部行为，采用自我报告法(self-report measures)收集数据，让参与者言语回答研究者提出的问题，自我报告包括问卷法和访谈法。自我报告法的缺陷有：不适合语言理解能力差的人，人们可能受社会期望的影响给出虚假的答案，访谈的情境会产生个人偏见和成见。</li><li>行为测量(behavioral measures)是研究外显行为和可观察、可记录的反应的方法。自然观察是在不改变或不干预自然环境的条件下观察自然情境下发生的行为。对于不方便观察或收集的行为，可以查询档案数据。</li></ul></li></ul><h1 id="3-行为的生物学和进化基础"><a href="#3-行为的生物学和进化基础" class="headerlink" title="3 行为的生物学和进化基础"></a>3 行为的生物学和进化基础</h1><ul><li>为了分离环境和基因的作用，研究者经常使用收养研究和双生子研究。前者评估儿童与其亲生父母以及养父母之间的相似性，后者比较同卵双生子和异卵双生子在特定性状或行为上的相似性。</li><li>感觉神经元携带来自感受器细胞的信息向内传至中枢神经系统，运动神经元携带来自中枢神经系统的信息向外传至肌肉和腺体，其他的都叫中间神经元。大脑的神经元网络之间有胶质细胞，负责固定神经元位置、清理脑内环境、轴突绝缘、隔离血液内的有害物质、以及影响神经冲动传递所必需的离子浓度。</li><li>动作电位(action potential)：又称神经冲动。在静息状态下，神经元外部钠离子浓度高，细胞内液相对于细胞外液具有跨膜负电压，也就是处于极化状态。神经元对神经冲动的输入发生反应时，静息电位转为动作电位，抑制性输入保持跨膜负电压，抑制了神经冲动的传输，兴奋性输入允许钠离子流入消除负电压，发生去极化，让动作电位继续向后传播，传播过后允许钾离子流出恢复静息电位。而细胞膜上的钠钾泵负责两种离子的反向供给。</li><li>动作电位在神经元之间靠突触传播。突触由突触前膜(发送神经元的终扣)、突触后膜(接受神经元的终扣)和突触间隙组成。动作电位沿轴突到达突触前膜后，开启离子通道允许钙离子流入，引起突触囊泡破裂释放神经递质，神经递质与突触后膜上的受体结合，由于神经递质与受体的结合具有专一性，所以可以说神经元接受的信号是兴奋还是抑制是由其上的受体决定的，但本质上是由神经递质和受体的组合决定的。</li><li>几种神经递质。<ul><li>乙酰胆碱：兴奋性递质，存在于中枢与外周神经系统，阿尔兹海默症的记忆丧失被认为是由于分泌乙酰胆碱的神经元退化所造成的。</li><li>GABA：是gamma-氨基丁酸的缩写，抑制性递质，存在于丘脑、下丘脑和枕叶皮层等脑结构，当脑中GABA水平降低时，人们会产生焦虑或抑郁。</li><li>谷氨酸：脑中最普遍的兴奋性递质，有助于在脑中传递信息，在情绪反应、学习和记忆过程中起着关键作用。</li><li>多巴胺、去甲肾上腺素：属于几茶酚胺，在心理障碍中有重要作用，如情感障碍和精神分裂症。</li><li>五羟色胺：位于脑干，抑制性递质，能让人产生愉悦情绪、抗抑郁。</li><li>内啡肽：属于神经调质，神经调质是能够改变或调节突触后神经元活动的物质。内啡肽是内源性吗啡的简称，在情绪行为和疼痛控制中有重要作用。</li></ul></li><li>神经系统分为中枢神经系统(central nervous system, CNS)和外周神经系统(peripheral nervous system, PNS)。CNS由脑和脊髓的所有神经元组成，作用是整合和协调所有身体功能，向身体不同部分发出指令，神经信息的发出和接受由脊髓完成。PNS由所有构成神经纤维的神经元组成，连接CNS与身体，作用是把来自感受器的信息提供给CNS。PNS包括躯体神经系统和自主神经系统，躯体神经系统调节身体骨骼肌的动作，自主神经系统维持机体的基本生命过程，如呼吸、消化。自主神经系统分为交感神经和副交感神经，交感神经支配应对紧急情况的反应，副交感神经监测身体内部功能的常规运行。</li><li>脑有三层结构：脑干、边缘系统和大脑。<ul><li>脑干：负责综合调节机体内部状态。延髓是呼吸、血压和心搏调节中枢。桥脑提供传入纤维到其他脑干结构和小脑之中。丘脑是感觉的最高中枢。小脑协调身体的运动和维持平衡。</li><li>边缘系统：与动机、情绪状态和记忆过程相关，也参与体温、血压和血糖水平的调节。海马在记忆获得中有重要作用。杏仁核在情绪控制和情绪记忆形成中起作用。下丘脑调节动机行为，包括摄食、饮水、体温调节和性唤醒，维持身体平衡或内稳态。</li><li>大脑：负责调节脑的高级认知功能和情绪功能。额叶参与运动控制和认知活动，包含与语言障碍相关的布罗卡区。顶叶负责触觉、痛觉和温度觉。枕叶是视觉信息到达的部位。颞叶负责听觉过程，包含与言语理解相关的威尔尼克区。额叶运动皮层控制身体肌肉。躯体感觉皮层处理温度、触觉、躯体位置和疼痛的信息。听皮层处理听觉信息。视皮层处理视觉信息。联络皮层负责整合不同感觉通道的信息。</li></ul></li><li>内分泌系统是一种腺体网络，制造和分泌激素到血液中。下丘脑是内分泌系统和中枢神经系统的中转站，下丘脑向脑垂体分泌激素，脑垂体再调节身体其他激素的释放。</li></ul><h1 id="4-感觉和知觉"><a href="#4-感觉和知觉" class="headerlink" title="4 感觉和知觉"></a>4 感觉和知觉</h1><ul><li>知觉(perception)是理解环境中客体和事件的所有过程，分成感觉、知觉组织以及辨认与识别客体三个阶段。感觉(sensation)是感受器受到刺激后产生神经冲动以反映身体内外经验的过程。知觉组织(perceptual organization)阶段大脑整合来自感官的信息形成对外部刺激的内部表征。辨认与识别(identification and recognition)阶段赋予知觉以意义。</li><li>环境中的物理客体称为远距刺激，如光线、空气振动，它们在感觉器官上直接产生的刺激称为近距刺激，如视网膜上的光学成像。知觉三个阶段的主要计算任务可以看成根据近距刺激中的信息来确定远距刺激。</li><li>心理物理学研究物理刺激与其所产生的心理行为和体验之间的关系，由古斯塔夫·费希纳首先提出。测量刺激的方法是确定阈限并建立感觉强度和刺激强度之间关系的心理物理量表。刺激的绝对阈限是产生感觉体验所需的最小物理刺激量，由于觉察过程不是突变的，所以绝对阈限的操作性定义为有一半次数能够觉察到感觉信号的刺激水平，绝对阈限的测量结果总结为心理测量函数，表示为每种刺激强度下刺激被觉察到的百分比的曲线，一般为S形曲线。感觉适应是指感觉系统对持续的刺激输入反应逐渐减小的现象。</li><li>阈限测量受反应偏差的影响，也就是测量中有干扰因素。针对反应偏差的研究方法是信号检测论(signal detection theory, SDT)，综合考虑测量结果的击中、漏报、虚报、正确否定的情况，相当于机器学习评价指标里true/false与positive/negtive组合的四个参数。</li><li>差别阈限是能够识别出两个刺激之间的最小物理差异，操作性定义为有一半次数觉察出差异的刺激值，又称最小可觉差。最小可觉差服从韦伯定律，即刺激之间的最小可觉差与标准刺激强度的比值是恒定的，标准刺激强度体现了感官对不同刺激的敏感程度，比如光强、气味、声音。</li><li>(人体感官的生物学知识略过~)</li><li>知觉组织的原则在格式塔心理学(Gestalt psychology)中得到深入研究，格式塔心理学注重对整体结构的理解，通过控制局部变化观察人们对整体的知觉组织的结果，总结出一套规律：<ul><li>接近律：人们会将最接近的元素组织在一起。</li><li>相似率：人们会将最相似的元素组织在一起。</li><li>连续率：即使线条被截断，人们也会将其知觉为连续的。</li><li>闭合率：人们倾向于填补小的空隙而将客体知觉为一个整体。</li><li>共同命运率：人们倾向于将看起来朝相同方向运动的客体组织起来。</li></ul></li></ul><h1 id="5-心理、意识和其他状态"><a href="#5-心理、意识和其他状态" class="headerlink" title="5 心理、意识和其他状态"></a>5 心理、意识和其他状态</h1><ul><li>非意识过程是很少进入意识的一些躯体活动，如血压调节，有些非意识过程可以有意识地调节，如控制呼吸。前意识记忆是指只有注意到之后才能到达意识的记忆。无意识行为由弗洛伊德提出，他主张某些意识经验具有威胁性以至于被心理过程排除在意识之外，如创伤性记忆和禁忌的欲望，但仍然能影响人的行为。</li><li>研究意识的方法：使深层的个人经验能够得到外显测量。一种方法是要求参与者在进行复杂任务时大声说出解决过程，记录成出声思维报告。另一种是经验抽样法，参与者提供关于他们在日常生活正常进程中的想法和感受的信息。</li><li>意识的作用。<ul><li>帮助生存：意识限制刺激的输入，通过过滤与当前目标无关的大量信息来限定人的注意力。意识允许将事件和经验按照个人需要分成相关的和无关的，选择性地存储人想要分析、解释并对将来起作用的刺激。意识允许人基于过去的知识思考可替代的方案和想象各种可能的结果。总之就是意识帮助人理解环境信息，计划最适宜而有效的行动。</li><li>对现实的个人和文化建构：基于个人或特定文化环境的知识、经验、记忆、需求、目标等，对当前情境做出独特的解释。</li></ul></li><li>弗洛伊德认为梦是对愿望的满足，梦里有两股动力，愿望和抵抗愿望的审查，审查是对愿望的伪装，把社会和个人不能接受的潜性梦境转化为可接受的显性梦境。梦的解析需要从显性梦境回溯到潜性梦境，也就是对梦中包含隐喻的意象进行解读。</li></ul><h1 id="6-学习与行为分析"><a href="#6-学习与行为分析" class="headerlink" title="6 学习与行为分析"></a>6 学习与行为分析</h1><ul><li>学习是基于经验而使行为或行为潜能发生相对一致变化的过程。<ul><li>学习只有通过经验才能发生，经验包括吸收信息和做出反应来影响环境。</li><li>无法直接观测学习本身，但学习能体现在外显行为表现的进步，或相对于外显行为的一种能改变行为的潜能，比如领悟力。</li><li>为了表明发生了学习，行为或行为潜能的变化必须在不同场合表现出相对一致性。</li></ul></li><li>学习的基本形式是习惯化和敏感化。习惯化是指，当刺激重复呈现时会减少行为回应，人会把注意焦点放在环境的新异事件上。敏感化是指，对重复呈现刺激的反应会变得更强烈。一般来说，在刺激很强烈或令人不适时更可能发生敏感化。习惯化和敏感化看似是相反的形式，但敏感化也可以理解成，重复的强刺激会使人对其他弱刺激的反应变得更强烈，导致总体上的反应是增强的，这也是一种习惯化。</li><li>约翰·华生创立了行为主义的心理学派，他认为主观的内省法不是研究行为的好方法，应该去研究客观的可观察的行为。斯金纳扩展了华生的理论，主张心理活动不是产生行为的原因，行为是由环境刺激产生的。斯金纳开创了行为分析理论，强调寻找学习和行为的环境决定因子，行为分析家的任务是在具有可比性的情景下，发现适用于包括人类在内的所有动物的普遍学习规则。</li><li>复杂形式的学习是简单学习形式的组合和加工，两种简单学习形式是经典条件作用和操作性条件作用。</li><li>经典条件作用是一种由一个刺激或事件预示另一个刺激或事件之到来的基本学习方式，是联想学习的一种形式，在此过程中有机体学会将两种刺激或事件联系起来。经典条件作用最初由巴甫洛夫观察狗分泌唾液的规律研究发现，所以又称巴甫洛夫条件作用。</li><li>经典条件作用的核心是反射性反应，如分泌唾液、瞳孔收缩。反射是由与有机体生物学相关的特定刺激自然诱发的，能自然诱发反射性行为的刺激叫做无条件刺激(unconditioned stimulus, UCS)，无条件刺激诱发的行为叫做无条件反应(unconditioned response, UCR)。不能自然诱发反射性行为，需要与UCS匹配使用的叫做条件刺激(CS)，CS诱发UCR的原因是它与UCS的联系，经过多次匹配使用后，单独使用CS也能引起的反射性行为叫做条件反应(CR)，CR就是学习的结果。一种反应是UCR还是CR是由诱因决定的，所以UCS引起的分泌唾液属于UCR，CS引起的分泌唾液属于CR。</li><li>经典条件作用就是通过USC-CS的匹配诱发CR。CS与USC有四种匹配模式，区别在于UCS的呈现时机：延迟条件作用是先呈现CS，UCS在CS取消前呈现。痕迹条件作用是先呈现CS，UCS在CS取消后呈现。同时性条件作用是UCS与CS同时呈现。倒摄条件作用是UCS先于CS呈现。同时性和倒摄条件作用效果较差，因为只有让CS先于UCS呈现，才能学到CS能预示UCS这样的联系。</li><li>当CS不再预示UCS时，CS逐渐无法诱发CR，这个过程叫做消退，消退后重新训练，CR的学习会更快速，说明消退只是削弱了行为，并没有消除先前全部的学习经验。</li><li>一旦CS与CR建立联系，与CS相似的刺激也能诱发CR，这种现象叫刺激泛化，由于重要刺激很少每次都以完全相同的形式出现，所以刺激泛化通过扩展最初的特定经验而扩大了学习范围。当某些与CS相似的刺激反复出现后，有机体对其他相似刺激的反应会减弱，这种现象叫刺激辨别。有机体需要平衡泛化和辨别的作用强度，避免产生过度选择(该反应的不反应)或过度反应(不该反应的瞎反应)。</li><li>有效的CS需要满足相倚性和信息性。相倚性是指CS要与UCS高度依赖，在没有CS时也不会有UCS。信息性是指CS要能提供UCS不具备的额外信息。</li><li>经典条件作用的应用：药物成瘾。药品(UCS)会诱发生理反应(UCR)，这种生理反应是机体对药物的对抗反应，久而久之，这种对抗反应变成了条件反应，在使用药物的场景(CS)中，如打针，机体会对药物的预期效应做好生理准备(CR)，机体需要消耗额外的药物克服CR，随着CR本身的增强，消耗的药物越来越多，慢慢呈现出药物上瘾。</li><li>爱德华·桑代克通过观察猫用试错法逃出迷笼，提出了效果律：随着体验行为带来的结果，机体自动学到了刺激-反应联结，导致带来满意结果的反应出现的概率会越来越大，而带来不满意结果的反应出现的概率会越来越小。</li><li>斯金纳继承了桑代克的观点，提出了操作性条件作用，操作性指的是机体自发产生的行为。操作性条件作用与经典条件作用的区别在于是否自愿，经典条件作用是在外部刺激下被动地学习，而操作性条件作用是通过主动产生行为并体验结果进行学习。</li><li>强化相倚是指某一反应和它使环境发生变化之间的一致性关系，这种一致性关系能够增大该反应出现的概率。其实和操作性条件作用是一个意思，就是通过体验反应的结果导致反应出现概率变大。当反应的结果是使喜爱的刺激出现，这种情况叫正强化。当反应的结果是使厌恶的刺激消失，这种情况叫负强化。正强化和负强化都增大了反应出现的概率，只是情感基础有区别。强化物是指与行为相倚的刺激，比如金钱奖励。和经典条件作用相同，操作性条件作用也有消退和快恢复的机制。</li><li>惩罚是减小反应出现概率的技术，与强化相倚的作用相反。当反应的结果是使厌恶的刺激出现，这种情况叫阳性惩罚。当反应的结果是使喜爱的刺激消失，这种情况叫阴性惩罚。区分强化和惩罚的关键在于反应出现的概率是增大还是减小。</li><li>三项相倚是指辨别性刺激-行为-结果这一序列。通过结合强化和惩罚，改变三项相倚中的成分，可以把某一行为限定在某一特定背景下。比如红灯和绿灯是两种辨别性刺激，在两种刺激下，过马路的行为会分别产生惩罚和强化两种结果。</li><li>部分强化效应表明，在部分强化中习得的反应比连续强化中习得的反应更能抵抗行为的消退。意思是不必在每次行为后都呈现强化物，有间隔地呈现强化物效果反而更好。强化程序表是指给予强化的策略，书中介绍了四种：<ul><li>固定比率(fixed-ratio, FR)程序表：强化物在有机体做出指定次数的反应后才出现。</li><li>可变比率(variable-ratio, VR)程序表：强化物在有机体平均做出指定次数的反应后才出现，具体到每一次强化前的反应次数是随意的。</li><li>固定间隔(fixed-interual, FI)程序表：强化物在固定时间间隔后，有机体首次做出反应时出现。</li><li>可变间隔(variable-interual, VI)程序表：强化物平均在固定时间间隔后，有机体首次做出反应时出现，具体到每一次强化前的时间间隔是随意的。</li></ul></li><li>学习的生物制约性指的是物种的遗传天赋给学习带来的任何限制。一种情况是本能漂移，实验者的强化物不能完美控制学习过程，随着时间的推移，习得的行为会向着本能行为漂移。一种情况是味觉-厌恶学习，比如老鼠在摄取有特殊味觉特征的食物后，如果出现腹泻等内脏不适症状，在以后的摄食活动中就会减少或拒绝摄取具有相同或相似味觉特征的食物，因为老鼠的遗传因素中对味道比较敏感，所以吃坏一次就能学到条件反应。</li><li>观察学习是指通过替代强化和替代惩罚的方式进行学习，通过观察他人的行为及结果，直接学习他人的经验来改变自己的行为。这是人类运用认知能力的高级学习方式。</li></ul><h1 id="7-记忆"><a href="#7-记忆" class="headerlink" title="7 记忆"></a>7 记忆</h1><ul><li>记忆是存储和提取信息的一种能力，也是一种信息加工过程。内隐记忆是指不需要有意识的努力就可以获得的信息，外显记忆是做了有意识的努力而恢复的信息。陈述性记忆是关于事实和事件的记忆，程序性记忆是关于怎样做某些事的记忆。</li><li>记忆涉及到对知识的编码、存储和提取。编码是把外部世界的信息加工成心理表征。存储是把编码后的信息在大脑结构中保存一段时间。提取是指被存储的信息在随后某一时间的恢复。</li><li>书中介绍了三种非持久记忆：<ul><li>映像记忆(iconic memory)：是一种视觉领域的记忆系统，属于感觉记忆的一种，能使大量信息被存储非常短暂的时间。</li><li>短时记忆(short-term memory, STM)：短期记忆有限的容量迫使注意力高度集中。在头脑里循环重复的方法叫做保持性复述，复述帮助人防止信息从短时记忆中衰退。当信息过于复杂不能被复述时，可以会使用组块策略，利用联想能力，把信息分解成几个有意义的组。</li><li>工作记忆(working memory)：用于完成诸如推理和言语理解这样的任务所需的记忆资源，包含语音环路、视觉空间画板、中央执行系统和情景缓冲区四个成分。短时记忆仅仅是对信息的存储，但工作记忆对信息进行了处理和加工，服务于随后的认知活动，比如心算和阅读理解都涉及工作记忆。</li></ul></li><li>长时记忆(long-term memory, LTM)是从感觉记忆和短时记忆中获得的所有体验、时间、信息、情感等的储存仓库，长时记忆构成了每个人对于世界和自我的全部知识。当编码信息的情景与试图提取它的情景能够很好匹配时，记忆效果最好，好的匹配体现在以下几个方面：<ul><li>提取线索：是指搜索一个特定记忆的时候可以利用的刺激，也就是提取记忆的目的。提取记忆的难易取决于提取线索的质量。比如再认测验比回忆测验更容易，因为再认的线索更有用。语义记忆(从不同情境的体验中总结出的一般化的抽象经验)比情景记忆(特定情景下的特定体验)更容易，因为情景记忆需要的线索更多。</li><li>背景和编码：编码特异性原则表明，当提取的背景与编码的背景相匹配时记忆最为有效。研究已经证明了存在背景依赖性记忆、状态依赖性记忆以及语言依赖性。</li><li>编码和提取的过程：加工水平理论认为，信息的加工水平越深，它转入记忆的可能性就越大，如果加工涉及的分析、理解、比较和精细处理越多越深，记忆效果就越好。传输适宜性加工理论认为，如果使用了一个特定类型的加工来编码信息，如物理的或语义的分析，那么使用相同类别的分析过程能更有效地提取信息。</li></ul></li><li>产生遗忘的原因是不同的记忆之间会互相干扰，前摄干扰是指过去获得的信息使你获得新信息更困难，倒摄干扰是指新信息的获得使你对旧信息的记忆更困难。艾宾浩斯是第一位严格通过实验证明干扰现象的研究者。</li><li>元记忆是指关于知道自己拥有什么信息的记忆，元记忆的一个主要问题是知道感是怎么产生的，也就是人为什么知道自己有哪些记忆。线索熟悉性假设认为，人们是基于他们对提取线索的熟悉性建立知道感的。易接近性假设认为，人们基于记忆中部分信息的可接近性或可得性来做出判断。总之就是人本身已经有相似或相关的记忆了，所以会自以为知道答案，这就是废话呀。</li><li>记忆的一项重要功能是把相似的信息连接起来。记忆结构包括概念、等级和图式。概念是有关归类或范畴的心理表征，等级是对概念的有意义的排列组合，图式是关于物体、人和情境的概念框架或知识群。</li><li>重构性记忆(reconstructive memory)是指不直接记忆新信息，而是基于记忆中更概括的知识来重构信息。重构记忆不是恢复一个特定的记忆表征，所以重构的记忆可能会与事实不符，弗雷德里克·巴特利特最先证明了记忆的扭曲，概括出三种扭曲的过程：趋平(简化故事)、精锐化(过分强调某些细节)和同化(将细节变得更符合自己的背景或知识)。</li><li>闪光灯记忆(flashbulb memory)是指当人们经历的事件引起情绪极大波动时，产生的鲜明的记忆，回忆出的信息与原始事件的情形完全一致，也就是所谓的历历在目，比如家里死人、911袭击。</li><li>记忆的物理痕迹广泛分布于整个大脑，小脑负责程序性记忆，纹状体是习惯的形成和刺激-反应间联系的基础，大脑皮层负责感觉记忆以及感觉间的关联记忆，海马组织负责事件、日期、名字等的陈述性记忆以及空间记忆的巩固，杏仁核在具有情绪意义的记忆的形成和提取中起着关键作用。记忆的生物学基础能够帮助解释遗忘症的原理。</li></ul><h1 id="8-认知过程"><a href="#8-认知过程" class="headerlink" title="8 认知过程"></a>8 认知过程</h1><ul><li>全是空话废话，就是推理、归纳、决策等等认知过程的基本阐述，学不到有意思的东西。</li></ul><h1 id="9-智力与智力测验"><a href="#9-智力与智力测验" class="headerlink" title="9 智力与智力测验"></a>9 智力与智力测验</h1><ul><li>心理测量是用来检测人们的能力、行为和个性特质的特定的测验程序。正式测量程序应该满足三方面要求：<ul><li>信度：是指某一测量工具给出的一致性分数的可信程度。检测信度的方法有三种。<ul><li>重测信度，对同一人使用同一种测验，计算两次结果的相关性。</li><li>平行测验，对同一人使用检测同一特质的不同测验，减少了参与者第一次测验的经验对后续测验的影响。</li><li>对单个测验进行内部一致性检验，比如对奇数项目和偶数项目的成绩进行一致性比较。</li></ul></li><li>效度：是指测验能够测得它所要测量的东西的程度。有三种重要的效度。<ul><li>内容效度：是指测验对欲测领域的所有方面的覆盖程度。</li><li>效标效度：又称预测效度，是指测验结果与效标的相关程度。效标是指与测验目标相关的其他指标，比如要测验智力，可以把权威的韦氏智力测验作为效标，与自己的测验结果相比较。</li><li>结构效度：是指充分测量潜在结构的程度。心理学家对一些抽象特质提出了相关理论或结构，如焦虑、抑郁等特质，测验结果与目标特质的结构越相关，结构效度就越高。</li></ul></li><li>标准化：是指在同一条件下对所有人、以同样的方式实施测验，得到的成绩分布就是测验的评分标准，也叫作常模。</li></ul></li><li>心理测量学是心理学的一个分支，主要是对心理能力进行全方位的测量，包括人格评定、智力评估和能力测量。通过在不同的能力测量中寻找统计相关，基于这些关系得到有关人类智力本质的结论，这种技术叫做因素分析。查理斯·斯皮尔曼认为存在一般智力因素或g因素，是所有智力操作的基础。雷蒙德·卡特尔认为一般智力分为两个相对独立的成分，一个是晶体智力，包括一个人获得的知识以及获得知识的能力，另一个是液体智力，是发现复杂关系和解决问题的能力。</li><li>罗伯特·斯滕伯格提出了三因素理论，认为智力包括分析、创造和实践三种类型。分析智力是对基础信息加工的能力。创造智力是处理新异问题的能力。实践能力是处理日常事物和适应环境的能力。</li><li>霍华德·加德纳提出了多元智力理论，归纳出语言、音乐、空间、逻辑-数学、自然主义、身体运动、人际和内观八种智力，政治家和生意人倾向于各种智力相对平衡，科学家和艺术家倾向于在一两种智力上表现卓越。</li><li>创造力是指就特定环境而言，个体产生新异的和合适的思想和产品的能力。创造力的测量集中在发散思维和聚合思维上，发散思维是对某一问题产生许多不寻常的想法的能力，聚合思维是整合不同来源信息从而解决问题的能力。</li><li>心理测量学的三个争议：<ul><li>基于测验的决策的公平性：用同一种常模评价所有的测验参与者，忽视了群体差异，使少数群体承受了负面后果。</li><li>测量用于教育评价的可行性：学校过分看重心理测验的成绩，扭曲了教育的目的，助长了撒谎作弊的风气。</li><li>以测验分数进行个体分类的意义：测验对人的标签化使得到负面评价的人产生心理障碍。</li></ul></li></ul><h1 id="10-人的毕生发展"><a href="#10-人的毕生发展" class="headerlink" title="10 人的毕生发展"></a>10 人的毕生发展</h1><ul><li>发展心理学是心理学一个分支，关注个体从受孕开始贯穿一生所发生的生理和心理机能的变化，对发展进行记录和解释。常模研究是指刻画某个特定年龄段或发展阶段的特征，使心理学家区分人的生理年龄。纵向研究是指连续多年持续观察同一个体，横向研究是指同一时间观测不同生理年龄阶段的参与者。</li><li>皮亚杰提出了一套关于儿童认知发展的理论。他把促使个体能够理解世界的心理结构称为图式，图式是发展变化的基本单元。认知的发展是两个基本过程的协同工作：同化和顺应。同化是对新的环境信息加以修改使之适合个体已有的知识结构。顺应是对已有的图式进行修改以使新的信息得到更全面的理解。同化和顺应协同的一个例子是婴儿基于先天的抓握行为改变抓握的尺度实现抓握奶瓶。</li><li>皮亚杰认为儿童的认知发展可以分为四个有序但不连续的阶段：<ul><li>感知运动阶段：从出生到两岁，婴儿基于注视、抓握等先天图式进行改善、组合来丰富自身的行为。婴儿期最重要的认知是获得了对不在眼前的客体形成心理表征的能力，也就是当感知目标消失了以后还能意识到它曾经存在过。</li><li>前运算阶段：2~7岁之间，前运算思维的特点是自我中心，也就儿童不能站在别人的角度思考问题，还有个特点是中心化，即儿童只会关注情境的某一方面而忽略其他相关方面。</li><li>具体运算阶段：7~11岁之间，儿童开始心理运算，在脑中产生逻辑思维的活动，可以用心理活动代替物理活动。儿童学会了守恒的概念，当改变物体的外表而不改变数量、质量等物理属性时，儿童能意识到这种不变性。</li><li>形式运算阶段：始于11岁，思维变得抽象，开始系统地思考复杂问题。</li></ul></li><li>社会性发展是个体的社会交往和社会期望在个体的一生中的变化。艾瑞克·埃里克森提出了8个心理社会发展阶段，每个阶段都有主要的冲突或危机：<ul><li>信任对不信任：0~1.5岁，通过与照料者之间的交往建立对环境的基本信任。相反，当儿童的基本需要没有得到满足，可能发展出不信任感、不安全感和焦虑感。</li><li>自主对自我怀疑：1.5~3岁，通过探索和操纵客体产生安全的自主感。相反，对儿童过分批评或约束可能导致他们产生自我怀疑。</li><li>主动对内疚：3~6岁，发展了基本信任感的儿童能够主动产生智力或运动行为，父母的鼓励促进了自主感和自信感。相反，父母的负面评价会使儿童产生内疚感。</li><li>勤奋对自卑：6岁~青春期，儿童系统地发展各项能力，努力追求能力的提升使自己感到有能力。相反，如果儿童仅作为旁观者或经历太多失败，会产生自卑感。</li><li>同一性对角色混乱：青少年期，对不同人扮演不同角色，并在这种混乱中培养对自我的一致感。反之则导致青少年缺乏稳定的、核心的自我形象。</li><li>亲密对孤独：成年早期，发展对他人做出充满感情、道德和性的承诺的能力。</li><li>繁殖对停滞：成年中期，把对自己和伴侣的承诺扩展为对整个家庭、工作、社会以及后代的承诺。</li><li>自我整合对绝望：成年晚期，回顾往事，不留遗憾，产生圆满感。</li></ul></li></ul><h1 id="11-动机"><a href="#11-动机" class="headerlink" title="11 动机"></a>11 动机</h1><ul><li>动机(motivation)是对所有引起、指向和维持生理和心理活动的过程的统称。心理学家采用动机的概念有五个目的：把生物学和行为联系起来、解释行为的多样性、以公开的行动来推断内心的状态、将责任感赋予行动、解释逆境中的意志。</li><li>动机来自于内因和外因。内因包括内驱力(drive)、本能(instinct)和历史学习，内驱力是指生物体为满足生理需求或维持平衡状态做出的反应，比如保持体温、消除紧张。外部诱因(incentive)是外部的刺激和奖赏，与生理需要没有直接联系。把动机来源看成内部还是外部，一定程度依赖于人对客观实体的主观认识。</li><li>亚伯拉罕·马斯洛提出了需要层次论，认为基本的动机形成了五个层次，在到达下一个更高层次之前，每一层次的需要都必须被满足。需求层次由低到高分别是：生理需要、安全需要、归属与爱的需要、尊重的需要、自我实现的需要。</li></ul><h1 id="12-情绪、压力和健康"><a href="#12-情绪、压力和健康" class="headerlink" title="12 情绪、压力和健康"></a>12 情绪、压力和健康</h1><ul><li>情绪(emotion)定义为对具体事件的特殊反应，强烈且持续时间短，而心境(mood)通常是不强烈且持续时间长的。</li><li>达尔文在《人类和动物的表情》里提出，所有物种的情绪与其他重要的结构及功能一同进化而来，是一种遗传得来、对世界上某类反复发生的情境做出反应的特定心理状态，比如婴儿一出生就能对巨大声响表现出恐惧。情绪作为进化的产物有适应能力，在不同的文化背景下，不同的社会规范影响了人们的情绪反应。</li><li>情绪反应的生物学基础是大脑和神经系统的协同作用，关于情绪与生理反应的关系，书中介绍了三种理论：<ul><li>詹姆斯-兰德理论：认为情绪来源于身体反馈，比如人不是因为难过而哭泣，而是因为哭泣而难过。这种理论把情绪链中最重要的角色赋给了内脏反应，直观上感觉是错误的。</li><li>坎农-巴德理论：认为情绪是中枢神经的作用，并通过实验证明了身体反应和心理反应的独立性。</li><li>认知评价理论：认为情绪的产生受到环境事件、生理状况和认知过 程三种因素的影响，其中认知过程是决定情绪性质的关键因素。</li></ul></li><li>应激(stress)是一种反应模式，当刺激事件打破了有机体的平衡和负荷能力，或者超过了个体的能力所及，就会体现为压力。分为急性应激和慢性应激。<ul><li>急性应激反应的中心是下丘脑，它控制自主神经系统调节机体活动，如心跳加快、血压上升，同时促进肾上腺素的分泌。面临危险时，男性的反应是身体做好防御、挣扎、逃跑的准备，这种应激叫做战斗或逃跑反应，女性的反应是照顾孩子的需求以及与相同目标的人结盟，这种应激叫做照料和结盟反应。然而这两种反应都不能完全适用于现实生活。</li><li>慢性应激时，有机体为了恢复平衡要经历报警、抵抗、衰竭三个阶段。应激激素的过度分泌会降低吞噬细胞的杀伤能力，损害免疫系统的完整性，出现心身失调的症状。</li></ul></li><li>健康心理学是心理学一个分支，研究人们怎样保持健康、患病的原因以及生病后的反应。健康是指身体和精神上的一种稳定、充满活力的一般状态。健康心理学以健康的生物心理社会模型为基础，生物心理社会模型将健康与心理状态和社会环境联系了起来。</li></ul><h1 id="13-理解人类人格"><a href="#13-理解人类人格" class="headerlink" title="13 理解人类人格"></a>13 理解人类人格</h1><ul><li>人格(personality)是一系列复杂的心理品质，具有跨时间、跨情境一致性的特点，对个体行为的特征性模式有独特的影响。人格理论是对个体人格结构和功能的假设性说明。</li><li>人格类型是依据人格理论对人的归类。有下几种人格类型理论：<ul><li>公元前五世纪，希波克拉底提出人体有血液、粘液、黑胆汁、黄胆汁四种基本体液，个体人格是由体内何种体液占主导决定的。</li><li>1942年，威廉·赛尔顿提出将体型与气质联系在一起，根据体型将人分成三种类型：内胚层型(胖、柔软、圆润)，中胚层型(肌肉发达、矩形身材、强壮)，外胚层型(瘦、长、虚弱)。</li><li>近些年，弗兰克·沙洛威提出基于出生顺序的现代类型理论，也就是在家里是先生子还是后生子。</li></ul></li><li>类型理论把人分成离散的几个类型，而特质理论推崇智力、友谊等连续性维度，特质就是人持久的品质或特征。有下几种人格特质理论：<ul><li>戈登·阿尔波特提出三种特质：首要特质、核心特质和次要特质。首要特质决定一个人如何组织生活，核心特质代表一个人主要特征和品质，次要特质有助于预测个体行为。</li><li>卡特尔提出了人类人格的16因素，称为根源特质。</li><li>艾森克根据人格测验的数据推论出三大维度：外向性(内向还是外向)、神经质(情绪稳定还是不稳定)和精神质(善良体贴还是冲动暴力)。</li><li>近年来提出了五因素模型，即外倾性(内向还是外向)、宜人性(善良还是冷漠)、尽责性(谨慎还是轻率)、神经质(情绪稳定还是不稳定)和开放性(聪明还是肤浅)，是艾森克理论的升级版。</li></ul></li><li>弗洛伊德提出了心理动力学的人格理论，认为是强大的内在驱力塑造人格并引发行为，试图从人格发展的起源和进程、心理的本质、变态人格的各个方面以及通过治疗改造人格进行解释。</li><li>弗洛伊德最初提出两种基本内驱力：自我生存和性本能。性欲心理发展有五个阶段和发展任务：口唇期(断奶)、肛门期(如厕)、生殖器期(俄狄浦斯情结)、潜伏期(防御机制的发展)和生殖期(成熟的性亲密行为)。弗洛伊德的精神决定论认为，所有心理和行为反应都是由早期经验决定的，行为可以被人意识不到的内驱力引发，所以弗洛伊德注重研究无意识，比如梦。</li><li>弗洛伊德认为人格的差异源于人们以不同的方式对待基本的驱力，人格是本我和超我的无休止的战斗，这种战斗由自我来调和。<ul><li>本我(id)：原始驱动力的储存处，非理性，受快乐原则支配，无节制地追求满足感而不计后果。</li><li>超我(superego)：价值观的储存处，与良心的概念相似。</li><li>自我(ego)：一个基于现实的方面，是关于行为的原因和后果的理性认识。受现实原则支配，使人选择能满足需求且后果可接受的行为，调和本我和超我的矛盾。</li></ul></li><li>自我防御机制是自我在寻求表现的本我冲动与否定他的超我要求之间的日常冲突中用来保护自身的心理策略，欲望的压抑就是一种自我防御，由此产生的强烈情绪反应就是焦虑。</li><li>后弗洛伊德理论是后继者对精神分析理论的修正：<ul><li>阿尔弗雷德·阿德勒提出人人都会体验到自卑感，会以自己的方式努力克服自卑感，人就是在这种基本的奋斗中构建人格。</li><li>凯伦·霍尼提出“子宫妒忌”使男人贬低女人，并通过无意识地进行创造性工作加以过度补偿。</li><li>卡尔·荣格提出了集体无意识的概念，是整个人类共有的基本心理事实。集体无意识可以解释人对普遍存在的、可构成原型的原始神话、艺术形式和象征的直觉性理解。</li></ul></li><li>人本主义学派从整合个体的个人经验和意识经验及成长潜能的角度理解人格，强调自我实现的驱力，自我实现是指个体不断努力开发自身智力、实现个人内在潜能的倾向。</li><li>人本主义理论具有三种特征：<ul><li>整体性：从个体的整体人格看待其分散的行为。</li><li>先天倾向性：关注影响、决定行为方向的个体内在特征，而把环境因素视为限制和障碍。</li><li>现象学性：强调个体的参考框架与对现实的主观看法，而不是观察者或治疗家的客观视角。</li></ul></li><li>不同的人格理论中存在着五个重要的差异：<ul><li>遗传和环境：对人格发展来说，生理因素和环境因素哪个更重要？</li><li>学习过程和先天法则：人格是先天决定的还是后天学习改变的？</li><li>过去、现在和将来：强调人生哪个阶段的人格发展。</li><li>意识与无意识：强调意识过程还是无意识过程？</li><li>内在倾向与外在情境：强调人格的内在倾向还是人格与环境的交互？</li></ul></li></ul><h1 id="14-心理障碍"><a href="#14-心理障碍" class="headerlink" title="14 心理障碍"></a>14 心理障碍</h1><ul><li>心理障碍(障碍:disorder)或心理病理是被认为不健康或变态的心理功能，严格说不是病，是一种对违反社会共识的心理状态。变态心理学研究的就是与个体意识、情绪和行为相关的病理问题。心理障碍有七个标识：痛苦或功能不良、适应不良(个体行为妨碍目标实现)、非理性、不可预测性、非惯常性和统计的极端性(个体行为不被公众接受且处于统计学的极端位置)、令观察者不适、以及对道德或理想标准的违反。</li><li>心理诊断是通过把观察到的行为模式归类到公认的诊断系统中。分类系统应当具有三点好处：<ul><li>通用的简略语言：促进心理病理领域的临床工作者和研究者之间快捷和清楚的相互理解。</li><li>病原学的理解：对于一种特定障碍的诊断应当将症状的病因澄清。</li><li>治疗计划：针对特定的障碍应当采取何种治疗方式。</li></ul></li><li>病原学(etiology)是指引起或促使心理疾病和医学疾病形成的因素，心理障碍的病因包括生物因素和心理因素。生物因素有遗传因素、脑损伤或感染等。心理因素目前主要有四种模型：<ul><li>心理动力学模型：行为是由人们意识不到的内驱力和愿望所驱动，心理病理症状的根源存在于无意识冲突和观念中。也就是由于自我无法调节本我和超我的冲突所导致的过度防御。</li><li>行为主义模型：变态的行为与健康的行为是通过同样的方式即学习和强化获得的。心理障碍之所以出现是因为个体学会了自我挫败或无效的行为方式。</li><li>认知模型：心理障碍的起源也在于人们如何感知或思考自己，以及与别人和周围环境之间的关系。心理问题是对现实情境的歪曲感知、错误推理，以及不良的问题解决所导致。</li><li>社会文化模型：特定文化背景对心理问题有诱发作用。</li></ul></li><li>焦虑障碍有五个主要类型：<ul><li>广泛性焦虑症：至少六个月以上的时间感到焦虑或担心，但不是由于特定危险的威胁。</li><li>惊恐障碍：意料之外的严重的惊恐发作，持续时间短，感觉到强烈的恐惧、害怕或惊慌。</li><li>恐惧症：恐惧是对于客观确认的外部危险的理性反应，恐惧症是病人持续和非理性地害怕某一特定的东西、活动或者情境，如社交恐惧症。</li><li>强迫症：无法摆脱特定的思维和行为模式，做出不合理的、多余的强迫行为。</li><li>创伤后应激障碍：通过痛苦的回忆、做梦、幻想或闪回，持续地重新体验到创伤事件。</li></ul></li><li>焦虑障碍的原因：<ul><li>生物学派：神经递质GABA的水平降低时会出现焦虑的感受。</li><li>心理动力学派：焦虑障碍的症状源自潜在的精神冲突或恐惧，目的是保护个体不受心理伤害。强迫行为是试图移除焦虑的一种努力。</li><li>行为主义学派：焦虑障碍的症状是强化或条件化的结果，中性刺激与恐怖经验一起出现时，会变成恐怖刺激，让人学到恐惧的条件反应。</li><li>认知学派：焦虑病人有认知上的偏差，可能高估了现实的危险，或低估了自己有效应对威胁的能力。</li></ul></li><li>人格障碍指的是一种持久的、不可变的、适应不良的感知、思维或行为模式，严重损害一个人在社交或职场中的功能，造成显著的痛苦。两种主要的人格障碍：<ul><li>边缘型人格障碍：人际关系紧张且极不稳定，部分原因是他们无法控制愤怒，表现出冲动性行为。还表现出对被遗弃的强烈恐惧。</li><li>反社会型人格障碍：持久的缺乏责任感、不遵守法律、做出违反社会规范的行为。</li></ul></li><li>精神分裂症是一种严重的心理病理形式，人格似乎解体，思维和知觉出现歪曲，情感变得迟钝。有五种主要类型：<ul><li>瓦解型：个体表现出不连贯的思维模式和非常怪异和紊乱的行为。</li><li>紧张型：表现出动作的紊乱和极端的违拗，即对所有的指示都表现出明显的、原因不明的抗拒。</li><li>偏执型：有复杂且具系统性的妄想，很少表现出紊乱行为，行为多半是激烈和正式的。</li><li>未分化型：表现出不止一种类型特征。</li><li>残留型：病人经受了上一次精神分裂症发作的影响，也就是精神病后遗症。</li></ul></li></ul><h1 id="15-心理治疗"><a href="#15-心理治疗" class="headerlink" title="15 心理治疗"></a>15 心理治疗</h1><ul><li>主要的治疗学派：<ul><li>生物医学治疗：关注改变中枢神经系统运转的机制。</li><li>心理动力学派：谈话治疗，帮助个体把外显症状与内部未能解决的冲突联系起来，引导其产生领悟。</li><li>行为治疗：对失调的行为进行矫正。</li><li>认知治疗：改变个体对问题的自我陈述，重建其思维方式，改变个体对困难的理解和认识。</li><li>人本主义学派：关注改善健康人的心理功能，而不是纠正处于严重失调的个体的症状，强调人的价值，认为要依靠自身的深化认识和潜能激发来恢复心理健康。</li></ul></li><li>心理动力学派起源于弗洛伊德的精神分析，一个重要目标是让病人能够洞察并领悟人际冲突。精神分析通过几项技术帮助病人将被压抑的冲突带回意识中并解决冲突：<ul><li>自由联想和宣泄：让病人的大脑处于自由状态，弗洛伊德认为自由联想的内容不是随机的，而是事先存在于个体的内心。鼓励病人宣泄情感，通过外显反应确定病因。</li><li>阻抗：在自由联想中，病人表现出不能或不愿意讨论某些观念、意愿或经历。心理治疗的目的是打破阻抗。</li><li>梦的解析：从无意识里寻找表达的潜在动机，以及某些重要生活经历或愿望所具有的象征意义。</li><li>移情和反移情：治疗过程中治疗师和病人相互产生的情绪反应，也就是拉近关系，帮助对方发现真实的自己。</li></ul></li><li>几种行为治疗。<ul><li>反作用条件是让个体学习一个新的条件反应去替代或对抗适应不良的反应，以反作用条件为基础发展出以下几种疗法：<ul><li>暴露疗法：让病人直接面对引发焦虑的客体或情境，主动学会放松自己。</li><li>系统脱敏法：交叉抑制理论认为神经系统无法同时处于放松和兴奋状态，所以原始暴露疗法是有缺陷的，应该让病人在放松状态逐步地暴露于刺激中。</li><li>满灌疗法：让病人迅速地暴露在刺激面前。</li><li>厌恶疗法：将诱发性刺激与令人厌恶的刺激混合，消除病人的负面条件反应。</li></ul></li><li>权变管理是借助改变行为的结果来改变行为的治疗策略，有两种主要的技术，正强化策略和消退策略，也就是施加适当的奖励或惩罚改变病人的行为。</li><li>社会学系疗法是通过设计特定情境，让来访者观察到榜样因表现出适应性行为而得到强化，进而矫正来访者的问题行为，也就是替代学习疗法。</li><li>泛化技术：增加治疗中的靶行为、强化物、榜样、刺激等与实际生活情境中事物的相似性，让病人在治疗中学会的新行为模式能运用在日常生活中。</li></ul></li><li>认知疗法就是口头教育，灌输正确价值观，我觉得我也可以。</li><li>人本主义有两种主要疗法：来访者中心疗法和格式塔疗法。来访者中心疗法就是众星捧月，一堆治疗师倾听来访者哔哔，帮助来访者开放表达，引发自己恢复心理健康的潜力。格式塔疗法就是帮助来访者自我对话，引发潜在力量。</li><li>生物医学治疗包括药物治疗、大脑手术治疗、大脑电击疗法等。</li></ul><h1 id="16-社会心理学"><a href="#16-社会心理学" class="headerlink" title="16 社会心理学"></a>16 社会心理学</h1><ul><li>战略性放弃</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="心理学" scheme="http://shivakasu.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《人类简史》</title>
    <link href="http://shivakasu.github.io/2020/01/26/read0/"/>
    <id>http://shivakasu.github.io/2020/01/26/read0/</id>
    <published>2020-01-26T11:07:20.000Z</published>
    <updated>2020-02-18T10:57:05.670Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="认知革命-约7万年前"><a href="#认知革命-约7万年前" class="headerlink" title="认知革命(约7万年前)"></a>认知革命(约7万年前)</h1><ul><li>烹调技术的发明减少了食物所需要的咀嚼和消化的时间，让人类可以缩短肠道、降低能量消耗，有了发育大脑的余地。学会用火让人类能主动控制和利用自然的力量，有了发展的实力。</li><li>智人能够淘汰其他的人种征服世界，是因为偶然的基因突变改变了大脑，让智人拥有了新的语言技能，不仅能沟通信息，还有了虚构故事的能力，这是智人集结人力、团结合作的基础。因为依靠互相认识、交流所能维持的团体大约是150人，而共同相信一个虚构的故事或存在就能打破团体规模变大产生的认知壁垒。现代社会也是如此，没文化的可以有相同的宗教崇拜，有文化的可以考虑共同利益，人之间的合作不再严格需要彼此认识和了解。</li><li>认知革命以来，智人生活在双重现实中。一个是客观存在的现实，一个是能使人相信的想象中的现实。这种意识形态的产生使人类社会的发展不再由基因的演变所主导，而是可以根据需求主动引导社会的变革，使人类社会走上快速发展的道路，这是智人胜利的关键。从此智人超越了生物学对人类行为和能力的基本限制，创造了文化和历史。</li><li>有证据表明，自采集时代以来智人的脑容量在逐渐减少，因为随着社会分工的发展，人类越来越能够依赖别人的技能和成果，不需要精通各方面的知识和技能也可以很好地生存。</li><li>远古采集时代的智人有健康和多样化的饮食、相对较短的工时，也少有传染病发生，许多专家将这种社会定义为“最初的富裕社会”。普遍认为远古采集者是泛神论者，相信万物有灵。但是由于时间久远、生活习惯严重分化，目前还没有对远古采集者的可信的研究。</li><li>远古智人学会了航海，因为自然和人口的压力移居到了其他大陆。气候变迁加上人类狩猎和火耕的影响，使其他大陆遭受了物种灭绝。智人的殖民消灭了地球上半数的大型陆地动物。工业革命以来人类对海洋资源的过度滥用，使得海洋生物也开始面临生态危机。</li></ul><h1 id="农业革命-约1万年前"><a href="#农业革命-约1万年前" class="headerlink" title="农业革命(约1万年前)"></a>农业革命(约1万年前)</h1><ul><li>农业革命最早发生在中东、中国和中美洲，因为适合被驯化的少数几种动植物只生长在这些地方。</li><li>农业革命并不完全意味着人类文明的进步，驯化少数几种动植物虽然增加了食物的总量，但人类也承受了改造自然的代价。人类从丰富的饮食结构变成只依赖于少数几种农作物，还要花费额外的精力去维护农作物的生长环境以及抵抗自然灾害，农耕所产生的土地所有权问题还会加剧人类之间的暴力冲突。虽然后续文明的发展得益于农业革命，但对于初代农耕人类来说，农业革命是弊大于利的。</li><li>一种观点认为农业革命的产生是因为人类的误判，想让生活更轻松，却没有考虑到随之而来的负面问题，导致最终反倒加重了生存的压力。另一种观点认为人类文化里发展出了信仰建筑，为了围绕信仰建筑建立住所，人类自愿生活得更辛苦，从采摘生活转为农耕生活。</li><li>农业时代人类的活动空间缩小了，但需要规划的未来变长了。不断主动生产充足的食物，会造成人口的爆炸，让人类越来越难以回到碰运气的采摘生活，取而代之的是由农作计划主导的生存状况，所以农民不得不考虑到更长远的未来，努力维持生活水平。</li><li>在农业时代的群体冲突下产生了精英阶层，他们为了实现统治的目的需要创造出一套虚拟的意象来维持群体的秩序，比如宗教、人权。这种虚拟意象要能让人们相信，至少不能明显违背人们对客观现实的认知，同时还要一代代对人们洗脑，最终让它成为一种社会共识，让人们自然而然地以它为基础思考，遵守这种虚拟的规则。越多的人服从统治，要打破规则就越难。</li><li>蚂蚁和蜜蜂的群体秩序是基因决定的，天生就决定了社会分工，他们的行为模式也并不复杂。但人类社会的秩序是由一套庞大的虚构的故事和规则维持的，人类自身的基因和大脑并没有进化成熟到支持存储这么复杂的群体合作的生物信息，所以记忆的局限促成了文字的发明。</li><li>人类不满足于用文字只记录无聊的数据，开始进行文娱方面的大量创作，使得文字记录越来越多，多到需要一种专门负责数据管理和检索的职位。组织文献的行为强化了社会分工和分层管理的理念，改变了人类思维和看待世界的方式，过去的自由连接、整体思考，已经转变为分割思考、官僚制度。</li><li>由于人类社会的秩序建立在虚构的规则之上，不能彻底避免歧视，所以出现了精英群体主导下的社会阶级、种族阶级等歧视性的制度。但维持社会秩序又似乎离不开阶级制度，因为人们不必浪费精力详细了解彼此，只需要知道各自所处的阶级，就能大致掌握彼此的社会分工以及相处的规矩。久而久之，阶级甚至会被人们视为天然正确而合理的存在。</li><li>阶级制度大多是由偶然的历史事件促成的，完全是人类虚构出的制度，所以在不同群体里的表现相差很大，但重男轻女的思想却出奇的一致，说明性别歧视是与人类的生物学特征相关的。目前有几种理论试图解释重男轻女：肌肉理论认为男人比女人强壮，把体力优势转化成了政治上的优势。流氓理论认为男性基因里有更多的暴力和侵略倾向，更适合主导战争、统治群体。父权基因理论认为在数百万年的演化过程中男性和女性发展出了不同的生存和繁殖策略，男性倾向于保留积极好胜的基因，女性倾向于保留顺从、接受照顾的基因。</li></ul><h1 id="人类的融合统一"><a href="#人类的融合统一" class="headerlink" title="人类的融合统一"></a>人类的融合统一</h1><ul><li>社会秩序是人类虚构、臆想的，所以人与人之间、群体与群体之间必然会存在价值观的矛盾，当人们试图解决这些矛盾时，就容易把问题上升到文明的冲突。一方面，文明冲突引发了战争，另一方面，不同文明的碰撞又激励了人们的思考、创造，推动文明的发展。</li><li>从宏观的历史角度看，人类文明是趋于融合的，就像如今所有人类都接受几乎同样的地缘政治体系、经济制度、法律制度、科学体系，尽管不同群体存在着文化差异，但不会再像远古时期一样完全不懂对方的文化，有了冲突只能依靠战争解决，而是在一套公认的基本国际共识下进行争斗。</li><li>随着全球贸易交流的进行，人类文明进一步融合，小群体的社会秩序慢慢孕育出了“世界一家”的理念。公元前的1000年间，出现了三种有可能达到“世界一家”的秩序：经济上的货币秩序，政治上的帝国秩序，以及宗教上的全球性宗教。</li><li>货币的出现是因为以物易物难以高效运行在规模庞大、结构复杂的社会中，一种通用的、中间性的交易媒介能够提高交易的效率，也让财富的转换、存储和运输变得更容易。</li><li>金钱是有史以来最普遍也是最有效的互信系统。</li><li>帝国的两个特征是文化多元性和疆界灵活性。帝国是造成民族多样性大幅减少的主因之一，但帝国也通过剥削战败者创造了大量文化成就。</li><li>帝国思想加速了文明的融合，因为处于统治的目的，帝国本身会刻意推动传播共同文化，主动对思想、制度、习俗、规范进行标准化。由于帝国思想的理念在于普遍和包容，所以结果不会是征服者对被征服者的文化灭绝，征服者会吸收不同的文化而让帝国形成一种融合后的文明，也就是文化的涵化和同化。</li><li>当下的国际形势可以理解成正在走向一个统一的全球帝国。各个国家遵循着国际秩序进行合作，得以共同解决关乎人类利益的更宏大的问题。国家的独立性正在迅速消失，越来越难脱离全球性的组织。</li><li>社会秩序和阶级都只是想象的产物，社会规模越大它们就越脆弱，宗教的重要性就在于让这些脆弱的架构有了超人类的合法性，确保了社会的稳定。</li><li>泛神论时代人们认为万物有灵，世上所有的存在都是要平等尊重的。到了农业时代，人们打破了这种平衡，对动植物有了控制的欲望和需求，农业革命最初的宗教意义，就是让动植物从与人类平等的生物，变成了人类的所有物。当农业因为天灾人祸的影响暂时失控时，由于人们已经不再相信万物平等，于是发明了鬼神崇拜来解释这种失控，试图与高于动植物的神明进行沟通，逐渐发展成了多神教信仰。人类地位的提升是多神论与泛神论的区别。</li><li>大多数多神教都相信存在一个超越一般神灵的最高意志，真正与一神论不同的是，多神论的最高意志不带有任何私心或偏见，对人类的各种世俗的欲望、担心和忧虑毫不在意。最高意志包容着不同领域各有私心的一般神灵，所以多神论本质上就是开明、包容的。历史上的宗教迫害基本都是一神教对异教徒的暴力行为。</li><li>当某些多神论者对自己信仰的某位神灵格外虔诚，就不再相信其上的最高意志，而是把那位神灵本身当做最高意志，于是从多神教里分化出了一神教。一神教的最高意志有私心和偏见，让人类可以直接和最高意志谈条件，所以人们更乐于接受一神教。</li><li>从历史上看，一神论吸收了二元论、多神论、泛神论的思想。就像基督徒信奉一神论的上帝，相信二元论的魔鬼，崇拜多神论的圣人，还相信泛神论的鬼魂。</li><li>除了信奉超自然神灵的宗教，还有信奉自然法则的宗教。如佛教信奉佛法，神的存在与否并不重要，重要的是相信自然法则，指导自身的修行。</li></ul><h1 id="科学革命-约500年前"><a href="#科学革命-约500年前" class="headerlink" title="科学革命(约500年前)"></a>科学革命(约500年前)</h1><ul><li>现代科学与先前的知识体系有三点不同：愿意承认自己的无知，以观察和数学为中心，运用理论取得新能力。</li><li>承认无知是知识体系不断发展进步的驱动力，欧洲在1900年左右征服世界的最大功臣就是科学，而欧洲科学领先的原因就是先承认无知。先前的帝国主义征服世界是为了扩张领土和传播统治思想，但欧洲帝国主义的扩张还多了学习新知识的目的。</li><li>发现美洲是科学革命的一大奠基事件，不但让欧洲人知道实际的观察比过去的传统更重要，而且像征服美洲的欲望也让欧洲人开始求知若渴。</li><li>早期社会的经济不发达是因为人们不相信未来会更好，认为世界是固定大小的一块蛋糕，获得利益的唯一途径是互相争夺。在承认自己的无知后，人们开始相信只要投资进行研究，一切就能变得更好，有了这种信任的基础，人们就会减少争斗、着重发展经济。信任创造了信贷，信贷发展了经济。</li><li>亚当斯密指出：人类全体财富的基础，就在于希望增加个人利润的自私心理。所以贪婪是好的，利己就是利他，因为人们相信个人获利也会使整个经济蛋糕变大。</li><li>现代资本主义经济的一大重点，就在于出现了一种新的道德标准：应该把利润拿出来，继续投资生产。资本主义认为资本和财富不同，资本是人们主动投入生产的资源。这也是因为人们开始相信，生产是可以不断发展进步的，而支持这种信任的，就是科学技术的不断发展。</li><li>资本主义影响了欧洲帝国主义，征服世界的资金从税收逐渐转为信贷，商人和银行家直接成为统治精英，因为投资有利润回报，所以帝国能通过信贷筹集更多的资金。鸦片战争就是典型的国家为资本家服务，国家在鸦片商的施压下向中国宣战。</li><li>资本主义以利润为至高目标，所以让社会上出现大量不平等的压迫现象。所以资本主义和共产主义互相看不上。</li><li>工业革命的核心是能源转换的革命，不断增加可用的能源，来支持人们对社会发展的期望。</li><li>工业革命时期，国家和市场取代了家庭和社群的物质功能，并创造了想象的社群来代替原始社群的情感功能，比如民族和消费大众，将人们捆绑在一个想象中的大家庭里。</li><li>科学技术让人们可以打破自然选择的法则。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="社会学" scheme="http://shivakasu.github.io/tags/%E7%A4%BE%E4%BC%9A%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>旅行商问题与最优解搜索算法</title>
    <link href="http://shivakasu.github.io/2020/01/16/arg3/"/>
    <id>http://shivakasu.github.io/2020/01/16/arg3/</id>
    <published>2020-01-16T07:00:20.000Z</published>
    <updated>2020-01-23T12:26:14.287Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h1><p>旅行商问题（Travelling Salesman Problem, TSP）是这样一个问题：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。它是组合优化中的一个NP困难问题。本文选择公开的<a href="http://elib.zib.de/pub/mp-testdata/tsp/tsplib/tsp/index.html" target="_blank" rel="noopener">a280数据集</a>进行测试，求解访问全部城市的最短路径。数据预处理及数据散点图如下：  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import math,random,time,copy</span><br><span class="line"></span><br><span class="line"># 城市坐标</span><br><span class="line">cities &#x3D; []</span><br><span class="line"># 邻接矩阵，distance[i][j]表示cities[i]到cities[j]的距离</span><br><span class="line">distance &#x3D; []</span><br><span class="line"></span><br><span class="line">def init():</span><br><span class="line">    with open(&quot;a280.tsp&quot;,&#39;r&#39;) as f:</span><br><span class="line">        lines &#x3D; f.readlines()</span><br><span class="line">    i&#x3D;0</span><br><span class="line">    while &quot;NODE_COORD_SECTION&quot; not in lines[i]:</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line">    for j in range(280):</span><br><span class="line">        c &#x3D; lines[i+1+j].split()</span><br><span class="line">        cities.append([int(c[1]),int(c[2])])</span><br><span class="line">    for i in range(len(cities)):</span><br><span class="line">        distance.append([])</span><br><span class="line">        for j in range(len(cities)):</span><br><span class="line">            if i&lt;&#x3D;j:</span><br><span class="line">                distance[i].append(math.sqrt((cities[i][0]-cities[j][0])**2+(cities[i][1]-cities[j][1])**2))</span><br><span class="line">            else:</span><br><span class="line">                distance[i].append(distance[j][i])</span><br><span class="line">                </span><br><span class="line"># 计算一个解的路径总长度</span><br><span class="line">def totalDistance(arr):</span><br><span class="line">    res &#x3D; 0</span><br><span class="line">    for i in range(len(arr)-1):</span><br><span class="line">        res +&#x3D; distance[arr[i]][arr[i+1]]</span><br><span class="line">    res +&#x3D; distance[arr[-1]][arr[0]]</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure></div><div id="echarts1525" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts1525'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>在最优解搜索问题中，首先需要明确的是解的形式是什么以及评价解好坏的标准是什么。在旅行商问题中，解的形式是遍历城市的顺序，也就是城市数组排列的一种顺序，评价解的标准是路径总长度。</p><h1 id="2-精确算法"><a href="#2-精确算法" class="headerlink" title="2 精确算法"></a>2 精确算法</h1><p>精确算法得到的结果是全局最优解，因而在求解NP完全问题时必然会遇到时间复杂度爆炸的瓶颈。</p><h2 id="2-1-暴力搜索"><a href="#2-1-暴力搜索" class="headerlink" title="2.1 暴力搜索"></a>2.1 暴力搜索</h2><p>暴力搜索是采用深度优先遍历，依次遍历所有可能的路径，保证最终能得到全局最优解。算法结构简单，占用空间小，但在问题包含 $N$ 个节点的情况下总路径数高达 $N!$ ，时间复杂度也是 $O(N!)$ 。</p><h2 id="2-2-动态规划"><a href="#2-2-动态规划" class="headerlink" title="2.2 动态规划"></a>2.2 动态规划</h2><p>首先要证明动态规划的可行性，即问题的最优解所包含的子问题的解也是最优的。在本题中就是要证明，当 $s_0\rightarrow s_1\rightarrow s_2 … \rightarrow s_{n-1} \rightarrow s_0$ 是从 $s_0$ 出发经过 $n$ 个城市回到 $s_0$ 的最短路径时，子问题 $s_1\rightarrow s_2…\rightarrow s_{n-1} \rightarrow s_0$ 就是从 $s_1$ 出发经过 $n-1$ 个城市到达 $s_0$ 的最短路径，使用反证法就能证明。</p><p>设 $dp(i,V)$ 表示从顶点 $s_i$ 出发经过 $V$ 中各个顶点一次且仅一次，最后回到出发点 $s_0$ 的最短路径长度。当 $V$ 是空集时，直接回到 $s_0$ 即可，路径长度就是 $s_i$ 到 $s_0$ 的距离，记为 $dp(i,\emptyset)=c_{i0}$ ，当 $V$ 不是空集时，就要遍历当前可选择的所有子问题，即 $dp(i,V)=min{c_{ik}+dp(k,V-{k})}$</p><p>时间复杂度 $O(2^nn^2)$ ，空间复杂度 $O(n2^n)$ </p><h1 id="3-个体启发式算法"><a href="#3-个体启发式算法" class="headerlink" title="3 个体启发式算法"></a>3 个体启发式算法</h1><h2 id="3-1-爬山法"><a href="#3-1-爬山法" class="headerlink" title="3.1 爬山法"></a>3.1 爬山法</h2><p>爬山法是一种简单的局部择优的算法。算法从一个随机位置开始（也就是先随机生成一个解），在每次迭代中随机访问当前最优解附近的一个解（也就是对当前最优解做一些微小的改变），如果新的解更优就更新为当前最优解，如果新的解更差就丢弃。直到在当前最优解附近找不到更优解，说明算法找到了一个局部最优解，就把这个解当做最终结果返回。在实际应用时，用这种随机方法寻找局部最优的时间可能很长，为了缩短程序的运行时间，需要设定最大迭代次数，当算法已经达到最大迭代次数，即使还未找到局部最优解也要停止迭代，返回当前最优解。Python3实现如下，迭代次数设为十万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def hillClimb():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    # 初始的随机解</span><br><span class="line">    arr &#x3D; list(range(len(cities)))</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    maxIter &#x3D; 100000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%1000&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        # 每次对解的改变就是随机交换两个位置的值</span><br><span class="line">        change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">        arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        newDistance &#x3D; totalDistance(arr)</span><br><span class="line">        if newDistance&lt;minDistance or minDistance&lt;0:</span><br><span class="line">            minDistance &#x3D; newDistance</span><br><span class="line">        else:</span><br><span class="line">            # 不是更优解就恢复原样</span><br><span class="line">            arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in arr]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts5289" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts5289'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[172, 93], [172, 77], [172, 69], [180, 61], [180, 53], [180, 29], [172, 29], [180, 77], [180, 85], [180, 101], [180, 109], [172, 109], [164, 137], [172, 145], [204, 145], [220, 145], [280, 109], [284, 93], [284, 85], [284, 77], [276, 85], [276, 93], [276, 101], [268, 97], [252, 101], [156, 137], [132, 137], [56, 129], [56, 145], [104, 161], [116, 161], [124, 169], [56, 153], [40, 145], [40, 137], [8, 41], [16, 25], [16, 17], [24, 17], [24, 25], [32, 73], [32, 89], [40, 99], [40, 113], [56, 121], [132, 169], [148, 169], [164, 169], [172, 169], [164, 145], [180, 117], [236, 85], [236, 77], [260, 77], [260, 85], [260, 93], [276, 77], [284, 69], [284, 61], [284, 53], [276, 61], [276, 69], [236, 69], [220, 73], [180, 69], [140, 65], [132, 61], [104, 49], [80, 41], [64, 41], [72, 41], [80, 25], [72, 25], [64, 21], [44, 11], [56, 9], [56, 17], [44, 35], [48, 51], [56, 81], [56, 89], [104, 105], [124, 109], [172, 85], [188, 93], [220, 125], [228, 145], [228, 125], [228, 117], [212, 117], [204, 109], [172, 101], [148, 85], [132, 81], [124, 85], [124, 77], [164, 81], [196, 101], [236, 145], [246, 141], [246, 157], [256, 157], [256, 141], [270, 133], [260, 129], [260, 109], [252, 125], [140, 145], [104, 169], [56, 169], [40, 161], [32, 161], [16, 109], [8, 89], [8, 57], [8, 49], [72, 9], [148, 9], [162, 9], [228, 21], [228, 29], [180, 21], [172, 21], [124, 37], [104, 41], [48, 63], [48, 73], [56, 73], [124, 117], [124, 125], [148, 137], [148, 145], [140, 137], [132, 145], [124, 145], [80, 157], [40, 169], [32, 169], [48, 83], [44, 43], [56, 25], [44, 27], [56, 33], [56, 41], [56, 105], [56, 113], [56, 137], [64, 157], [124, 101], [172, 61], [172, 53], [180, 45], [172, 45], [104, 57], [72, 49], [56, 57], [8, 81], [8, 73], [8, 65], [16, 57], [40, 63], [104, 89], [172, 117], [172, 125], [180, 125], [196, 145], [188, 145], [196, 161], [204, 169], [212, 169], [220, 169], [236, 169], [288, 149], [280, 133], [288, 129], [288, 109], [284, 101], [276, 53], [260, 29], [260, 37], [260, 45], [260, 53], [260, 61], [260, 69], [236, 45], [228, 37], [156, 25], [132, 21], [124, 21], [104, 33], [88, 49], [56, 97], [40, 121], [40, 129], [32, 137], [32, 129], [48, 99], [32, 25], [32, 17], [32, 41], [32, 65], [32, 97], [32, 113], [32, 121], [32, 145], [32, 153], [40, 153], [56, 161], [64, 165], [90, 165], [104, 153], [104, 137], [104, 145], [104, 129], [104, 121], [104, 113], [104, 81], [124, 53], [124, 61], [124, 69], [124, 93], [104, 73], [104, 65], [120, 9], [128, 9], [136, 9], [236, 29], [236, 21], [252, 21], [236, 37], [236, 53], [236, 61], [228, 109], [228, 161], [228, 169], [156, 145], [104, 97], [56, 49], [40, 51], [32, 49], [24, 45], [32, 57], [40, 83], [116, 145], [140, 169], [156, 169], [188, 169], [196, 169], [212, 145], [212, 65], [204, 57], [196, 49], [188, 41], [180, 37], [172, 37], [124, 45], [24, 89], [16, 97], [8, 109], [8, 97], [32, 81], [40, 73], [56, 65], [124, 29], [104, 17], [92, 9], [80, 9], [80, 25], [104, 25], [228, 53], [228, 45], [228, 61], [228, 69], [228, 77], [228, 85], [228, 101], [236, 101], [236, 93], [228, 93], [180, 93], [172, 93]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts4741" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts4741'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 34785.44749211156], [1000, 19353.928053910957], [2000, 15990.36106539108], [3000, 13907.361486648882], [4000, 12971.698829665102], [5000, 12106.015187587398], [6000, 11577.194724429764], [7000, 11387.98014104181], [8000, 11056.166015957479], [9000, 10747.544899934497], [10000, 10498.786823810482], [11000, 10179.57792450684], [12000, 9993.936333501777], [13000, 9910.278995349185], [14000, 9707.430276491103], [15000, 9592.808588624914], [16000, 9484.865119491764], [17000, 9354.789411464242], [18000, 9254.173599187503], [19000, 9211.638126464617], [20000, 9181.18561703581], [21000, 9129.946669826419], [22000, 9066.05502216996], [23000, 8947.643079000773], [24000, 8900.300665097733], [25000, 8858.430157973986], [26000, 8836.329616787592], [27000, 8801.868282679843], [28000, 8719.997067290158], [29000, 8657.454477721523], [30000, 8574.353392823134], [31000, 8510.628362689293], [32000, 8479.416515422137], [33000, 8350.620891677423], [34000, 8335.515801596865], [35000, 8320.650047002355], [36000, 8287.24830679945], [37000, 8263.777278938045], [38000, 8247.106338742791], [39000, 8225.139486807644], [40000, 8194.08962455832], [41000, 8160.6053551791365], [42000, 8133.806386817915], [43000, 8109.544807824241], [44000, 8076.693962845321], [45000, 8035.16907287191], [46000, 8032.495698356345], [47000, 8003.770743108615], [48000, 8003.770743108615], [49000, 7992.78996700886], [50000, 7980.460079147163], [51000, 7977.50615436722], [52000, 7961.833045793833], [53000, 7922.133569884537], [54000, 7897.88553922839], [55000, 7883.355987998853], [56000, 7845.334587547549], [57000, 7845.334587547549], [58000, 7827.847336635698], [59000, 7796.449910154846], [60000, 7776.99396386195], [61000, 7756.087485672815], [62000, 7746.450618302975], [63000, 7720.388837188945], [64000, 7701.099280287324], [65000, 7673.778341851368], [66000, 7664.8874403526925], [67000, 7658.280148888139], [68000, 7650.594077955203], [69000, 7628.45643887525], [70000, 7607.530023210174], [71000, 7597.594964510844], [72000, 7581.228277996682], [73000, 7561.654187119], [74000, 7531.348802729719], [75000, 7503.540382879502], [76000, 7493.710356815283], [77000, 7465.474074409009], [78000, 7455.788115130572], [79000, 7432.020821554273], [80000, 7414.6115815021785], [81000, 7401.726180560843], [82000, 7387.128172921726], [83000, 7373.812777236357], [84000, 7357.904505175984], [85000, 7355.067455725333], [86000, 7314.32368344745], [87000, 7296.716964497638], [88000, 7281.119395664033], [89000, 7263.907853160585], [90000, 7257.27443861171], [91000, 7250.239652458733], [92000, 7244.659180080416], [93000, 7244.245231903331], [94000, 7243.60911086437], [95000, 7236.705814133342], [96000, 7229.788199215191], [97000, 7219.717981814576], [98000, 7189.255339293897], [99000, 7171.7915439014705], [100000, 7162.610316569084]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="3-2-模拟退火"><a href="#3-2-模拟退火" class="headerlink" title="3.2 模拟退火"></a>3.2 模拟退火</h2><p>模拟退火算法（Simulated Annealing，SA）借鉴了物理中固体物质的退火过程，将固体加热到足够高的温度，使分子呈随机排列状态，然后逐步降温使之冷却，最后分子以低能状态排列，固体达到某种稳定状态。</p><p>模拟退火算法首先初始化一个随机解、一个较高的初始温度和一个降温速率，在每次迭代中对当前最优解做微小改变，如果新的解是更优解，就更新为当前最优解，与爬山法不同的是，如果新的解不是更优解，则以一个与当前温度呈正相关的概率接受新的解，一般根据Metropolis接受准则把概率设为 $p=exp(-\Delta F/T), \Delta F&gt;0$ ，其中 $\Delta F$ 是两个解在评估函数下的差值， $T$ 是当前温度。</p><p>以一定概率接受更差的解让算法有机会逃离局部最优，理论上能比爬山法找到更好的解。而随着温度下降，接受概率越来越低，最终趋近于0，表示不再接受差解，算法将收敛到一个更好的局部最优解。Python3实现如下，迭代次数设为十万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">def SA():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    # 初始的随机解</span><br><span class="line">    arr &#x3D; list(range(len(cities)))</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    maxIter &#x3D; 100000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    T &#x3D; 10000</span><br><span class="line">    alpha &#x3D; 0.99</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%1000&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        # 每次对解的改变就是随机交换两个位置的值</span><br><span class="line">        change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">        arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        newDistance &#x3D; totalDistance(arr)</span><br><span class="line">        if newDistance&lt;minDistance or minDistance&lt;0:</span><br><span class="line">            minDistance &#x3D; newDistance</span><br><span class="line">        # 一定概率接受差解</span><br><span class="line">        elif random.random()&lt;math.exp(-(newDistance-minDistance)&#x2F;T):</span><br><span class="line">            minDistance &#x3D; newDistance</span><br><span class="line">        else:</span><br><span class="line">            arr[change[0]],arr[change[1]] &#x3D; arr[change[1]],arr[change[0]]</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">        T *&#x3D; alpha</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in arr]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts4031" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts4031'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[32, 41], [16, 57], [8, 89], [8, 109], [16, 109], [32, 137], [32, 145], [32, 129], [8, 97], [8, 57], [8, 41], [16, 25], [16, 17], [24, 17], [32, 17], [44, 27], [72, 41], [80, 41], [104, 57], [104, 65], [104, 81], [104, 73], [124, 29], [132, 21], [156, 25], [172, 21], [180, 21], [180, 29], [180, 37], [188, 41], [228, 21], [228, 29], [236, 37], [236, 45], [228, 45], [228, 53], [204, 57], [180, 69], [172, 69], [40, 83], [32, 89], [48, 83], [56, 81], [104, 89], [140, 65], [172, 61], [180, 61], [212, 65], [228, 93], [228, 101], [228, 109], [252, 125], [236, 145], [246, 141], [260, 129], [236, 101], [236, 93], [220, 73], [180, 45], [172, 37], [88, 49], [72, 49], [64, 41], [56, 49], [48, 73], [48, 99], [40, 99], [32, 153], [32, 161], [40, 161], [40, 153], [104, 129], [172, 85], [180, 85], [180, 93], [188, 93], [228, 77], [228, 85], [236, 85], [280, 109], [270, 133], [256, 141], [256, 157], [246, 157], [220, 169], [196, 169], [188, 169], [172, 169], [164, 169], [132, 169], [104, 113], [40, 73], [32, 73], [32, 65], [40, 63], [40, 51], [44, 43], [56, 25], [64, 21], [80, 25], [80, 25], [180, 77], [252, 101], [280, 133], [288, 109], [284, 85], [276, 69], [260, 53], [260, 61], [260, 77], [228, 117], [212, 145], [116, 161], [104, 161], [104, 153], [104, 145], [32, 49], [24, 45], [32, 25], [56, 33], [92, 9], [104, 17], [120, 9], [128, 9], [136, 9], [124, 21], [124, 61], [124, 77], [132, 81], [172, 117], [196, 161], [204, 169], [212, 169], [220, 145], [236, 77], [228, 61], [228, 37], [260, 37], [260, 45], [284, 69], [276, 77], [260, 69], [196, 49], [172, 45], [172, 53], [180, 53], [228, 69], [236, 69], [236, 61], [260, 29], [252, 21], [236, 21], [236, 29], [172, 101], [172, 109], [180, 109], [180, 117], [212, 117], [204, 109], [196, 101], [180, 101], [172, 93], [104, 97], [56, 65], [56, 73], [56, 89], [40, 113], [56, 121], [104, 137], [132, 137], [140, 137], [172, 145], [164, 137], [164, 145], [156, 145], [148, 137], [124, 101], [124, 93], [164, 81], [172, 77], [260, 85], [260, 93], [268, 97], [276, 93], [276, 85], [284, 93], [284, 101], [288, 129], [288, 149], [236, 169], [228, 169], [228, 161], [228, 145], [220, 125], [148, 145], [140, 145], [132, 145], [64, 165], [56, 169], [40, 169], [32, 169], [40, 145], [40, 137], [40, 121], [56, 113], [56, 105], [56, 97], [56, 57], [72, 25], [80, 9], [72, 9], [56, 17], [44, 35], [32, 113], [32, 121], [40, 129], [56, 129], [56, 137], [56, 145], [116, 145], [196, 145], [204, 145], [228, 125], [260, 109], [276, 101], [284, 77], [284, 61], [276, 61], [284, 53], [276, 53], [236, 53], [172, 29], [162, 9], [148, 9], [56, 41], [48, 51], [48, 63], [32, 81], [24, 89], [16, 97], [8, 81], [8, 73], [8, 65], [8, 49], [24, 25], [44, 11], [56, 9], [104, 25], [104, 33], [104, 41], [104, 49], [132, 61], [124, 85], [104, 105], [104, 121], [124, 169], [124, 145], [124, 125], [124, 117], [156, 137], [172, 125], [188, 145], [180, 125], [148, 85], [124, 53], [124, 45], [124, 37], [124, 69], [124, 109], [156, 169], [148, 169], [140, 169], [104, 169], [90, 165], [80, 157], [64, 157], [56, 161], [56, 153], [32, 97], [32, 57], [32, 41]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts3038" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts3038'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 33914.60282260142], [1000, 21270.207203195747], [2000, 16265.112854912211], [3000, 14299.767111200072], [4000, 13408.644532288059], [5000, 12339.311403835165], [6000, 11823.985679204936], [7000, 11340.060799778334], [8000, 10863.903182397295], [9000, 10686.875031225838], [10000, 10596.85666254361], [11000, 10451.941764063176], [12000, 10280.422705331453], [13000, 10044.441189882806], [14000, 9869.56451305229], [15000, 9753.033813298916], [16000, 9552.69239083618], [17000, 9441.766474587757], [18000, 9359.747071906064], [19000, 9226.203899000713], [20000, 9079.179917384592], [21000, 8959.383039845281], [22000, 8877.551048473331], [23000, 8817.714324753268], [24000, 8738.491978633952], [25000, 8686.918621102634], [26000, 8630.222988717873], [27000, 8622.913625929883], [28000, 8568.295779995724], [29000, 8468.68454402818], [30000, 8449.181390727734], [31000, 8359.869091551473], [32000, 8261.168345179232], [33000, 8233.750270533823], [34000, 8190.034063630316], [35000, 8140.79462671016], [36000, 8128.658561316616], [37000, 8118.778995284066], [38000, 8077.483249476699], [39000, 8052.586715575036], [40000, 8019.217846182968], [41000, 8002.205777605603], [42000, 7970.2023637285165], [43000, 7952.3704645344], [44000, 7936.880848055674], [45000, 7925.326070917763], [46000, 7856.029446794221], [47000, 7847.696786030943], [48000, 7826.492945497338], [49000, 7817.134810060771], [50000, 7802.275591244446], [51000, 7795.9553643803465], [52000, 7776.3994280254265], [53000, 7774.510884205429], [54000, 7769.328707059647], [55000, 7732.0669905684845], [56000, 7689.552626860808], [57000, 7608.917431266603], [58000, 7529.500704854002], [59000, 7525.151492554089], [60000, 7483.045048948701], [61000, 7463.155471971213], [62000, 7463.155471971213], [63000, 7453.030001510787], [64000, 7439.796155583298], [65000, 7400.594587954039], [66000, 7380.726291722335], [67000, 7377.720146717941], [68000, 7372.2296017471335], [69000, 7347.252534616578], [70000, 7328.506489513188], [71000, 7310.4996327846575], [72000, 7308.063033400559], [73000, 7277.750739408965], [74000, 7277.750739408965], [75000, 7277.750739408965], [76000, 7276.375076640651], [77000, 7239.6198953633675], [78000, 7223.211139312575], [79000, 7222.101896122617], [80000, 7204.190999948586], [81000, 7168.37394620814], [82000, 7130.631996481255], [83000, 7107.593395968574], [84000, 7058.659038192923], [85000, 7026.328141448473], [86000, 7009.3114853990855], [87000, 6993.94744719539], [88000, 6974.881458775223], [89000, 6971.567750276238], [90000, 6964.771051249861], [91000, 6950.13105705818], [92000, 6930.272598874511], [93000, 6908.141847824359], [94000, 6890.168476817055], [95000, 6876.768343682251], [96000, 6874.833600240957], [97000, 6858.471825848977], [98000, 6853.884080443336], [99000, 6848.763030961273], [100000, 6841.984535031416]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="3-3-禁忌搜索"><a href="#3-3-禁忌搜索" class="headerlink" title="3.3 禁忌搜索"></a>3.3 禁忌搜索</h2><p>禁忌搜索（Tabu Search或Taboo Search，简称TS）是对局部搜索（LS）的一种扩展，是一种全局寻优算法，其特点是采用禁忌技术，即用一个禁忌表记录下已经到达过的局部最优点及求解过程，在下一次搜索中，利用禁忌表中的信息不再或有选择地搜索这些点，以此来跳出局部最优点。该算法可以克服爬山算法全局搜索能力不强的弱点。</p><p>算法流程如下，</p><p><a href="https://file.shivakasu.cn/d1a41dd3e548144b7516/arg3-0.jpg" data-fancybox="group" data-caption="arg3-0" class="fancybox"><img alt="arg3-0" data-src="https://file.shivakasu.cn/d1a41dd3e548144b7516/arg3-0.jpg" class="lazyload" title="arg3-0"></a></p><p>Python3实现如下，迭代次数设为四万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def TS():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    maxIter &#x3D; 40000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    searchNum &#x3D; 200</span><br><span class="line">    tabuLen &#x3D; 20</span><br><span class="line">    tabuTable &#x3D; []</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    # 初始的随机解</span><br><span class="line">    arr &#x3D; list(range(len(cities)))</span><br><span class="line">    random.shuffle(arr)</span><br><span class="line">    minDistance &#x3D; totalDistance(arr)</span><br><span class="line">    localBestPath &#x3D; []</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%400&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        # 当前邻域搜索</span><br><span class="line">        while i&lt;searchNum:</span><br><span class="line">            tmp &#x3D; copy.deepcopy(arr)</span><br><span class="line">            change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">            tmp[change[0]],tmp[change[1]] &#x3D; tmp[change[1]],tmp[change[0]]</span><br><span class="line">            # 搜索不在禁忌表中的解</span><br><span class="line">            if tmp not in tabuTable:</span><br><span class="line">                newDistance &#x3D; totalDistance(tmp)</span><br><span class="line">                if newDistance&lt;minDistance:</span><br><span class="line">                    localBestPath &#x3D; copy.deepcopy(tmp)</span><br><span class="line">                    minDistance &#x3D; newDistance</span><br><span class="line">                i +&#x3D; 1</span><br><span class="line">        arr &#x3D; copy.deepcopy(localBestPath)</span><br><span class="line">        # 更新禁忌表</span><br><span class="line">        if len(tabuTable)&#x3D;&#x3D;tabuLen:</span><br><span class="line">            tabuTable &#x3D; tabuTable[1:]</span><br><span class="line">        tabuTable.append(localBestPath)</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in arr]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts2913" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts2913'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[48, 51], [56, 49], [72, 49], [104, 33], [156, 25], [172, 29], [172, 37], [180, 45], [180, 53], [180, 61], [124, 69], [56, 57], [16, 57], [8, 57], [8, 49], [8, 41], [16, 25], [24, 45], [32, 41], [56, 65], [104, 121], [104, 129], [104, 137], [56, 137], [56, 129], [40, 129], [40, 121], [32, 121], [32, 129], [40, 137], [56, 145], [124, 145], [260, 109], [276, 93], [284, 93], [284, 85], [284, 77], [284, 69], [284, 61], [284, 53], [276, 53], [260, 29], [252, 21], [236, 21], [56, 9], [44, 11], [56, 17], [64, 21], [228, 109], [252, 125], [260, 129], [270, 133], [256, 141], [246, 141], [236, 145], [220, 125], [212, 117], [180, 101], [172, 93], [180, 93], [180, 85], [172, 85], [172, 77], [164, 81], [72, 25], [56, 25], [44, 35], [44, 43], [32, 49], [32, 65], [32, 81], [48, 99], [56, 121], [56, 153], [56, 161], [56, 169], [40, 169], [32, 169], [32, 161], [40, 161], [40, 153], [40, 113], [40, 99], [32, 97], [32, 89], [24, 89], [16, 97], [8, 89], [8, 97], [32, 137], [32, 145], [32, 153], [40, 145], [56, 113], [56, 105], [88, 49], [104, 25], [104, 17], [124, 29], [124, 37], [124, 45], [124, 53], [180, 69], [204, 57], [236, 61], [260, 53], [260, 45], [260, 37], [236, 53], [228, 61], [220, 73], [188, 93], [196, 101], [204, 109], [228, 117], [228, 125], [228, 145], [220, 145], [212, 145], [196, 145], [188, 145], [172, 145], [172, 125], [180, 125], [180, 117], [228, 77], [236, 69], [236, 45], [236, 37], [236, 29], [180, 29], [180, 21], [172, 21], [162, 9], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 41], [104, 49], [124, 61], [132, 61], [140, 65], [172, 69], [172, 61], [172, 53], [172, 45], [180, 37], [188, 41], [196, 49], [228, 21], [228, 29], [228, 37], [228, 45], [228, 53], [228, 69], [228, 85], [228, 93], [236, 93], [268, 97], [276, 101], [284, 101], [280, 109], [280, 133], [236, 169], [228, 169], [220, 169], [204, 145], [196, 161], [188, 169], [172, 169], [164, 169], [164, 137], [172, 109], [172, 101], [148, 85], [132, 81], [104, 81], [40, 73], [32, 73], [8, 65], [8, 73], [8, 81], [32, 113], [64, 157], [104, 169], [116, 161], [124, 169], [132, 169], [140, 169], [148, 169], [140, 145], [132, 137], [140, 137], [148, 145], [148, 137], [124, 117], [124, 125], [116, 145], [104, 161], [90, 165], [64, 165], [80, 157], [104, 153], [104, 145], [124, 109], [124, 101], [124, 93], [124, 85], [124, 77], [104, 65], [80, 41], [72, 41], [32, 25], [24, 25], [16, 17], [24, 17], [32, 17], [44, 27], [56, 33], [56, 41], [64, 41], [120, 9], [128, 9], [136, 9], [148, 9], [132, 21], [124, 21], [104, 57], [56, 89], [56, 97], [16, 109], [8, 109], [40, 83], [48, 83], [48, 73], [56, 73], [56, 81], [104, 89], [104, 97], [104, 105], [104, 113], [132, 145], [156, 169], [196, 169], [204, 169], [212, 169], [228, 161], [246, 157], [276, 85], [276, 77], [276, 69], [276, 61], [288, 109], [288, 129], [288, 149], [256, 157], [164, 145], [156, 145], [156, 137], [172, 117], [180, 109], [228, 101], [236, 101], [252, 101], [260, 93], [260, 85], [260, 77], [236, 85], [236, 77], [260, 69], [260, 61], [212, 65], [180, 77], [104, 73], [48, 63], [40, 63], [32, 57], [40, 51], [48, 51]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts208" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts208'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 33890.23101543088], [400, 9414.267797183507], [800, 7693.759751536997], [1200, 6968.071523569924], [1600, 6637.457204487098], [2000, 6159.892480829687], [2400, 6042.076698585728], [2800, 5950.848808320309], [3200, 5913.12574102969], [3600, 5901.85703497971], [4000, 5891.8393048938215], [4400, 5891.8393048938215], [4800, 5891.8393048938215], [5200, 5891.8393048938215], [5600, 5891.8393048938215], [6000, 5891.8393048938215], [6400, 5891.8393048938215], [6800, 5891.8393048938215], [7200, 5891.8393048938215], [7600, 5891.8393048938215], [8000, 5891.8393048938215], [8400, 5891.8393048938215], [8800, 5891.8393048938215], [9200, 5891.8393048938215], [9600, 5891.8393048938215], [10000, 5891.8393048938215], [10400, 5891.8393048938215], [10800, 5891.8393048938215], [11200, 5891.8393048938215], [11600, 5891.8393048938215], [12000, 5891.8393048938215], [12400, 5891.8393048938215], [12800, 5891.8393048938215], [13200, 5891.8393048938215], [13600, 5891.8393048938215], [14000, 5891.8393048938215], [14400, 5891.8393048938215], [14800, 5891.8393048938215], [15200, 5891.8393048938215], [15600, 5891.8393048938215], [16000, 5891.8393048938215], [16400, 5891.8393048938215], [16800, 5891.8393048938215], [17200, 5891.8393048938215], [17600, 5891.8393048938215], [18000, 5891.8393048938215], [18400, 5891.8393048938215], [18800, 5891.8393048938215], [19200, 5891.8393048938215], [19600, 5891.8393048938215], [20000, 5891.8393048938215], [20400, 5891.8393048938215], [20800, 5891.8393048938215], [21200, 5891.8393048938215], [21600, 5891.8393048938215], [22000, 5891.8393048938215], [22400, 5891.8393048938215], [22800, 5891.8393048938215], [23200, 5891.8393048938215], [23600, 5891.8393048938215], [24000, 5891.8393048938215], [24400, 5891.8393048938215], [24800, 5891.8393048938215], [25200, 5891.8393048938215], [25600, 5891.8393048938215], [26000, 5891.8393048938215], [26400, 5891.8393048938215], [26800, 5891.8393048938215], [27200, 5891.8393048938215], [27600, 5891.8393048938215], [28000, 5891.8393048938215], [28400, 5891.8393048938215], [28800, 5891.8393048938215], [29200, 5891.8393048938215], [29600, 5891.8393048938215], [30000, 5891.8393048938215], [30400, 5891.8393048938215], [30800, 5891.8393048938215], [31200, 5891.8393048938215], [31600, 5891.8393048938215], [32000, 5891.8393048938215], [32400, 5891.8393048938215], [32800, 5891.8393048938215], [33200, 5891.8393048938215], [33600, 5891.8393048938215], [34000, 5891.8393048938215], [34400, 5891.8393048938215], [34800, 5891.8393048938215], [35200, 5891.8393048938215], [35600, 5891.8393048938215], [36000, 5891.8393048938215], [36400, 5891.8393048938215], [36800, 5891.8393048938215], [37200, 5891.8393048938215], [37600, 5891.8393048938215], [38000, 5891.8393048938215], [38400, 5891.8393048938215], [38800, 5891.8393048938215], [39200, 5891.8393048938215], [39600, 5891.8393048938215], [40000, 5891.8393048938215]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h1 id="4-群体启发式算法"><a href="#4-群体启发式算法" class="headerlink" title="4 群体启发式算法"></a>4 群体启发式算法</h1><h2 id="4-1-遗传算法"><a href="#4-1-遗传算法" class="headerlink" title="4.1 遗传算法"></a>4.1 遗传算法</h2><p>遗传算法（GeneticAlgorithm ，GA ）借鉴了生物进化过程来优化随机搜索策略，与上述两种算法不同的是，遗传算法维护并更新的不是单个解，而是用一组解模拟种群。在迭代中主要模拟选择、遗传、变异、免疫等过程实现种群中个体信息的交换，提升整个种群的质量。在本题中的主要步骤如下：</p><ul><li>1、初始化种群规模、迭代次数、突变概率三个参数</li><li>2、随机生成一组解，代表初代种群。根据每个解的路径长度设定它的适应度，适应度表示个体对环境的适应程度，优胜劣汰，越是精英的个体适应度应该越高，所以路径长度越短的解适应度就越高。设 $dis[i]$ 表示种群中第 $i$ 个解的路径长度， $totalDis$ 表示种群中所有解的路径长度总和，那么第 $i$ 个解的适应度就是:<script type="math/tex; mode=display">P(i) = \frac{\frac{totalDis}{dis[i]}}{\sum_k \frac{totalDis}{dis[k]}}</script></li><li>3、父代选择。选择将要生成下一代的两个父代个体，同样为了保证优胜劣汰，要让适应度高的个体容易被选中。一般采用轮盘赌法选择个体，首先产生一个随机概率 $rand$ ，依次累种群个体的适应度，当出现 $rand &lt; \sum_{k=0}^jP(k)$ 时，说明从第0个个体到第 $j$ 个个体的累积适应度超过了随机概率 $rand$ ，此时选择第 $j$ 个个体，完成一次选择过程。之所以叫轮盘赌法，是因为这个选择过程就好像以一个随机的力度转轮盘，结果从0转到 $j$ 停止，非常形象。</li><li>4、两个父代个体杂交产生一个子代个体。方法不固定，只要是综合两个解的信息生成新的解就可以，根据方法的不同，既可以生成一个子代，也可以生成两个子代。本文采取的方法是，随机生成一个交叉点 $i$ ，两个父代中位于交叉点之前的城市顺序不变，而交叉点之后的城市顺序改成在对方中的顺序，交叉完毕后两个父代变成了两个新的子代。</li><li>5、子代变异。对于杂交产生的每个子代，生成一个随机数，如果随机数小于预设的变异概率，就对该子代做微小改变，视为遗传变异。本文采取的变异方法是随机交换两个城市的位置。</li><li>6、种群更新。保留子代中的精英个体，本文采取的方式是通过杂交变异生成两倍种群大小的子代，根据每个子代的路径长度排序，选择路径最短的一半作为新一代种群。</li></ul><p>Python3实现如下，迭代次数设为四万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">def GA():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    groupSize &#x3D; 1000</span><br><span class="line">    # 突变概率</span><br><span class="line">    mutation &#x3D; 0.01</span><br><span class="line">    maxIter &#x3D; 40000</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    fatherGroup &#x3D; []</span><br><span class="line">    sonGroup &#x3D; []</span><br><span class="line">    fitness &#x3D; []</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    minPath &#x3D; []</span><br><span class="line">    # 初始化种群</span><br><span class="line">    totalDis &#x3D; 0</span><br><span class="line">    for i in range(groupSize):</span><br><span class="line">        arr &#x3D; list(range(len(cities)))</span><br><span class="line">        random.shuffle(arr)</span><br><span class="line">        fatherGroup.append(arr)</span><br><span class="line">        d &#x3D; totalDistance(arr)</span><br><span class="line">        fitness.append(d)</span><br><span class="line">        totalDis +&#x3D; d</span><br><span class="line">    # 计算适应度</span><br><span class="line">    fitness &#x3D; [totalDis&#x2F;i for i in fitness]</span><br><span class="line">    totalFit &#x3D; sum(fitness)</span><br><span class="line">    fitness &#x3D; [i&#x2F;totalFit for i in fitness]</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%400&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            print(&quot;ga: &quot;+str(currIter))</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        sonDis &#x3D; []</span><br><span class="line">        # 杂交</span><br><span class="line">        for i in range(groupSize):</span><br><span class="line">            # 轮盘赌选择父代</span><br><span class="line">            f1 &#x3D; -1</span><br><span class="line">            r &#x3D; random.random()</span><br><span class="line">            p &#x3D; 0    </span><br><span class="line">            while r&gt;p:</span><br><span class="line">                f1 +&#x3D; 1</span><br><span class="line">                p +&#x3D; fitness[f1]</span><br><span class="line">            f2 &#x3D; f1</span><br><span class="line">            while f1&#x3D;&#x3D;f2:</span><br><span class="line">                f2 &#x3D; -1</span><br><span class="line">                r &#x3D; random.random()</span><br><span class="line">                p &#x3D; 0    </span><br><span class="line">                while r&gt;p:</span><br><span class="line">                    f2 +&#x3D; 1</span><br><span class="line">                    p +&#x3D; fitness[f2]</span><br><span class="line">            f1 &#x3D; fatherGroup[f1]</span><br><span class="line">            f2 &#x3D; fatherGroup[f2]</span><br><span class="line">            # 杂交生成两个子代</span><br><span class="line">            r &#x3D; random.randint(0,len(cities)-2)</span><br><span class="line">            s1 &#x3D; f1[:i]</span><br><span class="line">            s2 &#x3D; f2[:i]</span><br><span class="line">            for k in f1:</span><br><span class="line">                if k not in s2:</span><br><span class="line">                    s2.append(k)</span><br><span class="line">            for k in f2:</span><br><span class="line">                if k not in s1:</span><br><span class="line">                    s1.append(k)</span><br><span class="line">            r &#x3D; random.random()</span><br><span class="line">            if r&lt;mutation:</span><br><span class="line">                # 突变就是随机交换两个位置的值</span><br><span class="line">                change &#x3D; random.sample(range(len(cities)),2)</span><br><span class="line">                s1[change[0]],s1[change[1]] &#x3D; s1[change[1]],s1[change[0]]</span><br><span class="line">                s2[change[0]],s2[change[1]] &#x3D; s2[change[1]],s2[change[0]]</span><br><span class="line">            sonGroup.append(s1)</span><br><span class="line">            sonGroup.append(s2)</span><br><span class="line">            sonDis.append(totalDistance(s1))</span><br><span class="line">            sonDis.append(totalDistance(s2))</span><br><span class="line">        # 子代按路径长度排序</span><br><span class="line">        zipped&#x3D;zip(sonGroup,sonDis)</span><br><span class="line">        sort_zipped &#x3D; sorted(zipped,key&#x3D;lambda x:(x[1],x[0]))</span><br><span class="line">        result &#x3D; zip(*sort_zipped)</span><br><span class="line">        sonGroup, sonDis &#x3D; [list(x) for x in result]</span><br><span class="line">        sonGroup &#x3D; sonGroup[:groupSize]</span><br><span class="line">        sonDis &#x3D; sonDis[:groupSize]</span><br><span class="line">        # 种群更新</span><br><span class="line">        minDistance &#x3D; min(sonDis)</span><br><span class="line">        minPath &#x3D; sonGroup[sonDis.index(minDistance)]</span><br><span class="line">        totalDis &#x3D; sum(sonDis)</span><br><span class="line">        fitness &#x3D; [totalDis&#x2F;i for i in sonDis]</span><br><span class="line">        totalFit &#x3D; sum(fitness)</span><br><span class="line">        fitness &#x3D; [i&#x2F;totalFit for i in fitness]</span><br><span class="line">        fatherGroup &#x3D; sonGroup</span><br><span class="line">        sonGroup &#x3D; []</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in minPath]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts3359" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts3359'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[124, 45], [124, 37], [124, 29], [124, 21], [120, 9], [128, 9], [136, 9], [148, 9], [162, 9], [172, 21], [180, 21], [228, 45], [228, 53], [236, 45], [236, 53], [236, 61], [260, 77], [260, 85], [260, 93], [260, 109], [252, 125], [246, 141], [246, 157], [236, 169], [228, 169], [228, 161], [220, 169], [180, 125], [172, 125], [172, 117], [132, 61], [124, 53], [104, 33], [104, 25], [80, 25], [80, 25], [104, 73], [104, 105], [104, 113], [104, 121], [64, 157], [56, 153], [56, 145], [32, 137], [32, 129], [32, 121], [40, 121], [40, 129], [40, 137], [56, 129], [56, 121], [56, 113], [56, 105], [40, 99], [32, 97], [16, 57], [24, 25], [32, 25], [44, 27], [44, 35], [44, 43], [40, 63], [32, 73], [32, 65], [32, 57], [40, 51], [32, 49], [24, 45], [32, 41], [48, 51], [56, 49], [72, 41], [80, 41], [88, 49], [104, 49], [172, 53], [172, 61], [180, 61], [180, 69], [180, 77], [180, 85], [180, 101], [172, 101], [172, 109], [104, 97], [48, 83], [40, 83], [32, 89], [16, 97], [24, 89], [32, 81], [40, 73], [48, 73], [56, 73], [104, 81], [104, 89], [124, 85], [124, 93], [124, 101], [124, 109], [140, 137], [140, 145], [164, 169], [172, 169], [228, 145], [220, 145], [212, 145], [204, 145], [196, 145], [188, 145], [164, 145], [156, 145], [148, 145], [148, 137], [172, 37], [180, 29], [228, 21], [236, 21], [252, 21], [260, 29], [260, 37], [236, 37], [236, 29], [228, 29], [196, 49], [180, 53], [180, 45], [172, 45], [104, 41], [56, 57], [48, 63], [56, 65], [104, 65], [124, 69], [124, 77], [132, 81], [148, 85], [164, 81], [172, 85], [180, 93], [188, 93], [196, 101], [204, 109], [220, 125], [228, 125], [236, 145], [256, 157], [288, 149], [288, 129], [284, 85], [284, 77], [284, 69], [276, 77], [276, 93], [268, 97], [276, 101], [280, 109], [270, 133], [260, 129], [252, 101], [236, 101], [236, 93], [236, 85], [260, 61], [276, 69], [276, 61], [284, 61], [284, 53], [276, 53], [260, 53], [260, 45], [228, 37], [188, 41], [180, 37], [172, 29], [156, 25], [132, 21], [104, 17], [92, 9], [80, 9], [72, 9], [56, 25], [8, 41], [8, 49], [8, 57], [8, 65], [8, 73], [8, 81], [8, 89], [32, 113], [40, 113], [104, 137], [132, 145], [156, 137], [164, 137], [172, 145], [196, 161], [212, 169], [204, 169], [196, 169], [188, 169], [156, 169], [148, 169], [140, 169], [132, 169], [124, 169], [104, 169], [90, 165], [40, 161], [32, 161], [32, 153], [40, 145], [56, 137], [104, 129], [124, 125], [180, 109], [228, 109], [228, 101], [228, 93], [228, 85], [228, 77], [236, 77], [228, 69], [220, 73], [212, 65], [204, 57], [228, 61], [236, 69], [260, 69], [276, 85], [284, 93], [284, 101], [288, 109], [280, 133], [256, 141], [228, 117], [212, 117], [180, 117], [124, 117], [56, 97], [48, 99], [56, 89], [56, 81], [72, 25], [64, 21], [56, 17], [56, 9], [44, 11], [24, 17], [16, 17], [16, 25], [32, 17], [56, 33], [56, 41], [64, 41], [72, 49], [104, 57], [124, 61], [140, 65], [172, 69], [172, 77], [172, 93], [132, 137], [124, 145], [116, 145], [104, 145], [104, 153], [80, 157], [64, 165], [56, 161], [40, 153], [32, 145], [16, 109], [8, 97], [8, 109], [32, 169], [40, 169], [56, 169], [104, 161], [116, 161], [124, 45]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下：</p><div id="echarts2866" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts2866'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 31115.680460043088], [400, 15334.904769985365], [800, 12071.182794553366], [1200, 10698.827141318481], [1600, 9802.001624465336], [2000, 9363.246821117898], [2400, 8855.848613389555], [2800, 8549.646103173383], [3200, 7905.687169789544], [3600, 7640.008182252965], [4000, 7516.971538827085], [4400, 7460.390059229863], [4800, 7200.0973510901395], [5200, 7082.845365549378], [5600, 6978.533013510428], [6000, 6907.537885302301], [6400, 6869.699686143468], [6800, 6823.17796232125], [7200, 6674.49522306577], [7600, 6666.380071344395], [8000, 6633.3609340924295], [8400, 6597.376427533433], [8800, 6578.598330585508], [9200, 6556.286960088603], [9600, 6474.420573091844], [10000, 6456.020486728329], [10400, 6429.182170359672], [10800, 6371.598509726626], [11200, 6150.950225917906], [11600, 6137.483276498839], [12000, 6136.817159602187], [12400, 6128.433098194441], [12800, 6122.948394567252], [13200, 6121.990888588202], [13600, 6117.465969468466], [14000, 6108.045086009359], [14400, 6100.530453694365], [14800, 6044.424139457849], [15200, 6007.500448314685], [15600, 5994.222026814483], [16000, 5994.222026814483], [16400, 5994.222026814483], [16800, 5992.902025489408], [17200, 5987.447565187352], [17600, 5952.26454649637], [18000, 5926.7815784881], [18400, 5911.340727488466], [18800, 5903.943969863919], [19200, 5858.274377256338], [19600, 5677.451094165581], [20000, 5590.964423347894], [20400, 5583.820614362352], [20800, 5575.112715619656], [21200, 5564.2937512718345], [21600, 5564.2937512718345], [22000, 5558.186428738796], [22400, 5558.186428738796], [22800, 5558.186428738796], [23200, 5557.263600314162], [23600, 5557.263600314162], [24000, 5557.263600314162], [24400, 5557.263600314162], [24800, 5542.103563167821], [25200, 5538.32778373243], [25600, 5521.673384924751], [26000, 5516.955162350389], [26400, 5455.412913382425], [26800, 5454.581605653756], [27200, 5453.822244440534], [27600, 5453.118269038051], [28000, 5453.118269038051], [28400, 5453.118269038051], [28800, 5453.118269038051], [29200, 5446.960580111209], [29600, 5446.960580111209], [30000, 5443.485499230946], [30400, 5443.485499230946], [30800, 5443.485499230946], [31200, 5443.485499230946], [31600, 5443.485499230946], [32000, 5443.485499230946], [32400, 5443.485499230946], [32800, 5443.485499230946], [33200, 5438.761869151259], [33600, 5200.983199799323], [34000, 5200.983199799323], [34400, 5200.983199799323], [34800, 5200.983199799323], [35200, 5187.678339313514], [35600, 5171.529601838279], [36000, 5171.529601838279], [36400, 5171.529601838279], [36800, 5171.529601838279], [37200, 5171.529601838279], [37600, 5171.529601838279], [38000, 5171.529601838279], [38400, 5171.529601838279], [38800, 5171.529601838279], [39200, 5171.529601838279], [39600, 5171.529601838279], [40000, 5171.529601838279]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="4-2-蚁群算法"><a href="#4-2-蚁群算法" class="headerlink" title="4.2 蚁群算法"></a>4.2 蚁群算法</h2><p>蚁群算法（Ant Colony Optimization ，ACO ）的灵感来源于蚂蚁觅食。蚂蚁觅食是一种群体性行为，蚂蚁在寻找食物时，会在其经过的路径上释放一种信息素，并能够感知其他蚂蚁释放的信息素。信息素浓度的大小体现了路径的远近，因为蚂蚁会以较大的概率优先选择信息素浓度高的路径，并释放一定量的信息素，以增强该路径上的信息素浓度，这形成了一种正反馈，最终使得蚂蚁能够找到一条到食物源的最短路径。这种思路很适合解决旅行商问题，只需要把蚂蚁的行走路径表示为问题的解，每次迭代的过程就是把所有蚂蚁随机放置在不同的位置，根据路径的信息素浓度选择下一个访问的城市，当所有蚂蚁访问完所有的城市后，一个迭代结束。所以信息素的更新和路径的选择策略是蚁群算法的两大核心。</p><p>路径选择：设蚂蚁的数量为 $m$ ，城市的数量为 $n$ ，城市 $i$ 与城市 $j$ 之间的距离为 $d_{ij}$ ， $t$ 时刻城市 $i$ 与城市 $j$ 连接路径上的信息素浓度是 $\tau_{ij}(t)$ ，初始时刻，所有路径上的信息素浓度相同，即 $\tau_{ij}(0)=\tau_0$ 。设 $P_{ij}^k(t)$ 是 $t$ 时刻蚂蚁 $k$ 从城市 $i$ 转移到城市 $j$ 的概率，其计算公式为，</p><script type="math/tex; mode=display">P_{ij}^k(t)=\begin{cases}\frac{[\tau_{ij}(t)]^\alpha\times [\eta_{ij}(t)]^\beta}{\sum_{s\in allow_k}[\tau_{is}(t)]^\alpha\times [\eta_{is}(t)]^\beta} & s\in allow_k \\0 & s\notin allow_k \end{cases}</script><p>其中， $\eta_{ij}(t)$ 为启发函数， $\eta_{ij}(t)=1/d_{ij}$ ，表示蚂蚁从城市 $i$ 转移到城市 $j$ 的期望程度。 $allow_k$ 是蚂蚁 $k$ 待访问城市的集合，分段公式的第二段就表示蚂蚁转移到已经访问过的城市的概率是0。蚂蚁对下一个目的地的选择取决于信息素浓度和启发函数，而这里用的启发函数是距离的倒数，所以可以说蚂蚁的选择兼顾了群体行为留下的信息和当前城市到其他城市的客观距离，两个启发因子 $\alpha$ 和 $\beta$ 就是用来调节这两方面在决策中的重要程度。</p><p>信息素更新：当蚂蚁经过一条路径时，会释放信息素，同时路径上原有的信息素会有一定程度的挥发，设参数 $\rho(0&lt;\rho&lt;1)$ 表示信息素的挥发率，当所有蚂蚁完成一次循环后，各个路径上信息素的更新公式为，</p><script type="math/tex; mode=display">\begin{cases}\tau_{ij}(t+1)=(1-\rho)\tau_{ij}(t)+\Delta \tau_{ij} \\\Delta \tau_{ij}=\sum_{k=1}^n\Delta \tau_{ij}^k\end{cases}</script><p>其中， $\tau_{ij}^k$ 表示第 $k$ 只蚂蚁在城市 $i$ 到城市 $j$ 之间的路径上释放的信息素浓度， $\tau_{ij}$ 就表示所有蚂蚁在城市 $i$ 到城市 $j$ 之间的路径上释放的信息素浓度之和。对于 $\tau_{ij}^k$ 的计算方法，有三种模型：</p><ul><li>1、ant cycle system 模型<script type="math/tex; mode=display">\Delta\tau_{ij}^k=\begin{cases}Q/L_k & 第k只蚂蚁从城市i访问城市j \\0 & 其他\end{cases}</script>其中 $Q$ 为常数，表示蚂蚁循环一次所释放的信息素总量， $L_K$ 表示第 $k$ 只蚂蚁经过路径的长度</li><li>2、ant quantity system 模型<script type="math/tex; mode=display">\Delta\tau_{ij}^k=\begin{cases}Q/d_{ij} & 第k只蚂蚁从城市i访问城市j \\0 & 其他\end{cases}</script></li><li>3、ant density system 模型<script type="math/tex; mode=display">\Delta\tau_{ij}^k=\begin{cases}Q & 第k只蚂蚁从城市i访问城市j \\0 & 其他\end{cases}</script>在上述三种模型中，一般采用ant cycle system 模型，让信息素的浓度随蚂蚁迄今走过的总长度的增加而下降，使得路径上的信息素浓度更包含一种全局性的信息。</li></ul><p>Python3实现如下，迭代次数设为一万次：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">def ACO():</span><br><span class="line">    startTime &#x3D; time.time()</span><br><span class="line">    history &#x3D; []</span><br><span class="line">    maxIter &#x3D; 500</span><br><span class="line">    currIter &#x3D; 0</span><br><span class="line">    minDistance &#x3D; -1</span><br><span class="line">    minPath &#x3D; []</span><br><span class="line">    # 初始化参数</span><br><span class="line">    antNum &#x3D; len(cities)  </span><br><span class="line">    alpha &#x3D; 1</span><br><span class="line">    beta &#x3D; 5</span><br><span class="line">    rho &#x3D; 0.1</span><br><span class="line">    Q &#x3D; 1000</span><br><span class="line">    # 初始化信息素矩阵</span><br><span class="line">    pheromone &#x3D; [[1 for i in range(len(cities))] for j in range(len(cities))]</span><br><span class="line">    while currIter&lt;maxIter:</span><br><span class="line">        if currIter&#x3D;&#x3D;1:</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        if currIter%5&#x3D;&#x3D;0 and currIter&gt;0:</span><br><span class="line">            print(&quot;aco: &quot;+str(currIter)+&quot; &quot;+str(minDistance))</span><br><span class="line">            history.append([currIter,minDistance])</span><br><span class="line">        # 初始化行走的路径</span><br><span class="line">        path &#x3D; [[] for j in range(antNum)]</span><br><span class="line">        visit &#x3D; [[0 for i in range(len(cities))] for j in range(antNum)]</span><br><span class="line">        antDis &#x3D; []</span><br><span class="line">        # 随机放置蚂蚁</span><br><span class="line">        arr &#x3D; list(range(len(cities)))</span><br><span class="line">        random.shuffle(arr)</span><br><span class="line">        for i in range(antNum):</span><br><span class="line">            path[i].append(arr[i])</span><br><span class="line">            visit[i][arr[i]] &#x3D; 1</span><br><span class="line">        # 所有蚂蚁都走完一条完整路径时才算一次迭代</span><br><span class="line">        for i in range(antNum):</span><br><span class="line">            while len(path[i])&lt;len(cities):</span><br><span class="line">                # 路径选择概率表</span><br><span class="line">                weight &#x3D; [0 for k in range(len(cities))]</span><br><span class="line">                for k in range(len(cities)):</span><br><span class="line">                    if visit[i][k]&#x3D;&#x3D;0:</span><br><span class="line">                        weight[k] &#x3D; (pheromone[path[i][-1]][k]**alpha)&#x2F;(distance[path[i][-1]][k]**beta+0.0001)</span><br><span class="line">                # 轮盘赌法选下个城市</span><br><span class="line">                totalWeight &#x3D; sum(weight)</span><br><span class="line">                p &#x3D; [w&#x2F;totalWeight for w in weight]</span><br><span class="line">                r &#x3D; random.random()</span><br><span class="line">                sumP &#x3D; 0</span><br><span class="line">                nextCity &#x3D; -1</span><br><span class="line">                while r&gt;sumP:</span><br><span class="line">                    nextCity +&#x3D; 1</span><br><span class="line">                    sumP +&#x3D; p[nextCity]</span><br><span class="line">                path[i].append(nextCity)</span><br><span class="line">                visit[i][nextCity] &#x3D; 1</span><br><span class="line">        for i in path:</span><br><span class="line">            antDis.append(totalDistance(i))</span><br><span class="line">        minDistance &#x3D; min(antDis)</span><br><span class="line">        minPath &#x3D; path[antDis.index(minDistance)]</span><br><span class="line">        # 更新信息素</span><br><span class="line">        delta &#x3D; [[0 for i in range(len(cities))] for j in range(len(cities))]</span><br><span class="line">        for i in range(antNum):</span><br><span class="line">            tau &#x3D; Q&#x2F;antDis[i]</span><br><span class="line">            for j in range(1,len(cities)):</span><br><span class="line">                fromCity &#x3D; path[i][j-1]</span><br><span class="line">                toCity &#x3D; path[i][j]</span><br><span class="line">                delta[fromCity][toCity] +&#x3D; tau</span><br><span class="line">                delta[toCity][fromCity] +&#x3D; tau</span><br><span class="line">        for i in range(len(cities)):</span><br><span class="line">            for j in range(len(cities)):</span><br><span class="line">                pheromone[i][j] &#x3D; pheromone[i][j]*(1-rho)+delta[i][j]</span><br><span class="line">        currIter +&#x3D; 1</span><br><span class="line">    history.append([maxIter,minDistance])</span><br><span class="line">    endTime &#x3D; time.time()</span><br><span class="line">    print(&quot;最短路程：&quot;+str(minDistance))</span><br><span class="line">    print(&quot;运行时间：&quot;+str(endTime-startTime))</span><br><span class="line">    print(&quot;最优路线：&quot;+str([list(cities[i]) for i in minPath]))</span><br><span class="line">    print(&quot;迭代历史：&quot;+str(history))</span><br></pre></td></tr></table></figure></div><p>最优结果对应的路线如下：</p><div id="echarts9035" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts9035'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["城市","路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[260, 85], [260, 77], [260, 69], [260, 61], [260, 53], [260, 45], [260, 37], [260, 29], [252, 21], [228, 37], [228, 45], [228, 53], [228, 61], [236, 61], [236, 69], [228, 69], [228, 77], [228, 85], [228, 93], [228, 101], [228, 109], [228, 117], [228, 125], [220, 125], [212, 117], [204, 109], [196, 101], [188, 93], [180, 93], [180, 101], [180, 109], [180, 117], [180, 125], [172, 125], [172, 117], [172, 109], [172, 101], [172, 93], [172, 85], [180, 85], [180, 77], [180, 69], [172, 69], [172, 61], [172, 53], [180, 53], [180, 61], [172, 45], [172, 37], [180, 37], [180, 29], [180, 21], [172, 21], [172, 29], [156, 25], [162, 9], [148, 9], [136, 9], [128, 9], [120, 9], [124, 21], [124, 29], [124, 37], [124, 45], [124, 53], [124, 61], [124, 69], [124, 77], [132, 81], [124, 85], [124, 93], [124, 101], [124, 109], [124, 117], [124, 125], [132, 137], [140, 137], [148, 137], [156, 137], [164, 137], [164, 145], [172, 145], [188, 145], [196, 145], [204, 145], [212, 145], [220, 145], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [270, 133], [280, 133], [288, 129], [288, 149], [256, 157], [246, 157], [236, 169], [228, 169], [228, 161], [220, 169], [212, 169], [204, 169], [196, 169], [196, 161], [188, 169], [172, 169], [164, 169], [156, 169], [148, 169], [140, 169], [132, 169], [124, 169], [116, 161], [104, 153], [104, 161], [104, 169], [90, 165], [80, 157], [64, 157], [64, 165], [56, 169], [56, 161], [56, 153], [56, 145], [56, 137], [56, 129], [56, 121], [56, 113], [56, 105], [56, 97], [56, 89], [56, 81], [48, 83], [40, 83], [40, 73], [32, 73], [32, 81], [32, 89], [32, 97], [40, 99], [48, 99], [40, 113], [32, 113], [32, 121], [32, 129], [40, 129], [40, 137], [40, 145], [40, 153], [40, 161], [40, 169], [32, 169], [32, 161], [32, 153], [32, 145], [32, 137], [40, 121], [16, 109], [8, 109], [8, 97], [16, 97], [24, 89], [8, 89], [8, 81], [8, 73], [8, 65], [8, 57], [8, 49], [8, 41], [16, 25], [16, 17], [24, 17], [32, 17], [32, 25], [24, 25], [32, 41], [32, 49], [32, 57], [32, 65], [40, 63], [48, 63], [56, 65], [56, 57], [56, 49], [56, 41], [64, 41], [72, 41], [72, 49], [88, 49], [80, 41], [80, 25], [80, 25], [72, 25], [64, 21], [56, 17], [56, 9], [44, 11], [44, 27], [44, 35], [44, 43], [48, 51], [40, 51], [24, 45], [16, 57], [56, 73], [48, 73], [56, 33], [56, 25], [72, 9], [80, 9], [92, 9], [104, 17], [104, 25], [104, 33], [104, 41], [104, 49], [104, 57], [104, 65], [104, 73], [104, 81], [104, 89], [104, 97], [104, 105], [104, 113], [104, 121], [104, 129], [104, 137], [104, 145], [116, 145], [124, 145], [132, 145], [140, 145], [148, 145], [156, 145], [148, 85], [164, 81], [172, 77], [140, 65], [132, 61], [132, 21], [188, 41], [180, 45], [196, 49], [204, 57], [212, 65], [220, 73], [236, 77], [236, 85], [236, 93], [236, 101], [252, 101], [260, 109], [268, 97], [260, 93], [276, 93], [276, 85], [276, 77], [276, 69], [284, 69], [284, 77], [284, 85], [284, 93], [284, 101], [276, 101], [280, 109], [288, 109], [276, 61], [284, 61], [284, 53], [276, 53], [236, 29], [228, 29], [228, 21], [236, 21], [236, 37], [236, 45], [236, 53], [252, 125], [260, 85]]        },        {            name: "城市",            type: "scatter",            data: [[228, 21], [44, 11], [24, 25], [16, 25], [8, 41], [40, 83], [32, 81], [32, 73], [48, 51], [56, 41], [44, 27], [32, 41], [24, 45], [32, 57], [32, 65], [56, 81], [148, 137], [156, 137], [220, 145], [270, 133], [280, 133], [288, 129], [104, 121], [40, 113], [32, 113], [32, 137], [32, 145], [32, 153], [40, 161], [56, 137], [56, 113], [56, 97], [48, 99], [40, 99], [48, 83], [104, 57], [124, 53], [124, 45], [172, 45], [188, 41], [236, 45], [236, 37], [260, 37], [260, 45], [260, 53], [236, 53], [180, 109], [172, 117], [164, 145], [172, 145], [188, 145], [220, 125], [228, 125], [276, 101], [276, 93], [260, 85], [260, 93], [252, 101], [212, 117], [156, 145], [148, 145], [116, 161], [104, 153], [104, 161], [104, 169], [124, 169], [196, 145], [204, 145], [212, 145], [228, 169], [236, 169], [256, 157], [288, 149], [276, 53], [260, 29], [252, 21], [180, 21], [124, 37], [104, 33], [104, 41], [104, 49], [88, 49], [56, 89], [40, 129], [32, 161], [32, 169], [32, 97], [32, 89], [40, 73], [48, 63], [124, 61], [140, 65], [180, 125], [204, 169], [212, 169], [104, 145], [40, 121], [32, 121], [32, 129], [56, 145], [90, 165], [140, 145], [228, 117], [260, 109], [280, 109], [288, 109], [284, 101], [284, 93], [268, 97], [236, 93], [228, 93], [228, 85], [220, 73], [212, 65], [172, 37], [124, 29], [104, 17], [72, 25], [64, 21], [56, 33], [44, 43], [40, 51], [32, 49], [8, 57], [8, 65], [16, 57], [8, 49], [16, 17], [24, 17], [32, 17], [32, 25], [44, 35], [72, 41], [104, 65], [124, 69], [124, 77], [124, 93], [56, 129], [40, 137], [40, 145], [40, 153], [56, 153], [104, 129], [124, 117], [124, 109], [124, 101], [148, 85], [172, 77], [172, 69], [172, 61], [172, 29], [180, 29], [180, 37], [180, 45], [180, 53], [180, 69], [180, 85], [180, 93], [172, 109], [180, 117], [228, 145], [236, 145], [246, 141], [256, 141], [260, 129], [236, 69], [236, 61], [228, 61], [228, 69], [228, 77], [236, 101], [228, 101], [228, 109], [260, 77], [260, 69], [276, 69], [276, 77], [276, 85], [252, 125], [228, 161], [196, 169], [196, 161], [188, 169], [132, 169], [140, 169], [148, 169], [156, 169], [220, 169], [246, 157], [284, 85], [284, 77], [284, 61], [284, 53], [284, 69], [276, 61], [260, 61], [228, 53], [204, 57], [180, 61], [180, 77], [172, 93], [180, 101], [196, 101], [204, 109], [188, 93], [164, 81], [132, 81], [124, 85], [24, 89], [8, 73], [8, 81], [8, 89], [8, 97], [16, 97], [8, 109], [16, 109], [56, 121], [132, 137], [140, 137], [124, 125], [56, 73], [56, 65], [48, 73], [40, 63], [56, 49], [80, 41], [104, 25], [124, 21], [132, 21], [196, 49], [236, 77], [236, 85], [92, 9], [80, 9], [72, 9], [80, 25], [80, 25], [104, 73], [104, 89], [104, 97], [104, 105], [104, 113], [104, 137], [116, 145], [124, 145], [132, 145], [164, 169], [172, 169], [164, 137], [172, 125], [172, 101], [172, 85], [172, 53], [156, 25], [128, 9], [136, 9], [162, 9], [148, 9], [132, 61], [104, 81], [64, 157], [64, 165], [80, 157], [40, 169], [56, 169], [56, 161], [56, 105], [56, 57], [72, 49], [64, 41], [56, 25], [56, 17], [56, 9], [120, 9], [172, 21], [228, 45], [228, 37], [228, 29], [236, 29], [236, 21]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>最优解搜索过程如下，在几种算法里是效果最好的。因为蚁群算法的原始思想就是找最短路径，从初始化开始就是找最短路径，而不是像其他算法一样要修改成适合旅行商问题的形式，从一个随机初始化的解开始迭代。</p><div id="echarts3467" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts3467'));        // 指定图表的配置项和数据        var option = {    tooltip: {        trigger: "axis",        showDelay: 0,        axisPointer: {            type: "cross",            lineStyle: {                type: "dashed",                width: 1            }        }    },    legend: {        bottom: 5,        data: ["最短路径"]    },    toolbox: {        show: true,        feature: {            mark: {                show: true            },            dataZoom: {                show: true            }        }    },    xAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    yAxis: [        {            type: "value",            power: 1,            precision: 2,            scale: true        }    ],    series: [        {            name: '最短路径',            type: 'line',            smooth: 0.2,            color: ['#66AEDE'],            data: [[1, 3525.323483452664], [5, 3155.9786053991943], [10, 3198.1954305052404], [15, 3187.9624616192996], [20, 3077.925362696013], [25, 3170.7241673705093], [30, 3148.6702846278945], [35, 3111.7258487602144], [40, 3087.8800152281005], [45, 3107.8380050836017], [50, 3140.5883387538834], [55, 3127.0518427781685], [60, 3073.1342139772532], [65, 3129.571863142564], [70, 3077.862464224103], [75, 3080.9757259533485], [80, 3157.1901107704957], [85, 3052.9825087167287], [90, 3133.0425119448], [95, 3128.0609084583507], [100, 2924.095523108582], [105, 3085.9893019859123], [110, 3105.290547210402], [115, 3109.096048032235], [120, 3120.5840641270865], [125, 3041.203053161302], [130, 3070.5996216800936], [135, 3148.0287278021215], [140, 3127.138022828557], [145, 3068.1098045165318], [150, 3100.2402069545506], [155, 3091.7373782438494], [160, 3110.4581133000784], [165, 3052.5760813078714], [170, 3127.176731218702], [175, 3109.4249804651104], [180, 3101.676984024719], [185, 3087.3670212489383], [190, 3113.378413993024], [195, 3111.71731437653], [200, 3073.867193563927], [205, 3008.046745322756], [210, 3102.589946601963], [215, 3127.2554753512845], [220, 3096.04542909826], [225, 3097.964252847144], [230, 3121.037787377663], [235, 3076.706051206151], [240, 3091.0954356958214], [245, 3082.9460006162253], [250, 3104.778830112415], [255, 3051.8581665339666], [260, 3139.3284997306137], [265, 3098.045393805626], [270, 3040.103490383168], [275, 2992.8722260395716], [280, 3091.9427644856764], [285, 3099.0265609494772], [290, 3100.0710885212834], [295, 3099.213863345473], [300, 3152.6969208238816], [305, 3166.1283973949703], [310, 3067.0764321822116], [315, 3096.786127538351], [320, 3126.6943630919727], [325, 2992.5229676594026], [330, 3008.3374290370057], [335, 3116.1989866768076], [340, 3035.9752202551363], [345, 3049.724462504239], [350, 3097.4257992160933], [355, 3079.620375237138], [360, 3103.4251046299005], [365, 3138.3917235807894], [370, 3098.320004367942], [375, 3094.815939495362], [380, 3068.4730594876783], [385, 3102.3050596509356], [390, 3085.0351971959044], [395, 3021.352709120023], [400, 3028.8765272162104], [405, 3031.270448419514], [410, 3064.0751584809655], [415, 3072.4117823811976], [420, 3079.810714105713], [425, 3035.3561260388096], [430, 3115.7594277182284], [435, 3135.3076421918477], [440, 3133.4525449544262], [445, 3051.8050347787002], [450, 3082.2833212674973], [455, 3132.3622626312954], [460, 3118.9943123554644], [465, 3084.9142358320414], [470, 3083.5421423024504], [475, 3048.709322365078], [480, 3056.4137021152496], [485, 3083.4645884663823], [490, 3124.419980076434], [495, 3001.5161365085064], [500, 3070.6424520713927]]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><h2 id="4-3-粒子群算法"><a href="#4-3-粒子群算法" class="headerlink" title="4.3 粒子群算法"></a>4.3 粒子群算法</h2><p>粒子群算法（ Particle Swarm Optimization, PSO）源于对鸟群觅食行为的研究。一群鸟在随机搜索食物，在这个区域里只有一块食物。所有的鸟都不知道食物在那里。但是他们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢。最简单有效的就是搜寻离食物最近的鸟的周围区域。用粒子模拟单个鸟类个体，粒子的位置对应优化问题的一个候选解，粒子的飞行过程即为该个体的解空间搜索过程。粒子的飞行速度可根据粒子历史最优位置和种群历史最优位置进行动态调整。粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。每个粒子单独搜寻的最优解叫做个体极值，粒子群中最优的个体极值作为当前全局极值。不断迭代，更新速度和位置，最终得到满足终止条件的最优解。</p><p>更新规则：粒子群算法的核心就是根据两个极值更新粒子的速度和位置。首先速度的更新公式为，</p><script type="math/tex; mode=display">v_i=\omega\times v_i+c_1\times rand()\times (pbest_i-x_i)+c_2\times rand()\times (gbest-x_i)</script><p>其中， $v_i$ 是粒子 $i$ 的速度， $x_i$ 是粒子 $i$ 的位置， $rand()$ 是介于 $(0,1)$ 的随机数， $pbest_i$ 是粒子 $i$ 的个体极值， $gbest$ 是粒子群的全局极值。组成该式子的三个部分分别叫做记忆项、自身认知项和群体认知项。记忆项代表上次的速度和位置，自身认知项代表了个体自身的历史经验，群体认知项代表了粒子间协同合作和知识共享的结果。 $\omega$ 、 $c1$ 和 $c2$<br>是三个权重因子，用来调节这三部分在粒子速度更新过程中的重要程度。最后，位置的更新公式相对简单， $x_i=x_i+v_i$</p><p>但是粒子群算法的原生公式不适用于旅行商问题，在解决旅行商问题时，要先定义粒子、位置、速度分别代表什么。一般思路是把粒子定义成问题的一个解，也就是城市序列，这个序列同时也代表粒子的位置。粒子移动的本质就是所有粒子向极值靠近，所以序列向序列靠近可以解释成序列片段的复制。这样看来，用粒子群算法解决旅行商问题就变得很像遗传算法的思路，只不过是把父代之间的序列片段交换，变成了粒子和极值之间的交换，三个权重因子也就代表着三次交换的片段的长度。</p><h2 id="4-4-免疫算法"><a href="#4-4-免疫算法" class="headerlink" title="4.4 免疫算法"></a>4.4 免疫算法</h2><p>和遗传算法大同小异，都是优胜劣汰的种群更新思路。</p><h2 id="4-5-鱼群算法"><a href="#4-5-鱼群算法" class="headerlink" title="4.5 鱼群算法"></a>4.5 鱼群算法</h2><h2 id="4-6-人工蜂群算法"><a href="#4-6-人工蜂群算法" class="headerlink" title="4.6 人工蜂群算法"></a>4.6 人工蜂群算法</h2><h2 id="4-7-蛙跳算法"><a href="#4-7-蛙跳算法" class="headerlink" title="4.7 蛙跳算法"></a>4.7 蛙跳算法</h2><h2 id="4-8-烟花算法"><a href="#4-8-烟花算法" class="headerlink" title="4.8 烟花算法"></a>4.8 烟花算法</h2><h2 id="4-9-萤火虫算法"><a href="#4-9-萤火虫算法" class="headerlink" title="4.9 萤火虫算法"></a>4.9 萤火虫算法</h2><h2 id="4-10-细菌觅食算法"><a href="#4-10-细菌觅食算法" class="headerlink" title="4.10 细菌觅食算法"></a>4.10 细菌觅食算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="http://shivakasu.github.io/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Manacher 算法</title>
    <link href="http://shivakasu.github.io/2020/01/15/arg2/"/>
    <id>http://shivakasu.github.io/2020/01/15/arg2/</id>
    <published>2020-01-15T12:14:20.000Z</published>
    <updated>2020-01-15T16:03:34.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、算法背景"><a href="#一、算法背景" class="headerlink" title="一、算法背景"></a>一、算法背景</h1><p>Manacher算法，中文名马拉车算法，用以解决求字符串中的最长回文子串。传统的寻找最长回文子串的方法是从左到右遍历字符串的每个字符，同时以每个字符为回文中心向左右两侧扩散寻找，当字符串中存在大量回文子串，比如在极端情况下 $“aa…aa”$ ，算法的时间复杂度是 $O(N^2)$ 。而Manacher算法能够把寻找最长回文子串的时间复杂度降到 $O(N)$ 。</p><h1 id="二、字符串预处理"><a href="#二、字符串预处理" class="headerlink" title="二、字符串预处理"></a>二、字符串预处理</h1><p>假设要处理的字符串是 $“abbabb”$ ，由于回文串有奇回文和偶回文，比如 $“bab”$ 是奇回文， $“abba”$ 是偶回文，奇回文的对称轴是一个字符，偶回文的对称轴是两个字符，为了消除这种差异，首先要对字符串预处理，在每个字符的两侧都添加占位符，比如 $“\sharp”$ ，原来的字符串就变成了 $“\sharp a\sharp b\sharp b\sharp a\sharp b\sharp b\sharp ”$ 。对于其中的每个回文串，预处理相当于在每个字符的右侧添加占位符，变成偶回文，再在整体回文串的左侧添加一个占位符，变成奇回文。比如上述两个回文串变成了 $“\sharp b\sharp a\sharp b\sharp ”$ 和 $“\sharp a\sharp b\sharp b\sharp a\sharp ”$ ，长度分别是7和9，都是奇回文。</p><h1 id="二、计算最长回文子串半径"><a href="#二、计算最长回文子串半径" class="headerlink" title="二、计算最长回文子串半径"></a>二、计算最长回文子串半径</h1><p>除了对字符串的预处理，算法还需要一个辅助数组 $p$ ，设预处理后的字符串是 $arr$ ，则 $p[i]$ 表示以 $arr[i]$ 为回文中心的最大回文半径。由于所有回文串都是奇回文，所以回文半径可以表示为 $(回文串长度+1)\div 2$ ，也就是包含回文中心的回文串的一半。比如下表中， $p[3]=2$ 表示以 $arr[3]$ 为回文中心的最长回文子串是 $“\sharp b\sharp ”$ ，回文半径是2，即 $“\sharp b”$ 的长度。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i ：</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">arr：</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p ：</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><p>计算数组 $p$ 需要两个辅助变量， $maxright$ 表示遍历至此发现的回文串所能达到的最右边界， $center$ 表示到达最右边界的回文串的回文中心。当遍历到 $arr[i]$ 时，要计算的是以 $arr[i]$ 为回文中心的最大回文半径，由于 $center$ 和 $maxright$ 是当前已知的回文中心和回文边界，所以一定是在之前的步骤算出来的，所以必有 $center&lt;i&lt;maxright$ ，又因为 $arr[center..maxright]$ 是一个回文串的右半部分，所以在 $arr[0..center]$ 中必有 $i$ 的对称点，记为 $i’$ ，以及 $maxright$ 的对称点 $maxright’$ ，至此，可以确定以下数组下标的位置关系：</p><script type="math/tex; mode=display">maxright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow maxright</script><p>Manacher算法的核心就是利用之前步骤算出的 $p$ 数组的值来减少对字符串的遍历。在当前的步骤中就体现在根据 $p[i’]$ 值的情况优化计算 $p[i]$ 的过程，把以 $arr[i]$ 为回文中心的回文串的右边界记为 $iright$ ，关于 $center$ 的对称点记为 $iright’$ ，分为两种情况：</p><p>情况一：$p[i’]&lt;maxright-i$<br>$p[i’]$ 是 $i’$ 到 $iright’$ 的距离，$maxright-i$ 是 $i’$ 到 $maxright’$ 的距离，位置关系如下，</p><script type="math/tex; mode=display">maxright'\rightarrow iright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow iright\rightarrow maxright</script><p>说明以 $arr[i]$ 为回文中心的回文串被完全包含在以 $arr[center]$ 为回文中心的回文串中。必有 $p[i]=p[i’]$ </p><p>情况二：$p[i’]\geq maxright-i$<br>位置关系如下，</p><script type="math/tex; mode=display">iright'\rightarrow maxright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow maxright\rightarrow iright</script><p>说明以 $arr[i]$ 为回文中心的最大回文半径至少是 $maxright-i$ ，而 $maxright’$ 左侧与 $maxright$ 右侧的字符是否匹配还不知道，因为 $maxright$ 就是当前遍历到的最右边界，再右边的字符还没遍历到，所以此时可以把 $maxright’$ 和 $maxright$ 当做左右边界向外扩散匹配，而回文中心 $i$ 到 $maxright$ 之间的字符就不必判断了，因为 $p[i’]$ 保证了这一段一定是能匹配成功的。</p><p>一句话总结， $p$ 数组的计算过程就是利用算过的 $p$ 数组的值优化左右扩散匹配。</p><h1 id="三、最长回文子串起始坐标"><a href="#三、最长回文子串起始坐标" class="headerlink" title="三、最长回文子串起始坐标"></a>三、最长回文子串起始坐标</h1><p>算好了数组 $p$ ，其中最大的值就是最长回文子串的半径，但这里得到的长度和坐标都是基于预处理后的字符串 $arr$ ，获取最长回文子串需要知道他在原字符串 $str$ 里的起始点和半径。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i ：</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">arr：</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p ：</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">str：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td></tr></tbody></table></div><p>在上图的例子中，基于 $arr$ 得到的回文中心是 $arr[7]$ ，回文半径是 $p[7]=6$ ，而在目标字符串中需要找到的回文串是 $str[1..5]$ 。</p><p>回文串在原字符串中的起始坐标是 $index=(i-p[i])\div 2$ ，其中 $i-p[i]$ 是 $arr$ 起点到回文串左边界的距离，在例子中就是 $“\sharp a”$ 这一段，由于最大回文字符串的首尾一定是占位符，所以从 $arr$ 起点到回文左边界这一段中的每个字符只有左侧有占位符，也就是说字符和占位符的数量是相同的，所以式子最后要除以2，才能得到其中所有有效字符的数量，这个去除了占位符的长度就是原字符串 $str$ 中起点到回文左边界的距离。</p><p>$str$ 中的回文半径也容易计算。如果 $arr$ 中的回文中心是有效字符，说明这个回文串预处理前是奇回文，回文串的左半部分中每个字符的左侧都有一个占位符，在例子里也就是 $“\sharp b\sharp b\sharp a”$ ，这时真实的回文半径就是 $p[i]\div 2$ 。如果 $arr$ 中的回文中心是占位符，说明这个回文串预处理前是偶回文，回文串的左半部分中每个字符的左侧都有一个占位符，同时多了回文中心上的一个占位符，这时真实的回文半径就是 $(p[i]-1)\div 2$ 。</p><p>Manacher算法的 $O(N)$ 时间复杂度可以理解成 $maxright$ 从 $arr$ 起点移动到终点的过程， $maxright$ 左侧的字符都是不必重复匹配的，右侧随着匹配过程不断更新 $maxright$ 的位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="http://shivakasu.github.io/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法总结</title>
    <link href="http://shivakasu.github.io/2020/01/11/arg1/"/>
    <id>http://shivakasu.github.io/2020/01/11/arg1/</id>
    <published>2020-01-11T10:41:20.000Z</published>
    <updated>2020-01-16T02:25:17.497Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>输入原字符串(String)和子串(Pattern)，找到子串在原字符串中第一次出现的位置，两个字符串分别命名为 $s$ 和 $p$</p><h1 id="二、暴力检索"><a href="#二、暴力检索" class="headerlink" title="二、暴力检索"></a>二、暴力检索</h1><p>暴力检索(Brute Force)是最简单的匹配方法，首先把 $s$ 和 $p$ 左端对齐，从两个字符串头部开始逐位匹配，匹配失败后将 $p$ 右移一位，从 $p$ 的头部和 $s$ 的对应位置重新匹配。</p><p>最坏情况下，假设 $s=“xx….xy”$ ，长度为 $N$ ， $p=“xx…xy”$ ，长度为 $M$ ，每次匹配都需要比较全部 $M$ 个字符，而只有最后一次匹配才能匹配成功，所以时间复杂度是 $O(M\times N)$</p><h1 id="三、KMP算法"><a href="#三、KMP算法" class="headerlink" title="三、KMP算法"></a>三、KMP算法</h1><p>KMP算法全称是Knuth-Morris-Pratt字符串查找算法，算法的核心思想是利用最大相同前缀后缀长度来减少匹配次数。例如 $ABCAB$ 的前缀有 $A$ 、 $AB$ 、 $ABC$ 、 $ABCA$ 四个，后缀有 $B$ 、 $AB$ 、 $CAB$ 、 $BCAB$ 四个，那么他的最大相同前缀后缀就是 $AB$ ，最大相同前缀后缀长度是2。所以对于字符串 $str[0..n]$ 来说，最大相同前缀后缀长度是 $k$ 就表示 $str[0..k-1]=str[n-k+1..n]$ 但 $str[k]\neq str[n-k]$ </p><p>先默认已经有了记录子串 $p$ 最大相同前缀后缀长度的数组 $F$ ， $F[k]$ 就是 $p[0..k]$ 的最大相同前缀后缀长度。借用<a href="https://www.cnblogs.com/SYCstudio/p/7194315.html" target="_blank" rel="noopener">某篇博客</a>里的例子，</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr></tbody></table></div><p>对于 $p=”abaabbabaab”$ ， $F=[0,0,1,1,2,0,1,2,3,4,5]$</p><p>$i$ 表示 $s$ 的下标， $j$ 表示 $p$ 的下标，第一次匹配如下， $s[5]$ 和 $p[5]$ 匹配失败。查询 $F[5-1]$ ，发现 $F[4]=2$ ，说明 $p[0..4]$ 的前两位和最后两位能够匹配上，又因为 $p[0..4]=s[0..4]$ ，下次匹配子串 $p$ 就不必只后移一位，可以直接让 $p[0..1]$ 和 $s[3..4]$ 对齐，因为最大相同前缀后缀长度是2就说明当 $p[0..1]$ 和 $s[3..4]$ 之前的位置对齐时，最多能匹配两位，在第三位之前一定会匹配失败。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第二次匹配如下，发现 $s[13]$ 和 $p[10]$ 匹配失败，查询得到 $F[9]=4$ ，所以下次直接让 $p[0..3]$ 和 $s[9..12]$ 对齐</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第三次匹配如下，发现 $s[13]$ 和 $p[4]$ 匹配失败，查询得到 $F[3]=1$ ， 所以下次直接让 $p[0]$ 和 $s[12]$ 对齐</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第四次匹配如下，发现 $s[13]$ 和 $p[1]$ 匹配失败，查询得到 $F[0]=0$ ， 所以下次只能老老实实把 $p$ 右移一位</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第五次匹配如下，匹配成功</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>还剩一个问题是如何预先求解数组 $F$ ，一种简单的方法是用两个指针 $i$、$j$ 错位遍历子串 $p$ 。初始化 $i=1$ 、 $j=0$ ，指针 $i$ 用于主循环，每当 $p[i]=p[j]$ 时，指针 $j$ 才加一，如果 $p[i]\neq p[j]$ 就把 $j$ 打回原位 $j=0$ ， $i$ 遍历的同时能够确定 $F[i]$ ，时间复杂度为 $O(N)$ ，随便用python写了一下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">while i&lt;len(a):</span><br><span class="line">    if a[i]!&#x3D;a[j]:</span><br><span class="line">        if j&#x3D;&#x3D;0:</span><br><span class="line">            b.append(0)</span><br><span class="line">        else:</span><br><span class="line">            if a[i]&#x3D;&#x3D;a[0]:</span><br><span class="line">                j&#x3D;1</span><br><span class="line">                b.append(1)</span><br><span class="line">            else:</span><br><span class="line">                j&#x3D;0</span><br><span class="line">                b.append(0)</span><br><span class="line">    else:</span><br><span class="line">        b.append(b[-1]+1)</span><br><span class="line">        j+&#x3D;1</span><br><span class="line">    i+&#x3D;1</span><br></pre></td></tr></table></figure></div><p>KMP算法的确能够减少匹配次数，一般认为其时间复杂度是 $O(M+N)$ ，但是极端情况下时间复杂度依然可以是 $O(M\times N)$ ，一种情况是子串的 $F$ 数组都是0时，完全用不到 $F$ ，就退化成了暴力检索，另一种情况是 $p=“aa…aa”$ ，最大相同前缀后缀分别就是 $p[0,i-1]$ 和 $p[1,i]$ ，利用 $F$ 数组就相当于只后移一位。</p><h1 id="三、RK算法"><a href="#三、RK算法" class="headerlink" title="三、RK算法"></a>三、RK算法</h1><p>RK算法全称Rabin-Karp字符串匹配算法，核心思想是利用字符串的哈希值比较替代逐字符匹配，因为一个足够好的哈希函数能够把不同的字符串映射到不同的哈希值，而把相同的字符串映射到相同的哈希值。对于一个 $N$ 位的字符串 $s$ 和一个 $M$ 位的模式串 $p$ ，依次计算 $s[0..M-1]$ 、 $s[M..2M-1]$ 、… 、 $s[N-M+1..N]$ 的哈希值，并与 $p$ 的哈希值进行比较。</p><p>由于哈希函数多少有一定的错误率，为了确保字符串匹配的准确度，当哈希值相同时，需要用传统的逐字符比较的方法进行验证，一般认为时间复杂度是 $O(M+N)$ ，但实际的时间复杂度与选择的哈希函数有很大关系，一个差的哈希函数也可以使时间复杂度趋近 $O(M\times N)$</p><h1 id="四、BM算法"><a href="#四、BM算法" class="headerlink" title="四、BM算法"></a>四、BM算法</h1><p>BM算法全称Boyer-Moore字符串搜索算法，与其他方法不同的是，BM算法从字符串尾部开始匹配，利用坏字符原则和好后缀原则优化模式串 $p$ 的移动距离。</p><p>坏字符原则：当匹配失败时， $s[i]\neq p[j]$ ，称 $s[i]$ 为坏字符。此时检查 $s[i]$ 是否出现在匹配失败位置的左侧，即 $p[0..j-1]$ 中是否存在 $p[k]$ 使得 $p[k]=s[i] (k&lt;j)$ ，如果存在一个或多个，选择其中最右的 $p[k]$ 与当前的 $s[i]$ 对齐，如果不存在，就把 $p[0..j-1]$ 全部移动到匹配失败位置后面，也就是把 $p[0]$ 和 $s[i+1]$ 对齐。</p><p>好后缀原则：当匹配失败时， $s[i]\neq p[j]$ ，此时检查模式串 $p$ 是否有后缀匹配成功，即 $p[k..m] (k&gt;j)$ 与 $s$ 的相应位置匹配成功，称这样的后缀为好后缀。如果不存在好后缀，就按照朴素方法把 $p$ 后移一位重新匹配。如果存在好后缀，首先检查最长的好后缀是否出现在匹配失败位置之前，即 $p[h..h+m-k]=p[k..m]$ ，如果出现了最长好后缀，就把 $p[h..h+m-k]$ 与当前的 $p[k..m]$ 对齐，如果没有出现，就按照由长到短的顺序依次检查其他好后缀，如果某个好后缀与 $p$ 的某个前缀相等，就把这对前缀后缀对齐。</p><p>匹配失败时，分别按照坏字符原则和好后缀原则计算模式串 $p$ 应该向后移动的距离，取二者的最大值作为实际移动距离。借用Moore教授提供的例子，</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr></tbody></table></div><p>第一次匹配如下，对子串 $p$ 从后往前检查，发现 $s[6]\neq p[6]$ 。根据坏字符原则，由于 $s[6]$ 没有在 $p[0..5]$ 中出现过，所以要把 $p[0..5]$ 全部移到坏字符 $s[6]$ 后面，也就是把 $p[0]$ 和 $s[7]$ 对齐，移动距离是7。根据好后缀原则，由于没有好后缀，只能按照朴素方法把 $p$ 后移一位。相比之下，坏字符原则确定的后移距离更长，所以移动距离是7。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第二次匹配如下，从后往前检查，发现 $s[13]\neq p[6]$ 。根据坏字符原则，由于 $s[13]=p[4]$ ，所以要把 $p[4]$ 和 $s[13]$ 对齐，移动距离是2。根据好后缀原则，由于没有好后缀，只能按照朴素方法把 $p$ 后移一位。相比之下，坏字符原则确定的后移距离更长，所以移动距离是2。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第三次匹配如下，从后往前检查，发现 $s[11]\neq p[2]$ 。根据坏字符原则，由于 $s[11]$ 没有在 $p[0..1]$ 中出现过，所以要把 $p[0..1]$ 全部移到坏字符 $s[11]$ 后面，也就是把 $p[0]$ 和 $s[12]$ 对齐，移动距离是3。根据好后缀原则，发现匹配到 $“mple”$ 、 $“ple”$ 、 $“le”$ 、 $“e”$ 四个好后缀，首先检查最长的好后缀 $“mple”$ 是否出现在匹配失败位置的左侧，发现不存在，然后依次检查其他好后缀是否匹配到子串 $p$ 的前缀，发现 $“e”$ 能够匹配到 $p$ 的前缀，所以把两个 $“e”$ 对齐，也就是把 $p[0]$ 和 $s[15]$ 对齐，移动距离是6。相比之下，好后缀原则确定的后移距离更长，所以移动距离是6。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第四次匹配如下，从后往前检查，发现 $s[21]\neq p[6]$ 。根据坏字符原则， $s[21]=p[4]$ ，所以应该把 $p[4]$ 和 $s[21]$ 对齐，移动距离是2。根据好后缀原则，由于没有好后缀，只能按照朴素方法把 $p$ 后移一位。相比之下，坏字符原则确定的后移距离更长，所以移动距离是2。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第五次匹配如下，匹配成功</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>BM算法是不稳定的贪心算法，最好情况下时间复杂度 $O(N\div M)$ ，最差情况下时间复杂度为 $O(M\times N)$ 。<a href="http://ddrv.cn/a/55208" target="_blank" rel="noopener">某篇文章</a>里对BF、KMP、BM三种算法进行了测试对比，结果表明匹配花费的时间 $BM&lt;BF&lt;KMP$ ，可见KMP只是理论上的优化，实际使用时很难遇到较多的相同前缀后缀，对此复杂的优化操作就变得多余，导致算法效率甚至不如暴力检索。</p><h1 id="五、Horspool-算法"><a href="#五、Horspool-算法" class="headerlink" title="五、Horspool 算法"></a>五、Horspool 算法</h1><p>就是BM算法中的坏字符原则</p><h1 id="六、Sunday-算法"><a href="#六、Sunday-算法" class="headerlink" title="六、Sunday 算法"></a>六、Sunday 算法</h1><p>Sunday 算法从左到右匹配，但每次匹配失败后查看 $s$ 中参与匹配的最后一个字符的下一个字符，在 $p$ 中查找是否存在该字符，也就是当 $p[M-1]$ 与 $s[k]$ 对齐时，查看 $s[k+1]$ 是否在 $p$ 中出现。如果出现一次或多次，把最右的一个与 $s[k+1]$ 对齐，如果没有出现，就把 $p[0]$ 和 $s[k+2]$ 对齐，相当于整个子串跳过 $s[k+1]$ ，举例说明，</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr></tbody></table></div><p>第一次匹配如下，从左到右检查，发现 $s[1]\neq p[1]$ ，此时查看 $p[5]$ 所对应的 $s$ 中的字符的下一个字符，也就是 $s[6]$ 是否出现在 $p$ 中，结果是没有出现，所以直接把 $p[0]$ 和 $s[7]$ 对齐。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table></div><p>第二次匹配如下，从左到右检查，发现 $s[7]\neq p[0]$ ，此时查看 $s[13]$ 是否出现在 $p$ 中，结果 $s[13]=p[3]$，所以把 $p[3]$ 和 $s[13]$ 对齐。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table></div><p>第三次匹配如下，匹配成功。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table></div><p>Sunday算法类似于BM算法，是不稳定的贪心算法，时间复杂度也和BM算法一样，最好情况下时间复杂度 $O(N\div M)$ ，最差情况下时间复杂度为 $O(M\times N)$ 。二者的思路都是在匹配失败时从尾部入手，便于找到一个相对较远的位置，把模式串移动到该位置，同时保证移动到左侧的任何位置时都无法匹配成功，从而有效减少了匹配次数。</p><h1 id="七、AC自动机"><a href="#七、AC自动机" class="headerlink" title="七、AC自动机"></a>七、AC自动机</h1><p>AC自动机全称Aho–Corasick算法，是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法。传统的字符串匹配算法只能同时搜索一个子串 $p$ ，在多模式串匹配任务中只能针对每个子串 $p$ 分别从头到尾扫描一遍母串，效率非常低。AC自动机针使用了Trie树存储所有的子串，树的每个节点表示一个字符，以遍历节点的方式匹配母串，每当匹配失败时，转向当前节点的Fail节点继续匹配，母串也可以从当前位置继续向后匹配而不需要返回头部，如此可以实现只遍历母串一次来匹配所有的子串。以下例子转自<a href="https://www.jianshu.com/p/2ad417a184fd" target="_blank" rel="noopener">别人的转自</a>，</p><p>假设子串集合为 $p={she,he,say,her,shr}$ ，母串是 $yasherhs$ 。首先根据子串的集合构造Trie树(过程简单直接略过)，结果如下。</p><p><a href="https://file.shivakasu.cn/364f6662c4b968167ac6/arg1-0.png" data-fancybox="group" data-caption="Trie树" class="fancybox"><img alt="Trie树" data-src="https://file.shivakasu.cn/364f6662c4b968167ac6/arg1-0.png" class="lazyload" title="Trie树"></a></p><p>注意需要为节点添加一个指针属性，在Trie树构建完毕后，将每个节点的该指针指向他的Fail节点，设置好Fail节点的Trie树如下。假设节点 $i$ 的Fail节点是节点 $j$ ，从根节点到节点 $i$ 的字符串记为 $word[i]$ ，从根节点到节点 $j$ 的字符串记为 $word[j]$ ，那么Fail节点的含义就是 $word[j]$ 是 $word[i]$ 在树中以根节点为起点的最长后缀。例如图中右侧 $she$ 的 $e$ 节点的Fail节点是左侧 $he$ 的 $e$ 节点，表示 $he$ 是 $she$ 在树中的最长后缀。</p><p><a href="https://file.shivakasu.cn/bfcf8fb05a570058e756/arg1-1.png" data-fancybox="group" data-caption="带Fail指针的Trie树" class="fancybox"><img alt="带Fail指针的Trie树" data-src="https://file.shivakasu.cn/bfcf8fb05a570058e756/arg1-1.png" class="lazyload" title="带Fail指针的Trie树"></a></p><p>Fail节点的设置只需要遵循一个原则，一个节点 $i$ 的Fail指针指向他父节点的Fail节点的与 $i$ 同名的子节点。这里涉及了四个节点，举例来说，为图中最右的 $h$ 节点指定Fail节点，他的父节点是 $s$ ， $s$ 的Fail指针指向根节点，根节点的孩子中存在与 $h$ 同名的节点，也就是最左的 $h$ 节点，所以最右的 $h$ 节点的Fail指针应该指向最左的 $h$ 节点。如果不存在这样的节点，就把Fail指针指向根节点，比如图中两个 $r$ 节点。此外，根节点不需要设置Fail指针。在这个过程中，回溯父节点的步骤可以通过递归实现，遍历到子节点的同时把父节点的Fail指针传递给子节点。</p><p>母串 $yasherhs$ 的匹配过程：<br>第一步，当前节点是根节点，查找字符是 $y$ ，发现根节点没有为 $y$ 的子节点，又因为根节点没有Fail节点，所以留在原地，母串索引加一。<br>第二步，当前节点是根节点，查找字符是 $a$ ，发现根节点没有为 $a$ 的子节点，又因为根节点没有Fail节点，所以留在原地，母串索引加一。<br>第三步，当前节点是根节点，查找字符是 $s$ ，因此转到根节点的右子节点 $s$ ，匹配成功，母串索引加一。<br>第四步，当前节点是 $s$ ，查找字符是 $h$ ，因此转到根节点的右子节点 $h$ ，匹配成功，母串索引加一。<br>第五步，当前节点是 $h$ ，查找字符是 $e$ ，因此转到根节点的左子节点 $e$ ，该节点同时是词尾节点，说明子串 $she$ 匹配成功，母串索引加一。<br>第六步，当前节点是 $e$ ，查找字符是 $r$ ，因为当前节点没有子节点，匹配失败，转向他的Fail节点，也就是左侧的 $e$ 节点，发现该节点是词尾节点，说明子串 $he$ 匹配成功，同时该节点的子节点包含目标字符 $r$ ，因此转向左子节点 $r$ ，发现节点 $r$ 也是词尾节点，说明子串 $her$ 匹配成功。母串索引加一。<br>第七步，当前节点是 $r$ ，查找字符是 $h$ ，因为当前节点没有子节点，匹配失败，转向他的Fail节点，也就是根节点，根节点的子节点包含目标字符 $h$ ，因此转向左侧的节点 $h$ ，母串索引加一。<br>第八步，当前节点是 $h$ ，查找字符是 $s$ ，因为当前节点的子节点没有 $s$ ，匹配失败，转向他的Fail节点，也就是根节点，根节点的子节点包含目标字符 $s$ ，因此转向右侧的节点 $s$ ，母串索引到头了，匹配结束。</p><p>整个匹配过程中，母串仅遍历了一次，匹配了多个子串，大大提高了匹配效率。Fail指针的合理性在于指向以根节点为起点的最长后缀，一方面，以根节点为起始说明这个后缀同时也是某个子串的前缀，从Fail节点开始匹配就相当于在默认匹配了某个子串前缀的条件下，从该子串的中间继续匹配。另一方面，指向最长后缀能够保证不会漏掉能够匹配到子串的有效后缀，假如一个节点有两个有效后缀，一定是该节点的Fail指针指向最长后缀，最长后缀的Fail指针指向次长后缀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="http://shivakasu.github.io/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《程序员代码面试指南》</title>
    <link href="http://shivakasu.github.io/2020/01/10/arg0/"/>
    <id>http://shivakasu.github.io/2020/01/10/arg0/</id>
    <published>2020-01-09T16:43:20.000Z</published>
    <updated>2020-02-18T10:57:18.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-栈和队列"><a href="#第一章-栈和队列" class="headerlink" title="第一章 栈和队列"></a>第一章 栈和队列</h1><h2 id="1-1-getmin-栈"><a href="#1-1-getmin-栈" class="headerlink" title="1.1  $getmin$ 栈"></a>1.1  $getmin$ 栈</h2><p>用两个栈， $A$ 正常使用， $B$ 在 $A$ 的 $push$ 和 $pop$ 时保持栈顶是 $A$ 的最小值</p><h2 id="1-2-两个栈组成队列"><a href="#1-2-两个栈组成队列" class="headerlink" title="1.2 两个栈组成队列"></a>1.2 两个栈组成队列</h2><p>两个栈方向相反， $A$ 压栈代表入队， $B$ 退栈代表出队，当 $B$ 为空时，把 $A$ 反向导入 $B$ </p><p>问题是不能保证出队 $O(1)$ ？</p><h2 id="1-3-用递归函数和栈逆序一个栈"><a href="#1-3-用递归函数和栈逆序一个栈" class="headerlink" title="1.3 用递归函数和栈逆序一个栈"></a>1.3 用递归函数和栈逆序一个栈</h2><p>两个递归函数， $A$ 递归 $pop$ 栈中所有元素，返回最后一个元素，再把剩下的 $push$ 回去。 $B$ 递归调用 $A$ ，把 $A$ 返回的 $push$ 回去</p><h2 id="1-4-猫狗队列"><a href="#1-4-猫狗队列" class="headerlink" title="1.4 猫狗队列"></a>1.4 猫狗队列</h2><p>一个队列存猫，一个队列存狗，一个数组用01标注存放顺序</p><h2 id="1-5-用一个栈实现另一个栈的排序"><a href="#1-5-用一个栈实现另一个栈的排序" class="headerlink" title="1.5 用一个栈实现另一个栈的排序"></a>1.5 用一个栈实现另一个栈的排序</h2><p>把A栈的依次 $pop$ ，如果比B栈顶大就 $push$ 到 $B$ ，否则把 $B$ $pop$ 并 $push$ 回 $A$ 直到比 $B$ 栈顶大，核心就是利用两个栈来回倒，用一个临时变量做插入排序</p><h2 id="1-6-用栈求解汉诺塔"><a href="#1-6-用栈求解汉诺塔" class="headerlink" title="1.6 用栈求解汉诺塔"></a>1.6 用栈求解汉诺塔</h2><p>递归思路：把 $1\sim N$ 从左移动到右，相当于把 $1\sim(N-1)$ 从左移动到中，再把 $N$ 从左移动到右，再把 $1\sim(N-1)$ 从中移动到右</p><p><span id="jump"></span></p><h2 id="1-7-生成窗口最大值数组"><a href="#1-7-生成窗口最大值数组" class="headerlink" title="1.7 生成窗口最大值数组"></a>1.7 生成窗口最大值数组</h2><p>维护一个最大长度为 $k$ 的队列，保证队头是当前位置往前 $k$ 个数的从大到小的下标，遇到较大值就弃掉前边比他小的</p><h2 id="1-8-maxtree"><a href="#1-8-maxtree" class="headerlink" title="1.8 maxtree"></a>1.8 maxtree</h2><p>对每一个元素，从左边和右边各选择第一个比这个元素大的值，选择值较小的元素作为父节点。证明过程就是先证明结果只有一棵树，再证明数组里每个元素在左右两侧最多分别有一个孩子</p><h2 id="1-9-最大子矩阵"><a href="#1-9-最大子矩阵" class="headerlink" title="1.9 最大子矩阵"></a>1.9 最大子矩阵</h2><p>以每一行为底，算出每行的纵向向上连续高度，根据高度差找最大矩阵</p><h2 id="1-10-最大值减最小值小于等于-num-的子数组数量"><a href="#1-10-最大值减最小值小于等于-num-的子数组数量" class="headerlink" title="1.10 最大值减最小值小于等于 $num$ 的子数组数量"></a>1.10 最大值减最小值小于等于 $num$ 的子数组数量</h2><p>仿照 <a href="#jump">1.7</a> 维护两个队列，分别存储最大值和最小值的下标，若 $a[i,j]$ 满足/不满足条件，她的所有子数组也满足/不满足条件，因此只需要两个 $flag$ 遍历数组， $j$ 向后遍历，遇到不满足的就让 $i+1$ ，再接着遍历 $j$ </p><h1 id="第二章-链表问题"><a href="#第二章-链表问题" class="headerlink" title="第二章 链表问题"></a>第二章 链表问题</h1><h2 id="2-1-打印两个有序链表的公共部分"><a href="#2-1-打印两个有序链表的公共部分" class="headerlink" title="2.1 打印两个有序链表的公共部分"></a>2.1 打印两个有序链表的公共部分</h2><p>因为是有序的，所以就交错遍历，遇到相等就打印</p><h2 id="2-2-在单链表和双向链表中删除倒数第k个节点"><a href="#2-2-在单链表和双向链表中删除倒数第k个节点" class="headerlink" title="2.2 在单链表和双向链表中删除倒数第k个节点"></a>2.2 在单链表和双向链表中删除倒数第k个节点</h2><p>遍历两次</p><h2 id="2-3-删除链表的中间节点"><a href="#2-3-删除链表的中间节点" class="headerlink" title="2.3 删除链表的中间节点"></a>2.3 删除链表的中间节点</h2><p>立个 $flag$ 表示中点，一边遍历一边移动 $flag$ </p><p><span id="jump2"></span></p><h2 id="2-4-反转单向和双向链表"><a href="#2-4-反转单向和双向链表" class="headerlink" title="2.4 反转单向和双向链表"></a>2.4 反转单向和双向链表</h2><p>维护三个指针，每次反转一条边</p><h2 id="2-5-反转部分单向链表"><a href="#2-5-反转部分单向链表" class="headerlink" title="2.5 反转部分单向链表"></a>2.5 反转部分单向链表</h2><p>把中间那段提出来仿照 <a href="#jump2">2.4</a> 反转，再反过来拼接上</p><h2 id="2-6-环形链表的约瑟夫问题"><a href="#2-6-环形链表的约瑟夫问题" class="headerlink" title="2.6 环形链表的约瑟夫问题"></a>2.6 环形链表的约瑟夫问题</h2><p>简单版：模拟过程转圈找   </p><p>进阶版：总结出递归表达式提前算出答案</p><h2 id="2-7-判断链表是否回文"><a href="#2-7-判断链表是否回文" class="headerlink" title="2.7 判断链表是否回文"></a>2.7 判断链表是否回文</h2><p>简单版：遍历两次，空间 $O(N)$   </p><p>进阶版：反转后半部分指向中间节点，从两头同时遍历，空间 $O(1)$ </p><h2 id="2-8-单链表划分成左边小中间相等右边大"><a href="#2-8-单链表划分成左边小中间相等右边大" class="headerlink" title="2.8 单链表划分成左边小中间相等右边大"></a>2.8 单链表划分成左边小中间相等右边大</h2><p>遍历一遍，把链表拆成三段，再把三段拼起来，因为是对原链表的指针操作，所以空间 $O(1)$ </p><h2 id="2-9-复制含有随机指针节点的链表"><a href="#2-9-复制含有随机指针节点的链表" class="headerlink" title="2.9 复制含有随机指针节点的链表"></a>2.9 复制含有随机指针节点的链表</h2><p>简单版：遍历两次，使用哈希表确定节点 </p><p>进阶版：遍历两次，第一次在每个节点后边生成复制节点，第二次复制连接，最后分离原始链表和复制链表，不必使用额外数据结构</p><h2 id="2-10-两个单链表模拟整数相加"><a href="#2-10-两个单链表模拟整数相加" class="headerlink" title="2.10 两个单链表模拟整数相加"></a>2.10 两个单链表模拟整数相加</h2><p>用栈或反转链表，目的是实现低位到高位的计算</p><h2 id="2-11-一个链表是否有环"><a href="#2-11-一个链表是否有环" class="headerlink" title="2.11 一个链表是否有环"></a>2.11 一个链表是否有环</h2><p>快慢指针追逐法，第一次相遇后快指针变慢指针从头跑，两个慢指针会在入环点相遇</p><h2 id="2-12-两个无环链表是否相交"><a href="#2-12-两个无环链表是否相交" class="headerlink" title="2.12 两个无环链表是否相交"></a>2.12 两个无环链表是否相交</h2><p>因为是单链表，所以一旦相交，后续将合并成一个链表，因此只需要对比两个链表的尾结点</p><h2 id="2-13-两个有环链表是否相交"><a href="#2-13-两个有环链表是否相交" class="headerlink" title="2.13 两个有环链表是否相交"></a>2.13 两个有环链表是否相交</h2><p>找到两个入环点，追逐法判断是否是同一个环</p><h2 id="2-14-将单链表每k个节点之间逆序"><a href="#2-14-将单链表每k个节点之间逆序" class="headerlink" title="2.14 将单链表每k个节点之间逆序"></a>2.14 将单链表每k个节点之间逆序</h2><p>计数反转后拼接</p><h2 id="2-15-删除无序单链表中值重复的节点"><a href="#2-15-删除无序单链表中值重复的节点" class="headerlink" title="2.15 删除无序单链表中值重复的节点"></a>2.15 删除无序单链表中值重复的节点</h2><p>方法一：哈希表，遍历一遍，时间空间都是 $O(N)$   </p><p>方法二：从每个节点遍历一遍，时间 $O(N^2)$ ，空间 $O(1)$ </p><h2 id="2-16-单链表删除指定值的节点"><a href="#2-16-单链表删除指定值的节点" class="headerlink" title="2.16 单链表删除指定值的节点"></a>2.16 单链表删除指定值的节点</h2><p>直接遍历，时间 $O(N)$ ，空间 $O(1)$ </p><h2 id="2-17-二叉树转双向链表"><a href="#2-17-二叉树转双向链表" class="headerlink" title="2.17 二叉树转双向链表"></a>2.17 二叉树转双向链表</h2><p>用队列保存中序遍历，再依次出队重连</p><h2 id="2-18-单链表选择排序"><a href="#2-18-单链表选择排序" class="headerlink" title="2.18 单链表选择排序"></a>2.18 单链表选择排序</h2><p>时间 $O(N^2)$ ，空间 $O(1)$ </p><h2 id="2-19-怪异的节点删除方式"><a href="#2-19-怪异的节点删除方式" class="headerlink" title="2.19 怪异的节点删除方式"></a>2.19 怪异的节点删除方式</h2><p>要删除节点 $A$ ，可以先把 $A.next$ 的数据复制到 $A$ ，把 $A$ 指向 $A.next.next$ ，本质上只是复制数据，没有删除节点</p><h2 id="2-20-向有序环形单链表插入新节点"><a href="#2-20-向有序环形单链表插入新节点" class="headerlink" title="2.20 向有序环形单链表插入新节点"></a>2.20 向有序环形单链表插入新节点</h2><p>遍历，插入</p><h2 id="2-21-合并两个有序单链表"><a href="#2-21-合并两个有序单链表" class="headerlink" title="2.21 合并两个有序单链表"></a>2.21 合并两个有序单链表</h2><p>一个插到另一个里，时间 $O(M+N)$ ，空间 $O(1)$ </p><h2 id="2-22-按照左右半区重新组合单链表"><a href="#2-22-按照左右半区重新组合单链表" class="headerlink" title="2.22 按照左右半区重新组合单链表"></a>2.22 按照左右半区重新组合单链表</h2><p>提前知道链表长度，找到左右半区的头节点，交叉拼接</p><h1 id="第三章-二叉树问题"><a href="#第三章-二叉树问题" class="headerlink" title="第三章 二叉树问题"></a>第三章 二叉树问题</h1><h2 id="3-1-非递归二叉树先序遍历"><a href="#3-1-非递归二叉树先序遍历" class="headerlink" title="3.1 非递归二叉树先序遍历"></a>3.1 非递归二叉树先序遍历</h2><p>一个栈，压入头节点，[ 弹，右，左，弹 ] 循环</p><h2 id="3-2-非递归二叉树中序遍历"><a href="#3-2-非递归二叉树中序遍历" class="headerlink" title="3.2 非递归二叉树中序遍历"></a>3.2 非递归二叉树中序遍历</h2><p>一个栈，循环压左到 $null$ ，弹出栈顶节点并转到他的右节点，这两步循环</p><h2 id="3-3-非递归二叉树后序遍历"><a href="#3-3-非递归二叉树后序遍历" class="headerlink" title="3.3 非递归二叉树后序遍历"></a>3.3 非递归二叉树后序遍历</h2><p>两个栈， $A$ 栈中，弹，左，右循环，弹出到 $B$ 栈，最后 $B$ 全部弹出</p><h2 id="3-4-打印二叉树边界节点"><a href="#3-4-打印二叉树边界节点" class="headerlink" title="3.4 打印二叉树边界节点"></a>3.4 打印二叉树边界节点</h2><p>得到二叉树每层的左右边界：遍历得到树的高度 $h$ ，建立二维数组 $edge[h][2]$ ，递归先序遍历，数组第一位保存每层最先遍历到的节点，也就是左边界，每遍历到新的节点就更新数组的第二位，最终保存的就是右边界  </p><h2 id="3-5-直观打印二叉树"><a href="#3-5-直观打印二叉树" class="headerlink" title="3.5 直观打印二叉树"></a>3.5 直观打印二叉树</h2><p>右中左遍历并打印，因为纵向看，每一个节点都可以占单独的一列，无脑输出换行就行</p><h2 id="3-6-二叉树的序列化和反序列化"><a href="#3-6-二叉树的序列化和反序列化" class="headerlink" title="3.6 二叉树的序列化和反序列化"></a>3.6 二叉树的序列化和反序列化</h2><p>先序遍历+分隔符，把 $null$ 也记录下，方便计算子树在字符串中的范围。核心思想是用 $null$ 占位变成满二叉树，节点位置就可以计算了</p><h2 id="3-7-遍历二叉树的神级方法"><a href="#3-7-遍历二叉树的神级方法" class="headerlink" title="3.7 遍历二叉树的神级方法"></a>3.7 遍历二叉树的神级方法</h2><p>$Morris$ 遍历法，不使用递归和栈结构保存历史，让每个节点的左子树的最右节点指向该节点，核心思想是修改 $null$ 指针实现遍历时的回溯</p><h2 id="3-8-在二叉树中找到累加和为指定值的最长路径长度"><a href="#3-8-在二叉树中找到累加和为指定值的最长路径长度" class="headerlink" title="3.8 在二叉树中找到累加和为指定值的最长路径长度"></a>3.8 在二叉树中找到累加和为指定值的最长路径长度</h2><p>先序遍历二叉树，对每条路径应用 <a href="#jump5">8.11</a> 的方法，但是从左子树转到右子树时要把左子树在哈希表的记录删除，可以通过在哈希表记录节点的所在层次判断</p><h2 id="3-9-找到二叉树中的最大搜索二叉子树"><a href="#3-9-找到二叉树中的最大搜索二叉子树" class="headerlink" title="3.9 找到二叉树中的最大搜索二叉子树"></a>3.9 找到二叉树中的最大搜索二叉子树</h2><p>递归后序遍历，遍历完左右子树后，如果都是搜索二叉树，那么最大搜索二叉树要么是包括父节点的整棵树，要么是左右子树里节点多的那个，通过比较节点值可以确定</p><h2 id="3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构"><a href="#3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构" class="headerlink" title="3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构"></a>3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构</h2><p>自顶向下法：以每个节点为头节点往下找，满足条件就计数，时间 $O(N^2)$  </p><p>自底向上法：后序遍历，记录左右子树对父节点能贡献多少个满足条件的节点，空间 $O(N)$ ，根据树的形状，时间最优 $O(N)$ 最差 $O(NlogN)$ ，证明懒得看</p><h2 id="3-11-二叉树按层打印和-zigzag-打印"><a href="#3-11-二叉树按层打印和-zigzag-打印" class="headerlink" title="3.11 二叉树按层打印和 $zigzag$ 打印"></a>3.11 二叉树按层打印和 $zigzag$ 打印</h2><p>按层打印：使用队列，根据当前层的末尾标记出队，出队的时候把其子节点入队，入队同时更新标记下层的最后一个节点，也就是用两个末尾标记实现在队列里区分层次  </p><p>$zigzag$ 打印：双端队列，头进尾出和尾进头出交替进行</p><h2 id="3-12-调整搜索二叉树中两个错误节点"><a href="#3-12-调整搜索二叉树中两个错误节点" class="headerlink" title="3.12 调整搜索二叉树中两个错误节点"></a>3.12 调整搜索二叉树中两个错误节点</h2><p>中序遍历，如果降序一次，错的就是降序的两个节点，如果降序两次，错的是第一次的大节点和第二次的小节点。交换两个节点时要考虑各种连接情况</p><h2 id="3-13-判断-t1-树是否包含-t2-树全部的拓扑结构"><a href="#3-13-判断-t1-树是否包含-t2-树全部的拓扑结构" class="headerlink" title="3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构"></a>3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构</h2><p>把所有头节点与 $t2$ 相同的子树都匹配一遍，时间 $O(M\times N)$ </p><h2 id="3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树"><a href="#3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树" class="headerlink" title="3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树"></a>3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树</h2><p>方法一同上，方法二遍历成字符串，看 $t2$ 是不是 $t1$ 子串，时间 $O(M+N)$ </p><h2 id="3-15-判断二叉树是否是平衡二叉树"><a href="#3-15-判断二叉树是否是平衡二叉树" class="headerlink" title="3.15 判断二叉树是否是平衡二叉树"></a>3.15 判断二叉树是否是平衡二叉树</h2><p>后序遍历，记录遍历深度，递归检验左右子树是否是平衡二叉树</p><h2 id="3-16-根据后序数组重建搜索二叉树"><a href="#3-16-根据后序数组重建搜索二叉树" class="headerlink" title="3.16 根据后序数组重建搜索二叉树"></a>3.16 根据后序数组重建搜索二叉树</h2><p>后序遍历头节点都在末尾，比值确定前面左右子树分界</p><h2 id="3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树"><a href="#3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树" class="headerlink" title="3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树"></a>3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树</h2><p>搜索二叉树：中序遍历一遍   </p><p>完全二叉树：按层遍历，节点不够时判断是否时靠左排的叶节点</p><h2 id="3-18-通过有序数组生成平衡搜索二叉树"><a href="#3-18-通过有序数组生成平衡搜索二叉树" class="headerlink" title="3.18 通过有序数组生成平衡搜索二叉树"></a>3.18 通过有序数组生成平衡搜索二叉树</h2><p>数组中间的节点就是头节点，再递归处理左右子树</p><h2 id="3-19-在二叉树中找到一个节点中序遍历的后继节点"><a href="#3-19-在二叉树中找到一个节点中序遍历的后继节点" class="headerlink" title="3.19 在二叉树中找到一个节点中序遍历的后继节点"></a>3.19 在二叉树中找到一个节点中序遍历的后继节点</h2><p>先找右子树，再回溯父节点</p><h2 id="3-20-在二叉树中找到两个节点的最近公共祖先"><a href="#3-20-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="3.20 在二叉树中找到两个节点的最近公共祖先"></a>3.20 在二叉树中找到两个节点的最近公共祖先</h2><p>后序遍历，遍历左右子树后返回是否有目标节点，当左右子树都各找到一个目标节点是，当前节点就是最近祖先</p><h2 id="3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题"><a href="#3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题" class="headerlink" title="3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题"></a>3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题</h2><p>单独写</p><h2 id="3-22-二叉树节点间的最大距离"><a href="#3-22-二叉树节点间的最大距离" class="headerlink" title="3.22 二叉树节点间的最大距离"></a>3.22 二叉树节点间的最大距离</h2><p>最大距离有三种可能：左子树最大距离，右子树最大距离，左子树深度+1+右子树深度。后序遍历一次，同时记录子树最大距离和深度，比值得出结果</p><h2 id="3-23-先中后序数组两两结合重构二叉树"><a href="#3-23-先中后序数组两两结合重构二叉树" class="headerlink" title="3.23 先中后序数组两两结合重构二叉树"></a>3.23 先中后序数组两两结合重构二叉树</h2><p>先后序数组根节点在两端，代入中序数组可以区分左右子树。  </p><p>只有先后序时，由于左右可以混淆，如果有任一节点只有一个子节点，都无法重构原二叉树，先序中根节点之后就是左子树根节点，后序数组中左子树根节点之前的就是左子树，因此利用先后序数组可以区分左右子树。</p><h2 id="3-24-通过先序和中序数组生成后序数组"><a href="#3-24-通过先序和中序数组生成后序数组" class="headerlink" title="3.24 通过先序和中序数组生成后序数组"></a>3.24 通过先序和中序数组生成后序数组</h2><p>用先序数组确定后序数组最右的值，再利用中序数组分离出左右子树的先中序数组，重复这两步，把后序数组从右到左填满</p><h2 id="3-25-统计和生成所有不同的二叉树"><a href="#3-25-统计和生成所有不同的二叉树" class="headerlink" title="3.25 统计和生成所有不同的二叉树"></a>3.25 统计和生成所有不同的二叉树</h2><p>中序遍历为 $1\sim N$ 的一定是搜索二叉树，找规律，如果 $i$ 是头节点，则左子树有 $i-1$ 个节点，右子树有 $N-i$ 个节点，所以 $num(N)=\sum_{i=1}^Nnum(i-1)*num(N-i)$ </p><h2 id="3-26-统计完全二叉树的节点数"><a href="#3-26-统计完全二叉树的节点数" class="headerlink" title="3.26 统计完全二叉树的节点数"></a>3.26 统计完全二叉树的节点数</h2><p>一直向左遍历可以得到树的深度，因为完全二叉树叶节点靠左排列，所以遍历一个节点的右子树的最左节点，得到右子树的深度，如果等于整个树的深度，说明左子树节点是满的，循环这个步骤遍历右子树，如果深度小于树的深度，说明在这个深度下右子树节点是满的，循环这个步骤遍历左子树</p><h1 id="第四章-递归和动态规划"><a href="#第四章-递归和动态规划" class="headerlink" title="第四章 递归和动态规划"></a>第四章 递归和动态规划</h1><p>优化思路：压缩空间，枚举简化</p><h2 id="4-1-求斐波那契第N项"><a href="#4-1-求斐波那契第N项" class="headerlink" title="4.1 求斐波那契第N项"></a>4.1 求斐波那契第N项</h2><p>递归向下算，时间 $O(2^N)$   </p><p>从左向右依次算每一项，时间 $O(N)$   </p><p>用通项公式直接算，时间 $O(logN)$   </p><h2 id="4-2-斐波那契求奶牛数量"><a href="#4-2-斐波那契求奶牛数量" class="headerlink" title="4.2 斐波那契求奶牛数量"></a>4.2 斐波那契求奶牛数量</h2><p>$C(n)=C(n-1)+C(n-3)$ ，上一年的都活下来，三年前出生的都生一头小的，状态矩阵是三阶的</p><p><span id="jump3"></span></p><h2 id="4-3-矩阵的最小路径和"><a href="#4-3-矩阵的最小路径和" class="headerlink" title="4.3 矩阵的最小路径和"></a>4.3 矩阵的最小路径和</h2><p>动态规划，从左上角算到右下角，时间空间都是 $O(M\times N)$ ，只维护一行(列)空间时，向右或向下滚动更新，可以把空间压缩到 $O(min(M,N))$ ，之所以不用维护两行(列)是因为从前到后更新就相当于维护了两行(列)<br>P.S.：一般动态规划问题都可以用压缩空间的优化方法</p><h2 id="4-4-换钱的最少货币数"><a href="#4-4-换钱的最少货币数" class="headerlink" title="4.4 换钱的最少货币数"></a>4.4 换钱的最少货币数</h2><p>货币无限+面值不重复：维护二维数组，货币种类数*目标钱数，数组元素表示使用前 $i$ 种货币组成 $j$ 钱数需要的最少张数，遍历到 $dp[i][j]$ 时，枚举所有可能的 $k\geq0$ ，选择使用 $k$ 张当前货币时，最少张数的子问题。   </p><p>货币仅一张+面值可重复：和上面一样，只用做一次选择就够了，不用遍历所有 $k$ 。</p><h2 id="4-5-换钱的方法数"><a href="#4-5-换钱的方法数" class="headerlink" title="4.5 换钱的方法数"></a>4.5 换钱的方法数</h2><p>暴力搜索： $i$ 张第一+ $j$ 张第二+ $k$ 张第三……，时间最差 $O(aim^N)$  </p><p>带记忆的暴力搜索：避免重复计算，时间 $O(N\times aim^2)$     </p><p>经典动态规划：和上题一样，把值换成方法数，时间 $O(N\times aim^2)$   </p><p>时间复杂度一样是因为记忆搜索和经典动态规划的本质都是避免重复计算   </p><p>优化的动态规划(上题也可以用)：枚举所有可能的 $k\geq0$ 可以分成两部分，不用和必用当前货币，不用就是 $dp[i-1][j]$ ，必用本质上是 $dp[i][j-当前货币值]$ ，所以枚举的过程可以省去。时间 $O(N\times aim)$ </p><h2 id="4-6-最长递增子序列"><a href="#4-6-最长递增子序列" class="headerlink" title="4.6 最长递增子序列"></a>4.6 最长递增子序列</h2><p>经典： $dp[i]$ 表示以 $arr[i]$ 结尾的最长递增子序列长度，枚举前面所有结尾比 $arr[i]$ 小的 $dp[k]$ ，最后根据 $arr$ 和 $dp$ 数组得出序列， $O(N^2)$   </p><p>优化：建立辅助数组，记录长度为k的递增子序列最小结尾数，把枚举转化为在此数组上二分查找， $O(NlogN)$ </p><h2 id="4-7-汉诺塔"><a href="#4-7-汉诺塔" class="headerlink" title="4.7 汉诺塔"></a>4.7 汉诺塔</h2><p>递归， $n-1$ 左右中， $1$ 左中右， $n-1$ 中左右，每次在两个柱子间移动要考虑第三个柱子是为了递归的时候变换柱子的位置</p><h2 id="4-8-判断给的状态是不是汉诺塔最优过程中的某个状态"><a href="#4-8-判断给的状态是不是汉诺塔最优过程中的某个状态" class="headerlink" title="4.8 判断给的状态是不是汉诺塔最优过程中的某个状态"></a>4.8 判断给的状态是不是汉诺塔最优过程中的某个状态</h2><p>通过 $n$ 的位置可以知道进行到三个步骤中的哪个，然后递归检查 $n-1$ ，最后一定能确定具体步骤</p><h2 id="4-9-最长公共子序列"><a href="#4-9-最长公共子序列" class="headerlink" title="4.9 最长公共子序列"></a>4.9 最长公共子序列</h2><p>$dp[i][j]$ 表示 $str1[:i]$ 与 $str2[:j]$ 的最长公共子序列长度，取值为 $max{dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1(当前两个字符相同时)}$ ，获取序列要从右下角回溯，选择了三个值的哪一个就移动到他的位置，如果选择了 $dp[i-1][j-1]+1$ 就把当前字符放进结果</p><h2 id="4-10-最长公共子串"><a href="#4-10-最长公共子串" class="headerlink" title="4.10 最长公共子串"></a>4.10 最长公共子串</h2><p>经典： $dp[i][j]$ 表示以 $str1[i]$ 与 $str2[j]$ 结尾的最长公共子串长度，要么是 $0$ ，要么是 $dp[i-1][j-1]+1$ ，根据最大的 $dp$ 值直接得到子串，空间 $O(M\times N)$   </p><p>压缩：由于 $dp[i][j]$ 只和左上角的值有关，可以从左上到右下按斜线更新，一次更新一个，空间 $O(1)$ </p><h2 id="4-11-最小编辑代价"><a href="#4-11-最小编辑代价" class="headerlink" title="4.11 最小编辑代价"></a>4.11 最小编辑代价</h2><p>$dp[i][j]$ 表示 $str1[0,i-1]$ 编辑成 $str2[0,j-1]$ 的最小代价，第一行和第一列是全添和全删，中间的 $dp[i][j]$ 有四种取值： $dp[i-1][j]+删$ ，表示删去 $str1[i-1]$ 后把 $str1[0,i-2]$ 编辑成 $str2[0,j-1]$ ， $dp[i][j-1]+添$ ，表示把 $str1[0,i-1]$ 编辑成 $str2[0,j-2]$ 后添加 $str2[j-1]$ ， $dp[i-1][j-1]+改$ ，表示把 $str1[0,i-2]$ 编辑成 $str2[0,j-2]$ 后修改最后一个字符， $dp[i-1][j-1]$ ，表示当前两个字符正好相等   </p><p>压缩：因为可取值太多，要维护两行(列)</p><h2 id="4-12-字符串的交错组成"><a href="#4-12-字符串的交错组成" class="headerlink" title="4.12 字符串的交错组成"></a>4.12 字符串的交错组成</h2><p>$dp[i][j]$ 表示 $aim[0,i+j-1]$ 能否被 $str1[0,i-1]$ 和 $str2[0,j-1]$ 交错组成，第一行和第一列就是和两个字符串单独比较，中间的 $dp[i][j]=true$ 有两种情况： $str1[i-1]=aim[i+j-1]$ 且 $dp[i-1][j]=true$ ， $str2[j-1]=aim[i+j-1]$ 且 $dp[i][j-1]=true$ ，其余情况都是 $false$ </p><h2 id="4-13-龙与地下城"><a href="#4-13-龙与地下城" class="headerlink" title="4.13 龙与地下城"></a>4.13 龙与地下城</h2><p>和 <a href="#jump3">4.3</a> 一样，求的是最大值</p><h2 id="4-14-数字字符串转换为字母组合的种数"><a href="#4-14-数字字符串转换为字母组合的种数" class="headerlink" title="4.14 数字字符串转换为字母组合的种数"></a>4.14 数字字符串转换为字母组合的种数</h2><p>$dp[i]$ 表示前 $k$ 位不可变时的组合数，从后往前算， $dp[N]=1$ ，当 $str[i+1]=0$ 时 $dp[i]=0$ ，当 $str[i,i+1]$ 可转换时， $dp[i]=dp[i+1]+dp[i+2]$ ，否则 $dp[i]=dp[i+1]$ </p><h2 id="4-15-表达式得到期望结果的组合种数"><a href="#4-15-表达式得到期望结果的组合种数" class="headerlink" title="4.15 表达式得到期望结果的组合种数"></a>4.15 表达式得到期望结果的组合种数</h2><p>表达式 $express$ 一定是数字符号交错组成的，每一个奇数位上的符号把式子分成两部分，维护两个 $dp$ 二维数组分别表示 $express[i,j]$ 为 $true$ 和 $false$ 的组合种数， $dp[0,N]=\sum op_k(dp[0,k],dp[k,N-1])$ ，相当于在每个符号做一次分割，这种大分割产生的两组括号是唯一的，所以不同分割下不会出现重复的情况</p><h2 id="4-16-排成一条线的纸牌博弈问题"><a href="#4-16-排成一条线的纸牌博弈问题" class="headerlink" title="4.16 排成一条线的纸牌博弈问题"></a>4.16 排成一条线的纸牌博弈问题</h2><p>维护两个二维 $dp$ ， $dp_1[i][j]$ 表示面对 $s[i,j]$ 先拿的人最终能得到多少分， $dp_2[i][j]$ 表示后拿的人最终能得到多少分，只剩一张牌时 $dp_1[k][k]=arr[k]$ ， $dp_2[k][k]=0$ ，从右下往左上算， $dp_1[i][j]$ 可取值有 $arr[i]+dp_2[i+1][j]$ 和 $arr[j]+dp_2[i][j-1]$ ， $dp_2[i][j]$ 可取值有 $dp_1[i+1][j]$ 和 $dp_1[i][j-1]$ ，时间 $O(N^2)$  </p><h2 id="4-17-跳跃问题"><a href="#4-17-跳跃问题" class="headerlink" title="4.17 跳跃问题"></a>4.17 跳跃问题</h2><p>从左到右遍历一遍，维护三个临时变量， $jump$ 表示步数， $cur$ 表示以当前为起点能去的最远处， $next$ 表示以遍历过程中的点为起点能去的最远处，当遍历到 $cur$ 时，把 $cur$ 更新成 $next$ ，同时 $jump+1$ </p><h2 id="4-18-数组中的最长连续序列"><a href="#4-18-数组中的最长连续序列" class="headerlink" title="4.18 数组中的最长连续序列"></a>4.18 数组中的最长连续序列</h2><p>每次遍历一个数，先使用哈希表去重，然后保存在一个列表里，当列表里出现连续对时，合并成表示范围的二元组 $(left,right)$ ，由于能查询哈希表，检测连续时不需要遍历列表，所以最终时间空间都是 $O(N)$ </p><h2 id="4-19-N-皇后问题"><a href="#4-19-N-皇后问题" class="headerlink" title="4.19  $N$ 皇后问题"></a>4.19  $N$ 皇后问题</h2><p>暴力搜索：为减小空间复杂度，递归函数维护一维数组， $record[i]$ 表示第 $i$ 行放置的列数，遍历 $N$ 个列时实时检查该列能不能放</p><p>优化：利用位运算加速，用两个 $N$ 位二进制数表示当前哪些位置受列和斜线的影响不能放置，其实只加速了检查的操作</p><h1 id="第五章-字符串问题"><a href="#第五章-字符串问题" class="headerlink" title="第五章 字符串问题"></a>第五章 字符串问题</h1><p>子串是连续的，子序列是可以分散的</p><h2 id="5-1-判断两个字符串是否互为变形词"><a href="#5-1-判断两个字符串是否互为变形词" class="headerlink" title="5.1 判断两个字符串是否互为变形词"></a>5.1 判断两个字符串是否互为变形词</h2><p>建一个字符集大小的数组计数</p><h2 id="5-2-字符串中数字子串的求和"><a href="#5-2-字符串中数字子串的求和" class="headerlink" title="5.2 字符串中数字子串的求和"></a>5.2 字符串中数字子串的求和</h2><p>从左到右遍历，用几个变量标记</p><h2 id="5-3-去掉字符串中连续出现k个0的子串"><a href="#5-3-去掉字符串中连续出现k个0的子串" class="headerlink" title="5.3 去掉字符串中连续出现k个0的子串"></a>5.3 去掉字符串中连续出现k个0的子串</h2><p>从左到右遍历，用一个变量标记0的个数</p><h2 id="5-4-判断两个字符串是否互为旋转词"><a href="#5-4-判断两个字符串是否互为旋转词" class="headerlink" title="5.4 判断两个字符串是否互为旋转词"></a>5.4 判断两个字符串是否互为旋转词</h2><p>把两个 $str2$ 拼在一起，检查 $str1$ 是否是子串，方法同 $KMP$ 算法</p><h2 id="5-5-将整数字符串转成整数值"><a href="#5-5-将整数字符串转成整数值" class="headerlink" title="5.5 将整数字符串转成整数值"></a>5.5 将整数字符串转成整数值</h2><p>从左到右遍历</p><h2 id="5-6-替换字符串中连续出现的指定字符串"><a href="#5-6-替换字符串中连续出现的指定字符串" class="headerlink" title="5.6 替换字符串中连续出现的指定字符串"></a>5.6 替换字符串中连续出现的指定字符串</h2><p>从左到右遍历</p><h2 id="5-7-字符串的统计字符串"><a href="#5-7-字符串的统计字符串" class="headerlink" title="5.7 字符串的统计字符串"></a>5.7 字符串的统计字符串</h2><p>从左到右遍历</p><h2 id="5-8-判断字符数组中是否所有的字符都只出现过一次"><a href="#5-8-判断字符数组中是否所有的字符都只出现过一次" class="headerlink" title="5.8 判断字符数组中是否所有的字符都只出现过一次"></a>5.8 判断字符数组中是否所有的字符都只出现过一次</h2><p>使用哈希保存遍历结果，时间空间都是 $O(N)$   </p><p>原地排序，遍历检查，时间 $O(NlogN)$ ，空间 $O(1)$ </p><h2 id="5-9-在有序但含有空的数组中查找字符串"><a href="#5-9-在有序但含有空的数组中查找字符串" class="headerlink" title="5.9 在有序但含有空的数组中查找字符串"></a>5.9 在有序但含有空的数组中查找字符串</h2><p>二分查找</p><h2 id="5-10-字符串的调整与替换"><a href="#5-10-字符串的调整与替换" class="headerlink" title="5.10 字符串的调整与替换"></a>5.10 字符串的调整与替换</h2><p>从左到右遍历一遍，算出替换后的长度，再从右到左遍历，从尾部更新</p><h2 id="5-11-翻转字符串"><a href="#5-11-翻转字符串" class="headerlink" title="5.11 翻转字符串"></a>5.11 翻转字符串</h2><p>翻转单词：先整体逆序，再逐单词逆序   </p><p>翻转片段：先逐片段逆序，再整体逆序</p><h2 id="5-12-数组中两个字符串的最小距离"><a href="#5-12-数组中两个字符串的最小距离" class="headerlink" title="5.12 数组中两个字符串的最小距离"></a>5.12 数组中两个字符串的最小距离</h2><p>遍历一遍，找到 $str2$ 和他前后最近的两个 $str1$ 。进阶问题查询时间 $O(1)$ 就是先花时间做个查询表，mdzz</p><h2 id="5-13-添加最少字符使字符串整体都是回文字符串"><a href="#5-13-添加最少字符使字符串整体都是回文字符串" class="headerlink" title="5.13 添加最少字符使字符串整体都是回文字符串"></a>5.13 添加最少字符使字符串整体都是回文字符串</h2><p>动态规划， $dp[i][j]$ 表示使 $str[i,j]$ 回文需要添加的最少字符数， $dp[i][j]$ 有三种取值：长度为 $1$ 时 $dp$ 是 $0$ ，长度为 $2$ 时 $dp$ 是 $0$ 或 $1$ ，长度大于 $2$ 时，首尾相等 $dp[i][j]=dp[i+1][j-1]$ ，首尾不等时 $dp[i][j]=min{dp[i+1][j],dp[i][j-1]}+1$ ，从对角线向两侧更新 $dp$ ，最后新建长为 $N+dp[0][N-1]$ 的空字符串，从 $dp[0][N-1]$ 回溯填充得到回文串，时间 $O(N^2)$ </p><h2 id="5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"><a href="#5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串" class="headerlink" title="5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"></a>5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串</h2><p>新建空字符串，长度为原字符串长度两倍减去回文子序列长度，从原字符串两端同时搜索回文子序列，每搜到一对就把两侧经过的其他字符拼接填充在左侧，逆序后再填充到右侧，时间 $O(N)$ ，回文子序列位置有混淆也不影响，因为最终遍历的回文对数是不变的</p><h2 id="5-15-括号字符串的有效性和最长有效长度"><a href="#5-15-括号字符串的有效性和最长有效长度" class="headerlink" title="5.15 括号字符串的有效性和最长有效长度"></a>5.15 括号字符串的有效性和最长有效长度</h2><p>有效性：从左到右遍历计数，右括号始终不能多于左括号且最终相等   </p><p>最长有效长度：动态规划， $dp[i]$ 表示以 $str[i]$ 结尾的最长有效长度， $dp[0]=0$ ， $str[i]$ 是左括号时 $dp[i]=0$ ， $str[i]$ 是右括号时，如果 $str[i-1]$ 是左括号直接配对， $dp[i]=dp[i-2]+2$ ，如果 $dp[i-1]$ 不是 $0$ 且 $str[i-dp[i-1]-1]$ 是左括号， $dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]$ ，其余情况 $dp[i]=0$ </p><h2 id="5-16-公式字符串求值"><a href="#5-16-公式字符串求值" class="headerlink" title="5.16 公式字符串求值"></a>5.16 公式字符串求值</h2><p>数值栈+符号栈，遇到右括号和乘除尝试计算</p><h2 id="5-17-0-左边必有-1-的二进制字符串数量"><a href="#5-17-0-左边必有-1-的二进制字符串数量" class="headerlink" title="5.17  $0$ 左边必有 $1$ 的二进制字符串数量"></a>5.17  $0$ 左边必有 $1$ 的二进制字符串数量</h2><p> $dp[i]$ 表示满足条件的 $i$ 位字符串数量，一个满足条件的字符串后面可以补 $1$ ，但是只有末尾为 $1$ 时可以补 $0$ ，所以 $dp[i+1]=dp[i]+dp_1[i]$ ，而第 $i$ 位为 $1$ 时表示第 $i-1$ 位随意，所以 $dp_1[i]=dp[i-1]$ ，所以 $dp[i+1]=dp[i]+dp[i-1]$ ，是斐波那契数列，最优时间 $O(logN)$ </p><h2 id="5-18-拼接所有字符串产生字典顺序最小的大写字符串"><a href="#5-18-拼接所有字符串产生字典顺序最小的大写字符串" class="headerlink" title="5.18 拼接所有字符串产生字典顺序最小的大写字符串"></a>5.18 拼接所有字符串产生字典顺序最小的大写字符串</h2><p>如果 $A+B$ 的字典序小于 $B+A$ ， $A$ 就应该在 $B$ 前边，照这个思路选择排序。</p><p>$\color{red}{不理解这个为什么算贪心算法？为什么需要证明？}$</p><h2 id="5-19-找到字符串的最长无重复字符子串"><a href="#5-19-找到字符串的最长无重复字符子串" class="headerlink" title="5.19 找到字符串的最长无重复字符子串"></a>5.19 找到字符串的最长无重复字符子串</h2><p>哈希表记录，标记子串头，从左到右遍历，时间 $O(N)$ ，空间 $O(M)$ ， $M$ 是字符集大小</p><h2 id="5-20-找到被指的新类型字符"><a href="#5-20-找到被指的新类型字符" class="headerlink" title="5.20 找到被指的新类型字符"></a>5.20 找到被指的新类型字符</h2><p> $str[k-1]$ 小写则结果从 $str[k]$ 开始， $str[k-1]$ 大写时，向左找有几个连续的大写，有偶数个大写则结果从 $str[k]$ 开始，反之结果从 $str[k-1]$ 开始</p><h2 id="5-21-最小包含子串的长度"><a href="#5-21-最小包含子串的长度" class="headerlink" title="5.21 最小包含子串的长度"></a>5.21 最小包含子串的长度</h2><p>哈希表记录，左右边界设在起点，右边界向右找到子串，左边界向右缩小范围，得到备选子串，循环该过程不断从右边界重新遍历，选所有备选子串里最短的，时间 $O(N)$ </p><h2 id="5-22-回文最少分割数"><a href="#5-22-回文最少分割数" class="headerlink" title="5.22 回文最少分割数"></a>5.22 回文最少分割数</h2><p>动态规划， $dp[i]$ 表示 $str[0,i]$ 的最少分割数，从 $0$ 到 $i$ 找到第一个使 $str[j,i]$ 回文的 $j$ ， $dp[i]=dp[j]+1$ ，判断回文的过程可优化</p><h2 id="5-23-字符串匹配问题"><a href="#5-23-字符串匹配问题" class="headerlink" title="5.23 字符串匹配问题"></a>5.23 字符串匹配问题</h2><p>正则匹配原理：有限状态机+递归匹配</p><h2 id="5-24-字典树的实现"><a href="#5-24-字典树的实现" class="headerlink" title="5.24 字典树的实现"></a>5.24 字典树的实现</h2><p>简单粗暴，节点属性有共用数、词尾数、子节点集合</p><h1 id="第六章-大数据和空间限制"><a href="#第六章-大数据和空间限制" class="headerlink" title="第六章 大数据和空间限制"></a>第六章 大数据和空间限制</h1><p>降低精度或增加时间从而减少空间</p><h2 id="6-1-布隆过滤器"><a href="#6-1-布隆过滤器" class="headerlink" title="6.1 布隆过滤器"></a>6.1 布隆过滤器</h2><p>创建一个巨大的长为 $m$ 的 $bit$ 数组，对每条数据使用 $k$ 个哈希函数，分别对 $m$ 取余，把 $bit$ 数组的 $k$ 个 $bit$ 置为 $1$ 。使用时如果输入对应的 $k$ 个位置都为 $1$ 就过滤，只会误杀不会漏杀</p><p><span id="jump4"></span></p><h2 id="6-2-找到出现最多的数"><a href="#6-2-找到出现最多的数" class="headerlink" title="6.2 找到出现最多的数"></a>6.2 找到出现最多的数</h2><p>读文件不会把整个文件放进内存，但是查哈希表是把整个表放进内存。 把 $N$ 个数的文件用哈希函数分配到 $k$ 个哈希表里，哈希函数能保证相同的数都在同一个表里，每次查找只把一个表放进内存，查完所有表后对比各自频次最多的数，把大的集合分组不仅能减少内存占用，还能减少哈希表里表示键值的比特长度</p><h2 id="6-3-找到没出现的数"><a href="#6-3-找到没出现的数" class="headerlink" title="6.3 找到没出现的数"></a>6.3 找到没出现的数</h2><p>只考虑出现与否不需要计数，可以使用 $bit$ 数组减少内存占用，再优化还可以分组统计，每次只检查 $k$ 个数出现与否，但每组都要遍历一遍原文件</p><h2 id="6-4-找到所有重复的-url"><a href="#6-4-找到所有重复的-url" class="headerlink" title="6.4 找到所有重复的 $url$"></a>6.4 找到所有重复的 $url$</h2><p>同 <a href="#jump4">6.2</a> ，大文件拆成多个小文件</p><h2 id="6-5-统计词汇-top-k"><a href="#6-5-统计词汇-top-k" class="headerlink" title="6.5 统计词汇 $top_k$"></a>6.5 统计词汇 $top_k$</h2><p>同 <a href="#jump4">6.2</a> ，大文件拆成多个小文件，每个小文件 $top_k$ 再排序</p><h2 id="6-6-找到出现两次的数"><a href="#6-6-找到出现两次的数" class="headerlink" title="6.6 找到出现两次的数"></a>6.6 找到出现两次的数</h2><p>双倍 $bit$ 数组，每个数用两个 $bit$ 统计出现 $0$ 次、 $1$ 次、 $2$ 次和多次</p><h2 id="6-7-找中位数"><a href="#6-7-找中位数" class="headerlink" title="6.7 找中位数"></a>6.7 找中位数</h2><p>先分好 $k$ 个区间，遍历一遍文件得到中位数出现的区间，再遍历一遍在目标区间里接着找，空间不够可以继续分区间</p><h2 id="6-8-一致性哈希算法"><a href="#6-8-一致性哈希算法" class="headerlink" title="6.8 一致性哈希算法"></a>6.8 一致性哈希算法</h2><p>环形分配可以减小增删机器时数据迁移的代价，虚拟节点可以减小机器较少时的负载不均衡</p><h1 id="第七章-位运算"><a href="#第七章-位运算" class="headerlink" title="第七章 位运算"></a>第七章 位运算</h1><h2 id="7-1-不用额外变量交换两个整数的值"><a href="#7-1-不用额外变量交换两个整数的值" class="headerlink" title="7.1 不用额外变量交换两个整数的值"></a>7.1 不用额外变量交换两个整数的值</h2><p>$a=a\oplus b$ , $b=a\oplus b$ , $a=a\oplus b$ ，第一步把 $a$ 和 $b$ 信息不同的比特位标为 $1$ ，第二步当信息不同且 $b$ 是 $0$ 时结果是 $1$ ，信息相同 $b$ 是 $1$ 是返回 $1$ ，所以结果就是原来的 $a$ ，第三步当信息不同且 $b$ (原来的 $a$ )是 $0$ 时结果是 $1$ ，信息相同 $b$ 是 $1$ (原来的 $a$ )是返回 $1$ ，所以结果就是 $a$ (原来的 $b$ )</p><h2 id="7-2-不用任何比较判断找出两个数中较大的数"><a href="#7-2-不用任何比较判断找出两个数中较大的数" class="headerlink" title="7.2 不用任何比较判断找出两个数中较大的数"></a>7.2 不用任何比较判断找出两个数中较大的数</h2><p>二进制最高位是符号位， $1$ 是负数， $0$ 是非负，查看 $a$ 、 $b$ 和 $a-b$ 的符号， $a$ 和 $b$ 符号相反直接返回非负的， $a$ 和 $b$ 符号相同则 $a-b$ 不会溢出，根据 $a-b$ 符号返回结果</p><h2 id="7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出"><a href="#7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出" class="headerlink" title="7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)"></a>7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)</h2><p>加法：只相加不进位时 $a+b=a^b$ ，向前进位的序列是 $(a\&amp;b)\ll 1$ ，再以异或序列和进位序列不断循环前两步，直到进位序列全是 $0$   </p><p>减法： $a-b=a+(-b)$ ， $b$ 的相反数是把 $b$ 取反加一得到补码，再和 $a$ 做上述加法  </p><p>乘法： $a\times b$ 本质是 $a$ 循环累加，把 $b$ 按位拆分，最低位是 $1$ 时结果加 $a$ ，高位都代表 $2$ 的乘方，通过对 $a$ 向左移位可以实现，最终 $a\times b=a\times b<em>0+\sum</em>{i=1}^n(a\ll i)\times b_i$ ，因为 $b_i$ 是 $0$ 或 $1$ ，所以式子里的乘法只是形式上的， $b$ 是负数也成立  </p><p>除法： $a\div b$ 本质是 $a$ 循环减去 $b$ ，因此可以对 $b$ 移位比大小得到比 $a$ 小的最大的数。如果 $a$ 、 $b$ 中有负数要先转成非负，最后再考虑符号。一个特例是， $int$ 的最小值的绝对值比最大值大 $1$ ，所以 $int$ 的最小值不能转成正数，当不能直接判断出结果，也就是最小值必须参与计算时，可以把最小值拆成几段分开算，最后用余数再算一次</p><h2 id="7-4-整数的二进制表达中有多少个-1"><a href="#7-4-整数的二进制表达中有多少个-1" class="headerlink" title="7.4 整数的二进制表达中有多少个 $1$"></a>7.4 整数的二进制表达中有多少个 $1$</h2><p>方法一：循环 $n=n\And(n-1)$ 或 $n-=n\And(1-n)$ 直到 $n=0$ ，这个操作本质上是去掉 $n$ 最右边的 $1$ ，两个式子右边一个返回去掉末尾 $1$ 的 $n$ ，一个直接返回末尾 $1$  </p><p>方法二：平行算法，统计 $1$ 的个数不用把整个二进制序列当成一个数，同时在每个bit上操作既提高了效率又排除了序列里高低位的影响，平行算法采用归并的思路，依次算出每 $2^k$ 位里有多少个 $1$ ，最后一步的结果就是整个序列里有多少个 $1$<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int function(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    n &#x3D; (n &amp; 0x55555555) + ((n&gt;&gt; 1) &amp; 0x55555555); #每2bit为一组相加 </span><br><span class="line">    n &#x3D; (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333); #每4bit为一组相加 </span><br><span class="line">    n &#x3D; (n &amp; 0x0f0f0f0f) + ((n&gt;&gt; 4) &amp; 0x0f0f0f0f); #每2bit为一组相加   </span><br><span class="line">    n &#x3D; (n &amp; 0xff00ff) + ((n&gt;&gt; 8) &amp; 0xff00ff); #每16bit为一组相加      </span><br><span class="line">    n &#x3D; (n &amp; 0xffff) + ((n&gt;&gt; 16) &amp; 0xffff) ; #每32bit为一组相加         </span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="7-5-在其他数都出现偶数次的数组中找到出现奇数次的数"><a href="#7-5-在其他数都出现偶数次的数组中找到出现奇数次的数" class="headerlink" title="7.5 在其他数都出现偶数次的数组中找到出现奇数次的数"></a>7.5 在其他数都出现偶数次的数组中找到出现奇数次的数</h2><p>一个数奇数次： $n\oplus0=n,n\oplus n=0$ ，所以只要用一个 $0$ 把所有数都异或一遍，剩下的值就是奇数次那个数  </p><p>两个数奇数次：用 $0$ 异或一遍结果是 $a\oplus b$ ，两个数不相等结果必有个第 $k$ 位是 $1$ ，再用 $0$ 与第 $k$ 位是 $1$ 的所有数异或一遍，得到的就是 $a$ 或 $b$ </p><h2 id="7-6-在其他数都出现-k-次的数组中找到只出现一次的数"><a href="#7-6-在其他数都出现-k-次的数组中找到只出现一次的数" class="headerlink" title="7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数"></a>7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数</h2><p>$k$ 个相同的 $k$ 进制的数无进位相加结果是 $0$ ，因为结果每一位都是 $(k\times a)\%k$ ，所以把所有数转为 $k$ 进制累加，得到的结果就是只出现一次的数</p><h1 id="第八章-数组和矩阵问题"><a href="#第八章-数组和矩阵问题" class="headerlink" title="第八章 数组和矩阵问题"></a>第八章 数组和矩阵问题</h1><h2 id="8-1-转圈打印矩阵"><a href="#8-1-转圈打印矩阵" class="headerlink" title="8.1 转圈打印矩阵"></a>8.1 转圈打印矩阵</h2><p>就是从外到内逐层打印，用每一圈的四个角的坐标判断</p><h2 id="8-2-将正方形矩阵顺时针旋转-90-deg"><a href="#8-2-将正方形矩阵顺时针旋转-90-deg" class="headerlink" title="8.2 将正方形矩阵顺时针旋转 90&deg;"></a>8.2 将正方形矩阵顺时针旋转 90&deg;</h2><p>方阵里一个数顺时针旋转 90&deg; 就是沿着他所在的一圈顺时针走一条边的距离，和上题一样逐圈操作</p><h2 id="8-3-之字形打印矩阵"><a href="#8-3-之字形打印矩阵" class="headerlink" title="8.3 之字形打印矩阵"></a>8.3 之字形打印矩阵</h2><p>算坐标，碰到边界再判断怎么移动</p><h2 id="8-4-找到无序数组中最小的-k-个数"><a href="#8-4-找到无序数组中最小的-k-个数" class="headerlink" title="8.4 找到无序数组中最小的 $k$ 个数"></a>8.4 找到无序数组中最小的 $k$ 个数</h2><p>$O(Nlogk)$ 方法：维护一个 $k$ 个节点的大根堆，遍历数组，如果元素小于堆顶就插入堆，其中遍历 $O(N)$ ，堆插入 $O(logk)$    </p><p>$O(N)$ 方法： $BFPRT$ 算法可以从数组中找到第 $k$ 小的数，把原数组每五个数分一组，分别求中位数，再递归求中位数的中位数，最终得到一个中位数 $x$ ，用 $x$ 划分原数组中大于 $x$ 和小于 $x$ 的数，在其中一边继续用中位数方法划分，最终能得到 $x$ 在数组中的位置是第 $k$ ，可以用数学证明该过程时间复杂度是 $O(N)$ ，大概意思就是用中位数划分数组效率高，所以能收敛到 $O(N)$ ，所以找到 $k$ 个最小的数总的时间复杂度也是 $O(N)$ </p><h2 id="8-5-需要排序的最短子数组长度"><a href="#8-5-需要排序的最短子数组长度" class="headerlink" title="8.5 需要排序的最短子数组长度"></a>8.5 需要排序的最短子数组长度</h2><p>从左到右、从右到左分别遍历，找边界</p><h2 id="8-6-在数组中找到出现次数大于-N-K-的数"><a href="#8-6-在数组中找到出现次数大于-N-K-的数" class="headerlink" title="8.6 在数组中找到出现次数大于 $N/K$ 的数"></a>8.6 在数组中找到出现次数大于 $N/K$ 的数</h2><p>遍历一遍数组，循环排除 $K$ 个不同的数，直到剩下的不足 $K$ ，剩下的就是出现次数大于 $N/K$ 的数。具体实现是建立两个长度为 $K-1$ 的数组， $A$ 数组存数组里的数， $B$ 数组存出现次数，当遍历到的 $x$ 与 $A$ 里的都不同时， $B$ 数组都减一同时遍历下一个，就相当于排除了 $K$ 个不同的数，次数归零时用遍历到的数补位，最终时间复杂度 $O(N\times K)$ ，空间复杂度 $O(K)$ </p><h2 id="8-7-在行列都排好序的矩阵中找数"><a href="#8-7-在行列都排好序的矩阵中找数" class="headerlink" title="8.7 在行列都排好序的矩阵中找数"></a>8.7 在行列都排好序的矩阵中找数</h2><p>$M\times N$ 的矩阵中，每个以对角线上一点为右下角的一行和一列的组合里，对角线上这个点都是最大的，相当于从左上角到右下角沿着对角线剥洋葱，遍历的最大长度是对角线+一行+一列，时间 $O(M+N)$ </p><h2 id="8-8-最长的可整合子数组的长度"><a href="#8-8-最长的可整合子数组的长度" class="headerlink" title="8.8 最长的可整合子数组的长度"></a>8.8 最长的可整合子数组的长度</h2><p>可整合数组就是元素不重复，最大值-最小值+1是元素个数的数组，从左到右以每个元素为起点遍历一次，时间 $O(N^2)$ </p><h2 id="8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><a href="#8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组" class="headerlink" title="8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组"></a>8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组</h2><p>二元组：一个左指针一个右指针向中间遍历，时间 $O(N)$   </p><p>三元组：从左到右遍历，每遍历到一个元素，就把他后面的当成一个二元组问题求解，时间 $O(N^2)$ </p><h2 id="8-10-未排序正数数组中累加和为给定值的最长子数组长度"><a href="#8-10-未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="8.10 未排序正数数组中累加和为给定值的最长子数组长度"></a>8.10 未排序正数数组中累加和为给定值的最长子数组长度</h2><p>左右两个指针从数组头遍历，变量 $sum$ 存两个指针标记的子数组累加和，变量 $len$ 存 $sum$ 为给定值 $k$ 时的最长子数组长度，右指针向右遍历， $sum\geq k$ 时左指针加一</p><p><span id="jump5"></span></p><h2 id="8-11-未排序数组中最长子数组系列问题"><a href="#8-11-未排序数组中最长子数组系列问题" class="headerlink" title="8.11 未排序数组中最长子数组系列问题"></a>8.11 未排序数组中最长子数组系列问题</h2><p>累加和为 $k$ ： $s[i]$ 表示子数组 $arr[0,i]$ 的累加和，则 $arr[j,i]$ 的累加和就是 $s[i]-s[j-1]$ ，从左到右遍历数组计算累加和，建立哈希表， $key$ 是累加和， $value$ 是最先产生该累加和的数组下标，若 $s[i]=k$ ，就得到了一个满足条件的子数组，若 $s[i]&gt;k$ ，就在表中查找 $s[i]-k$   </p><p>正数与负数个数相等：正数变 $1$ ，负数变 $-1$ ，相当于求累加和为 $0$ </p><p>数组里只有 $0$ 和 $1$ ，子数组 $0$ 和 $1$ 个数相等： $0$ 变 $-1$ ，求累加和为 $0$ </p><h2 id="8-12-未排序数组中累加和小于或等于给定值的最长子数组长度"><a href="#8-12-未排序数组中累加和小于或等于给定值的最长子数组长度" class="headerlink" title="8.12 未排序数组中累加和小于或等于给定值的最长子数组长度"></a>8.12 未排序数组中累加和小于或等于给定值的最长子数组长度</h2><p>建立数组 $s$ 记录累加和，建立数组 $h$ 记录 $s[0,i]$ 之间的最大值，遍历一遍原数组 $O(N)$ ，每遍历一个元素，如果 $s[i]\leq k$ 就更新最长子数组长度，反之就在 $0\sim i$ 之间搜索是否存在 $s[i]-s[j-1]\leq k$ ，即 $s[j-1]\geq s[i]-k$ ，由于 $h$ 是递增数组，结合数组 $s$ 可以实现 $O(logN)$ 的二分查找，最终时间 $O(NlogN)$ ， 空间 $O(N)$ </p><h2 id="8-13-计算数组的小和"><a href="#8-13-计算数组的小和" class="headerlink" title="8.13 计算数组的小和"></a>8.13 计算数组的小和</h2><p>在归并排序的过程中计算小和，因为每一步操作的两个数组都是排好序的，所以节省了遍历的时间，对于 $s_1[i]$ ，只要找到第一个 $s_1[i]&lt;s_2[j]$ ，直接给总数组小和加上 $s_1[i]*(len(s_2)-j+1)$ ，时间 $O(NlogN)$ ，空间 $O(N)$ </p><h2 id="8-14-自然数数组的排序"><a href="#8-14-自然数数组的排序" class="headerlink" title="8.14 自然数数组的排序"></a>8.14 自然数数组的排序</h2><p>前提是已经知道了一个数应该放在哪里，从左到右遍历，如果一个位置上的数不对，就把他放到正确的位置，替换掉那个位置上的数，然后循环修正替换下来的数，最后会回到原来遍历中止的位置，继续往后遍历</p><h2 id="8-15-奇数下标都是奇数或者偶数下标都是偶数"><a href="#8-15-奇数下标都是奇数或者偶数下标都是偶数" class="headerlink" title="8.15 奇数下标都是奇数或者偶数下标都是偶数"></a>8.15 奇数下标都是奇数或者偶数下标都是偶数</h2><p>两个指针从左到右分别遍历数组的奇数和偶数位置，循环检查数组最后一个数，放在相应指针标记的位置，把该位置替换下来的数放在数组尾部，对应指针加二</p><h2 id="8-16-子数组的最大累加和问题"><a href="#8-16-子数组的最大累加和问题" class="headerlink" title="8.16 子数组的最大累加和问题"></a>8.16 子数组的最大累加和问题</h2><p>从左到右累加，累加和变成负数就从下个数重新累加，用一个变量记录累加和的最大值</p><h2 id="8-17-子矩阵的最大累加和问题"><a href="#8-17-子矩阵的最大累加和问题" class="headerlink" title="8.17 子矩阵的最大累加和问题"></a>8.17 子矩阵的最大累加和问题</h2><p>把矩阵的 $k$ 行累加成一行，转化成子数组的最大累加和问题，结果就是以这 $k$ 行为基础搜索矩阵的列找到的子矩阵，从上到下以每行为起点遍历所有行数的矩阵，搜索最大累加和的子矩阵，最终时间 $O(N^3)$ ，空间 $O(N)$  </p><h2 id="8-18-在数组中找到一个局部最小的位置"><a href="#8-18-在数组中找到一个局部最小的位置" class="headerlink" title="8.18 在数组中找到一个局部最小的位置"></a>8.18 在数组中找到一个局部最小的位置</h2><p>先判断首尾有没有，没有就二分查找，如果 $arr[mid]&gt;arr[mid-1]$ ，因为左半边肯定不单调，所以一定存在局部最小，如果 $arr[mid]&gt;arr[mid+1]$ 就在右半边找，最终时间 $O(logN)$ </p><h2 id="8-19-数组中子数组的最大累乘积"><a href="#8-19-数组中子数组的最大累乘积" class="headerlink" title="8.19 数组中子数组的最大累乘积"></a>8.19 数组中子数组的最大累乘积</h2><p>从左到右遍历，分别求以每个 $arr[i]$ 结尾的最大累乘积 $max[i]$ 和最小累乘积 $min[i]$ ，通过比较 $max[i-1]\times arr[i]$ 、 $min[i-1]\times arr[i]$ 和  $arr[i]$ 三个数确定最大最小累乘积，再用一个变量保存整个过程中的最大累乘积，时间 $O(N)$ ，空间 $O(1)$ </p><h2 id="8-20-打印-N-个数组整体最大的-topK"><a href="#8-20-打印-N-个数组整体最大的-topK" class="headerlink" title="8.20 打印 $N$ 个数组整体最大的 $topK$"></a>8.20 打印 $N$ 个数组整体最大的 $topK$</h2><p>维护一个大根堆，因为数组都是有序的，取 $N$ 个数组的最大值建堆，时间 $O(N)$ ，每次把堆顶加入 $topK$ 并把堆顶元素所在数组的下一个最大值插入堆，每次插入 $O(logN)$ ，插入总时间 $O(KlogN)$ </p><h2 id="8-21-边界都是-1-的最大正方形大小"><a href="#8-21-边界都是-1-的最大正方形大小" class="headerlink" title="8.21 边界都是 $1$ 的最大正方形大小"></a>8.21 边界都是 $1$ 的最大正方形大小</h2><p>以每个点为正方形的左上角，对于所有可能的边长，检查正方形的四条边，时间 $O(N^4)$ ，空间 $O(1)$ 。可以通过预处理矩阵把检查四条边的时间变成 $O(1)$ ，预先生成两个矩阵，用来记录每个点向右和向下有多少个连续的 $1$ ，从右下角开始算，每次利用之前计算出的结果，可以把预处理时间降到 $O(N^2)$ ，优化后的总时间是 $O(N^3)$ ，空间 $O(N^2)$ </p><h2 id="8-22-不包含本位置值的累乘数组"><a href="#8-22-不包含本位置值的累乘数组" class="headerlink" title="8.22 不包含本位置值的累乘数组"></a>8.22 不包含本位置值的累乘数组</h2><p>使用除法：用总乘积除以每一位</p><p>不使用除法：创建两个数组分别存储从左到右和从右到左的累乘，不包含一个数的累乘相当于他的左累乘和右累乘的乘积；或者用异或代替除法</p><h2 id="8-23-数组的-partition-调整"><a href="#8-23-数组的-partition-调整" class="headerlink" title="8.23 数组的 $partition$ 调整"></a>8.23 数组的 $partition$ 调整</h2><p>从左到右遍历，交换数值，相当于用一个左指针把数组分成两个区，遍历过程中在区之间做交换。更复杂的问题可以用一个左指针一个右指针把数组分成三个区</p><h2 id="8-24-求最短通路值"><a href="#8-24-求最短通路值" class="headerlink" title="8.24 求最短通路值"></a>8.24 求最短通路值</h2><p>广度优先遍历，时间 $O(M\times N)$ </p><h2 id="8-25-数组中未出现的最小正整数"><a href="#8-25-数组中未出现的最小正整数" class="headerlink" title="8.25 数组中未出现的最小正整数"></a>8.25 数组中未出现的最小正整数</h2><p>理想情况是数组里存着 $1\sim N$ ，当发现不属于这个范围的数或有重复数时，说明坑位不够了。初始化 $l=0$ 和 $r=N$ 标记空余位置的范围。循环遍历范围头部：<br>若 $arr[l]=l+1$ ，说明正好占对了最左边的坑， $l++$<br>若 $arr[l] &lt; l$ 或 $arr[l]&gt;r$ ，说明有范围外的占坑了，把 $arr[r-1]$ 保存到 $arr[l]$ ，同时 $r—$ ，表示删除一个坑位<br>若 $arr[arr[l]-1]=arr[l]$ ，说明 $arr[l]$ 是合法范围内的数，但是他应该在的位置 $arr[l]-1$ 上已经有相同的数了，说明出现了重复，把 $arr[r-1]$ 保存到 $arr[l]$ ，同时 $r—$ ，表示删除一个坑位<br>若以上错误都没出现，说明 $arr[l]$ 是合法范围内的数，把他和 $arr[l]-1$ 位置上的数交换<br>最终左右指针相遇， $l+1$ 就是未出现的最小正整数</p><h2 id="8-26-数组排序之后相邻数的最大差值"><a href="#8-26-数组排序之后相邻数的最大差值" class="headerlink" title="8.26 数组排序之后相邻数的最大差值"></a>8.26 数组排序之后相邻数的最大差值</h2><p>遍历一次找到最大最小值，做桶排序，时间 $O(N)$ </p><h1 id="第九章-其他题目"><a href="#第九章-其他题目" class="headerlink" title="第九章 其他题目"></a>第九章 其他题目</h1><h2 id="9-1-从-5-随机到-7-随机及其扩展"><a href="#9-1-从-5-随机到-7-随机及其扩展" class="headerlink" title="9.1 从 $5$ 随机到 $7$ 随机及其扩展"></a>9.1 从 $5$ 随机到 $7$ 随机及其扩展</h2><p>$rand1to5$ 实现 $rand1to7$ ：独立调用两次 $rand1to5$ ， $res=(rand1to5-1)\times 5+(rand1to5-1)$ 等概率随机生成 $0\sim 24$ 之间的数，当结果在 $0\sim 20$ 之间时， $res\%7+1$ 就等概率随机生成 $0\sim 27$ 之间的数 </p><p>$rand01p$ 实现 $rand1to6$ ：由于 $rand01p$ 生成 $01$ 和 $10$ 的概率都是 $p(1-p)$ ，所以先通过调用两次 $rand01p$ 实现等概率产生 $0$ 和 $1$ 的 $rand01$ 。 $rand0to3=rand01\times 2+rand01$ 等概率随机生成 $0\sim 3$ ， $res=rand0to3\times 4+rand0to3$ 等概率随机生成 $0\sim 15$ ，当结果在 $0\sim 11$ 之间时， $res\%6+1$ 就等概率随机生成 $0\sim 6$ 之间的数 </p><p>$rand1toM$ 实现 $rand1toN$ ：如果 $M&gt;N$ ，调用一次直接筛选 $res$ ，如果 $M&lt;N$ ，调用多次拼接成一个多位的 $M$ 进制数，再筛选 $res$ </p><h2 id="9-2-一行代码求两个数的最大公约数"><a href="#9-2-一行代码求两个数的最大公约数" class="headerlink" title="9.2 一行代码求两个数的最大公约数"></a>9.2 一行代码求两个数的最大公约数</h2><p>辗转相除法， $gcd(a,b)=gcd(b,a\%b)$ </p><h2 id="9-3-有关阶乘的两个问题"><a href="#9-3-有关阶乘的两个问题" class="headerlink" title="9.3 有关阶乘的两个问题"></a>9.3 有关阶乘的两个问题</h2><p>阶乘末尾 $0$ 的数量：遍历 $1\sim N$ 的所有数，累计每个数的因子 $5$ 的个数，遍历过程可以优化，一个数有多少 $5^k$ 的因子，就能提供多少个 $5$ ，所以因子 $5$ 总数为： $\sum_{k=1} N/5^k$ </p><p>阶乘的二进制表示中最右边的 $1$ 的位置：末尾 $0$ 的数量是因子 $2$ 的个数 $\sum_{k=1} N/2^k$ </p><h2 id="9-4-判断一个点是否在矩形内部"><a href="#9-4-判断一个点是否在矩形内部" class="headerlink" title="9.4 判断一个点是否在矩形内部"></a>9.4 判断一个点是否在矩形内部</h2><p>比较坐标位置；或者看横纵直线和矩形的交点，一个点在凸多边形的内部，从这个点引出的横纵两条直线与多边形的四个交点一定分布在这个点的上下左右</p><h2 id="9-5-判断一个点是否在三角形内部"><a href="#9-5-判断一个点是否在三角形内部" class="headerlink" title="9.5 判断一个点是否在三角形内部"></a>9.5 判断一个点是否在三角形内部</h2><p>同上</p><h2 id="9-6-折纸问题"><a href="#9-6-折纸问题" class="headerlink" title="9.6 折纸问题"></a>9.6 折纸问题</h2><p>找规律，每次折叠产生的新折痕都是在上次折叠新产生的每一条折痕前后生成下折痕和上折痕<br>第一次折叠：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;下<br>第二次折叠：&emsp;&emsp;&emsp;下&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;上<br>第三次折叠：&emsp;下&emsp;&emsp;&emsp;上&emsp;&emsp;&emsp;下&emsp;&emsp;&emsp;上<br>第四次折叠：下&emsp;上&emsp;下&emsp;上&emsp;下&emsp;上&emsp;下&emsp;上<br>中序遍历的结果就是折痕顺序</p><h2 id="9-7-蓄水池算法"><a href="#9-7-蓄水池算法" class="headerlink" title="9.7 蓄水池算法"></a>9.7 蓄水池算法</h2><p>前 $k$ 个球直接放入，对于第 $i(i&gt;k)$ 个球，以 $k/i$ 的概率决定放入，如果放入了就随机扔掉袋子里的一个球，可以数学证明每个球最终留在袋子里的概率都是 $k/N$ </p><h2 id="9-8-设计有-setAll-功能的哈希表"><a href="#9-8-设计有-setAll-功能的哈希表" class="headerlink" title="9.8 设计有 $setAll$ 功能的哈希表"></a>9.8 设计有 $setAll$ 功能的哈希表</h2><p>给每个值附加一个时间戳，创建一个 $key=setAll$ 的条目，每次调用 $setAll$ 方法就更新 $setAll$ 条目的值和时间戳，当查询的值的时间比 $setAll$ 早时，返回 $setAll$ 条目的值，从查询结果看是重置了所有值，其实只是把查询重定向了</p><h2 id="9-9-最大的-leftMax-与-rightMax-之差的绝对值"><a href="#9-9-最大的-leftMax-与-rightMax-之差的绝对值" class="headerlink" title="9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值"></a>9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值</h2><p>方法一：创建两个数组，从左到右和从右到左各遍历一遍，记录 $leftMax$ 和 $rightMax$ ，最后再遍历一次直接出结果，时间 $O(N)$ ，空间 $O(N)$ </p><p>方法二：遍历一遍找到数组最大值，再和数组首尾两个元素分别算差值，因为当最大值在一侧时，另一侧最小的最大值就是只有一个元素的情况，时间 $O(N)$ ，空间 $O(1)$ </p><h2 id="9-10-设计可以变更的缓存结构"><a href="#9-10-设计可以变更的缓存结构" class="headerlink" title="9.10 设计可以变更的缓存结构"></a>9.10 设计可以变更的缓存结构</h2><p>双向队列实现节点的排序，头部存旧节点，尾部存最近访问的节点，当一个节点被访问时就移到尾部，要淘汰节点时直接从头部删除，用哈希表映射节点实现 $O(1)$ 的时间复杂度</p><h2 id="9-11-设计-RandomPool-结构"><a href="#9-11-设计-RandomPool-结构" class="headerlink" title="9.11 设计 $RandomPool$ 结构"></a>9.11 设计 $RandomPool$ 结构</h2><p>数据只有 $key$ 没有 $value$ ，所以可以用哈希表给 $key$ 一个 $index$ ，一个哈希表的索引是 $key$ ，另一个的索引是 $index$ ， $getRandom$ 就是在 $0\sim index$ 之间生成一个随机数</p><h2 id="9-12-调整-0-x-区间上的数出现的概率"><a href="#9-12-调整-0-x-区间上的数出现的概率" class="headerlink" title="9.12 调整 $[0,x)$ 区间上的数出现的概率"></a>9.12 调整 $[0,x)$ 区间上的数出现的概率</h2><p>分别调用 $k$ 次 $random$ 函数，返回最大的值，因为只要有一次不在 $[0,x)$ 内，结果就不在 $[0,x)$ 内，说明随机到 $[0,x)$ 内的概率是 $x^k$ </p><h2 id="9-13-路径数组变为统计数组"><a href="#9-13-路径数组变为统计数组" class="headerlink" title="9.13 路径数组变为统计数组"></a>9.13 路径数组变为统计数组</h2><p>从左到右遍历 $path$ ，如果不是首都就跳到他指向的城市，最终要么跳到首都要么跳到一个已经遍历过的节点，然后反向跳回去，同时设置每一步到首都的距离，遍历一遍后 $path[i]$ 就表示城市 $i$ 到首都的距离。再从左到右遍历 $path$ ，还是用跳跃的方法赋值，先 $path[path[0]]=1$ ，对替换下来的 $path[path[0]]$ 再 $path[path[path[0]]]=1$ ，遍历完后 $path[i]$ 就表示到首都距离为 $i$ 的城市数。两次遍历期间可以用数值的正负来区分数值代表的含义</p><h2 id="9-14-正数数组的最小不可组成和"><a href="#9-14-正数数组的最小不可组成和" class="headerlink" title="9.14 正数数组的最小不可组成和"></a>9.14 正数数组的最小不可组成和</h2><p>动态规划，对数组求一次总和 $sum$ ，把 $dp$ 长度设成 $sum$ ， $dp[i]$ 表示存在子数组累加和是 $i$ ，从左到右遍历数组，对于每一个元素 $k$ ，遍历 $dp[i]=1$ 使 $dp[i+k]=1$ ，最后再扫一遍 $dp$ 找最小不可组成和，时间 $O(N\times sum)$ ，空间 $O(sum)$ </p><p>已知数组中有 $1$ 时：数组排序，遍历一遍求每个位置 $i$ 的 $range$ ，表示 $[1,range]$ 能够被 $arr[0,i-1]$ 表示，初始 $range=1$ ，如果 $arr[i]&gt;range+1$ ，说明 $range+1$ 无法组成，直接返回结果，如果 $arr[i]\leq range+1$ ，说明 $[1,range+arr[i]]$ 能够被 $arr[0,i]$ 表示，让 $range+=arr[i]$ ，时间 $O(NlogN)$ ，空间 $O(1)$ </p><p>$\color{red}{没明白已知有1到底影响了什么}$</p><h2 id="9-14-一种字符串和数字的对应关系"><a href="#9-14-一种字符串和数字的对应关系" class="headerlink" title="9.14 一种字符串和数字的对应关系"></a>9.14 一种字符串和数字的对应关系</h2><p>数字转字符串：把字符串看成是伪 $k$ 进制数，每位的范围是 $1\sim k$ ，先用目标数依次减去 $k$ 、 $k^2$ 、 $k^3$ 等，算出字符串需要的位数，再用剩下的数从高位到低位依次赋值</p><p>字符串转数字：第 $i$ 位的值表示有多少个 $k^i$ ，所有位求和</p><h2 id="9-15-1-到-n-中-1-出现的次数"><a href="#9-15-1-到-n-中-1-出现的次数" class="headerlink" title="9.15  $1$ 到 $n$ 中 $1$ 出现的次数"></a>9.15  $1$ 到 $n$ 中 $1$ 出现的次数</h2><p>找规律，分别算每一位上 $1$ 出现的次数，取右数第 $i$ 位左边的数字(没有就是0)，乘以 $10^{i−1}$ ，得到基础值 $a$ ，取第 $i$ 位数字，计算修正值：<br>如果大于 $1$ ，则结果为 $a+10^{i−1}$<br>如果小于 $1$ ，则结果为 $a$<br>如果等 $1$ ，则取第 $i$ 位右边数字，设为 $b$ ，最后结果为 $a+b+1$   </p><h2 id="9-16-从-N-个数中等概率打印-M-个数"><a href="#9-16-从-N-个数中等概率打印-M-个数" class="headerlink" title="9.16 从 $N$ 个数中等概率打印 $M$ 个数"></a>9.16 从 $N$ 个数中等概率打印 $M$ 个数</h2><p>随机打印 $[0,N-1]$ 的一个位置 $a$ 上的 $arr[a]$ ，把 $arr[a]$ 和 $arr[N-1]$ 交换，再随机打印 $[0,N-2]$ 的一个位置 $b$ 上的 $arr[b]$ ，循环该过程直到打印出 $N$ 个数，可以推出来每个数打印的概率都是 $1/N$ </p><h2 id="9-17-判断一个数是否是回文数"><a href="#9-17-判断一个数是否是回文数" class="headerlink" title="9.17 判断一个数是否是回文数"></a>9.17 判断一个数是否是回文数</h2><p>左右比较，剥洋葱法</p><h2 id="9-18-在有序旋转数组中找到最小值"><a href="#9-18-在有序旋转数组中找到最小值" class="headerlink" title="9.18 在有序旋转数组中找到最小值"></a>9.18 在有序旋转数组中找到最小值</h2><p>递增数组旋转过的数组中间有断点，如果子数组左小右大说明不包含断点，左大右小说明一定包含断点，左右相等时不确定，如 $[3,1,2,3]$ ，此时需要对子数组进行查找，整个过程尽量使用二分查找，最优情况 $O(logN)$ ，最坏情况 $O(N)$  </p><h2 id="9-19-在有序旋转数组中找到一个数"><a href="#9-19-在有序旋转数组中找到一个数" class="headerlink" title="9.19 在有序旋转数组中找到一个数"></a>9.19 在有序旋转数组中找到一个数</h2><p>二分查找，根据子数组左中右的值，判断断点可能的位置以及需要继续搜索的子数组</p><h2 id="9-20-数字的英文表达和中文表达"><a href="#9-20-数字的英文表达和中文表达" class="headerlink" title="9.20 数字的英文表达和中文表达"></a>9.20 数字的英文表达和中文表达</h2><p>英文三位一组(个十百)，中文四位一组(个十百千)</p><h2 id="9-21-分糖果问题"><a href="#9-21-分糖果问题" class="headerlink" title="9.21 分糖果问题"></a>9.21 分糖果问题</h2><p>从左到右遍历，每找到一个上下坡的组合就开始赋值，两个坡最低处都是 $1$ ，两侧上坡都是递增加一，直到两个坡交汇，交汇处的值由坡长的一侧决定</p><h2 id="9-22-一种消息接受并打印的结构设计"><a href="#9-22-一种消息接受并打印的结构设计" class="headerlink" title="9.22 一种消息接受并打印的结构设计"></a>9.22 一种消息接受并打印的结构设计</h2><p>创建长度为 $N$ 的数组，接受的数字对号入座，当打印到 $k$ 时就把 $k+1$ 当做下一次打印的标志，一旦接收到就向后打印连续区间值</p><h2 id="9-23-设计一个没有扩容负担的堆结构"><a href="#9-23-设计一个没有扩容负担的堆结构" class="headerlink" title="9.23 设计一个没有扩容负担的堆结构"></a>9.23 设计一个没有扩容负担的堆结构</h2><p>二叉树</p><h2 id="9-24-随时找到数据流的中位数"><a href="#9-24-随时找到数据流的中位数" class="headerlink" title="9.24 随时找到数据流的中位数"></a>9.24 随时找到数据流的中位数</h2><p>一个大根堆存较小的一半数，一个小根堆存较大的一半数，新的数通过比较堆顶决定加入哪个堆，每次插入后平衡两个堆的大小，保证中位数只和两个堆顶有关</p><h2 id="9-25-在两个长度相等的排序数组中找到上中位数"><a href="#9-25-在两个长度相等的排序数组中找到上中位数" class="headerlink" title="9.25 在两个长度相等的排序数组中找到上中位数"></a>9.25 在两个长度相等的排序数组中找到上中位数</h2><p>两个数组分别二分查找，结果是分成了四段数组，比较 $arr1[mid]$ 和 $arr2[mid]$ ，如果二者相等说明 $arr[mid]$ 就是合并后数组的上中位数，如果 $arr1[mid]&gt;arr2[mid]$ ，说明合并后的数组中， $arr1[mid:right]$ 在最右边， $arr2[left:mid]$ 在最左边，把这两部分排除，对 $arr1[left:mid]$ 和 $arr2[mid:right]$ 继续做二分查找，最终时间 $O(logN)$  </p><h2 id="9-26-在两个排序数组中找到第-K-小的数"><a href="#9-26-在两个排序数组中找到第-K-小的数" class="headerlink" title="9.26 在两个排序数组中找到第 $K$ 小的数"></a>9.26 在两个排序数组中找到第 $K$ 小的数</h2><p>仿照上题，看第 $K$ 小的数出现在哪部分里，每次对新的子数组二分查找要让 $K$ 减去左边排除掉的部分，最终时间 $O(log(min{M,N}))$ ，因为分别在两个数组上二分查找，复杂度由短的决定</p><h2 id="9-27-两个有序数组间相加和的-TOPK-问题"><a href="#9-27-两个有序数组间相加和的-TOPK-问题" class="headerlink" title="9.27 两个有序数组间相加和的 $TOPK$ 问题"></a>9.27 两个有序数组间相加和的 $TOPK$ 问题</h2><p>维护一个大根堆，先把 $arr1[M-1]+arr2[N-1]$ 插入堆，重复以下操作，弹出堆顶，假设是 $arr1[i]+arr2[j]$ ，同时把 $arr1[i-1]+arr2[j]$ 和 $arr1[i]+arr2[j-1]$ 插入堆，也就是每次从堆里弹出一个元素，同时保证还在堆里的元素是数组间相加和最大的几个，每次堆的大小加一，最终大小是 $K$ ，堆插入时间是 $O(logK)$ ，所以总时间 $O(KlogK)$ </p><h2 id="9-28-出现次数的-TOPK-问题"><a href="#9-28-出现次数的-TOPK-问题" class="headerlink" title="9.28 出现次数的 $TOPK$ 问题"></a>9.28 出现次数的 $TOPK$ 问题</h2><p>先用哈希表统计词频，再建立小根堆，堆的节点存储字符串和出现次数，遍历哈希表，依次把每条记录插入堆，当堆的大小是 $K$ 时，只有出现次数比堆顶元素多时才插入，最终堆里的元素就是出现次数 $TOPK$ ，时间 $O(NlogK)$  </p><p>没有数组，字符串动态添加，实时打印：也是维护一个大小为 $K$ 的小根堆，用一个哈希表 $A$ 存储字符串和节点的映射，再用一个哈希表 $B$ 存储节点到堆中位置的映射，每次添加字符串时，先更新 $A$ 中节点的频次属性，如果是新节点直接插入堆，否则然后通过 $B$ 找到节点在堆中的位置，更新节点的频次属性，调整节点的位置，期间保证哈希表和堆的修改同步，最终添加操作 $O(logK)$ ，打印操作直接按位置顺序打印，时间 $O(K)$  </p><h2 id="9-29-Manacher-算法"><a href="#9-29-Manacher-算法" class="headerlink" title="9.29  $Manacher$ 算法"></a>9.29  $Manacher$ 算法</h2><p>单独写</p><h2 id="9-30-KMP-算法"><a href="#9-30-KMP-算法" class="headerlink" title="9.30  $KMP$ 算法"></a>9.30  $KMP$ 算法</h2><p>单独写</p><h2 id="9-31-丢棋子问题"><a href="#9-31-丢棋子问题" class="headerlink" title="9.31 丢棋子问题"></a>9.31 丢棋子问题</h2><p>方法一： $P(N,K)$ 表示 $N$ 层楼有 $K$ 个棋子在最差情况下扔的最少次数，显然 $P(0,K)=0$ ， $P(N,1)=N$ ，一般情况时，当在第 $i$ 层扔下，如果碎了，结果就是 $1+P(i-1,K-1)$ ，如果没碎，结果就是 $1+P(N-i,K)$ ，最差情况是二者的最大值，所以用递归的方法， $P(N,K)=min{max{P(i-1,K-1),P(N-i,K)}}(1\leq i\leq N)+1$ ，时间复杂度 $O(N!)$</p><p>方法二：动态规划， $dp[i][j]=P(i,j)$ ，遍历数组时间 $O(N\times K)$ ，求 $min-max$ 过程 $O(N)$ ，所以总时间 $O(N^2\times K)$   </p><p>优化一：压缩空间， $P(N,K)$  的子问题只遍历 $N$ ，所以对于每个 $dp[i][j]$ 只需要维护左边一列和上边一行空间</p><p>优化二：用四边形不等式优化枚举，楼层数相同时，棋子少越少，第一个棋子扔的层数就越高，棋子数相同时，楼层数越多，第一个棋子扔的层数就越高，所以第一个棋子扔的位置可以作为边界来减少枚举</p><p>$\color{red}{四边形不等式的原理没太看懂}$</p><p>最优解： $map[i][j]$ 表示 $i$ 个棋子扔 $j$ 次最多能判断多高的楼层，第一行第一列直接赋值，扔了第一个棋子后，如果碎了就剩 $i-1$ 个棋子扔 $j-1$ 次，如果没碎就剩 $i$ 个棋子扔 $j-1$ 次，再加上第一次扔的这层，有 $map[i][j]=map[i-1][j-1]+map[i][j-1]+1$ ，之所以不需要 $min-max$ 的过程是因为 $map$ 表示能力的上限，第一次扔完以后要么只向下搜索要么只向上搜索，所以能力值应该是两个方向上的总和，而 $P(N,K)$ 表示运气最差的一种情况，所以必须要通过遍历确定唯一的子问题。在棋子数给定时，只需遍历 $map$ 的一行就能搜索到答案</p><h2 id="9-32-画匠问题"><a href="#9-32-画匠问题" class="headerlink" title="9.32 画匠问题"></a>9.32 画匠问题</h2><p>方法一： $dp[i][j]$ 表示 $i$ 个画家画 $j$ 幅画的最少时间，有 $dp[i][j]=min{max{dp[i-1][k]+sum[k+1..j]}}(0\leq k\leq j)$ ，时间 $O(N^2\times K)$ </p><p>优化：四边形不等式减少枚举，时间 $O(N^2)$  </p><p>最优解：规定每个画匠最大工作时间 $limit$ ，遍历一遍数组可以知道至少需要几个画匠， $limit$ 的范围是 $[0,sum(arr)]$ ，比较 $limit$ 限定下画匠人数与题目给出的人数，用二分法确定 $limit$ 的大小，时间 $O(NlogSum(arr))$   </p><h2 id="9-33-邮局选址问题"><a href="#9-33-邮局选址问题" class="headerlink" title="9.33 邮局选址问题"></a>9.33 邮局选址问题</h2><p>方法一：假设 $arr[i,j]$ 上只能建一个邮局，一定是建在中点上总距离最小， $w[i][j]$ 表示这个总距离，因为 $arr[i,j-1]$ 变成 $arr[i,j]$ 后中点位置不变，所以有 $w[i][j]=w[i][j-1]+arr[j]-arr[(i+j)/2]$ ，多的就是新增的点到中点的距离。 $dp[i][j]$ 表示在 $arr[0,j]$ 上建 $i+1$ 个邮局的最小总距离，首先有 $dp[0][j]=w[0][j]$ ，一般情况下 $dp[i][j]=min{dp[i-1][k]+w[k+1][j]}(0\leq k\leq N)$ ，表示在 $arr[0,k]$ 建 $i-1$ 个，在 $arr[k+1,j]$ 建 $1$ 个，枚举所有情况选择总距离最小的，时间 $O(N^2\times Num)$   </p><p>优化：四边形不等式，时间 $O(N^2)$ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://shivakasu.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 7：函数装饰器和闭包</title>
    <link href="http://shivakasu.github.io/2019/02/10/fpy4/"/>
    <id>http://shivakasu.github.io/2019/02/10/fpy4/</id>
    <published>2019-02-09T17:56:20.000Z</published>
    <updated>2020-01-15T10:52:15.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、python中的函数装饰器(Function decorator)用来“标记函数”，以某种方式增强函数的行为，其实就是一种语法糖(syntactic sugar)，用来简化复杂的代码。如下：</p><p><a href="https://file.shivakasu.cn/8c1032b5313113d9b58d/fpy4-0.png" data-fancybox="group" data-caption="fpy4-0" class="fancybox"><img alt="fpy4-0" data-src="https://file.shivakasu.cn/8c1032b5313113d9b58d/fpy4-0.png" class="lazyload" title="fpy4-0"></a></p><p>可以用装饰器实现函数的替换，虽然这么做没什么意义：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def deco(func):</span><br><span class="line">...     def inner():</span><br><span class="line">...print(&#39;running inner()&#39;)</span><br><span class="line">...     return inner #1</span><br><span class="line">&gt;&gt;&gt; @deco</span><br><span class="line">... def target(): #2</span><br><span class="line">...     print(&#39;running target()&#39;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; target() #3</span><br><span class="line">running inner()</span><br><span class="line">&gt;&gt;&gt; target #4</span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at 0x10063b598&gt;</span><br></pre></td></tr></table></figure></div></p><p>还可以用作注册函数，对于新增的函数，只需要添加装饰器，而不用手动进行注册：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">registry &#x3D; []</span><br><span class="line"></span><br><span class="line">def register(func):</span><br><span class="line">  print(&#39;running register(%s)&#39; % func) </span><br><span class="line">    registry.append(func)</span><br><span class="line">  return func</span><br><span class="line"></span><br><span class="line">@register</span><br><span class="line">def f1():</span><br><span class="line">    print(&#39;running f1()&#39;)</span><br><span class="line"></span><br><span class="line">@register</span><br><span class="line">def f2():</span><br><span class="line">    print(&#39;running f2()&#39;)</span><br><span class="line"></span><br><span class="line">def f3():</span><br><span class="line">    print(&#39;running f3()&#39;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&#39;running main()&#39;) </span><br><span class="line">    print(&#39;registry -&gt;&#39;, registry) </span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line">    </span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;: </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div></p><p>装饰器在函数定义后立即运行，这通常是在导入(import)时，例如上面代码的执行结果是：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python3 registration.py</span><br><span class="line">running register(&lt;function f1 at 0x100631bf8&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x100631c80&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x100631bf8&gt;, &lt;function f2 at 0x100631c80&gt;] running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure></div></p><p>单独执行import操作，得到的结果是：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import registration</span><br><span class="line">running register(&lt;function f1 at 0x10063b1e0&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x10063b268&gt;)</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;2、闭包(closures)指的是嵌套函数的作用于问题，如图，内层函数可以直接使用上层函数定义的变量，这种变量又叫做自由变量。</p><p><a href="https://file.shivakasu.cn/1a649177761a4cfd26cd/fpy4-1.png" data-fancybox="group" data-caption="fpy4-1" class="fancybox"><img alt="fpy4-1" data-src="https://file.shivakasu.cn/1a649177761a4cfd26cd/fpy4-1.png" class="lazyload" title="fpy4-1"></a></p><p>但自由变量只能使用，如果对自由变量进行赋值，就会被解释器当做局部变量而抛出“变量未定义”的异常，如下，这是由于python不要求像C一样先声明变量再使用变量，所以遇到对非全局变量的赋值操作会直接看作局部变量。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    total &#x3D; 0</span><br><span class="line">    def averager(new_value):</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        total +&#x3D; new_value</span><br><span class="line">        return total &#x2F; count</span><br><span class="line">    return averager</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; avg &#x3D; make_averager()</span><br><span class="line">&gt;&gt;&gt; avg(10)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">UnboundLocalError: local variable &#39;count&#39; referenced before assignment</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></div></p><p>这种情况下不能使用<code>global</code>关键字，因为没有涉及全局变量，而是嵌套函数中因为层次关系产生的相对外层的变量，这时候就要用<code>nonlocal</code>关键字，用法和<code>global</code>一样。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    total &#x3D; 0</span><br><span class="line">    def averager(new_value):</span><br><span class="line">        nonlocal count, total</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        total +&#x3D; new_value</span><br><span class="line">        return total &#x2F; count</span><br><span class="line">    return averager</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;3、functools模块有两个实用的装饰器。<code>lru_cache</code>用来缓存函数的中间结果，LRU即Least Recently Used，如下，在计算斐波那契数的递归过程中，计算过的值会保存在缓存中，减少重复计算。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">@functools.lru_cache()</span><br><span class="line">def fibonacci(n):</span><br><span class="line">    if n&lt;2:</span><br><span class="line">        return n</span><br><span class="line">    return fibonacci(n-2) + fibonacci(n-1)</span><br></pre></td></tr></table></figure></div></p><p><code>singledispatch</code>装饰器用来生成泛函数(generic function)，指的是根据函数参数的类型以不同方式执行操作。由于<code>singledispatch</code>只根据函数第一个参数，所以称作单分派泛函数，与之对应的是多分派(multiple-dispatch)。用法如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from functools import singledispatch</span><br><span class="line">from collections import abc</span><br><span class="line">import numbers</span><br><span class="line">import html</span><br><span class="line"></span><br><span class="line">@singledispatch</span><br><span class="line">def htmlize(obj):</span><br><span class="line">    content &#x3D; html.escape(repr(obj))</span><br><span class="line">    return &#39;&lt;pre&gt;&#123;&#125;&lt;&#x2F;pre&gt;&#39;.format(content)</span><br><span class="line"></span><br><span class="line">@htmlize.register(str) </span><br><span class="line">def _(text):        </span><br><span class="line">    content &#x3D; html.escape(text).replace(&#39;\n&#39;, &#39;&lt;br&gt;\n&#39;)</span><br><span class="line">    return &#39;&lt;p&gt;&#123;0&#125;&lt;&#x2F;p&gt;&#39;.format(content)</span><br><span class="line"></span><br><span class="line">@htmlize.register(numbers.Integral)</span><br><span class="line">def _(n):</span><br><span class="line">    return &#39;&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;&#x2F;pre&gt;&#39;.format(n)</span><br><span class="line"></span><br><span class="line">@htmlize.register(tuple)</span><br><span class="line">@htmlize.register(abc.MutableSequence)</span><br><span class="line">def _(seq):</span><br><span class="line">    inner &#x3D; &#39;&lt;&#x2F;li&gt;\n&lt;li&gt;&#39;.join(htmlize(item) for item in seq)</span><br><span class="line">    return &#39;&lt;ul&gt;\n&lt;li&gt;&#39; + inner + &#39;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;&#39;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;4、闭包是静态作用域(static scope)下的概念，与之相对的是动态作用域(dynamic scope)。静态作用域又叫做词法作用域(lexical scope)，C、C++、Python、Java等大多数现在程序设计语言都是采用静态作用域规则，指的是变量的作用域是确定的，词法分析时不会逐层检查函数的调用链，而是检查函数定义时的外部环境，从当前作用域由内而外寻找最近的该变量的定义。动态作用域完全相反，变量的作用域是不确定的，根据函数的调用层次确定变量的定义，也就是说只要在调用函数之前在当前环境重新定义变量，函数就能使用新定义的变量，不关注结构上的层次。个人理解动态作用域的缺点就是变量随意覆盖可能引起意外bug，而且代码中一个变量有多个版本也会大大降低可读性吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 5：一等函数</title>
    <link href="http://shivakasu.github.io/2019/02/10/fpy3/"/>
    <id>http://shivakasu.github.io/2019/02/10/fpy3/</id>
    <published>2019-02-09T16:45:20.000Z</published>
    <updated>2020-01-15T10:51:40.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、在python中，函数是一等对象(first-class object)，一等对象的特征有：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ul><p>接受函数为参数或把函数作为结果返回的函数又叫高阶函数(higher-order function)，常见的高阶函数例如python内置的<code>sorted</code>，其接收一个参数key，当想根据长度排序时，可以写成<code>sorted(xxx,key=len)</code>，这就是把<code>len()</code>函数作为参数传给<code>sorted()</code>。在函数式编程范式中，常用的高阶函数有<code>map</code>、<code>filter</code>、<code>reduce</code>和<code>apply</code>，然而在python中不常用这些函数，因为已经有了更简单的替代方式。</p><ul><li><code>map</code>函数用来求一个序列或者多个序列进行函数映射之后的值，<code>filter</code>函数用来过滤掉序列中不符合函数条件的元素，二者完全可以用列表推导式替代，对应for循环和if条件判定。</li><li><code>reduce</code>函数用来对一个序列进行压缩运算，在python3中已经移到了functools模块，该方法最常用于序列求和，因此可以用python内置的<code>sum</code>函数替代。</li><li><code>apply(func [, args [, kwargs ]])</code>函数用于当函数参数已经存在于一个元组或字典中时，间接地调用函数。因为python本来就支持函数定义中包含不定量参数，所以<code>apply</code>函数反而多此一举，python3中已经移除了。但在第三方库例如pandas中还在使用。</li></ul><p>&emsp;&emsp;2、python中能使用调用符号“()”的对象称为可调用对象(Callable Objects)，有7种可调用对象：</p><ul><li>用户用<code>def</code>或<code>lambda</code>定义的函数</li><li>内置函数：使用C语言实现的函数，如<code>len</code>或<code>time.strftime</code></li><li>内置方法：使用C语言实现的方法，如<code>dict.get</code></li><li>方法：在类的定义体中定义的函数</li><li>类：由于python没有new函数，所以创建实例时直接调用类</li><li>类的实例：如果类定义了<code>__call__</code>方法，它的实例就可以作为函数调用</li><li>生成器函数：使用<code>yield</code>关键字的函数或方法</li></ul><p>&emsp;&emsp;3、有必要理解一下关键字、方法、函数的区别：</p><ul><li>关键字：内置的、具有特殊意义的表示符，使用时不加“()”</li><li>方法：封装了独立的功能，需要用对象调用，对象.方法名(参数)</li><li>函数：也是封装了独立的功能，直接调用或使用模块名调用</li></ul><p>&emsp;&emsp;4、operator模块提供了对函数式编程的支持。例如在使用<code>reduce</code>函数对序列求和时，需要传入一个函数，因此不能直接使用“+”，所以需要另外定义表示加减乘除这类运算的函数，operator模块内置了这些函数，所以就没必要自己定义了。</p><p>&emsp;&emsp;operator模块的<code>itemgetter</code>和<code>attrgetter</code>函数可用于替代从序列中取出元素或读取对象属性的lambda表达式，如下：</p><p><a href="https://file.shivakasu.cn/40f22754538470b8b094/fpy3-0.png" data-fancybox="group" data-caption="fpy3-0" class="fancybox"><img alt="fpy3-0" data-src="https://file.shivakasu.cn/40f22754538470b8b094/fpy3-0.png" class="lazyload" title="fpy3-0"></a></p><p>&emsp;&emsp;5、第六章讲的是用一等函数实现设计模式，思想很简单，因为函数也能作为参数，所以就可以简化代码，不必为了实现特定功能而创建一个类，再用类的实例调用方法，而是可以直接定义函数，把函数作为参数传进方法里调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 3：字典和集合</title>
    <link href="http://shivakasu.github.io/2019/02/07/fpy2/"/>
    <id>http://shivakasu.github.io/2019/02/07/fpy2/</id>
    <published>2019-02-07T07:35:20.000Z</published>
    <updated>2020-01-15T10:51:17.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、collections.abc模块中有Mapping和MutableMapping两个抽象基类，它们的作用是为dict和其他类似的类型定义形式接口。</p><p><a href="https://file.shivakasu.cn/0f9a7c1e0a2a1f236e69/fpy2-0.png" data-fancybox="group" data-caption="fpy2-0" class="fancybox"><img alt="fpy2-0" data-src="https://file.shivakasu.cn/0f9a7c1e0a2a1f236e69/fpy2-0.png" class="lazyload" title="fpy2-0"></a></p><p>&emsp;&emsp;2、标准库里的所有映射类型都是利用dict实现的，只有可散列(hashable)的数据类型才能用作这些映射里的键。如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现<code>__hash__()</code>方法进行散列，也要实现<code>__eq__()</code>方法进行键的比较。python的原子不可变类型(str、bytes和数值类型)是可散列的，一个元组是可散列的当且仅当其包含的元素都是可散列的。所以严格来说不可变类型不都是可散列的，元组不一定。</p><p>&emsp;&emsp;3、和列表推导式类似，字典也有推导构建法：</p><p><a href="https://file.shivakasu.cn/e836fd38437371f66c90/fpy2-1.png" data-fancybox="group" data-caption="fpy2-1" class="fancybox"><img alt="fpy2-1" data-src="https://file.shivakasu.cn/e836fd38437371f66c90/fpy2-1.png" class="lazyload" title="fpy2-1"></a></p><p>&emsp;&emsp;4、处理字典可能找不到键的情况：</p><ul><li>使用<code>setdefault()</code>方法，如下图。这样做的好处是减少了查询字典的次数，如果键不存在，不使用<code>setdefault()</code>就需要查三次字典。</li></ul><p><a href="https://file.shivakasu.cn/46667e1b2d7ac26c5a89/fpy2-2.png" data-fancybox="group" data-caption="fpy2-2" class="fancybox"><img alt="fpy2-2" data-src="https://file.shivakasu.cn/46667e1b2d7ac26c5a89/fpy2-2.png" class="lazyload" title="fpy2-2"></a></p><ul><li><p>使用<code>collections.defaultdict</code>字典，提供一个可调用对象作为参数。例如当用语句<code>index = collections.defaultdict(list)</code>创建字典后，执行<code>index[&#39;new_key&#39;]</code>找不到键，则会自动调用<code>list()</code>方法生成空列表，并以<code>new_key</code>为键添加到字典中，最后返回该列表的引用。</p></li><li><p>上述两种方法的原理都是实现了<code>__missing__</code>方法，字典使用<code>__getitem__</code>方法进行查询，当找不到键时，如果实现了<code>__missing__</code>方法，<code>__getitem__</code>会直接调用，否则抛出异常。原始的dict没有实现<code>__missing__</code>方法，但它知道有了<code>__missing__</code>方法就可以用。所以第三种方法是创建dict的子类，实现<code>__missing__</code>方法。</p></li></ul><p>&emsp;&emsp;5、types模块有一个封装类MappingProxyType，用于返回一个字典的不可变的视图，这个视图是动态的，原字典改变视图也会随之改变，所以如果不想字典在使用过程中被修改，可能会用到这个类。</p><p><a href="https://file.shivakasu.cn/abfb07d5347032214e78/fpy2-3.png" data-fancybox="group" data-caption="fpy2-3" class="fancybox"><img alt="fpy2-3" data-src="https://file.shivakasu.cn/abfb07d5347032214e78/fpy2-3.png" class="lazyload" title="fpy2-3"></a></p><p>&emsp;&emsp;6、python的集合类型有set和frozenset，集合中的元素必须是可散列的，set本身是不可散列的，但frozenset是可散列的。</p><p>&emsp;&emsp;7、set集合除了可以从列表生成，还可以使用集合字面量(set literals)定义。比如<code>s=set([1,2,3])</code>和<code>s={1,2,3}</code>是等价的，但字面量方式更高效。需要注意，空集只能用<code>s=set()</code>生成，字面量形式的<code>s={}</code>是生成空字典。此外，frozenset不支持字面量操作，所以只能从列表生成。由于支持字面量定义，set集合还能用推导式生成，和列表推导式类似，只不过两端是大括号。</p><p>&emsp;&emsp;8、集合类的继承关系如下：</p><p><a href="https://file.shivakasu.cn/86d91f935448abd03439/fpy2-4.png" data-fancybox="group" data-caption="fpy2-4" class="fancybox"><img alt="fpy2-4" data-src="https://file.shivakasu.cn/86d91f935448abd03439/fpy2-4.png" class="lazyload" title="fpy2-4"></a></p><p>&emsp;&emsp;9、dict是用散列表实现的，理论上只要字典不超过内存大小，查询操作耗费的时间都能忽略不计。散列表的查询流程如下，其中bucket指的是散列表中的单元，即表元，dict的每个键值对占用一个表元。由于流程中使用散列值的一部分进行匹配，可能会发生匹配部分相同但整体键不相等，这就叫散列冲突(hash collision)，这时就会取散列值的另一部分再进行匹配。虽然看似效率低下，但散列函数的特性是不相等的对象散列值差别很大，所以实际上发生散列冲突的概率非常小。</p><p><a href="https://file.shivakasu.cn/bdf6d1f9ffd1823a2b1e/fpy2-5.png" data-fancybox="group" data-caption="fpy2-5" class="fancybox"><img alt="fpy2-5" data-src="https://file.shivakasu.cn/bdf6d1f9ffd1823a2b1e/fpy2-5.png" class="lazyload" title="fpy2-5"></a></p><p>&emsp;&emsp;10、字典提供了无视数据量大小的快速访问，代价是空间效率低下，因为散列表必须是稀疏的，需要占用大量空间。此外，不能对字典同时进行迭代和修改，如果往字典里添加新键，解释器可能会做出为字典扩容的决定，将当前散列表迁移到更大的散列表中，在这个过程中对字典进行迭代，可能会出现问题。</p><p>&emsp;&emsp;11、set和frozenset集合也是基于散列表实现的，只不过表元是对单个元素的引用。所以集合类型也有时间效率高、空间效率低的特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 2：序列构成的数组</title>
    <link href="http://shivakasu.github.io/2019/02/06/fpy1/"/>
    <id>http://shivakasu.github.io/2019/02/06/fpy1/</id>
    <published>2019-02-06T15:13:20.000Z</published>
    <updated>2020-01-15T10:49:51.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、python标准库用C实现了丰富的序列类型：</p><ul><li>容器序列(Container sequences)：list、tuple、collections.deque这些序列能存放不同类型数据。</li><li>扁平序列(Flat sequences)：str、bytes、bytearray、memoryview、array.array这些序列只能容纳一种类型。</li><li>可变序列(Mutable sequences)：list、bytearray、array.array、collections.deque、memoryview这些序列可以原地修改。</li><li>不可变序列(Immutable sequences)：tuple、str、bytes这些序列不能原地修改。</li></ul><p>&emsp;&emsp;下图是序列对象的继承关系，箭头从子类指向父类，可以看到可变对象之所以能够修改是因为实现了<code>__setitem__</code>、<code>__delitem__</code>等方法。</p><p><a href="https://file.shivakasu.cn/30693800bf9c8aaec269/fpy1-0.png" data-fancybox="group" data-caption="fpy1-0" class="fancybox"><img alt="fpy1-0" data-src="https://file.shivakasu.cn/30693800bf9c8aaec269/fpy1-0.png" class="lazyload" title="fpy1-0"></a></p><p>&emsp;&emsp;2、python会忽略代码里[]、()、{}中的换行，所以写列表推导时直接回车换行，不用加续行符“\”。</p><p>&emsp;&emsp;3、当使用“*”对序列进行复制时，要保证序列里没有对其他可变对象的引用，引用只能浅复制，当修改其中一个引用时，其他的也会改变。如下：</p><p><a href="https://file.shivakasu.cn/5c7b7afa5830505936ad/fpy1-1.png" data-fancybox="group" data-caption="fpy1-1" class="fancybox"><img alt="fpy1-1" data-src="https://file.shivakasu.cn/5c7b7afa5830505936ad/fpy1-1.png" class="lazyload" title="fpy1-1"></a></p><p>&emsp;&emsp;4、不要把可变对象放到元组里，修改元组里的可变对象虽然会抛出异常，但对象可能会真的被修改。</p><p>&emsp;&emsp;5、<code>list.sort()</code>原地排序，<code>sorted()</code>创建新列表排序并返回。</p><p>&emsp;&emsp;6、如果需要一个只包含数字的列表，使用array.array比list更高效，因为list将数字存成python的整形和浮点型，而array.array把数字直接存成机器翻译，也就是字节表述。道理是这样，用的时候还是对比一下速度吧，list、array和numpy的array。</p><p>&emsp;&emsp;7、python内置的排序函数使用了Timsort排序算法。Timsort混合了插入排序和归并排序，因为真实世界中的数据往往带有一定的顺序，所以根据输入的特点进行分区，分区内插入排序，分区间归并排序。</p><p><a href="https://file.shivakasu.cn/07961a9a7b4f7d22bf62/fpy1-2.png" data-fancybox="group" data-caption="fpy1-2" class="fancybox"><img alt="fpy1-2" data-src="https://file.shivakasu.cn/07961a9a7b4f7d22bf62/fpy1-2.png" class="lazyload" title="fpy1-2"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 1：Python 数据模型</title>
    <link href="http://shivakasu.github.io/2019/02/04/fpy0/"/>
    <id>http://shivakasu.github.io/2019/02/04/fpy0/</id>
    <published>2019-02-04T07:08:20.000Z</published>
    <updated>2020-01-15T10:49:04.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;这一章写的是python的特殊方法(special method)，又叫作魔术方法(magic method)。最常见的就是面向对象编程时的初始化方法<code>__init__</code>，这类方法的特点有：</p><ul><li>方法名首尾有两个下划线。</li><li>所有特殊方法都是python内置的，使用时只需要在类里重写，最好不要自己定义新的特殊方法。</li><li>特殊方法都与特殊操作绑定，不需要显式调用。如<code>__init__</code>与对象初始化绑定，<code>__len__</code>与<code>len()</code>方法绑定，<code>__add__</code>与<code>+</code>运算绑定。</li></ul><p>&emsp;&emsp;部分特殊方法如下，首先是与运算符无关的特殊方法：<br><a href="https://file.shivakasu.cn/8836120fad62e60bb92d/fpy0-0.png" data-fancybox="group" data-caption="fpy0-0" class="fancybox"><img alt="fpy0-0" data-src="https://file.shivakasu.cn/8836120fad62e60bb92d/fpy0-0.png" class="lazyload" title="fpy0-0"></a></p><p>然后是与运算符有关的特殊方法：<br><a href="https://file.shivakasu.cn/f0816f76a0187e1073fd/fpy0-1.png" data-fancybox="group" data-caption="fpy0-1" class="fancybox"><img alt="fpy0-1" data-src="https://file.shivakasu.cn/f0816f76a0187e1073fd/fpy0-1.png" class="lazyload" title="fpy0-1"></a></p><p>&emsp;&emsp;<code>__repr__</code>和<code>__str__</code>都是用于定义对象的字符串表示形式。区别是前者用于在命令行直接输入一个对象时返回的字符串，后者是调用<code>str()</code>方法或<code>print()</code>时返回的字符串。如果只想实现其中一个特殊方法，就实现<code>__repr__</code>，因为没有<code>__str__</code>时解释器会自动调用<code>__repr__</code>。</p><p>&emsp;&emsp;<code>__bool__</code>用于定义一个对象的真值，如果对象需要参与条件判定的话，可以用<code>bool()</code>方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 6：文档-语言及属性</title>
    <link href="http://shivakasu.github.io/2019/02/03/mir4/"/>
    <id>http://shivakasu.github.io/2019/02/03/mir4/</id>
    <published>2019-02-02T18:20:20.000Z</published>
    <updated>2020-01-15T10:57:35.651Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-文本相似度"><a href="#1-文本相似度" class="headerlink" title="1 文本相似度"></a>1 文本相似度</h2><p>&emsp;&emsp;文本的相似度依靠距离函数度量，距离函数应该是对称的，即不受参数顺序影响，并且应该满足三角不等式：</p><script type="math/tex; mode=display">distance(a,c)\leq distance(a,b)+distance(b,c)</script><p>&emsp;&emsp;常见的距离函数如下：</p><ul><li>海明距离(Hamming distance)：对于相同长度的字符串，定义它们之间的距离为他们拥有不同字符的位置的个数。</li><li>编辑距离(Edit distance)：使两个字符串相同而在其中任何一个字符串上进行字符插入、删除和替换操作的最少次数。如“color”和“colour”的编辑距离是1。编辑距离是处理语法错误的首选模型。</li><li>最长公共子序列(longest common subsequence, LCS)：如“survey”和“surgery”的最长公共子序列是“surey”。</li><li>余弦相似度：第三章提到过。</li><li>类似度(resemblance)：两个文档词汇表的重合度。定义 <script type="math/tex">W(d_j)</script> 是 <script type="math/tex">d_j</script> 中所有不同词的集合，两个文档的类似度定义为：<script type="math/tex; mode=display">R(d_i,d_j)=\frac{|W(d_i)\cap W(d_j)|}{|W(d_i)\cup W(d_j)|}</script></li></ul><p>&emsp;&emsp;任何在 <script type="math/tex">[0,1]</script> 范围内的相似度度量都可以通过以下方式方便地转换为距离函数：</p><script type="math/tex; mode=display">D(d_i,d_j)=1-Sim(d_i,d_j)</script><h2 id="2-文档预处理"><a href="#2-文档预处理" class="headerlink" title="2 文档预处理"></a>2 文档预处理</h2><p>&emsp;&emsp;文档预处理阶段的逻辑视图如下，主要分为五个步骤：<br><a href="https://file.shivakasu.cn/655c2c17308c95635b27/mir4-0.png" data-fancybox="group" data-caption="mir4-0" class="fancybox"><img alt="mir4-0" data-src="https://file.shivakasu.cn/655c2c17308c95635b27/mir4-0.png" class="lazyload" title="mir4-0"></a></p><h3 id="2-1-词汇分析"><a href="#2-1-词汇分析" class="headerlink" title="2.1 词汇分析"></a>2.1 词汇分析</h3><p>&emsp;&emsp;词汇分析(Lexical analysis)是将字符流转化为单词流的过程，就是分词。主要考虑以下几种情况：</p><ul><li>空格(Space)：最常见的分词符。</li><li>数字(Numbers)：根据上下文确定数字代表的意义，如量化数值、时间点，或是“512B.C.”这样的混合词。</li><li>连字符(Hyphens)：要不要拆，像“state-of-the-art”可拆可不拆，像表示序号的“A-3”最好不要拆。</li><li>标点符号(Punctuation marks)：区别对待句间分隔符、词间分隔符和词内分隔符。</li><li>大小写：要不要区分单词大小写，通常会影响到一些专有名词，如人名、地名、组织名。</li></ul><h3 id="2-2-去除停用词"><a href="#2-2-去除停用词" class="headerlink" title="2.2 去除停用词"></a>2.2 去除停用词</h3><p>&emsp;&emsp;停用词(Stopwords)通常是出现频率较多的词，被认为没有什么区分度，常见的是冠词、介词和连词。去除停用词可以减少索引结构的大小，但也会造成召回率的降低，也就是把一些相关的文本删到识别不出。所以有些Web搜索引擎会采用全文检索，不去除停用词。</p><h3 id="2-3-词干提取"><a href="#2-3-词干提取" class="headerlink" title="2.3 词干提取"></a>2.3 词干提取</h3><p>&emsp;&emsp;词干(stem)提取就是所谓的词形还原，把名词复数、动词过去式等还原。我觉得比较靠谱的方法也就是根据语法规则和查词表两种，但是词干提取对检索性能是否有帮助仍然存在争论。</p><h3 id="2-4-关键词选择"><a href="#2-4-关键词选择" class="headerlink" title="2.4 关键词选择"></a>2.4 关键词选择</h3><p>&emsp;&emsp;和全文索引相对立，只选取文本中一部分代表性的词作为索引项，因此这种索引项也叫作关键词。关键词通常都是名词或者名词组，因为名词能够携带更多的信息。</p><h3 id="2-5-同义词典"><a href="#2-5-同义词典" class="headerlink" title="2.5 同义词典"></a>2.5 同义词典</h3><p>&emsp;&emsp;好像没什么用。</p><h2 id="3-组织文档"><a href="#3-组织文档" class="headerlink" title="3 组织文档"></a>3 组织文档</h2><p>&emsp;&emsp;顾名思义，就是文档的组织方式。主要有分类体系法(Taxonomies)和分众分类法(Folksonomies)。</p><p>&emsp;&emsp;分类体系法的核心是层次化，需要有一个清晰的分类层次，也需要对文档的类别有准确的描述，如下图：<br><a href="https://file.shivakasu.cn/8deff9e5f5b1bae97655/mir4-1.png" data-fancybox="group" data-caption="mir4-1" class="fancybox"><img alt="mir4-1" data-src="https://file.shivakasu.cn/8deff9e5f5b1bae97655/mir4-1.png" class="lazyload" title="mir4-1"></a></p><p>&emsp;&emsp;分众分类法的核心是扁平化，最常见的是标签云，如下图。因为不能准确、完全地描述文档，所以只提取一些用户感兴趣的关键词作为标签。<br><a href="https://file.shivakasu.cn/492e5812293591e5228f/mir4-2.png" data-fancybox="group" data-caption="mir4-2" class="fancybox"><img alt="mir4-2" data-src="https://file.shivakasu.cn/492e5812293591e5228f/mir4-2.png" class="lazyload" title="mir4-2"></a></p><h2 id="4-文本压缩"><a href="#4-文本压缩" class="headerlink" title="4 文本压缩"></a>4 文本压缩</h2><p>&emsp;&emsp;文本压缩的目的是减少空间开销、输入/输出开销和通信时延。选择压缩方法时需要考虑的因素有：</p><ul><li>压缩比，即压缩后大小与压缩前大小之比。</li><li>压缩和解压缩的速度，通常解压缩的速度更重要，因为只有在存储文档的时候需要压缩，而后续每次访问文档时都需要进行解压。</li><li>压缩文本是否支持搜索，即检索过程可以直接在压缩文档上进行，不需要预先解压缩，直接搜索压缩文档的速度会更快。</li></ul><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>&emsp;&emsp;文本压缩有两个通用方法：统计方法(statistical)和基于字典的方法(dictionary based)。统计方法估计每个文本符号出现的概率，根据出现概率将文本符号转换为二进制编码。字典方法从文档中识别出一系列可以被引用的短语，短语的集合称为字典，压缩的过程就是把文本中的短语替换成相应字典条目的指针。虽然压缩分为无损压缩和有损压缩，但在文档存储和检索的任务中，使用的基本都是无损压缩。</p><h3 id="4-2-统计方法"><a href="#4-2-统计方法" class="headerlink" title="4.2 统计方法"></a>4.2 统计方法</h3><p>&emsp;&emsp;统计方法定义为两个任务的组合：建模和编码。前者估计每个后续字符的概率，后者把后续符号编码成模型分配给他的概率函数，把每个符号表示成码字(codeword)。统计方法的理论基础是香农的信息论，信息压缩的下界是信息熵，文本的熵定义为：</p><script type="math/tex; mode=display">E=\sum p_ilog_2\frac{1}{p_i}</script><p>也就是出现概率为 <script type="math/tex">p_i</script> 的符号至少需要长度为 <script type="math/tex">log_2\frac{1}{p_i}</script> 的码字表示，由于码字通常是整数个编码单元，实际长度往往会大于这个理论值。同时，编码需要给出现概率高的符号尽可能短的码字，这样才能保证较低的压缩率。</p><h3 id="4-3-统计方法：建模"><a href="#4-3-统计方法：建模" class="headerlink" title="4.3 统计方法：建模"></a>4.3 统计方法：建模</h3><p>&emsp;&emsp;压缩模型分为自适应模型(adaptive model)、静态模型(static model)和半静态模型(semi-static model)。</p><ul><li>自适应模型：不需要关于文本的先验知识，只需要处理文本一遍，在处理过程中根据读入的新文档动态调整字符的概率分布。有两个缺点，一是速度慢，因为需要动态更新，二是只能从压缩文档的开头进行解压，因为关于分布的信息数据实在文件中增量存储的。</li><li>静态模型：对所有输入的文本假设一个分布，只需要处理文本一遍，对所有要压缩的文本都使用这个分布。缺点是不使用，假设的分布在新的文档上往往效果很差。</li><li>半静态模型：不需要假设分布，但是要处理文本两遍。第一遍学习字符的概率分布，第二遍进行压缩，优缺点也很明显。</li></ul><p>&emsp;&emsp;模型的阶(order)指的是用来估计下一个符号的概率而使用的前面符号的个数。 <script type="math/tex">0</script> 阶模型就是所谓的上下文无关模型，每个符号概率的计算都是独立的。高阶模型压缩效果更好，但是需要更大的空间存储和运行，此外，任一位置的解压都需要知道前面 <script type="math/tex">k</script> 个符号，所以高阶模型只能从开头进行解压，不支持随机访问。</p><p>&emsp;&emsp;除了基于字符的模型，还有基于词的模型，也就是直接对单词进行编码。词模型的理论基础是两个统计法则。一是 <script type="math/tex">Heaps</script> 法则，指出 <script type="math/tex">n</script> 个词的自然语言文本的词汇表大小 <script type="math/tex">V</script> 的增长是 <script type="math/tex">V=O(n^\beta)</script> ，其中 <script type="math/tex">\beta <1</script> 是一个依赖于特定文本的常数。第二个法则是 <script type="math/tex">Zipf</script> 法则，指出最常出现的第 <script type="math/tex">i</script> 个单词出现 <script type="math/tex">O(n/i^\alpha)</script> 次，其中 <script type="math/tex">\alpha >1</script> 是依赖于文本的常数。这两个法则保证了基于词的模型不会产生量级的爆炸，同时概率分布具有良好的偏斜性。</p><h3 id="4-4-统计方法：编码"><a href="#4-4-统计方法：编码" class="headerlink" title="4.4 统计方法：编码"></a>4.4 统计方法：编码</h3><p>&emsp;&emsp;霍夫曼编码(Huffman coding)是基于二叉树的前缀无关编码，通常使用霍夫曼树的规范树(canonical tree)形式，规范树规定任何结点的右子树不能高于他的左子树，因此给出有序的叶节点可以方便地还原规范树的结构。霍夫曼编码的缺点是只能从开头解码，因此不支持随机检索，例如考虑以下编码：A(0)、B(10)、C(110)、D(111)，若随机检索到编码片段 “11110”，就无法确定是“DB”还是开头少了一个1的“DC”，也就是两个码字的结合包含了第三个码字。更严谨的说法是不支持从任意位置解码，支持从任意码字的开头进行解码，虽然这么说没什么意义吧。</p><p>&emsp;&emsp;字节霍夫曼编码(Byte-Huffman coding)是基于词的模型，使用字节代替位进行编码，因此编码树不是二叉树，而是256叉树。好像用的不是很多。</p><p>&emsp;&emsp;密集编码(Dense coding)也是基于字节的编码，如下图，其中“<128>”指的是该字节的值是128。密集编码比字节霍夫曼编码更简单，在各个方面都优于字节霍夫曼编码，更重要的是密集编码支持从任意位置解码。因为密集编码可以很好地区分码头和码尾，整个字节的识别是很简单的，而观察到密集编码的结束字节值是在128到255之间的，这种属性称作自同步(self-synchronizing)，结束的字节称为停止符，之前的所有字节都称为持续符。更广义的密集编码记作 <script type="math/tex">(s,c)</script> 密集编码，不把128作为持续符和停止符的界限，只要保证 <script type="math/tex">s+c=256</script> ，可以修改为 <script type="math/tex">c</script> 个持续符和 <script type="math/tex">s</script> 个停止符，选择最优的组合。<br><a href="https://file.shivakasu.cn/041fc0ed18d81d8d73cc/mir4-3.png" data-fancybox="group" data-caption="mir4-3" class="fancybox"><img alt="mir4-3" data-src="https://file.shivakasu.cn/041fc0ed18d81d8d73cc/mir4-3.png" class="lazyload" title="mir4-3"></a></128></p><p>&emsp;&emsp;算术编码，只写了一段，细节太少，没看懂。</p><h3 id="4-5-字典方法"><a href="#4-5-字典方法" class="headerlink" title="4.5 字典方法"></a>4.5 字典方法</h3><p>&emsp;&emsp;字典方法就不区分建模和编码的环节了，核心就是查字典而已。唯一需要考虑的问题是如何选择字典条目，同样也分成静态、半静态和自适应的方法，缺点也和上面说的类似。静态方法泛化性差，自适应方法的代表是 Ziv-Lempel 算法，字典随着压缩过程动态创建，问题就是不支持随机访问，半静态的方法最好，代表是 Re-Pair 算法。 Re-Pair 算法的核心简单说就是消除所有的重复符号对，首先给每个符号赋予一个整数，如果有重复的整数对“AB”，就用新的整数“C”替换“AB”，替换规则也可以嵌套，比如“CD”又重复了，就用“E”替换“CD”。缺点其实就是半静态方法的缺点，慢。</p><h3 id="4-6-压缩预处理"><a href="#4-6-压缩预处理" class="headerlink" title="4.6 压缩预处理"></a>4.6 压缩预处理</h3><p>&emsp;&emsp;文本压缩的最新趋势是压缩前的预处理，比较著名的方法是 Burrows-Wheeler 变换，简称BWT。流程就看下面两张图，原始字符串是“mississippi$”，其中“$”是可以是别的特殊终结符。首先列出原始字符串循环移位的矩阵，矩阵的每一行是上一行左移一位后的字符串。然后根据矩阵第一列按字典序排序，排序后矩阵的最后一列就是变换后的字符串。BWT的优点有两个，一是可逆，根据变换后的字符串可以还原出原始字符串，二是能够保证原始字符串中重复出现的字符可以在变换后的字符串中连续出现或至少离得比较近，图中的例子不太明显，比如“SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES”经过变换后成了“TEXYDST.E.IXIXIXXSSMPPS.B..E.S.EUSFXDIIOIIIT”，就很明显了。<br><a href="https://file.shivakasu.cn/e409e20e6c49f4193eca/mir4-4.png" data-fancybox="group" data-caption="mir4-4" class="fancybox"><img alt="mir4-4" data-src="https://file.shivakasu.cn/e409e20e6c49f4193eca/mir4-4.png" class="lazyload" title="mir4-4"></a><br><a href="https://file.shivakasu.cn/a900368af7421d8f37f4/mir4-5.png" data-fancybox="group" data-caption="mir4-5" class="fancybox"><img alt="mir4-5" data-src="https://file.shivakasu.cn/a900368af7421d8f37f4/mir4-5.png" class="lazyload" title="mir4-5"></a></p><h3 id="4-7-压缩方法的比较"><a href="#4-7-压缩方法的比较" class="headerlink" title="4.7 压缩方法的比较"></a>4.7 压缩方法的比较</h3><p><a href="https://file.shivakasu.cn/566ac26954b7e304e60d/mir4-6.png" data-fancybox="group" data-caption="mir4-6" class="fancybox"><img alt="mir4-6" data-src="https://file.shivakasu.cn/566ac26954b7e304e60d/mir4-6.png" class="lazyload" title="mir4-6"></a></p><h3 id="4-8-结构化文本压缩"><a href="#4-8-结构化文本压缩" class="headerlink" title="4.8 结构化文本压缩"></a>4.8 结构化文本压缩</h3><p>&emsp;&emsp;结构化文本就是XML一类的文本，区分属性、元素这种层次。压缩方法其实就是根据文本的结构修改或者组合上面提到的这些方法，本质上没什么特别的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 4：检索评价</title>
    <link href="http://shivakasu.github.io/2019/02/01/mir3/"/>
    <id>http://shivakasu.github.io/2019/02/01/mir3/</id>
    <published>2019-02-01T10:09:20.000Z</published>
    <updated>2020-01-15T10:56:03.630Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>&emsp;&emsp;检索评价针对信息检索系统响应用户查询的返回结果，系统化地给出了一个量化的指标。这个指标应该和检索结果与用户的相关性直接联系。计算这个指标的通常方法是，对于给定的一组查询，比较由系统产生的结果和由人产生的结果。这里的检索评价仅针对检索系统的结果质量，不考虑界面设计、系统性能等因素的影响。</p><h2 id="2-检索指标"><a href="#2-检索指标" class="headerlink" title="2 检索指标"></a>2 检索指标</h2><h3 id="2-1-精度和召回率"><a href="#2-1-精度和召回率" class="headerlink" title="2.1 精度和召回率"></a>2.1 精度和召回率</h3><p>&emsp;&emsp;精度(Precison)是检出文档中相关文档的比例，召回率(Recall)是相关文档集中被检出的比率。将相关文档集记作 <script type="math/tex">R</script> ，系统得出的结果集为 <script type="math/tex">A</script> ，则：</p><script type="math/tex; mode=display">精度=p=\frac{|R\cap A|}{|A|}</script><script type="math/tex; mode=display">召回率=r=\frac{|R\cap A|}{|R|}</script><p>以横坐标为召回率，纵坐标为精度可绘制精度-召回率曲线，曲线下面积(Area Unser the Curve, AUC)可用于评估不同答案集的质量，面积越大表明质量越好。</p><p>&emsp;&emsp;缺点：</p><ul><li>召回率无法准确估计。</li><li>精度和召回率是相关联的指标，将二者结合为单一指标会更合适。</li><li>只能度量批处理状态下对一组查询进行处理的结果。</li><li>对于只需要弱偏序关系的系统来说，精度和召回率可能不适合。(?)</li></ul><h3 id="2-2-单值总结"><a href="#2-2-单值总结" class="headerlink" title="2.2 单值总结"></a>2.2 单值总结</h3><p>&emsp;&emsp;(1) 前 <script type="math/tex">n</script> 平均精度 <script type="math/tex">P@n</script> ：大部分搜索不需要高的召回率，绝大部分用户只需要顶部的几篇相关文档，通常计算前5篇或前10篇文档的平均精度(不管是相关还是不相关)， <script type="math/tex">P@n</script> 提供了可靠的指标来评价Web搜索引擎的用户是否在排序的顶部得到了相关文档。</p><p>&emsp;&emsp;(2) 平均精度均值(Mean Average Precision, MAP)：通过对每个新观察到的相关文档计算精度并做平均来得到关于排序的总结性的单一指标。查询 <script type="math/tex">q_i</script> 的平均精度定义为：</p><script type="math/tex; mode=display">MAP_i=\frac{1}{|R_i|}\sum_{k=1}^{|R_i|}P(R_i[k])</script><p>其中 <script type="math/tex">R_i</script> 是 <script type="math/tex">q_i</script> 对应的相关文档的集合， <script type="math/tex">P(R_i[k])</script> 是从头遍历结果集的排序队列直到观察到 <script type="math/tex">R_i</script> 中第 <script type="math/tex">k</script> 篇文档时的精度，如果没有观察到就记作0。此外，在一组查询上的平均精度均值定义为：</p><script type="math/tex; mode=display">MAP=\frac{1}{|N_q|}\sum_{i=1}^{|N_q|}MAP_i</script><p>其中 <script type="math/tex">N_q</script> 是查询的总数目。</p><p>&emsp;&emsp;(3) <script type="math/tex">R</script> 精度：设当前查询的相关文档集 <script type="math/tex">R</script> 的容量为 <script type="math/tex">n</script> ，取排序队列的前 <script type="math/tex">n</script> 篇文档计算精度，简单粗暴。但是对于一组查询，计算每个查询的 <script type="math/tex">R</script> 精度再取平均效果可能不好。</p><p>&emsp;&emsp;(4) 精度直方图：核心思想就是对于一组查询，可以分别比较每个查询在不同算法上的 <script type="math/tex">R</script> 精度，来比较两个算法的检索质量，废话。</p><p>&emsp;&emsp;(5) 平均排序倒数：适用于QA系统、特定主页查询等任务，更关注第一个正确的结果，而不是整个排序的结果集。设 <script type="math/tex">R_i</script> 是相对于查询 <script type="math/tex">q_i</script> 的排序， <script type="math/tex">S_{correct}(R_i)</script> 函数返回在 <script type="math/tex">R_i</script> 中第一个正确答案的位置，给定一个排序位置阈值 <script type="math/tex">S_h</script> ， <script type="math/tex">R_i</script> 的排序倒数定义为：</p><script type="math/tex; mode=display">\begin{cases}\frac{1}{S_{correct}(R_i)} & S_{correct}(R_i)\leq S_h \\0 & otherwise\end{cases}</script><p>对于由 <script type="math/tex">N_q</script> 个查询组成的集合 <script type="math/tex">Q</script> 来说，平均排序倒数(Mean Reciproach Rank, MRR)是所有排序倒数的均值，即：</p><script type="math/tex; mode=display">MRR(Q)=\frac{1}{N_q}\cdot\sum_{i=1}^{N_q}\frac{1}{S_{correct}(R_i)}</script><script type="math/tex; mode=display">MRR$$ 是倾向于那些第一个正确的结果出现在排序顶部的指标。&emsp;&emsp;(6) E值：结合精度和召回率，公式为：$$E(j)=1-\frac{1+b^2}{\frac{b^2}{r(j)}+\frac{1}{P(j)}}</script><p>其中 <script type="math/tex">r(j)</script> 是在排序中第 <script type="math/tex">j</script> 个位置的召回率， <script type="math/tex">P(j)</script> 是在排序中第 <script type="math/tex">j</script> 个位置的精度， <script type="math/tex">b(b\geq 0)</script> 是用户定义的参数。</p><p>&emsp;&emsp;(7) F值：同样是结合精度和召回率，公式为：</p><script type="math/tex; mode=display">F(j)=\frac{2}{\frac{1}{r(j)}+\frac{1}{P(j)}}</script><p>注意到，当E值的 <script type="math/tex">b=1</script> 时， <script type="math/tex">F(j)=1-E(j)</script> 。</p><p>&emsp;&emsp;(8) 摘要统计表：就是把查询数、文档数等统计特征列个表，没什么用。</p><h3 id="2-3-面向用户的指标"><a href="#2-3-面向用户的指标" class="headerlink" title="2.3 面向用户的指标"></a>2.3 面向用户的指标</h3><p>&emsp;&emsp;在相关文档集 <script type="math/tex">R</script> 和结果集 <script type="math/tex">A</script> 之外，考虑用户的认知范围，即用户已知的文档 <script type="math/tex">K</script> ，如下图：<br><a href="https://file.shivakasu.cn/33c0aa6ab8cd06c8bce7/mir3-0.png" data-fancybox="group" data-caption="mir3-0" class="fancybox"><img alt="mir3-0" data-src="https://file.shivakasu.cn/33c0aa6ab8cd06c8bce7/mir3-0.png" class="lazyload" title="mir3-0"></a></p><p>定义覆盖率为：</p><script type="math/tex; mode=display">coverage=\frac{|K\cap R\cap A|}{|K\cap R|}</script><p>定义新颖率为：</p><script type="math/tex; mode=display">novelty=\frac{|(R\cap A)-K|}{|K\cap R|}</script><p>高覆盖率表明系统找到了用户期望看到的大部分相关文档，高新颖率表明系统向用户展示了许多之前未知的新的相关文档。</p><h3 id="2-4-折扣累计增益"><a href="#2-4-折扣累计增益" class="headerlink" title="2.4 折扣累计增益"></a>2.4 折扣累计增益</h3><p>&emsp;&emsp;上述基于相关文档集和结果集计算的指标只考虑文档与查询的相关与否，而没有考虑到相关性的强弱。当检查查询的结果时，可以观察到两个重要的现象：</p><ul><li>在排序的顶部我们更希望是高度相关的文档，而不是轻度相关的文档。</li><li>出现在排序底部的相关文档的价值不高。</li></ul><p>&emsp;&emsp;针对第一个现象，赋予每个相关文档相关性强度，0表示不相关，值越大表示相关性越强，对系统返回的排序列表，增益向量(gain vector) <script type="math/tex">G</script> 定义为其中每个元素的相关性强度组成的向量，如：</p><script type="math/tex; mode=display">G=(1,0,1,0,0,3,0,0,0,2,0,0,0,0,3)</script><p>累计增益(Cumulated Gain) $CG$ 定义为：</p><script type="math/tex; mode=display">CG[i]=\begin{cases}G[1] & i=1 \\G[i]+CG[i-1] & i>1\end{cases}</script><p>则对于上面的增益向量：</p><script type="math/tex; mode=display">CG=(1,1,2,2,2,5,5,5,5,7,7,7,7,7,10)</script><p>&emsp;&emsp;针对第二个问题，按照文档在排序列表中的位置进行价值衰减，定义折扣累计增益(Discounted Cumulated Gain) $DCG$ 为：</p><script type="math/tex; mode=display">DCG[i]=\begin{cases}G[1] & i=1 \\\frac{G[i]}{log_2i}+DCG[i-1] & i>1\end{cases}</script><p>则对于上面的增益向量：</p><script type="math/tex; mode=display">DCG=(1.0,1.0,1.6,1.6,1.6,2.8,2.8,2.8,2.8,3.4,3.4,3.4,3.4,3.4,4.2)</script><p>同理，对于由多个查询组成的集合，可计算平均累计增益 <script type="math/tex">\overline{CG}</script> 和平均折扣累计增益 <script type="math/tex">\overline{DCG}</script> 。</p><p>&emsp;&emsp;由于累计增益没有参照，定义理想 <script type="math/tex">CG</script> 和 <script type="math/tex">DCG</script> 为最优排序列表得到的结果，即文档相关性强度从大到小排列，记作 <script type="math/tex">ICG</script> 和 <script type="math/tex">IDCG</script> 。将原始的 <script type="math/tex">CG</script> 和 <script type="math/tex">DCG</script> 进行归一化：</p><script type="math/tex; mode=display">NCG[i]=\frac{\overline{CG[i]}}{\overline{ICG[i]}}</script><script type="math/tex; mode=display">NDCG[i]=\frac{\overline{DCG[i]}}{\overline{IDCG[i]}}</script><p>得到了在区间 <script type="math/tex">[0,1]</script> 上的累计增益指标，可用于不同排序算法之间的比较。</p><h3 id="2-5-二元偏好"><a href="#2-5-二元偏好" class="headerlink" title="2.5 二元偏好"></a>2.5 二元偏好</h3><p>&emsp;&emsp;Todo</p><h3 id="2-6-排序相关性测度"><a href="#2-6-排序相关性测度" class="headerlink" title="2.6 排序相关性测度"></a>2.6 排序相关性测度</h3><p>&emsp;&emsp;当没有参照或没有评测人员时，很难计算出上述指标，则可以直接度量两个排序函数产生的结果的相关性，若对其中一个排序函数有一定的了解，就可以根据二者的相关性分析另一个排序函数的优劣。</p><p>&emsp;&emsp;斯皮尔曼系数(Spearman coefficient)根据相同文档在不同排序中的位置差值计算相关性。设 <script type="math/tex">s_{1,j}</script> 是文档 <script type="math/tex">d_j</script> 在排序 <script type="math/tex">R_1</script> 中的位置， <script type="math/tex">s_{2,j}</script> 是文档 <script type="math/tex">d_j</script> 在排序 <script type="math/tex">R_2</script> 中的位置，则位置差值是 <script type="math/tex">|s_{1,j}-s_{2,j}|</script> ，或计算差值平方和 <script type="math/tex">(s_{1,j}-s_{2,j})^2</script> 。如果有K篇排序文档，对排序差值求平方和，则差值平方和的最大值是 <script type="math/tex">\frac{K\times(K^2-1)}{3}</script> ，即两个排序互为反序。使用该最大值进行差值平方和的归一化，即：</p><script type="math/tex; mode=display">\frac{\sum_{j=1}^K(s_{1,j}-s_{2,j})^2}{\frac{K\times(K^2-1)}{3}}</script><p>将该分式乘2，再用1减去结果，就得到了在区间 <script type="math/tex">[-1,1]</script> 上的斯皮尔曼系数：</p><script type="math/tex; mode=display">S(R_1,R_2)=1-\frac{6\times\sum_{j=1}^K(s_{1,j}-s_{2,j})^2}{K\times(K^2-1)}</script><p>值越大表明相关性越强。然而，通常两个排序文档集的大小和内容是不同的，这时的做法是取并集，将 <script type="math/tex">R_2</script> 中不属于 <script type="math/tex">R_1</script> 的文档添加在 <script type="math/tex">R_1</script> 尾部，同时将 <script type="math/tex">R_1</script> 中不属于 <script type="math/tex">R_2</script> 的文档添加在 <script type="math/tex">R_2</script> 尾部，之后再对这两个增广排序计算斯皮尔曼系数。</p><p>&emsp;&emsp;肯德尔系数(Kendall Tau coefficient)比斯皮尔曼系数代数结构简单，有更清楚和直观的解释。给定两篇文档 <script type="math/tex">d_j</script> 和 <script type="math/tex">d_k</script> ，若在两个排序列表 <script type="math/tex">R_1</script> 和 <script type="math/tex">R_2</script> 中， <script type="math/tex">s_{1,j}-s_{1,k}</script> 和 <script type="math/tex">s_{2,j}-s_{2,k}</script> 同号，那么就说文档二元组 <script type="math/tex">[d_j,d_k]</script> 在这两个排序中是协调的，反之则是不协调的。如果有K篇排序文档，则共有 <script type="math/tex">K(K-1)</script> 个文档二元组，肯德尔系数定义为：</p><script type="math/tex; mode=display">\tau(R_1,R_2)=1-\frac{2\times\Delta(R_1,R_2)}{K(K-1)}</script><p>和斯皮尔曼系数的形式是几近相同的，当两个排序文档集不同时，也可以用相同的方式增广排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 3：信息检索建模</title>
    <link href="http://shivakasu.github.io/2019/01/24/mir2/"/>
    <id>http://shivakasu.github.io/2019/01/24/mir2/</id>
    <published>2019-01-24T05:40:20.000Z</published>
    <updated>2020-01-15T10:55:43.840Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-信息检索模型"><a href="#1-信息检索模型" class="headerlink" title="1 信息检索模型"></a>1 信息检索模型</h2><p>&emsp;&emsp;信息检索模型是一个四元组 <script type="math/tex">[D,Q,F,R(q_i,d_i)]</script> 。其中D(Document)是文档表示的集合，Q(Query)是查询表示的集合，F(Framework)是对文档、查询及其关系建模的框架，例如布尔框架、线性框架，R(Ranking)是排序函数，对于查询表达式 <script type="math/tex">q_i\in Q</script> 和文档表达式 <script type="math/tex">d_i\in D</script> ，函数返回文档 <script type="math/tex">d_i</script> 关于查询<script type="math/tex">q_i</script>的文档次序。</p><p>&emsp;&emsp;信息检索主要基于文本，文本模型也细分为是否考虑文本结构，所谓考虑文本结构就是区别对待标题、段落等文档不同结构处的内容。在web中，由于文档数量巨大，还需要考虑网页之间的链接，如今的web排序函数结合了经典的信息检索模型和基于链接模型的特征来提高检索性能。信息检索还可基于图像、音频等多媒体数据，检索策略更复杂。信息检索模型的分类体系见下图：<br><a href="https://file.shivakasu.cn/648d8d4d85d3f6ed9f89/mir2-0.png" data-fancybox="group" data-caption="mir2-0" class="fancybox"><img alt="mir2-0" data-src="https://file.shivakasu.cn/648d8d4d85d3f6ed9f89/mir2-0.png" class="lazyload" title="mir2-0"></a></p><h2 id="2-经典信息检索"><a href="#2-经典信息检索" class="headerlink" title="2 经典信息检索"></a>2 经典信息检索</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><ul><li>索引项(index term)：文档里的一个词或一组连续的词，主要是名词，因为名词相比于形容词、副词等往往能包含更多信息，具体的选择策略因人而异。</li><li>词汇表(vocabulary)： <script type="math/tex">V=(k_1,k_2,\cdots ,k_t)</script> ，其中 <script type="math/tex">t</script> 是文档集中索引项的数量， <script type="math/tex">k_i</script> 是某个索引项。</li><li>文档表示：就是简单的词袋方法，表示成和词汇表一样长的向量，其中每个元素是0或1，0表示对应的索引项在文档中未出现，1表示对应的索引项在文档中出现。</li><li>查询表示：和文档表示相同，每个元素表示相应索引项是否在查询中出现。</li><li>项-文档矩阵：行数是索引项个数，列数是文档个数，元素 <script type="math/tex">f_{i,j}</script> 表示第 <script type="math/tex">i</script> 个索引项在第 <script type="math/tex">j</script> 个文档中出现的频数。显然，在词袋方法中是0-1矩阵。</li><li>文档的逻辑视图：大概就是表示文档的方式。通常是把文档全文转变成索引项集合，流程如下图：<br><a href="https://file.shivakasu.cn/4433d3fae9363c920f64/mir2-1.png" data-fancybox="group" data-caption="mir2-1" class="fancybox"><img alt="mir2-1" data-src="https://file.shivakasu.cn/4433d3fae9363c920f64/mir2-1.png" class="lazyload" title="mir2-1"></a></li></ul><h3 id="2-2-布尔模型"><a href="#2-2-布尔模型" class="headerlink" title="2.2 布尔模型"></a>2.2 布尔模型</h3><p>&emsp;&emsp;使用词袋方法表示文档，用析取范式(disjunct normal form)表示查询。例如对于词汇表 <script type="math/tex">V=(k_a,k_b,k_c,k_d)</script> 和查询 <script type="math/tex">q=k_a\wedge (k_b\vee k_c)</script> ，用析取范式表示查询为：</p><script type="math/tex; mode=display">q_{DNF}=(1,1,1,0)\vee(1,1,1,1)\vee(1,1,0,0)\vee(1,1,0,1)\vee(1,0,0,0)\vee(1,0,0,1)</script><p>文档与查询的相关度定义为析取范式中是否有一项与文档表示相同，因此也是二值的。</p><p>&emsp;&emsp;布尔模型的优点是简单，缺点是不支持排序。因为相关度是二值的，只能表示相关与否，而不能表示相关的程度。</p><h3 id="2-3-项权重"><a href="#2-3-项权重" class="headerlink" title="2.3 项权重"></a>2.3 项权重</h3><p>&emsp;&emsp;提高检索质量的一个方法是给每个索引项设置权重，通常根据索引项在整个文档集中出现的频次设置权重。如果不假设索引项之间相互独立，还要考虑索引项之间的相关性，因为索引项之间的关联往往会反映文档之间的关联，一种计算项间相关性的方法是项-文档矩阵乘他的转置矩阵，如下图：<br><a href="https://file.shivakasu.cn/0149fd92db89c2e04630/mir2-2.png" data-fancybox="group" data-caption="mir2-2" class="fancybox"><img alt="mir2-2" data-src="https://file.shivakasu.cn/0149fd92db89c2e04630/mir2-2.png" class="lazyload" title="mir2-2"></a><br>假设项间相互独立可以简化模型、提高计算效率，而利用项间相关性提高排序水平也是十分复杂的工作，考虑了项间相关性并不能保证排序水平的提高，因此是否假设项间相互独立没有固定的标准。</p><h3 id="2-4-TD-IDF"><a href="#2-4-TD-IDF" class="headerlink" title="2.4 TD-IDF"></a>2.4 TD-IDF</h3><p>&emsp;&emsp;TF-IDF是一个常用的计算项权重的指标，其中TF(Term frequency)表示项频，IDF(Inverse document frequency)表示反比文档频率。</p><p>&emsp;&emsp;使用项频是基于Luhn假设，即高频项对描述文档的关键主题是重要的。可以直接将索引项的频次作为TF权重，即 <script type="math/tex">tf_{i,j}=f_{i,j}</script> ，但考虑到要与IDF权重结合，而IDF使用了对数运算，因此通常使用TF权重的一个变种：</p><script type="math/tex; mode=display">tf_{i,j}=\begin{cases}1+log_2f_{i,j} & f_{i,j}>0 \\0 & otherwise\end{cases}</script><p>&emsp;&emsp;TF权重倾向于给频次高的索引项更大的权重，但也要考虑索引项的区分度，即索引项特异性(term specificity)。如果一个索引项在每个文档中都出现，虽然出现频次高，但是对于文档排序等任务没有太大帮助，最常见的就是a、the这样的冠词、连词和介词。因此不仅要考虑高频项，还要考虑区分度大的索引项。IDF权重考虑的就是某个索引项在多少个文档中出现，即相对文档频率 <script type="math/tex">n_i/N</script> ， <script type="math/tex">IDF_i=log_2\frac{N}{n_i}</script> ，其中 <script type="math/tex">N</script> 是文档集中的文档数量， <script type="math/tex">n_i</script> 是出现索引项 <script type="math/tex">k_i</script> 的文档数量，因为相对文档频率越小的索引项区分度越大，所以IDF使用了相对文档频率的倒数，称作反比文档频率。</p><p>&emsp;&emsp;TF-IDF将二者结合起来，计算方法如下：</p><script type="math/tex; mode=display">w_{i,j}=\begin{cases}(1+log_2f_{i,j})*log_2\frac{N}{n_i} & f_{i,j}>0 \\0 & otherwise\end{cases}</script><p>&emsp;&emsp;TF、IDF和TF-IDF有多种变体。TF变体如下：<br><a href="https://file.shivakasu.cn/6a3557149d63d9d07c8d/mir2-3.png" data-fancybox="group" data-caption="mir2-3" class="fancybox"><img alt="mir2-3" data-src="https://file.shivakasu.cn/6a3557149d63d9d07c8d/mir2-3.png" class="lazyload" title="mir2-3"></a></p><p>IDF变体如下：<br><a href="https://file.shivakasu.cn/9b5b06f2b588a7e7566c/mir2-4.png" data-fancybox="group" data-caption="mir2-4" class="fancybox"><img alt="mir2-4" data-src="https://file.shivakasu.cn/9b5b06f2b588a7e7566c/mir2-4.png" class="lazyload" title="mir2-4"></a></p><p>TF-IDF变体如下：<br><a href="https://file.shivakasu.cn/4a396f3ce65a26f1b49a/mir2-5.png" data-fancybox="group" data-caption="mir2-5" class="fancybox"><img alt="mir2-5" data-src="https://file.shivakasu.cn/4a396f3ce65a26f1b49a/mir2-5.png" class="lazyload" title="mir2-5"></a></p><p>&emsp;&emsp;通过下图可以分析出TF-IDF的性质。TF和IDF权重表现出的幂律特性会相互平衡，高TF权重趋于和低IDF权重结合，低TF权重趋于和高IDF权重结合，结果是TF-IDF权重最高的索引项往往具有中等TF和IDF权重，而项频太高的项和文档频率太低的项经过平衡后都具有较低的TF-IDF权重。妙啊！<br><a href="https://file.shivakasu.cn/ded9527fd90145d96807/mir2-6.png" data-fancybox="group" data-caption="mir2-6" class="fancybox"><img alt="mir2-6" data-src="https://file.shivakasu.cn/ded9527fd90145d96807/mir2-6.png" class="lazyload" title="mir2-6"></a></p><h3 id="2-5-文档长度归一化"><a href="#2-5-文档长度归一化" class="headerlink" title="2.5 文档长度归一化"></a>2.5 文档长度归一化</h3><p>&emsp;&emsp;对于给定的查询，较长的文档仅仅因为包含更多的索引项而更可能被检出，为了消除这一影响，可以把文档的排序除以其长度，这个过程称为文档长度归一化，如何计算文档长度取决于文档的表示形式。</p><h3 id="2-6-向量模型"><a href="#2-6-向量模型" class="headerlink" title="2.6 向量模型"></a>2.6 向量模型</h3><p>&emsp;&emsp;布尔模型使用析取范式的每一项和文档表示进行严格匹配，难以得到理想的结果。向量模型将文档和查询表示为向量形式，使用向量夹角的余弦值衡量相似度，成功将相似度量化为可用于比较和排序的数值，基于相似度的排序可以理解为一种部分匹配策略。文档的向量表示为 <script type="math/tex">\vec{d_j}=(w_{1,j},w_{2,j},\cdots,w_{t,j})</script> ，其中 <script type="math/tex">t</script> 是索引项总个数， <script type="math/tex">w_{i,j}</script>是项-文档对 <script type="math/tex">(k_i,d_j)</script> 的权重，一般采用TF-IDF权重，查询的向量表示为 <script type="math/tex">\vec{q}=(w_{1,q},w_{2,q},\cdots,w_{t,q})</script> , <script type="math/tex">w_{i,q}</script>是项-查询对 <script type="math/tex">(k_i,q)</script> 的权重。文档-查询余弦相似度公式为：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{\vec{d_j}\cdot\vec{q}}{|\vec{d_j}|\times|\vec{q}|}</script><p>注意到余弦公式分母的向量范数恰好也起到了文档长度归一化的作用。</p><h3 id="2-7-概率模型"><a href="#2-7-概率模型" class="headerlink" title="2.7 概率模型"></a>2.7 概率模型</h3><p>&emsp;&emsp;概率模型的目标是估计文档与查询相关的概率，他假定这种相关性仅依赖于文档和查询本身的表示，并假定存在一个理想答案集，仅包含所有与查询相关的文档，因此能够最大化与用户相关的总体概率。显然，这种假设是对真实情况的简化，所以必然会存在一些缺陷。</p><p>&emsp;&emsp;概率模型计算相关度的公式是：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{P(R|\vec{d_j})}{P(\overline{R}|\vec{d_j})}</script><p>其中 <script type="math/tex">R</script> 是与查询 <script type="math/tex">q</script> 相关的文档的集合， <script type="math/tex">\overline{R}</script> 是与查询 <script type="math/tex">q</script> 不相关的文档的集合， <script type="math/tex">P(R|\vec{d_j})</script>是文档 <script type="math/tex">d_j</script> 与查询 <script type="math/tex">q</script> 相关的概率， <script type="math/tex">P(\overline{R}|\vec{d_j})</script>是文档 <script type="math/tex">d_j</script> 与查询 <script type="math/tex">q</script> 不相关的概率。根据贝叶斯公式：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{P(\vec{d_j}|R,q)\times P(R,q)}{P(\vec{d_j}|\overline{R},q)\times P(\overline{R},q)}\sim\frac{P(\vec{d_j}|R,q)}{P(\vec{d_j}|\overline{R},q)}</script><p>其中 <script type="math/tex">P(\vec{d_j}|R,q)</script> 表示从查询 <script type="math/tex">q</script> 的相关文档集 <script type="math/tex">R</script> 中随机选择的一偏文档表示为 <script type="math/tex">\vec{d_j}</script> 的概率， <script type="math/tex">P(R,q)</script> 表示从整个文档集中随机选择的文档和查询 <script type="math/tex">q</script> 相关的概率， <script type="math/tex">P(\vec{d_j}|\overline{R},q)</script> 和 <script type="math/tex">P(\overline{R},q)</script> 的含义是相似且互补的。概率模型中不考虑项权重，所以 <script type="math/tex">\vec{d_j}</script> 是一个二值向量，如果假设索引项间的独立性，即所谓的二值独立假设，可以得到：</p><script type="math/tex; mode=display">sim(d_j,q)\sim\frac{(\prod_{k_i|w_{i,j}=1}p_{iR})\times(\prod_{k_i|w_{i,j}=0}(1-p_{iR}))}{(\prod_{k_i|w_{i,j}=1}q_{iR})\times(\prod_{k_i|w_{i,j}=0}(1-q_{iR}))}</script><p>其中 <script type="math/tex">p_{iR}</script> 表示索引项 <script type="math/tex">k_i</script> 出现在从查询 <script type="math/tex">q</script> 的相关文档集 <script type="math/tex">R</script> 中随机选择的一偏文档内的概率， <script type="math/tex">q_{iR}</script> 表示索引项 <script type="math/tex">k_i</script> 出现在从查询 <script type="math/tex">q</script> 的不相关文档集 <script type="math/tex">\overline{R}</script> 中随机选择的一偏文档内的概率。使用对数函数只改变数值而不改变排序结果，所以可以进一步简化为：</p><script type="math/tex; mode=display">sim(d_j,q)\sim\sum_{k_i\in q\wedge k_i\in d_j}log(\frac{p_{iR}}{1-p_{iR}})+log(\frac{1-q_{iR}}{q_{iR}})</script><p>得到了相似度公式，接下来就是如何计算 <script type="math/tex">p_{iR}</script> 和 <script type="math/tex">q_{iR}</script> 。</p><p>&emsp;&emsp;一种计算方法是使用索引项出现列联表，如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">相关文档数</th><th style="text-align:center">不相关文档数</th><th style="text-align:center">总文档数</th></tr></thead><tbody><tr><td style="text-align:center">包含 $k_i$ 的文档</td><td style="text-align:center">$r_i$</td><td style="text-align:center">$n_i-r_i$</td><td style="text-align:center">$n_i$</td></tr><tr><td style="text-align:center">不包含 $k_i$ 的文档</td><td style="text-align:center">$R-r_i$</td><td style="text-align:center">$N-n_i-(R-r_i)$</td><td style="text-align:center">$N-n_i$</td></tr><tr><td style="text-align:center">所有文档</td><td style="text-align:center">$R$</td><td style="text-align:center">$N-R$</td><td style="text-align:center">$N$</td></tr></tbody></table></div><p>那么可以得到，</p><script type="math/tex; mode=display">p_{iR}=\frac{r_i}{R}\quad, \quad q_{iR}=\frac{n_i-r_i}{N-R}</script><script type="math/tex; mode=display">sim(d_j,q)\sim\sum_{k_i\in q\wedge k_i\in d_j}log(\frac{(r_i+0.5)(N-n_i-R+r_i+0.5)}{(R-r_i+0.5)(n_i-r_i+0.5)})</script><p>之所以给每个包含 <script type="math/tex">r_i</script> 的项加0.5，是为了减小极端情况下过小的 <script type="math/tex">r_i</script> 对 <script type="math/tex">log</script> 计算的影响。这种方法需要人工估计 <script type="math/tex">r_i</script> 和 <script type="math/tex">R</script> 值，所以不实用，同时缺少文档长度归一化的操作，使得排序效果也不是很好。</p><p>&emsp;&emsp;另一种方法是在避免人工估计的条件下，基于几条假设来自动更新 <script type="math/tex">r_i</script> 和 <script type="math/tex">R</script> 值，个人认为这里的假设太牵强，理解不了。</p><p>&emsp;&emsp;概率模型的优点是能按照相关概率进行排序，但其认为相关性仅与文档和查询的内容有关，所以实际应用时效果难以保证。此外，概率模型不可避免地要做初始估计将文档分为相关和不相关集合，不太好操作。观察上面计算 <script type="math/tex">sim(d_j,q)</script> 的公式，与IDF权重的公式是相似的，从这个角度看，概率模型的另一个缺点是没有用到TF特征，也没有进行文档长度归一化。</p><h2 id="3-其他集合论模型"><a href="#3-其他集合论模型" class="headerlink" title="3 其他集合论模型"></a>3 其他集合论模型</h2><h3 id="3-1-基于集合的模型"><a href="#3-1-基于集合的模型" class="headerlink" title="3.1 基于集合的模型"></a>3.1 基于集合的模型</h3><p>&emsp;&emsp;基于集合的模型不考虑单独的索引项，而是考虑索引项之间的相互依赖性，通过引入项集的概念表示索引项之间的关联。</p><p>&emsp;&emsp;项集(Termset)：项集 <script type="math/tex">S_i=\{k_a,k_b,\cdots,k_n\}</script> 是文档集中索引项的子集。若 <script type="math/tex">S_i</script> 中所有的索引项都出现在文档 <script type="math/tex">d_j</script> 中，就称项集 <script type="math/tex">S_i</script> 出现在 <script type="math/tex">d_j</script> 中。</p><p>&emsp;&emsp;显然，若文档集中有 <script type="math/tex">t</script> 个索引项，则理论上有 <script type="math/tex">2^t</script> 个项集，但实际数据集中一般仅包含部分项集。同时，用项集表示替代索引项表示就需要把项的词汇表改为项集的词汇表，即 <script type="math/tex">V_S=\{S_1,S_2,\cdots,S_{2^t}\}</script> 。</p><p>&emsp;&emsp;频繁项集(Frequent termsets)：由 <script type="math/tex">n</script> 个项构成的项集称为 <script type="math/tex">n</script> 项集，如果包含某个 <script type="math/tex">n</script> 项集的文档数 <script type="math/tex">\mathcal{N}_i</script> 高于某个给定的阈值，那么这个 <script type="math/tex">n</script> 项集 <script type="math/tex">S_i</script> 称为是频繁的。显然，一个 <script type="math/tex">n</script> 项集是频繁的当且仅当他的所有 <script type="math/tex">(n-1)</script> 项集都是频繁地。</p><p>&emsp;&emsp;在TF-IDF中，计算的权重是项-文档矩阵的元素，在集合模型中与之类似，计算的权重是项集-文档矩阵的元素。对于 <script type="math/tex">(S_i,d_j)</script> ，令 <script type="math/tex">N</script> 是文档集中文档总数，<script type="math/tex">\mathcal{F}_{i,j}</script> 是项集 <script type="math/tex">S_i</script> 在文档 <script type="math/tex">d_j</script> 中的原始出现频率，赋予项集权重：</p><script type="math/tex; mode=display">\mathcal{W}_{i,j}=\begin{cases}(1+log_2\mathcal{F}_{i,j})*log_2(1+\frac{N}{\mathcal{N}_i}) & \mathcal{F}_{i,j}>0 \\0 & otherwise\end{cases}</script><p>同理， <script type="math/tex">\vec{d_j}=(\mathcal{W}_{1,j},\mathcal{W}_{2,j},\cdots,\mathcal{W}_{2^t,j})</script> ， <script type="math/tex">\vec{q}=(\mathcal{W}_{1,q},\mathcal{W}_{2,q},\cdots,\mathcal{W}_{2^t,q})</script>，相似度计算公式为：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{\vec{d_j}\cdot\vec{q}}{|\vec{d_j}|\times|\vec{q}|}=\frac{\sum_{S_i}\mathcal{W}_{i,j}\times\mathcal{W}_{i,q}}{|\vec{d_j}|\times|\vec{q}|}</script><p>由于项集空间是项空间的指数级大小，所以相似度的计算十分复杂，需要进行计算简化。例如在计算向量范数时只考虑 <script type="math/tex">1</script> 项集。或是进一步缩小项集的范围，只考虑频繁闭项集，闭项集(Closed termset)就是项集的闭包，比如项集 <script type="math/tex">\{k_1\}</script> 、 <script type="math/tex">\{k_2\}</script> 、 <script type="math/tex">\{k_1,k_2\}</script>出现在相同的文档子集中，那么可以只计算 <script type="math/tex">\{k_1,k_2\}</script>，大大减小了计算量，除了频繁闭项集，还可选择最大频繁集，即添加任何索引项都不能使其保持频繁性。从项集数目上看，频繁项集&gt;频繁闭项集&gt;最大频繁集，需要注意的是，减少计算必然伴随着信息的损失，因此需要根据实际情况进行权衡。</p><h3 id="3-2-扩展布尔模型"><a href="#3-2-扩展布尔模型" class="headerlink" title="3.2 扩展布尔模型"></a>3.2 扩展布尔模型</h3><p>&emsp;&emsp;用向量模型的特征扩展布尔模型，狗尾续貂？</p><h3 id="3-3-模糊集模型"><a href="#3-3-模糊集模型" class="headerlink" title="3.3 模糊集模型"></a>3.3 模糊集模型</h3><p>&emsp;&emsp;模糊集模型基于模糊集理论，对于每一个索引项 <script type="math/tex">k_i</script> ，为其分配一个模糊集(fuzzy set) <script type="math/tex">D_i</script> ，模糊集为每一个文档 <script type="math/tex">d_j</script> 分配一个介于区间 <script type="math/tex">[0,1]</script> 之间的隶属度(degree of membership)  <script type="math/tex">\mu_{i,j}</script> ，若 <script type="math/tex">\mu_{i,j}\sim 1</script> 表明 <script type="math/tex">k_i</script> 是 <script type="math/tex">d_j</script> 的良好模糊索引项，若 <script type="math/tex">\mu_{i,j}\sim 0</script> 表明 <script type="math/tex">k_i</script> 不是 <script type="math/tex">d_j</script> 的良好模糊索引项。隶属度可以通过项间相关性矩阵 <script type="math/tex">C</script> 来计算，索引项 <script type="math/tex">k_i</script> 和 <script type="math/tex">k_l</script> 的相关性计算公式为：</p><script type="math/tex; mode=display">c_{i,l}=\frac{n_{i,l}}{n_i+n_l-n_{i,l}}</script><p>其中 <script type="math/tex">n_i</script> 是含有索引项 <script type="math/tex">k_i</script> 的文档数， <script type="math/tex">n_l</script> 是含有索引项 <script type="math/tex">k_l</script> 的文档数， <script type="math/tex">n_{i,l}</script> 是同时含有这两个索引项的文档数，这种相关性度量被广泛应用在聚类算法中。有了相关性度量，就可以计算隶属度：</p><script type="math/tex; mode=display">\mu_{i,j}=1-\prod_{k_l\in d_j}(1-c_{i,l})</script><p>这其实就是在考虑 <script type="math/tex">k_i</script> 和 <script type="math/tex">d_j</script> 中每一个索引项的相关性，可以看出，只要 <script type="math/tex">d_j</script> 中至少有一个索引项 <script type="math/tex">k_l</script> 与 <script type="math/tex">k_i</script> 关系密切(即 <script type="math/tex">c_{i,l}\sim 1</script> )，则 <script type="math/tex">\mu_{i,j}\sim 1</script> 。此外，采用代数和的方式计算而不是对所有相关性使用 <script type="math/tex">max</script> 函数，可以使 <script type="math/tex">\mu_{i,j}</script> 的值变得平滑。</p><p>&emsp;&emsp;有了文档相对索引项的隶属度，就可以进一步计算文档相对于查询的隶属度，因为借鉴布尔模型的方法，查询可以表示成索引项组成的逻辑表达式。例如对于查询 <script type="math/tex">q=k_a\wedge (k_b\vee\neg k_c)</script> ，可以写成析取范式 <script type="math/tex">\vec{q}_{dnf}=(1,1,1)\vee(1,1,0)\vee(1,0,0)</script> ，设 <script type="math/tex">D_a</script> 、 <script type="math/tex">D_b</script> 、 <script type="math/tex">D_c</script> 分别是 <script type="math/tex">k_a</script> 、 <script type="math/tex">k_b</script> 、 <script type="math/tex">k_c</script> 的模糊集，查询的模糊集 <script type="math/tex">D_q</script> 可以从下图理解：<br><a href="https://file.shivakasu.cn/3d166e41cb81bea90ac8/mir2-7.png" data-fancybox="group" data-caption="mir2-7" class="fancybox"><img alt="mir2-7" data-src="https://file.shivakasu.cn/3d166e41cb81bea90ac8/mir2-7.png" class="lazyload" title="mir2-7"></a><br>其中， <script type="math/tex">cc_1=\mu_{a,j}\mu_{b,j}\mu_{c,j}</script> 、 <script type="math/tex">cc_2=\mu_{a,j}\mu_{b,j}(1-\mu_{c,j})</script> 、 <script type="math/tex">cc_3=\mu_{a,j}(1-\mu_{b,j})(1-\mu_{c,j})</script> ，则：</p><script type="math/tex; mode=display">\mu_{q,j}=1-\prod_{i=1}^3(1-cc_i)</script><p>同样，采用代数和的方式计算而不是对所有相关性使用 <script type="math/tex">max</script> 函数，可以使<script type="math/tex">\mu_{q,j}</script> 的值变得平滑。</p><h2 id="4-其他代数模型"><a href="#4-其他代数模型" class="headerlink" title="4 其他代数模型"></a>4 其他代数模型</h2><h3 id="4-1-广义向量空间模型"><a href="#4-1-广义向量空间模型" class="headerlink" title="4.1 广义向量空间模型"></a>4.1 广义向量空间模型</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 2：用户搜索界面</title>
    <link href="http://shivakasu.github.io/2019/01/19/mir1/"/>
    <id>http://shivakasu.github.io/2019/01/19/mir1/</id>
    <published>2019-01-19T09:26:20.000Z</published>
    <updated>2020-01-10T04:09:24.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="人们如何搜索"><a href="#人们如何搜索" class="headerlink" title="人们如何搜索"></a>人们如何搜索</h3><ul><li><p>信息查找(information lookup)类似于事实检索或问题回答，只需要简短而离散的信息。</p></li><li><p>探索式搜索(exploratory search)分为学习和调查两类，需要花费更长的时间并整合更多内容。</p></li><li><p>信息搜寻过程是由一系列相互关联但又不完全相同的搜索所组成的，搜索带来的主要价值体现在搜索过程中持续的学习和所获得的信息，而不只是最后的搜索结果。</p></li><li><p>信息搜寻过程的经典模型：明确问题-&gt;表达信息需求-&gt;构造查询-&gt;评价结果。经典模型假设用户的信息需求是静态的，最近的模型强调搜索过程的动态性，认为用户会根据搜索结果动态调整信息需求，这种动态过程有时称为搜索的采摘模型(berry picking model)。例如，用户给出一个快速、不精确的查询，近似得到信息空间的一部分内容，再进行一系列本地导航操作，从而获得更贴近用户兴趣的信息。有些搜索模型关注搜索策略，对搜索策略建模，预测用户的搜索行为。</p></li><li><p>除了传统的搜索框查询，还可以使用导航界面，让用户通过浏览导航和点击链接搜寻信息。</p></li></ul><h3 id="现今的搜索界面"><a href="#现今的搜索界面" class="headerlink" title="现今的搜索界面"></a>现今的搜索界面</h3><ul><li><p>启动搜寻：通常使用Web搜索引擎。导航网站逐渐被淘汰，一是因为网络规模变大，无法手动构造目录，二是因为Web搜索的精度提高。</p></li><li><p>查询描述：解析查询项，Web排序</p></li><li><p>查询描述界面：搜索框placeholder提示，自动补全建议列表。根据用户搜索历史或其他用户的热门搜索。</p></li><li><p>检索结果显示：文档摘要，查询项高亮。</p></li><li><p>查询重构：拼写校对或建议，相关查询项推荐。</p></li><li><p>组织搜索结果：分类和聚类。区别在于是否需要人工组织层次结构。</p></li></ul><p>(这章真的是看不下去了，一个搜索界面说了这么多废话，太无聊了)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 1：引言</title>
    <link href="http://shivakasu.github.io/2019/01/18/mir0/"/>
    <id>http://shivakasu.github.io/2019/01/18/mir0/</id>
    <published>2019-01-18T08:36:26.000Z</published>
    <updated>2020-01-15T10:53:20.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>信息检索涉及对文档、网页、联机目录、结构化和半结构化记录及多媒体对象等信息项的表示、存储、组织和访问。信息项的表示和组织必须便于用户访问他们感兴趣的信息。</p></li><li><p>信息检索发展的关键阶段：书籍-&gt;图书馆-&gt;索引-&gt;计算机-&gt;排序技术和搜索引擎等现代研究内容</p></li><li><p>信息检索系统的主要目标是检出所有和用户查询相关的文档，并且把检出的不相关文档控制在最低限度。相关性的概念对信息检索至关重要。对相关性的评估没有固定标准，不存在能在任何时间给任何用户提供完美答案的检索系统。</p></li><li><p>检索任务可分为浏览和搜索，浏览是探索式检索，目标不太明确，搜索则相反。</p></li><li><p>信息检索系统的高层软件架构：<br><a href="https://file.shivakasu.cn/6ffe81624404da41f82a/mir0-0.png" data-fancybox="group" data-caption="mir0-0" class="fancybox"><img alt="mir0-0" data-src="https://file.shivakasu.cn/6ffe81624404da41f82a/mir0-0.png" class="lazyload" title="mir0-0"></a></p></li><li><p>文档的索引、检索和排序过程：<br><a href="https://file.shivakasu.cn/69f58a9d8db7b0682f6e/mir0-1.png" data-fancybox="group" data-caption="mir0-1" class="fancybox"><img alt="mir0-1" data-src="https://file.shivakasu.cn/69f58a9d8db7b0682f6e/mir0-1.png" class="lazyload" title="mir0-1"></a></p></li><li><p>Web流行的根源：出版自由。</p></li><li><p>Web对搜索的影响：网页爬取新技术，海量文档集和海量查询流量，相关性预测更复杂，从文字搜索转向结构化数据搜索，垃圾信息泛滥。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>解决 anaconda3 安装 xgboost：/usr/lib/libstdc++.so.6：version &#39;GLIBCXX_3.4.14&#39; not found问题</title>
    <link href="http://shivakasu.github.io/2017/07/01/bugfix0/"/>
    <id>http://shivakasu.github.io/2017/07/01/bugfix0/</id>
    <published>2017-07-01T15:00:20.000Z</published>
    <updated>2020-01-10T04:11:29.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda install libgcc</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
