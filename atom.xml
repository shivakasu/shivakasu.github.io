<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHIVAKASU</title>
  <icon>https://www.gravatar.com/avatar/db3726c77acefe0355d29843a28e9ca4</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shivakasu.github.io/"/>
  <updated>2020-01-15T16:03:34.716Z</updated>
  <id>http://shivakasu.github.io/</id>
  
  <author>
    <name>w.k.x.</name>
    <email>wkx1996@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Manacher 算法</title>
    <link href="http://shivakasu.github.io/2020/01/15/arg2/"/>
    <id>http://shivakasu.github.io/2020/01/15/arg2/</id>
    <published>2020-01-15T12:14:20.000Z</published>
    <updated>2020-01-15T16:03:34.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、算法背景"><a href="#一、算法背景" class="headerlink" title="一、算法背景"></a>一、算法背景</h1><p>Manacher算法，中文名马拉车算法，用以解决求字符串中的最长回文子串。传统的寻找最长回文子串的方法是从左到右遍历字符串的每个字符，同时以每个字符为回文中心向左右两侧扩散寻找，当字符串中存在大量回文子串，比如在极端情况下 $“aa…aa”$ ，算法的时间复杂度是 $O(N^2)$ 。而Manacher算法能够把寻找最长回文子串的时间复杂度降到 $O(N)$ 。</p><h1 id="二、字符串预处理"><a href="#二、字符串预处理" class="headerlink" title="二、字符串预处理"></a>二、字符串预处理</h1><p>假设要处理的字符串是 $“abbabb”$ ，由于回文串有奇回文和偶回文，比如 $“bab”$ 是奇回文， $“abba”$ 是偶回文，奇回文的对称轴是一个字符，偶回文的对称轴是两个字符，为了消除这种差异，首先要对字符串预处理，在每个字符的两侧都添加占位符，比如 $“\sharp”$ ，原来的字符串就变成了 $“\sharp a\sharp b\sharp b\sharp a\sharp b\sharp b\sharp ”$ 。对于其中的每个回文串，预处理相当于在每个字符的右侧添加占位符，变成偶回文，再在整体回文串的左侧添加一个占位符，变成奇回文。比如上述两个回文串变成了 $“\sharp b\sharp a\sharp b\sharp ”$ 和 $“\sharp a\sharp b\sharp b\sharp a\sharp ”$ ，长度分别是7和9，都是奇回文。</p><h1 id="二、计算最长回文子串半径"><a href="#二、计算最长回文子串半径" class="headerlink" title="二、计算最长回文子串半径"></a>二、计算最长回文子串半径</h1><p>除了对字符串的预处理，算法还需要一个辅助数组 $p$ ，设预处理后的字符串是 $arr$ ，则 $p[i]$ 表示以 $arr[i]$ 为回文中心的最大回文半径。由于所有回文串都是奇回文，所以回文半径可以表示为 $(回文串长度+1)\div 2$ ，也就是包含回文中心的回文串的一半。比如下表中， $p[3]=2$ 表示以 $arr[3]$ 为回文中心的最长回文子串是 $“\sharp b\sharp ”$ ，回文半径是2，即 $“\sharp b”$ 的长度。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i ：</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">arr：</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p ：</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><p>计算数组 $p$ 需要两个辅助变量， $maxright$ 表示遍历至此发现的回文串所能达到的最右边界， $center$ 表示到达最右边界的回文串的回文中心。当遍历到 $arr[i]$ 时，要计算的是以 $arr[i]$ 为回文中心的最大回文半径，由于 $center$ 和 $maxright$ 是当前已知的回文中心和回文边界，所以一定是在之前的步骤算出来的，所以必有 $center&lt;i&lt;maxright$ ，又因为 $arr[center..maxright]$ 是一个回文串的右半部分，所以在 $arr[0..center]$ 中必有 $i$ 的对称点，记为 $i’$ ，以及 $maxright$ 的对称点 $maxright’$ ，至此，可以确定以下数组下标的位置关系：</p><script type="math/tex; mode=display">maxright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow maxright</script><p>Manacher算法的核心就是利用之前步骤算出的 $p$ 数组的值来减少对字符串的遍历。在当前的步骤中就体现在根据 $p[i’]$ 值的情况优化计算 $p[i]$ 的过程，把以 $arr[i]$ 为回文中心的回文串的右边界记为 $iright$ ，关于 $center$ 的对称点记为 $iright’$ ，分为两种情况：</p><p>情况一：$p[i’]&lt;maxright-i$<br>$p[i’]$ 是 $i’$ 到 $iright’$ 的距离，$maxright-i$ 是 $i’$ 到 $maxright’$ 的距离，位置关系如下，</p><script type="math/tex; mode=display">maxright'\rightarrow iright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow iright\rightarrow maxright</script><p>说明以 $arr[i]$ 为回文中心的回文串被完全包含在以 $arr[center]$ 为回文中心的回文串中。必有 $p[i]=p[i’]$ </p><p>情况二：$p[i’]\geq maxright-i$<br>位置关系如下，</p><script type="math/tex; mode=display">iright'\rightarrow maxright'\rightarrow i'\rightarrow center\rightarrow i \rightarrow maxright\rightarrow iright</script><p>说明以 $arr[i]$ 为回文中心的最大回文半径至少是 $maxright-i$ ，而 $maxright’$ 左侧与 $maxright$ 右侧的字符是否匹配还不知道，因为 $maxright$ 就是当前遍历到的最右边界，再右边的字符还没遍历到，所以此时可以把 $maxright’$ 和 $maxright$ 当做左右边界向外扩散匹配，而回文中心 $i$ 到 $maxright$ 之间的字符就不必判断了，因为 $p[i’]$ 保证了这一段一定是能匹配成功的。</p><p>一句话总结， $p$ 数组的计算过程就是利用算过的 $p$ 数组的值优化左右扩散匹配。</p><h1 id="三、最长回文子串起始坐标"><a href="#三、最长回文子串起始坐标" class="headerlink" title="三、最长回文子串起始坐标"></a>三、最长回文子串起始坐标</h1><p>算好了数组 $p$ ，其中最大的值就是最长回文子串的半径，但这里得到的长度和坐标都是基于预处理后的字符串 $arr$ ，获取最长回文子串需要知道他在原字符串 $str$ 里的起始点和半径。</p><div class="table-container"><table><thead><tr><th style="text-align:center">i ：</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">arr：</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">a</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td><td style="text-align:center">b</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">p ：</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">str：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td></tr></tbody></table></div><p>在上图的例子中，基于 $arr$ 得到的回文中心是 $arr[7]$ ，回文半径是 $p[7]=6$ ，而在目标字符串中需要找到的回文串是 $str[1..5]$ 。</p><p>回文串在原字符串中的起始坐标是 $index=(i-p[i])\div 2$ ，其中 $i-p[i]$ 是 $arr$ 起点到回文串左边界的距离，在例子中就是 $“\sharp a”$ 这一段，由于最大回文字符串的首尾一定是占位符，所以从 $arr$ 起点到回文左边界这一段中的每个字符只有左侧有占位符，也就是说字符和占位符的数量是相同的，所以式子最后要除以2，才能得到其中所有有效字符的数量，这个去除了占位符的长度就是原字符串 $str$ 中起点到回文左边界的距离。</p><p>$str$ 中的回文半径也容易计算。如果 $arr$ 中的回文中心是有效字符，说明这个回文串预处理前是奇回文，回文串的左半部分中每个字符的左侧都有一个占位符，在例子里也就是 $“\sharp b\sharp b\sharp a”$ ，这时真实的回文半径就是 $p[i]\div 2$ 。如果 $arr$ 中的回文中心是占位符，说明这个回文串预处理前是偶回文，回文串的左半部分中每个字符的左侧都有一个占位符，同时多了回文中心上的一个占位符，这时真实的回文半径就是 $(p[i]-1)\div 2$ 。</p><p>Manacher算法的 $O(N)$ 时间复杂度可以理解成 $maxright$ 从 $arr$ 起点移动到终点的过程， $maxright$ 左侧的字符都是不必重复匹配的，右侧随着匹配过程不断更新 $maxright$ 的位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="http://shivakasu.github.io/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法总结</title>
    <link href="http://shivakasu.github.io/2020/01/11/arg1/"/>
    <id>http://shivakasu.github.io/2020/01/11/arg1/</id>
    <published>2020-01-11T10:41:20.000Z</published>
    <updated>2020-01-15T15:50:41.541Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>输入原字符串(String)和子串(Pattern)，找到子串在原字符串中第一次出现的位置，两个字符串分别命名为 $s$ 和 $p$</p><h1 id="二、暴力检索"><a href="#二、暴力检索" class="headerlink" title="二、暴力检索"></a>二、暴力检索</h1><p>暴力检索(Brute Force)是最简单的匹配方法，首先把 $s$ 和 $p$ 左端对齐，从两个字符串头部开始逐位匹配，匹配失败后将 $p$ 右移一位，从 $p$ 的头部和 $s$ 的对应位置重新匹配。</p><p>最坏情况下，假设 $s=“xx….xy”$ ，长度为 $N$ ， $p=“xx…xy”$ ，长度为 $M$ ，每次匹配都需要比较全部 $M$ 个字符，而只有最后一次匹配才能匹配成功，所以时间复杂度是 $O(M\times N)$</p><h1 id="三、KMP算法"><a href="#三、KMP算法" class="headerlink" title="三、KMP算法"></a>三、KMP算法</h1><p>KMP算法全称是Knuth-Morris-Pratt字符串查找算法，算法的核心思想是利用最大相同前缀后缀长度来减少匹配次数。例如 $ABCAB$ 的前缀有 $A$ 、 $AB$ 、 $ABC$ 、 $ABCA$ 四个，后缀有 $B$ 、 $AB$ 、 $CAB$ 、 $BCAB$ 四个，那么他的最大相同前缀后缀就是 $AB$ ，最大相同前缀后缀长度是2。所以对于字符串 $str[0..n]$ 来说，最大相同前缀后缀长度是 $k$ 就表示 $str[0..k-1]=str[n-k+1..n]$ 但 $str[k]\neq str[n-k]$ </p><p>先默认已经有了记录子串 $p$ 最大相同前缀后缀长度的数组 $F$ ， $F[k]$ 就是 $p[0..k]$ 的最大相同前缀后缀长度。借用<a href="https://www.cnblogs.com/SYCstudio/p/7194315.html" target="_blank" rel="noopener">某篇博客</a>里的例子，</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr></tbody></table></div><p>对于 $p=”abaabbabaab”$ ， $F=[0,0,1,1,2,0,1,2,3,4,5]$</p><p>$i$ 表示 $s$ 的下标， $j$ 表示 $p$ 的下标，第一次匹配如下， $s[5]$ 和 $p[5]$ 匹配失败。查询 $F[5-1]$ ，发现 $F[4]=2$ ，说明 $p[0..4]$ 的前两位和最后两位能够匹配上，又因为 $p[0..4]=s[0..4]$ ，下次匹配子串 $p$ 就不必只后移一位，可以直接让 $p[0..1]$ 和 $s[3..4]$ 对齐，因为最大相同前缀后缀长度是2就说明当 $p[0..1]$ 和 $s[3..4]$ 之前的位置对齐时，最多能匹配两位，在第三位之前一定会匹配失败。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第二次匹配如下，发现 $s[13]$ 和 $p[10]$ 匹配失败，查询得到 $F[9]=4$ ，所以下次直接让 $p[0..3]$ 和 $s[9..12]$ 对齐</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第三次匹配如下，发现 $s[13]$ 和 $p[4]$ 匹配失败，查询得到 $F[3]=1$ ， 所以下次直接让 $p[0]$ 和 $s[12]$ 对齐</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第四次匹配如下，发现 $s[13]$ 和 $p[1]$ 匹配失败，查询得到 $F[0]=0$ ， 所以下次只能老老实实把 $p$ 右移一位</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>第五次匹配如下，匹配成功</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td></tr></tbody></table></div><p>还剩一个问题是如何预先求解数组 $F$ ，一种简单的方法是用两个指针 $i$、$j$ 错位遍历子串 $p$ 。初始化 $i=1$ 、 $j=0$ ，指针 $i$ 用于主循环，每当 $p[i]=p[j]$ 时，指针 $j$ 才加一，如果 $p[i]\neq p[j]$ 就把 $j$ 打回原位 $j=0$ ， $i$ 遍历的同时能够确定 $F[i]$ ，时间复杂度为 $O(N)$ ，随便用python写了一下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">while i&lt;len(a):</span><br><span class="line">    if a[i]!&#x3D;a[j]:</span><br><span class="line">        if j&#x3D;&#x3D;0:</span><br><span class="line">            b.append(0)</span><br><span class="line">        else:</span><br><span class="line">            if a[i]&#x3D;&#x3D;a[0]:</span><br><span class="line">                j&#x3D;1</span><br><span class="line">                b.append(1)</span><br><span class="line">            else:</span><br><span class="line">                j&#x3D;0</span><br><span class="line">                b.append(0)</span><br><span class="line">    else:</span><br><span class="line">        b.append(b[-1]+1)</span><br><span class="line">        j+&#x3D;1</span><br><span class="line">    i+&#x3D;1</span><br></pre></td></tr></table></figure></div><p>KMP算法的确能够减少匹配次数，一般认为其时间复杂度是 $O(M+N)$ ，但是极端情况下时间复杂度依然可以是 $O(M\times N)$ ，一种情况是子串的 $F$ 数组都是0时，完全用不到 $F$ ，就退化成了暴力检索，另一种情况是 $p=“aa…aa”$ ，最大相同前缀后缀分别就是 $p[0,i-1]$ 和 $p[1,i]$ ，利用 $F$ 数组就相当于只后移一位。</p><h1 id="三、RK算法"><a href="#三、RK算法" class="headerlink" title="三、RK算法"></a>三、RK算法</h1><p>RK算法全称Rabin-Karp字符串匹配算法，核心思想是利用字符串的哈希值比较替代逐字符匹配，因为一个足够好的哈希函数能够把不同的字符串映射到不同的哈希值，而把相同的字符串映射到相同的哈希值。对于一个 $N$ 位的字符串 $s$ 和一个 $M$ 位的模式串 $p$ ，依次计算 $s[0..M-1]$ 、 $s[M..2M-1]$ 、… 、 $s[N-M+1..N]$ 的哈希值，并与 $p$ 的哈希值进行比较。</p><p>由于哈希函数多少有一定的错误率，为了确保字符串匹配的准确度，当哈希值相同时，需要用传统的逐字符比较的方法进行验证，一般认为时间复杂度是 $O(M+N)$ ，但实际的时间复杂度与选择的哈希函数有很大关系，一个差的哈希函数也可以使时间复杂度趋近 $O(M\times N)$</p><h1 id="四、BM算法"><a href="#四、BM算法" class="headerlink" title="四、BM算法"></a>四、BM算法</h1><p>BM算法全称Boyer-Moore字符串搜索算法，与其他方法不同的是，BM算法从字符串尾部开始匹配，利用坏字符原则和好后缀原则优化模式串 $p$ 的移动距离。</p><p>坏字符原则：当匹配失败时， $s[i]\neq p[j]$ ，称 $s[i]$ 为坏字符。此时检查 $s[i]$ 是否出现在匹配失败位置的左侧，即 $p[0..j-1]$ 中是否存在 $p[k]$ 使得 $p[k]=s<a href="k&lt;j">i</a>$ ，如果存在一个或多个，选择其中最右的 $p[k]$ 与当前的 $s[i]$ 对齐，如果不存在，就把 $p[0..j-1]$ 全部移动到匹配失败位置后面，也就是把 $p[0]$ 和 $s[i+1]$ 对齐。</p><p>好后缀原则：当匹配失败时， $s[i]\neq p[j]$ ，此时检查模式串 $p$ 是否有后缀匹配成功，即 $p<a href="k&gt;j">k..m</a>$ 与 $s$ 的相应位置匹配成功，称这样的后缀为好后缀。如果不存在好后缀，就按照朴素方法把 $p$ 后移一位重新匹配。如果存在好后缀，首先检查最长的好后缀是否出现在匹配失败位置之前，即 $p[h..h+m-k]=p[k..m]$ ，如果出现了最长好后缀，就把 $p[h..h+m-k]$ 与当前的 $p[k..m]$ 对齐，如果没有出现，就按照由长到短的顺序依次检查其他好后缀，如果某个好后缀与 $p$ 的某个前缀相等，就把这对前缀后缀对齐。</p><p>匹配失败时，分别按照坏字符原则和好后缀原则计算模式串 $p$ 应该向后移动的距离，取二者的最大值作为实际移动距离。借用Moore教授提供的例子，</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr></tbody></table></div><p>第一次匹配如下，对子串 $p$ 从后往前检查，发现 $s[6]\neq p[6]$ 。根据坏字符原则，由于 $s[6]$ 没有在 $p[0..5]$ 中出现过，所以要把 $p[0..5]$ 全部移到坏字符 $s[6]$ 后面，也就是把 $p[0]$ 和 $s[7]$ 对齐，移动距离是7。根据好后缀原则，由于没有好后缀，只能按照朴素方法把 $p$ 后移一位。相比之下，坏字符原则确定的后移距离更长，所以移动距离是7。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第二次匹配如下，从后往前检查，发现 $s[13]\neq p[6]$ 。根据坏字符原则，由于 $s[13]=p[4]$ ，所以要把 $p[4]$ 和 $s[13]$ 对齐，移动距离是2。根据好后缀原则，由于没有好后缀，只能按照朴素方法把 $p$ 后移一位。相比之下，坏字符原则确定的后移距离更长，所以移动距离是2。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第三次匹配如下，从后往前检查，发现 $s[11]\neq p[2]$ 。根据坏字符原则，由于 $s[11]$ 没有在 $p[0..1]$ 中出现过，所以要把 $p[0..1]$ 全部移到坏字符 $s[11]$ 后面，也就是把 $p[0]$ 和 $s[12]$ 对齐，移动距离是3。根据好后缀原则，发现匹配到 $“mple”$ 、 $“ple”$ 、 $“le”$ 、 $“e”$ 四个好后缀，首先检查最长的好后缀 $“mple”$ 是否出现在匹配失败位置的左侧，发现不存在，然后依次检查其他好后缀是否匹配到子串 $p$ 的前缀，发现 $“e”$ 能够匹配到 $p$ 的前缀，所以把两个 $“e”$ 对齐，也就是把 $p[0]$ 和 $s[15]$ 对齐，移动距离是6。相比之下，好后缀原则确定的后移距离更长，所以移动距离是6。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第四次匹配如下，从后往前检查，发现 $s[21]\neq p[6]$ 。根据坏字符原则， $s[21]=p[4]$ ，所以应该把 $p[4]$ 和 $s[21]$ 对齐，移动距离是2。根据好后缀原则，由于没有好后缀，只能按照朴素方法把 $p$ 后移一位。相比之下，坏字符原则确定的后移距离更长，所以移动距离是2。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>第五次匹配如下，匹配成功</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th><th style="text-align:center">21</th><th style="text-align:center">22</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">h</td><td style="text-align:center">e</td><td style="text-align:center">r</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">i</td><td style="text-align:center">s</td><td style="text-align:center"></td><td style="text-align:center">a</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">i</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">e</td><td style="text-align:center">x</td><td style="text-align:center">a</td><td style="text-align:center">m</td><td style="text-align:center">p</td><td style="text-align:center">l</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table></div><p>BM算法是不稳定的贪心算法，最好情况下时间复杂度 $O(N\div M)$ ，最差情况下时间复杂度为 $O(M\times N)$ 。<a href="http://ddrv.cn/a/55208" target="_blank" rel="noopener">某篇文章</a>里对BF、KMP、BM三种算法进行了测试对比，结果表明匹配花费的时间 $BM&lt;BF&lt;KMP$ ，可见KMP只是理论上的优化，实际使用时很难遇到较多的相同前缀后缀，对此复杂的优化操作就变得多余，导致算法效率甚至不如暴力检索。</p><h1 id="五、Horspool-算法"><a href="#五、Horspool-算法" class="headerlink" title="五、Horspool 算法"></a>五、Horspool 算法</h1><p>就是BM算法中的坏字符原则</p><h1 id="六、Sunday-算法"><a href="#六、Sunday-算法" class="headerlink" title="六、Sunday 算法"></a>六、Sunday 算法</h1><p>Sunday 算法从左到右匹配，但每次匹配失败后查看 $s$ 中参与匹配的最后一个字符的下一个字符，在 $p$ 中查找是否存在该字符，也就是当 $p[M-1]$ 与 $s[k]$ 对齐时，查看 $s[k+1]$ 是否在 $p$ 中出现。如果出现一次或多次，把最右的一个与 $s[k+1]$ 对齐，如果没有出现，就把 $p[0]$ 和 $s[k+2]$ 对齐，相当于整个子串跳过 $s[k+1]$ ，举例说明，</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr></tbody></table></div><p>第一次匹配如下，从左到右检查，发现 $s[1]\neq p[1]$ ，此时查看 $p[5]$ 所对应的 $s$ 中的字符的下一个字符，也就是 $s[6]$ 是否出现在 $p$ 中，结果是没有出现，所以直接把 $p[0]$ 和 $s[7]$ 对齐。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table></div><p>第二次匹配如下，从左到右检查，发现 $s[7]\neq p[0]$ ，此时查看 $s[13]$ 是否出现在 $p$ 中，结果 $s[13]=p[3]$，所以把 $p[3]$ 和 $s[13]$ 对齐。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table></div><p>第三次匹配如下，匹配成功。</p><style> table { font-size: 12px; } </style><div class="table-container"><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th></tr></thead><tbody><tr><td style="text-align:center">s：</td><td style="text-align:center">s</td><td style="text-align:center">u</td><td style="text-align:center">b</td><td style="text-align:center">s</td><td style="text-align:center">t</td><td style="text-align:center">r</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td><td style="text-align:center">i</td><td style="text-align:center">n</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">p：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">s</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">r</td><td style="text-align:center">c</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table></div><p>Sunday算法类似于BM算法，是不稳定的贪心算法，时间复杂度也和BM算法一样，最好情况下时间复杂度 $O(N\div M)$ ，最差情况下时间复杂度为 $O(M\times N)$ 。二者的思路都是在匹配失败时从尾部入手，便于找到一个相对较远的位置，把模式串移动到该位置，同时保证移动到左侧的任何位置时都无法匹配成功，从而有效减少了匹配次数。</p><h1 id="七、AC自动机"><a href="#七、AC自动机" class="headerlink" title="七、AC自动机"></a>七、AC自动机</h1><p>AC自动机全称Aho–Corasick算法，是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法。传统的字符串匹配算法只能同时搜索一个子串 $p$ ，在多模式串匹配任务中只能针对每个子串 $p$ 分别从头到尾扫描一遍母串，效率非常低。AC自动机针使用了Trie树存储所有的子串，树的每个节点表示一个字符，以遍历节点的方式匹配母串，每当匹配失败时，转向当前节点的Fail节点继续匹配，母串也可以从当前位置继续向后匹配而不需要返回头部，如此可以实现只遍历母串一次来匹配所有的子串。以下例子转自<a href="https://www.jianshu.com/p/2ad417a184fd" target="_blank" rel="noopener">别人的转自</a>，</p><p>假设子串集合为 $p={she,he,say,her,shr}$ ，母串是 $yasherhs$ 。首先根据子串的集合构造Trie树(过程简单直接略过)，结果如下。</p><p><a href="https://file.shivakasu.cn/364f6662c4b968167ac6/arg1-0.png" data-fancybox="group" data-caption="Trie树" class="fancybox"><img alt="Trie树" title="Trie树" data-src="https://file.shivakasu.cn/364f6662c4b968167ac6/arg1-0.png" class="lazyload"></a></p><p>注意需要为节点添加一个指针属性，在Trie树构建完毕后，将每个节点的该指针指向他的Fail节点，设置好Fail节点的Trie树如下。假设节点 $i$ 的Fail节点是节点 $j$ ，从根节点到节点 $i$ 的字符串记为 $word[i]$ ，从根节点到节点 $j$ 的字符串记为 $word[j]$ ，那么Fail节点的含义就是 $word[j]$ 是 $word[i]$ 在树中以根节点为起点的最长后缀。例如图中右侧 $she$ 的 $e$ 节点的Fail节点是左侧 $he$ 的 $e$ 节点，表示 $he$ 是 $she$ 在树中的最长后缀。</p><p><a href="https://file.shivakasu.cn/bfcf8fb05a570058e756/arg1-1.png" data-fancybox="group" data-caption="带Fail指针的Trie树" class="fancybox"><img alt="带Fail指针的Trie树" title="带Fail指针的Trie树" data-src="https://file.shivakasu.cn/bfcf8fb05a570058e756/arg1-1.png" class="lazyload"></a></p><p>Fail节点的设置只需要遵循一个原则，一个节点 $i$ 的Fail指针指向他父节点的Fail节点的与 $i$ 同名的子节点。这里涉及了四个节点，举例来说，为图中最右的 $h$ 节点指定Fail节点，他的父节点是 $s$ ， $s$ 的Fail指针指向根节点，根节点的孩子中存在与 $h$ 同名的节点，也就是最左的 $h$ 节点，所以最右的 $h$ 节点的Fail指针应该指向最左的 $h$ 节点。如果不存在这样的节点，就把Fail指针指向根节点，比如图中两个 $r$ 节点。此外，根节点不需要设置Fail指针。在这个过程中，回溯父节点的步骤可以通过递归实现，遍历到子节点的同时把父节点的Fail指针传递给子节点。</p><p>母串 $yasherhs$ 的匹配过程：<br>第一步，当前节点是根节点，查找字符是 $y$ ，发现根节点没有为 $y$ 的子节点，又因为根节点没有Fail节点，所以留在原地，母串索引加一。<br>第二步，当前节点是根节点，查找字符是 $a$ ，发现根节点没有为 $a$ 的子节点，又因为根节点没有Fail节点，所以留在原地，母串索引加一。<br>第三步，当前节点是根节点，查找字符是 $s$ ，因此转到根节点的右子节点 $s$ ，匹配成功，母串索引加一。<br>第四步，当前节点是 $s$ ，查找字符是 $h$ ，因此转到根节点的右子节点 $h$ ，匹配成功，母串索引加一。<br>第五步，当前节点是 $h$ ，查找字符是 $e$ ，因此转到根节点的左子节点 $e$ ，该节点同时是词尾节点，说明子串 $she$ 匹配成功，母串索引加一。<br>第六步，当前节点是 $e$ ，查找字符是 $r$ ，因为当前节点没有子节点，匹配失败，转向他的Fail节点，也就是左侧的 $e$ 节点，发现该节点是词尾节点，说明子串 $he$ 匹配成功，同时该节点的子节点包含目标字符 $r$ ，因此转向左子节点 $r$ ，发现节点 $r$ 也是词尾节点，说明子串 $her$ 匹配成功。母串索引加一。<br>第七步，当前节点是 $r$ ，查找字符是 $h$ ，因为当前节点没有子节点，匹配失败，转向他的Fail节点，也就是根节点，根节点的子节点包含目标字符 $h$ ，因此转向左侧的节点 $h$ ，母串索引加一。<br>第八步，当前节点是 $h$ ，查找字符是 $s$ ，因为当前节点的子节点没有 $s$ ，匹配失败，转向他的Fail节点，也就是根节点，根节点的子节点包含目标字符 $s$ ，因此转向右侧的节点 $s$ ，母串索引到头了，匹配结束。</p><p>整个匹配过程中，母串仅遍历了一次，匹配了多个子串，大大提高了匹配效率。Fail指针的合理性在于指向以根节点为起点的最长后缀，一方面，以根节点为起始说明这个后缀同时也是某个子串的前缀，从Fail节点开始匹配就相当于在默认匹配了某个子串前缀的条件下，从该子串的中间继续匹配。另一方面，指向最长后缀能够保证不会漏掉能够匹配到子串的有效后缀，假如一个节点有两个有效后缀，一定是该节点的Fail指针指向最长后缀，最长后缀的Fail指针指向次长后缀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="日常专业学习" scheme="http://shivakasu.github.io/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《程序员代码面试指南》阅后简记</title>
    <link href="http://shivakasu.github.io/2020/01/10/arg0/"/>
    <id>http://shivakasu.github.io/2020/01/10/arg0/</id>
    <published>2020-01-09T16:43:20.000Z</published>
    <updated>2020-01-10T04:23:40.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-栈和队列"><a href="#第一章-栈和队列" class="headerlink" title="第一章 栈和队列"></a>第一章 栈和队列</h1><h2 id="1-1-getmin-栈"><a href="#1-1-getmin-栈" class="headerlink" title="1.1  $getmin$ 栈"></a>1.1  $getmin$ 栈</h2><p>用两个栈， $A$ 正常使用， $B$ 在 $A$ 的 $push$ 和 $pop$ 时保持栈顶是 $A$ 的最小值</p><h2 id="1-2-两个栈组成队列"><a href="#1-2-两个栈组成队列" class="headerlink" title="1.2 两个栈组成队列"></a>1.2 两个栈组成队列</h2><p>两个栈方向相反， $A$ 压栈代表入队， $B$ 退栈代表出队，当 $B$ 为空时，把 $A$ 反向导入 $B$ </p><p>问题是不能保证出队 $O(1)$ ？</p><h2 id="1-3-用递归函数和栈逆序一个栈"><a href="#1-3-用递归函数和栈逆序一个栈" class="headerlink" title="1.3 用递归函数和栈逆序一个栈"></a>1.3 用递归函数和栈逆序一个栈</h2><p>两个递归函数， $A$ 递归 $pop$ 栈中所有元素，返回最后一个元素，再把剩下的 $push$ 回去。 $B$ 递归调用 $A$ ，把 $A$ 返回的 $push$ 回去</p><h2 id="1-4-猫狗队列"><a href="#1-4-猫狗队列" class="headerlink" title="1.4 猫狗队列"></a>1.4 猫狗队列</h2><p>一个队列存猫，一个队列存狗，一个数组用01标注存放顺序</p><h2 id="1-5-用一个栈实现另一个栈的排序"><a href="#1-5-用一个栈实现另一个栈的排序" class="headerlink" title="1.5 用一个栈实现另一个栈的排序"></a>1.5 用一个栈实现另一个栈的排序</h2><p>把A栈的依次 $pop$ ，如果比B栈顶大就 $push$ 到 $B$ ，否则把 $B$ $pop$ 并 $push$ 回 $A$ 直到比 $B$ 栈顶大，核心就是利用两个栈来回倒，用一个临时变量做插入排序</p><h2 id="1-6-用栈求解汉诺塔"><a href="#1-6-用栈求解汉诺塔" class="headerlink" title="1.6 用栈求解汉诺塔"></a>1.6 用栈求解汉诺塔</h2><p>递归思路：把 $1\sim N$ 从左移动到右，相当于把 $1\sim(N-1)$ 从左移动到中，再把 $N$ 从左移动到右，再把 $1\sim(N-1)$ 从中移动到右</p><p><span id="jump"></span></p><h2 id="1-7-生成窗口最大值数组"><a href="#1-7-生成窗口最大值数组" class="headerlink" title="1.7 生成窗口最大值数组"></a>1.7 生成窗口最大值数组</h2><p>维护一个最大长度为 $k$ 的队列，保证队头是当前位置往前 $k$ 个数的从大到小的下标，遇到较大值就弃掉前边比他小的</p><h2 id="1-8-maxtree"><a href="#1-8-maxtree" class="headerlink" title="1.8 maxtree"></a>1.8 maxtree</h2><p>对每一个元素，从左边和右边各选择第一个比这个元素大的值，选择值较小的元素作为父节点。证明过程就是先证明结果只有一棵树，再证明数组里每个元素在左右两侧最多分别有一个孩子</p><h2 id="1-9-最大子矩阵"><a href="#1-9-最大子矩阵" class="headerlink" title="1.9 最大子矩阵"></a>1.9 最大子矩阵</h2><p>以每一行为底，算出每行的纵向向上连续高度，根据高度差找最大矩阵</p><h2 id="1-10-最大值减最小值小于等于-num-的子数组数量"><a href="#1-10-最大值减最小值小于等于-num-的子数组数量" class="headerlink" title="1.10 最大值减最小值小于等于 $num$ 的子数组数量"></a>1.10 最大值减最小值小于等于 $num$ 的子数组数量</h2><p>仿照 <a href="#jump">1.7</a> 维护两个队列，分别存储最大值和最小值的下标，若 $a[i,j]$ 满足/不满足条件，她的所有子数组也满足/不满足条件，因此只需要两个 $flag$ 遍历数组， $j$ 向后遍历，遇到不满足的就让 $i+1$ ，再接着遍历 $j$ </p><h1 id="第二章-链表问题"><a href="#第二章-链表问题" class="headerlink" title="第二章 链表问题"></a>第二章 链表问题</h1><h2 id="2-1-打印两个有序链表的公共部分"><a href="#2-1-打印两个有序链表的公共部分" class="headerlink" title="2.1 打印两个有序链表的公共部分"></a>2.1 打印两个有序链表的公共部分</h2><p>因为是有序的，所以就交错遍历，遇到相等就打印</p><h2 id="2-2-在单链表和双向链表中删除倒数第k个节点"><a href="#2-2-在单链表和双向链表中删除倒数第k个节点" class="headerlink" title="2.2 在单链表和双向链表中删除倒数第k个节点"></a>2.2 在单链表和双向链表中删除倒数第k个节点</h2><p>遍历两次</p><h2 id="2-3-删除链表的中间节点"><a href="#2-3-删除链表的中间节点" class="headerlink" title="2.3 删除链表的中间节点"></a>2.3 删除链表的中间节点</h2><p>立个 $flag$ 表示中点，一边遍历一边移动 $flag$ </p><p><span id="jump2"></span></p><h2 id="2-4-反转单向和双向链表"><a href="#2-4-反转单向和双向链表" class="headerlink" title="2.4 反转单向和双向链表"></a>2.4 反转单向和双向链表</h2><p>维护三个指针，每次反转一条边</p><h2 id="2-5-反转部分单向链表"><a href="#2-5-反转部分单向链表" class="headerlink" title="2.5 反转部分单向链表"></a>2.5 反转部分单向链表</h2><p>把中间那段提出来仿照 <a href="#jump2">2.4</a> 反转，再反过来拼接上</p><h2 id="2-6-环形链表的约瑟夫问题"><a href="#2-6-环形链表的约瑟夫问题" class="headerlink" title="2.6 环形链表的约瑟夫问题"></a>2.6 环形链表的约瑟夫问题</h2><p>简单版：模拟过程转圈找   </p><p>进阶版：总结出递归表达式提前算出答案</p><h2 id="2-7-判断链表是否回文"><a href="#2-7-判断链表是否回文" class="headerlink" title="2.7 判断链表是否回文"></a>2.7 判断链表是否回文</h2><p>简单版：遍历两次，空间 $O(N)$   </p><p>进阶版：反转后半部分指向中间节点，从两头同时遍历，空间 $O(1)$ </p><h2 id="2-8-单链表划分成左边小中间相等右边大"><a href="#2-8-单链表划分成左边小中间相等右边大" class="headerlink" title="2.8 单链表划分成左边小中间相等右边大"></a>2.8 单链表划分成左边小中间相等右边大</h2><p>遍历一遍，把链表拆成三段，再把三段拼起来，因为是对原链表的指针操作，所以空间 $O(1)$ </p><h2 id="2-9-复制含有随机指针节点的链表"><a href="#2-9-复制含有随机指针节点的链表" class="headerlink" title="2.9 复制含有随机指针节点的链表"></a>2.9 复制含有随机指针节点的链表</h2><p>简单版：遍历两次，使用哈希表确定节点 </p><p>进阶版：遍历两次，第一次在每个节点后边生成复制节点，第二次复制连接，最后分离原始链表和复制链表，不必使用额外数据结构</p><h2 id="2-10-两个单链表模拟整数相加"><a href="#2-10-两个单链表模拟整数相加" class="headerlink" title="2.10 两个单链表模拟整数相加"></a>2.10 两个单链表模拟整数相加</h2><p>用栈或反转链表，目的是实现低位到高位的计算</p><h2 id="2-11-一个链表是否有环"><a href="#2-11-一个链表是否有环" class="headerlink" title="2.11 一个链表是否有环"></a>2.11 一个链表是否有环</h2><p>快慢指针追逐法，第一次相遇后快指针变慢指针从头跑，两个慢指针会在入环点相遇</p><h2 id="2-12-两个无环链表是否相交"><a href="#2-12-两个无环链表是否相交" class="headerlink" title="2.12 两个无环链表是否相交"></a>2.12 两个无环链表是否相交</h2><p>因为是单链表，所以一旦相交，后续将合并成一个链表，因此只需要对比两个链表的尾结点</p><h2 id="2-13-两个有环链表是否相交"><a href="#2-13-两个有环链表是否相交" class="headerlink" title="2.13 两个有环链表是否相交"></a>2.13 两个有环链表是否相交</h2><p>找到两个入环点，追逐法判断是否是同一个环</p><h2 id="2-14-将单链表每k个节点之间逆序"><a href="#2-14-将单链表每k个节点之间逆序" class="headerlink" title="2.14 将单链表每k个节点之间逆序"></a>2.14 将单链表每k个节点之间逆序</h2><p>计数反转后拼接</p><h2 id="2-15-删除无序单链表中值重复的节点"><a href="#2-15-删除无序单链表中值重复的节点" class="headerlink" title="2.15 删除无序单链表中值重复的节点"></a>2.15 删除无序单链表中值重复的节点</h2><p>方法一：哈希表，遍历一遍，时间空间都是 $O(N)$   </p><p>方法二：从每个节点遍历一遍，时间 $O(N^2)$ ，空间 $O(1)$ </p><h2 id="2-16-单链表删除指定值的节点"><a href="#2-16-单链表删除指定值的节点" class="headerlink" title="2.16 单链表删除指定值的节点"></a>2.16 单链表删除指定值的节点</h2><p>直接遍历，时间 $O(N)$ ，空间 $O(1)$ </p><h2 id="2-17-二叉树转双向链表"><a href="#2-17-二叉树转双向链表" class="headerlink" title="2.17 二叉树转双向链表"></a>2.17 二叉树转双向链表</h2><p>用队列保存中序遍历，再依次出队重连</p><h2 id="2-18-单链表选择排序"><a href="#2-18-单链表选择排序" class="headerlink" title="2.18 单链表选择排序"></a>2.18 单链表选择排序</h2><p>时间 $O(N^2)$ ，空间 $O(1)$ </p><h2 id="2-19-怪异的节点删除方式"><a href="#2-19-怪异的节点删除方式" class="headerlink" title="2.19 怪异的节点删除方式"></a>2.19 怪异的节点删除方式</h2><p>要删除节点 $A$ ，可以先把 $A.next$ 的数据复制到 $A$ ，把 $A$ 指向 $A.next.next$ ，本质上只是复制数据，没有删除节点</p><h2 id="2-20-向有序环形单链表插入新节点"><a href="#2-20-向有序环形单链表插入新节点" class="headerlink" title="2.20 向有序环形单链表插入新节点"></a>2.20 向有序环形单链表插入新节点</h2><p>遍历，插入</p><h2 id="2-21-合并两个有序单链表"><a href="#2-21-合并两个有序单链表" class="headerlink" title="2.21 合并两个有序单链表"></a>2.21 合并两个有序单链表</h2><p>一个插到另一个里，时间 $O(M+N)$ ，空间 $O(1)$ </p><h2 id="2-22-按照左右半区重新组合单链表"><a href="#2-22-按照左右半区重新组合单链表" class="headerlink" title="2.22 按照左右半区重新组合单链表"></a>2.22 按照左右半区重新组合单链表</h2><p>提前知道链表长度，找到左右半区的头节点，交叉拼接</p><h1 id="第三章-二叉树问题"><a href="#第三章-二叉树问题" class="headerlink" title="第三章 二叉树问题"></a>第三章 二叉树问题</h1><h2 id="3-1-非递归二叉树先序遍历"><a href="#3-1-非递归二叉树先序遍历" class="headerlink" title="3.1 非递归二叉树先序遍历"></a>3.1 非递归二叉树先序遍历</h2><p>一个栈，压入头节点，[ 弹，右，左，弹 ] 循环</p><h2 id="3-2-非递归二叉树中序遍历"><a href="#3-2-非递归二叉树中序遍历" class="headerlink" title="3.2 非递归二叉树中序遍历"></a>3.2 非递归二叉树中序遍历</h2><p>一个栈，循环压左到 $null$ ，弹出栈顶节点并转到他的右节点，这两步循环</p><h2 id="3-3-非递归二叉树后序遍历"><a href="#3-3-非递归二叉树后序遍历" class="headerlink" title="3.3 非递归二叉树后序遍历"></a>3.3 非递归二叉树后序遍历</h2><p>两个栈， $A$ 栈中，弹，左，右循环，弹出到 $B$ 栈，最后 $B$ 全部弹出</p><h2 id="3-4-打印二叉树边界节点"><a href="#3-4-打印二叉树边界节点" class="headerlink" title="3.4 打印二叉树边界节点"></a>3.4 打印二叉树边界节点</h2><p>得到二叉树每层的左右边界：遍历得到树的高度 $h$ ，建立二维数组 $edge[h][2]$ ，递归先序遍历，数组第一位保存每层最先遍历到的节点，也就是左边界，每遍历到新的节点就更新数组的第二位，最终保存的就是右边界  </p><h2 id="3-5-直观打印二叉树"><a href="#3-5-直观打印二叉树" class="headerlink" title="3.5 直观打印二叉树"></a>3.5 直观打印二叉树</h2><p>右中左遍历并打印，因为纵向看，每一个节点都可以占单独的一列，无脑输出换行就行</p><h2 id="3-6-二叉树的序列化和反序列化"><a href="#3-6-二叉树的序列化和反序列化" class="headerlink" title="3.6 二叉树的序列化和反序列化"></a>3.6 二叉树的序列化和反序列化</h2><p>先序遍历+分隔符，把 $null$ 也记录下，方便计算子树在字符串中的范围。核心思想是用 $null$ 占位变成满二叉树，节点位置就可以计算了</p><h2 id="3-7-遍历二叉树的神级方法"><a href="#3-7-遍历二叉树的神级方法" class="headerlink" title="3.7 遍历二叉树的神级方法"></a>3.7 遍历二叉树的神级方法</h2><p>$Morris$ 遍历法，不使用递归和栈结构保存历史，让每个节点的左子树的最右节点指向该节点，核心思想是修改 $null$ 指针实现遍历时的回溯</p><h2 id="3-8-在二叉树中找到累加和为指定值的最长路径长度"><a href="#3-8-在二叉树中找到累加和为指定值的最长路径长度" class="headerlink" title="3.8 在二叉树中找到累加和为指定值的最长路径长度"></a>3.8 在二叉树中找到累加和为指定值的最长路径长度</h2><p>先序遍历二叉树，对每条路径应用 <a href="#jump5">8.11</a> 的方法，但是从左子树转到右子树时要把左子树在哈希表的记录删除，可以通过在哈希表记录节点的所在层次判断</p><h2 id="3-9-找到二叉树中的最大搜索二叉子树"><a href="#3-9-找到二叉树中的最大搜索二叉子树" class="headerlink" title="3.9 找到二叉树中的最大搜索二叉子树"></a>3.9 找到二叉树中的最大搜索二叉子树</h2><p>递归后序遍历，遍历完左右子树后，如果都是搜索二叉树，那么最大搜索二叉树要么是包括父节点的整棵树，要么是左右子树里节点多的那个，通过比较节点值可以确定</p><h2 id="3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构"><a href="#3-10-找到二叉树中符合搜索二叉树条件的最大拓扑结构" class="headerlink" title="3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构"></a>3.10 找到二叉树中符合搜索二叉树条件的最大拓扑结构</h2><p>自顶向下法：以每个节点为头节点往下找，满足条件就计数，时间 $O(N^2)$  </p><p>自底向上法：后序遍历，记录左右子树对父节点能贡献多少个满足条件的节点，空间 $O(N)$ ，根据树的形状，时间最优 $O(N)$ 最差 $O(NlogN)$ ，证明懒得看</p><h2 id="3-11-二叉树按层打印和-zigzag-打印"><a href="#3-11-二叉树按层打印和-zigzag-打印" class="headerlink" title="3.11 二叉树按层打印和 $zigzag$ 打印"></a>3.11 二叉树按层打印和 $zigzag$ 打印</h2><p>按层打印：使用队列，根据当前层的末尾标记出队，出队的时候把其子节点入队，入队同时更新标记下层的最后一个节点，也就是用两个末尾标记实现在队列里区分层次  </p><p>$zigzag$ 打印：双端队列，头进尾出和尾进头出交替进行</p><h2 id="3-12-调整搜索二叉树中两个错误节点"><a href="#3-12-调整搜索二叉树中两个错误节点" class="headerlink" title="3.12 调整搜索二叉树中两个错误节点"></a>3.12 调整搜索二叉树中两个错误节点</h2><p>中序遍历，如果降序一次，错的就是降序的两个节点，如果降序两次，错的是第一次的大节点和第二次的小节点。交换两个节点时要考虑各种连接情况</p><h2 id="3-13-判断-t1-树是否包含-t2-树全部的拓扑结构"><a href="#3-13-判断-t1-树是否包含-t2-树全部的拓扑结构" class="headerlink" title="3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构"></a>3.13 判断 $t1$ 树是否包含 $t2$ 树全部的拓扑结构</h2><p>把所有头节点与 $t2$ 相同的子树都匹配一遍，时间 $O(M\times N)$ </p><h2 id="3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树"><a href="#3-14-判断-t1-树中是否有与-t2-树拓扑结构完全相同的子树" class="headerlink" title="3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树"></a>3.14 判断 $t1$ 树中是否有与 $t2$ 树拓扑结构完全相同的子树</h2><p>方法一同上，方法二遍历成字符串，看 $t2$ 是不是 $t1$ 子串，时间 $O(M+N)$ </p><h2 id="3-15-判断二叉树是否是平衡二叉树"><a href="#3-15-判断二叉树是否是平衡二叉树" class="headerlink" title="3.15 判断二叉树是否是平衡二叉树"></a>3.15 判断二叉树是否是平衡二叉树</h2><p>后序遍历，记录遍历深度，递归检验左右子树是否是平衡二叉树</p><h2 id="3-16-根据后序数组重建搜索二叉树"><a href="#3-16-根据后序数组重建搜索二叉树" class="headerlink" title="3.16 根据后序数组重建搜索二叉树"></a>3.16 根据后序数组重建搜索二叉树</h2><p>后序遍历头节点都在末尾，比值确定前面左右子树分界</p><h2 id="3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树"><a href="#3-17-判断一颗二叉树是否是搜索二叉树和完全二叉树" class="headerlink" title="3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树"></a>3.17 判断一颗二叉树是否是搜索二叉树和完全二叉树</h2><p>搜索二叉树：中序遍历一遍   </p><p>完全二叉树：按层遍历，节点不够时判断是否时靠左排的叶节点</p><h2 id="3-18-通过有序数组生成平衡搜索二叉树"><a href="#3-18-通过有序数组生成平衡搜索二叉树" class="headerlink" title="3.18 通过有序数组生成平衡搜索二叉树"></a>3.18 通过有序数组生成平衡搜索二叉树</h2><p>数组中间的节点就是头节点，再递归处理左右子树</p><h2 id="3-19-在二叉树中找到一个节点中序遍历的后继节点"><a href="#3-19-在二叉树中找到一个节点中序遍历的后继节点" class="headerlink" title="3.19 在二叉树中找到一个节点中序遍历的后继节点"></a>3.19 在二叉树中找到一个节点中序遍历的后继节点</h2><p>先找右子树，再回溯父节点</p><h2 id="3-20-在二叉树中找到两个节点的最近公共祖先"><a href="#3-20-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="3.20 在二叉树中找到两个节点的最近公共祖先"></a>3.20 在二叉树中找到两个节点的最近公共祖先</h2><p>后序遍历，遍历左右子树后返回是否有目标节点，当左右子树都各找到一个目标节点是，当前节点就是最近祖先</p><h2 id="3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题"><a href="#3-21-Tarjan-算法与并查集解决二叉树节点最近公共祖先的批量查询问题" class="headerlink" title="3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题"></a>3.21  $Tarjan$ 算法与并查集解决二叉树节点最近公共祖先的批量查询问题</h2><p>单独写</p><h2 id="3-22-二叉树节点间的最大距离"><a href="#3-22-二叉树节点间的最大距离" class="headerlink" title="3.22 二叉树节点间的最大距离"></a>3.22 二叉树节点间的最大距离</h2><p>最大距离有三种可能：左子树最大距离，右子树最大距离，左子树深度+1+右子树深度。后序遍历一次，同时记录子树最大距离和深度，比值得出结果</p><h2 id="3-23-先中后序数组两两结合重构二叉树"><a href="#3-23-先中后序数组两两结合重构二叉树" class="headerlink" title="3.23 先中后序数组两两结合重构二叉树"></a>3.23 先中后序数组两两结合重构二叉树</h2><p>先后序数组根节点在两端，代入中序数组可以区分左右子树。  </p><p>只有先后序时，由于左右可以混淆，如果有任一节点只有一个子节点，都无法重构原二叉树，先序中根节点之后就是左子树根节点，后序数组中左子树根节点之前的就是左子树，因此利用先后序数组可以区分左右子树。</p><h2 id="3-24-通过先序和中序数组生成后序数组"><a href="#3-24-通过先序和中序数组生成后序数组" class="headerlink" title="3.24 通过先序和中序数组生成后序数组"></a>3.24 通过先序和中序数组生成后序数组</h2><p>用先序数组确定后序数组最右的值，再利用中序数组分离出左右子树的先中序数组，重复这两步，把后序数组从右到左填满</p><h2 id="3-25-统计和生成所有不同的二叉树"><a href="#3-25-统计和生成所有不同的二叉树" class="headerlink" title="3.25 统计和生成所有不同的二叉树"></a>3.25 统计和生成所有不同的二叉树</h2><p>中序遍历为 $1\sim N$ 的一定是搜索二叉树，找规律，如果 $i$ 是头节点，则左子树有 $i-1$ 个节点，右子树有 $N-i$ 个节点，所以 $num(N)=\sum_{i=1}^Nnum(i-1)*num(N-i)$ </p><h2 id="3-26-统计完全二叉树的节点数"><a href="#3-26-统计完全二叉树的节点数" class="headerlink" title="3.26 统计完全二叉树的节点数"></a>3.26 统计完全二叉树的节点数</h2><p>一直向左遍历可以得到树的深度，因为完全二叉树叶节点靠左排列，所以遍历一个节点的右子树的最左节点，得到右子树的深度，如果等于整个树的深度，说明左子树节点是满的，循环这个步骤遍历右子树，如果深度小于树的深度，说明在这个深度下右子树节点是满的，循环这个步骤遍历左子树</p><h1 id="第四章-递归和动态规划"><a href="#第四章-递归和动态规划" class="headerlink" title="第四章 递归和动态规划"></a>第四章 递归和动态规划</h1><p>优化思路：压缩空间，枚举简化</p><h2 id="4-1-求斐波那契第N项"><a href="#4-1-求斐波那契第N项" class="headerlink" title="4.1 求斐波那契第N项"></a>4.1 求斐波那契第N项</h2><p>递归向下算，时间 $O(2^N)$   </p><p>从左向右依次算每一项，时间 $O(N)$   </p><p>用通项公式直接算，时间 $O(logN)$   </p><h2 id="4-2-斐波那契求奶牛数量"><a href="#4-2-斐波那契求奶牛数量" class="headerlink" title="4.2 斐波那契求奶牛数量"></a>4.2 斐波那契求奶牛数量</h2><p>$C(n)=C(n-1)+C(n-3)$ ，上一年的都活下来，三年前出生的都生一头小的，状态矩阵是三阶的</p><p><span id="jump3"></span></p><h2 id="4-3-矩阵的最小路径和"><a href="#4-3-矩阵的最小路径和" class="headerlink" title="4.3 矩阵的最小路径和"></a>4.3 矩阵的最小路径和</h2><p>动态规划，从左上角算到右下角，时间空间都是 $O(M\times N)$ ，只维护一行(列)空间时，向右或向下滚动更新，可以把空间压缩到 $O(min(M,N))$ ，之所以不用维护两行(列)是因为从前到后更新就相当于维护了两行(列)<br>P.S.：一般动态规划问题都可以用压缩空间的优化方法</p><h2 id="4-4-换钱的最少货币数"><a href="#4-4-换钱的最少货币数" class="headerlink" title="4.4 换钱的最少货币数"></a>4.4 换钱的最少货币数</h2><p>货币无限+面值不重复：维护二维数组，货币种类数*目标钱数，数组元素表示使用前 $i$ 种货币组成 $j$ 钱数需要的最少张数，遍历到 $dp[i][j]$ 时，枚举所有可能的 $k\geq0$ ，选择使用 $k$ 张当前货币时，最少张数的子问题。   </p><p>货币仅一张+面值可重复：和上面一样，只用做一次选择就够了，不用遍历所有 $k$ 。</p><h2 id="4-5-换钱的方法数"><a href="#4-5-换钱的方法数" class="headerlink" title="4.5 换钱的方法数"></a>4.5 换钱的方法数</h2><p>暴力搜索： $i$ 张第一+ $j$ 张第二+ $k$ 张第三……，时间最差 $O(aim^N)$  </p><p>带记忆的暴力搜索：避免重复计算，时间 $O(N\times aim^2)$     </p><p>经典动态规划：和上题一样，把值换成方法数，时间 $O(N\times aim^2)$   </p><p>时间复杂度一样是因为记忆搜索和经典动态规划的本质都是避免重复计算   </p><p>优化的动态规划(上题也可以用)：枚举所有可能的 $k\geq0$ 可以分成两部分，不用和必用当前货币，不用就是 $dp[i-1][j]$ ，必用本质上是 $dp[i][j-当前货币值]$ ，所以枚举的过程可以省去。时间 $O(N\times aim)$ </p><h2 id="4-6-最长递增子序列"><a href="#4-6-最长递增子序列" class="headerlink" title="4.6 最长递增子序列"></a>4.6 最长递增子序列</h2><p>经典： $dp[i]$ 表示以 $arr[i]$ 结尾的最长递增子序列长度，枚举前面所有结尾比 $arr[i]$ 小的 $dp[k]$ ，最后根据 $arr$ 和 $dp$ 数组得出序列， $O(N^2)$   </p><p>优化：建立辅助数组，记录长度为k的递增子序列最小结尾数，把枚举转化为在此数组上二分查找， $O(NlogN)$ </p><h2 id="4-7-汉诺塔"><a href="#4-7-汉诺塔" class="headerlink" title="4.7 汉诺塔"></a>4.7 汉诺塔</h2><p>递归， $n-1$ 左右中， $1$ 左中右， $n-1$ 中左右，每次在两个柱子间移动要考虑第三个柱子是为了递归的时候变换柱子的位置</p><h2 id="4-8-判断给的状态是不是汉诺塔最优过程中的某个状态"><a href="#4-8-判断给的状态是不是汉诺塔最优过程中的某个状态" class="headerlink" title="4.8 判断给的状态是不是汉诺塔最优过程中的某个状态"></a>4.8 判断给的状态是不是汉诺塔最优过程中的某个状态</h2><p>通过 $n$ 的位置可以知道进行到三个步骤中的哪个，然后递归检查 $n-1$ ，最后一定能确定具体步骤</p><h2 id="4-9-最长公共子序列"><a href="#4-9-最长公共子序列" class="headerlink" title="4.9 最长公共子序列"></a>4.9 最长公共子序列</h2><p>$dp[i][j]$ 表示 $str1[:i]$ 与 $str2[:j]$ 的最长公共子序列长度，取值为 $max{dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1(当前两个字符相同时)}$ ，获取序列要从右下角回溯，选择了三个值的哪一个就移动到他的位置，如果选择了 $dp[i-1][j-1]+1$ 就把当前字符放进结果</p><h2 id="4-10-最长公共子串"><a href="#4-10-最长公共子串" class="headerlink" title="4.10 最长公共子串"></a>4.10 最长公共子串</h2><p>经典： $dp[i][j]$ 表示以 $str1[i]$ 与 $str2[j]$ 结尾的最长公共子串长度，要么是 $0$ ，要么是 $dp[i-1][j-1]+1$ ，根据最大的 $dp$ 值直接得到子串，空间 $O(M\times N)$   </p><p>压缩：由于 $dp[i][j]$ 只和左上角的值有关，可以从左上到右下按斜线更新，一次更新一个，空间 $O(1)$ </p><h2 id="4-11-最小编辑代价"><a href="#4-11-最小编辑代价" class="headerlink" title="4.11 最小编辑代价"></a>4.11 最小编辑代价</h2><p>$dp[i][j]$ 表示 $str1[0,i-1]$ 编辑成 $str2[0,j-1]$ 的最小代价，第一行和第一列是全添和全删，中间的 $dp[i][j]$ 有四种取值： $dp[i-1][j]+删$ ，表示删去 $str1[i-1]$ 后把 $str1[0,i-2]$ 编辑成 $str2[0,j-1]$ ， $dp[i][j-1]+添$ ，表示把 $str1[0,i-1]$ 编辑成 $str2[0,j-2]$ 后添加 $str2[j-1]$ ， $dp[i-1][j-1]+改$ ，表示把 $str1[0,i-2]$ 编辑成 $str2[0,j-2]$ 后修改最后一个字符， $dp[i-1][j-1]$ ，表示当前两个字符正好相等   </p><p>压缩：因为可取值太多，要维护两行(列)</p><h2 id="4-12-字符串的交错组成"><a href="#4-12-字符串的交错组成" class="headerlink" title="4.12 字符串的交错组成"></a>4.12 字符串的交错组成</h2><p>$dp[i][j]$ 表示 $aim[0,i+j-1]$ 能否被 $str1[0,i-1]$ 和 $str2[0,j-1]$ 交错组成，第一行和第一列就是和两个字符串单独比较，中间的 $dp[i][j]=true$ 有两种情况： $str1[i-1]=aim[i+j-1]$ 且 $dp[i-1][j]=true$ ， $str2[j-1]=aim[i+j-1]$ 且 $dp[i][j-1]=true$ ，其余情况都是 $false$ </p><h2 id="4-13-龙与地下城"><a href="#4-13-龙与地下城" class="headerlink" title="4.13 龙与地下城"></a>4.13 龙与地下城</h2><p>和 <a href="#jump3">4.3</a> 一样，求的是最大值</p><h2 id="4-14-数字字符串转换为字母组合的种数"><a href="#4-14-数字字符串转换为字母组合的种数" class="headerlink" title="4.14 数字字符串转换为字母组合的种数"></a>4.14 数字字符串转换为字母组合的种数</h2><p>$dp[i]$ 表示前 $k$ 位不可变时的组合数，从后往前算， $dp[N]=1$ ，当 $str[i+1]=0$ 时 $dp[i]=0$ ，当 $str[i,i+1]$ 可转换时， $dp[i]=dp[i+1]+dp[i+2]$ ，否则 $dp[i]=dp[i+1]$ </p><h2 id="4-15-表达式得到期望结果的组合种数"><a href="#4-15-表达式得到期望结果的组合种数" class="headerlink" title="4.15 表达式得到期望结果的组合种数"></a>4.15 表达式得到期望结果的组合种数</h2><p>表达式 $express$ 一定是数字符号交错组成的，每一个奇数位上的符号把式子分成两部分，维护两个 $dp$ 二维数组分别表示 $express[i,j]$ 为 $true$ 和 $false$ 的组合种数， $dp[0,N]=\sum op_k(dp[0,k],dp[k,N-1])$ ，相当于在每个符号做一次分割，这种大分割产生的两组括号是唯一的，所以不同分割下不会出现重复的情况</p><h2 id="4-16-排成一条线的纸牌博弈问题"><a href="#4-16-排成一条线的纸牌博弈问题" class="headerlink" title="4.16 排成一条线的纸牌博弈问题"></a>4.16 排成一条线的纸牌博弈问题</h2><p>维护两个二维 $dp$ ， $dp_1[i][j]$ 表示面对 $s[i,j]$ 先拿的人最终能得到多少分， $dp_2[i][j]$ 表示后拿的人最终能得到多少分，只剩一张牌时 $dp_1[k][k]=arr[k]$ ， $dp_2[k][k]=0$ ，从右下往左上算， $dp_1[i][j]$ 可取值有 $arr[i]+dp_2[i+1][j]$ 和 $arr[j]+dp_2[i][j-1]$ ， $dp_2[i][j]$ 可取值有 $dp_1[i+1][j]$ 和 $dp_1[i][j-1]$ ，时间 $O(N^2)$  </p><h2 id="4-17-跳跃问题"><a href="#4-17-跳跃问题" class="headerlink" title="4.17 跳跃问题"></a>4.17 跳跃问题</h2><p>从左到右遍历一遍，维护三个临时变量， $jump$ 表示步数， $cur$ 表示以当前为起点能去的最远处， $next$ 表示以遍历过程中的点为起点能去的最远处，当遍历到 $cur$ 时，把 $cur$ 更新成 $next$ ，同时 $jump+1$ </p><h2 id="4-18-数组中的最长连续序列"><a href="#4-18-数组中的最长连续序列" class="headerlink" title="4.18 数组中的最长连续序列"></a>4.18 数组中的最长连续序列</h2><p>每次遍历一个数，先使用哈希表去重，然后保存在一个列表里，当列表里出现连续对时，合并成表示范围的二元组 $(left,right)$ ，由于能查询哈希表，检测连续时不需要遍历列表，所以最终时间空间都是 $O(N)$ </p><h2 id="4-19-N-皇后问题"><a href="#4-19-N-皇后问题" class="headerlink" title="4.19  $N$ 皇后问题"></a>4.19  $N$ 皇后问题</h2><p>暴力搜索：为减小空间复杂度，递归函数维护一维数组， $record[i]$ 表示第 $i$ 行放置的列数，遍历 $N$ 个列时实时检查该列能不能放</p><p>优化：利用位运算加速，用两个 $N$ 位二进制数表示当前哪些位置受列和斜线的影响不能放置，其实只加速了检查的操作</p><h1 id="第五章-字符串问题"><a href="#第五章-字符串问题" class="headerlink" title="第五章 字符串问题"></a>第五章 字符串问题</h1><p>子串是连续的，子序列是可以分散的</p><h2 id="5-1-判断两个字符串是否互为变形词"><a href="#5-1-判断两个字符串是否互为变形词" class="headerlink" title="5.1 判断两个字符串是否互为变形词"></a>5.1 判断两个字符串是否互为变形词</h2><p>建一个字符集大小的数组计数</p><h2 id="5-2-字符串中数字子串的求和"><a href="#5-2-字符串中数字子串的求和" class="headerlink" title="5.2 字符串中数字子串的求和"></a>5.2 字符串中数字子串的求和</h2><p>从左到右遍历，用几个变量标记</p><h2 id="5-3-去掉字符串中连续出现k个0的子串"><a href="#5-3-去掉字符串中连续出现k个0的子串" class="headerlink" title="5.3 去掉字符串中连续出现k个0的子串"></a>5.3 去掉字符串中连续出现k个0的子串</h2><p>从左到右遍历，用一个变量标记0的个数</p><h2 id="5-4-判断两个字符串是否互为旋转词"><a href="#5-4-判断两个字符串是否互为旋转词" class="headerlink" title="5.4 判断两个字符串是否互为旋转词"></a>5.4 判断两个字符串是否互为旋转词</h2><p>把两个 $str2$ 拼在一起，检查 $str1$ 是否是子串，方法同 $KMP$ 算法</p><h2 id="5-5-将整数字符串转成整数值"><a href="#5-5-将整数字符串转成整数值" class="headerlink" title="5.5 将整数字符串转成整数值"></a>5.5 将整数字符串转成整数值</h2><p>从左到右遍历</p><h2 id="5-6-替换字符串中连续出现的指定字符串"><a href="#5-6-替换字符串中连续出现的指定字符串" class="headerlink" title="5.6 替换字符串中连续出现的指定字符串"></a>5.6 替换字符串中连续出现的指定字符串</h2><p>从左到右遍历</p><h2 id="5-7-字符串的统计字符串"><a href="#5-7-字符串的统计字符串" class="headerlink" title="5.7 字符串的统计字符串"></a>5.7 字符串的统计字符串</h2><p>从左到右遍历</p><h2 id="5-8-判断字符数组中是否所有的字符都只出现过一次"><a href="#5-8-判断字符数组中是否所有的字符都只出现过一次" class="headerlink" title="5.8 判断字符数组中是否所有的字符都只出现过一次"></a>5.8 判断字符数组中是否所有的字符都只出现过一次</h2><p>使用哈希保存遍历结果，时间空间都是 $O(N)$   </p><p>原地排序，遍历检查，时间 $O(NlogN)$ ，空间 $O(1)$ </p><h2 id="5-9-在有序但含有空的数组中查找字符串"><a href="#5-9-在有序但含有空的数组中查找字符串" class="headerlink" title="5.9 在有序但含有空的数组中查找字符串"></a>5.9 在有序但含有空的数组中查找字符串</h2><p>二分查找</p><h2 id="5-10-字符串的调整与替换"><a href="#5-10-字符串的调整与替换" class="headerlink" title="5.10 字符串的调整与替换"></a>5.10 字符串的调整与替换</h2><p>从左到右遍历一遍，算出替换后的长度，再从右到左遍历，从尾部更新</p><h2 id="5-11-翻转字符串"><a href="#5-11-翻转字符串" class="headerlink" title="5.11 翻转字符串"></a>5.11 翻转字符串</h2><p>翻转单词：先整体逆序，再逐单词逆序   </p><p>翻转片段：先逐片段逆序，再整体逆序</p><h2 id="5-12-数组中两个字符串的最小距离"><a href="#5-12-数组中两个字符串的最小距离" class="headerlink" title="5.12 数组中两个字符串的最小距离"></a>5.12 数组中两个字符串的最小距离</h2><p>遍历一遍，找到 $str2$ 和他前后最近的两个 $str1$ 。进阶问题查询时间 $O(1)$ 就是先花时间做个查询表，mdzz</p><h2 id="5-13-添加最少字符使字符串整体都是回文字符串"><a href="#5-13-添加最少字符使字符串整体都是回文字符串" class="headerlink" title="5.13 添加最少字符使字符串整体都是回文字符串"></a>5.13 添加最少字符使字符串整体都是回文字符串</h2><p>动态规划， $dp[i][j]$ 表示使 $str[i,j]$ 回文需要添加的最少字符数， $dp[i][j]$ 有三种取值：长度为 $1$ 时 $dp$ 是 $0$ ，长度为 $2$ 时 $dp$ 是 $0$ 或 $1$ ，长度大于 $2$ 时，首尾相等 $dp[i][j]=dp[i+1][j-1]$ ，首尾不等时 $dp[i][j]=min{dp[i+1][j],dp[i][j-1]}+1$ ，从对角线向两侧更新 $dp$ ，最后新建长为 $N+dp[0][N-1]$ 的空字符串，从 $dp[0][N-1]$ 回溯填充得到回文串，时间 $O(N^2)$ </p><h2 id="5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"><a href="#5-14-已知最长回文子序列，添加最少字符使字符串整体都是回文字符串" class="headerlink" title="5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串"></a>5.14 已知最长回文子序列，添加最少字符使字符串整体都是回文字符串</h2><p>新建空字符串，长度为原字符串长度两倍减去回文子序列长度，从原字符串两端同时搜索回文子序列，每搜到一对就把两侧经过的其他字符拼接填充在左侧，逆序后再填充到右侧，时间 $O(N)$ ，回文子序列位置有混淆也不影响，因为最终遍历的回文对数是不变的</p><h2 id="5-15-括号字符串的有效性和最长有效长度"><a href="#5-15-括号字符串的有效性和最长有效长度" class="headerlink" title="5.15 括号字符串的有效性和最长有效长度"></a>5.15 括号字符串的有效性和最长有效长度</h2><p>有效性：从左到右遍历计数，右括号始终不能多于左括号且最终相等   </p><p>最长有效长度：动态规划， $dp[i]$ 表示以 $str[i]$ 结尾的最长有效长度， $dp[0]=0$ ， $str[i]$ 是左括号时 $dp[i]=0$ ， $str[i]$ 是右括号时，如果 $str[i-1]$ 是左括号直接配对， $dp[i]=dp[i-2]+2$ ，如果 $dp[i-1]$ 不是 $0$ 且 $str[i-dp[i-1]-1]$ 是左括号， $dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]$ ，其余情况 $dp[i]=0$ </p><h2 id="5-16-公式字符串求值"><a href="#5-16-公式字符串求值" class="headerlink" title="5.16 公式字符串求值"></a>5.16 公式字符串求值</h2><p>数值栈+符号栈，遇到右括号和乘除尝试计算</p><h2 id="5-17-0-左边必有-1-的二进制字符串数量"><a href="#5-17-0-左边必有-1-的二进制字符串数量" class="headerlink" title="5.17  $0$ 左边必有 $1$ 的二进制字符串数量"></a>5.17  $0$ 左边必有 $1$ 的二进制字符串数量</h2><p> $dp[i]$ 表示满足条件的 $i$ 位字符串数量，一个满足条件的字符串后面可以补 $1$ ，但是只有末尾为 $1$ 时可以补 $0$ ，所以 $dp[i+1]=dp[i]+dp_1[i]$ ，而第 $i$ 位为 $1$ 时表示第 $i-1$ 位随意，所以 $dp_1[i]=dp[i-1]$ ，所以 $dp[i+1]=dp[i]+dp[i-1]$ ，是斐波那契数列，最优时间 $O(logN)$ </p><h2 id="5-18-拼接所有字符串产生字典顺序最小的大写字符串"><a href="#5-18-拼接所有字符串产生字典顺序最小的大写字符串" class="headerlink" title="5.18 拼接所有字符串产生字典顺序最小的大写字符串"></a>5.18 拼接所有字符串产生字典顺序最小的大写字符串</h2><p>如果 $A+B$ 的字典序小于 $B+A$ ， $A$ 就应该在 $B$ 前边，照这个思路选择排序。</p><p>$\color{red}{不理解这个为什么算贪心算法？为什么需要证明？}$</p><h2 id="5-19-找到字符串的最长无重复字符子串"><a href="#5-19-找到字符串的最长无重复字符子串" class="headerlink" title="5.19 找到字符串的最长无重复字符子串"></a>5.19 找到字符串的最长无重复字符子串</h2><p>哈希表记录，标记子串头，从左到右遍历，时间 $O(N)$ ，空间 $O(M)$ ， $M$ 是字符集大小</p><h2 id="5-20-找到被指的新类型字符"><a href="#5-20-找到被指的新类型字符" class="headerlink" title="5.20 找到被指的新类型字符"></a>5.20 找到被指的新类型字符</h2><p> $str[k-1]$ 小写则结果从 $str[k]$ 开始， $str[k-1]$ 大写时，向左找有几个连续的大写，有偶数个大写则结果从 $str[k]$ 开始，反之结果从 $str[k-1]$ 开始</p><h2 id="5-21-最小包含子串的长度"><a href="#5-21-最小包含子串的长度" class="headerlink" title="5.21 最小包含子串的长度"></a>5.21 最小包含子串的长度</h2><p>哈希表记录，左右边界设在起点，右边界向右找到子串，左边界向右缩小范围，得到备选子串，循环该过程不断从右边界重新遍历，选所有备选子串里最短的，时间 $O(N)$ </p><h2 id="5-22-回文最少分割数"><a href="#5-22-回文最少分割数" class="headerlink" title="5.22 回文最少分割数"></a>5.22 回文最少分割数</h2><p>动态规划， $dp[i]$ 表示 $str[0,i]$ 的最少分割数，从 $0$ 到 $i$ 找到第一个使 $str[j,i]$ 回文的 $j$ ， $dp[i]=dp[j]+1$ ，判断回文的过程可优化</p><h2 id="5-23-字符串匹配问题"><a href="#5-23-字符串匹配问题" class="headerlink" title="5.23 字符串匹配问题"></a>5.23 字符串匹配问题</h2><p>正则匹配原理：有限状态机+递归匹配</p><h2 id="5-24-字典树的实现"><a href="#5-24-字典树的实现" class="headerlink" title="5.24 字典树的实现"></a>5.24 字典树的实现</h2><p>简单粗暴，节点属性有共用数、词尾数、子节点集合</p><h1 id="第六章-大数据和空间限制"><a href="#第六章-大数据和空间限制" class="headerlink" title="第六章 大数据和空间限制"></a>第六章 大数据和空间限制</h1><p>降低精度或增加时间从而减少空间</p><h2 id="6-1-布隆过滤器"><a href="#6-1-布隆过滤器" class="headerlink" title="6.1 布隆过滤器"></a>6.1 布隆过滤器</h2><p>创建一个巨大的长为 $m$ 的 $bit$ 数组，对每条数据使用 $k$ 个哈希函数，分别对 $m$ 取余，把 $bit$ 数组的 $k$ 个 $bit$ 置为 $1$ 。使用时如果输入对应的 $k$ 个位置都为 $1$ 就过滤，只会误杀不会漏杀</p><p><span id="jump4"></span></p><h2 id="6-2-找到出现最多的数"><a href="#6-2-找到出现最多的数" class="headerlink" title="6.2 找到出现最多的数"></a>6.2 找到出现最多的数</h2><p>读文件不会把整个文件放进内存，但是查哈希表是把整个表放进内存。 把 $N$ 个数的文件用哈希函数分配到 $k$ 个哈希表里，哈希函数能保证相同的数都在同一个表里，每次查找只把一个表放进内存，查完所有表后对比各自频次最多的数，把大的集合分组不仅能减少内存占用，还能减少哈希表里表示键值的比特长度</p><h2 id="6-3-找到没出现的数"><a href="#6-3-找到没出现的数" class="headerlink" title="6.3 找到没出现的数"></a>6.3 找到没出现的数</h2><p>只考虑出现与否不需要计数，可以使用 $bit$ 数组减少内存占用，再优化还可以分组统计，每次只检查 $k$ 个数出现与否，但每组都要遍历一遍原文件</p><h2 id="6-4-找到所有重复的-url"><a href="#6-4-找到所有重复的-url" class="headerlink" title="6.4 找到所有重复的 $url$"></a>6.4 找到所有重复的 $url$</h2><p>同 <a href="#jump4">6.2</a> ，大文件拆成多个小文件</p><h2 id="6-5-统计词汇-top-k"><a href="#6-5-统计词汇-top-k" class="headerlink" title="6.5 统计词汇 $top_k$"></a>6.5 统计词汇 $top_k$</h2><p>同 <a href="#jump4">6.2</a> ，大文件拆成多个小文件，每个小文件 $top_k$ 再排序</p><h2 id="6-6-找到出现两次的数"><a href="#6-6-找到出现两次的数" class="headerlink" title="6.6 找到出现两次的数"></a>6.6 找到出现两次的数</h2><p>双倍 $bit$ 数组，每个数用两个 $bit$ 统计出现 $0$ 次、 $1$ 次、 $2$ 次和多次</p><h2 id="6-7-找中位数"><a href="#6-7-找中位数" class="headerlink" title="6.7 找中位数"></a>6.7 找中位数</h2><p>先分好 $k$ 个区间，遍历一遍文件得到中位数出现的区间，再遍历一遍在目标区间里接着找，空间不够可以继续分区间</p><h2 id="6-8-一致性哈希算法"><a href="#6-8-一致性哈希算法" class="headerlink" title="6.8 一致性哈希算法"></a>6.8 一致性哈希算法</h2><p>环形分配可以减小增删机器时数据迁移的代价，虚拟节点可以减小机器较少时的负载不均衡</p><h1 id="第七章-位运算"><a href="#第七章-位运算" class="headerlink" title="第七章 位运算"></a>第七章 位运算</h1><h2 id="7-1-不用额外变量交换两个整数的值"><a href="#7-1-不用额外变量交换两个整数的值" class="headerlink" title="7.1 不用额外变量交换两个整数的值"></a>7.1 不用额外变量交换两个整数的值</h2><p>$a=a\oplus b$ , $b=a\oplus b$ , $a=a\oplus b$ ，第一步把 $a$ 和 $b$ 信息不同的比特位标为 $1$ ，第二步当信息不同且 $b$ 是 $0$ 时结果是 $1$ ，信息相同 $b$ 是 $1$ 是返回 $1$ ，所以结果就是原来的 $a$ ，第三步当信息不同且 $b$ (原来的 $a$ )是 $0$ 时结果是 $1$ ，信息相同 $b$ 是 $1$ (原来的 $a$ )是返回 $1$ ，所以结果就是 $a$ (原来的 $b$ )</p><h2 id="7-2-不用任何比较判断找出两个数中较大的数"><a href="#7-2-不用任何比较判断找出两个数中较大的数" class="headerlink" title="7.2 不用任何比较判断找出两个数中较大的数"></a>7.2 不用任何比较判断找出两个数中较大的数</h2><p>二进制最高位是符号位， $1$ 是负数， $0$ 是非负，查看 $a$ 、 $b$ 和 $a-b$ 的符号， $a$ 和 $b$ 符号相反直接返回非负的， $a$ 和 $b$ 符号相同则 $a-b$ 不会溢出，根据 $a-b$ 符号返回结果</p><h2 id="7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出"><a href="#7-3-只用位运算不用算术运算实现整数的加减乘除运算-不考虑溢出" class="headerlink" title="7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)"></a>7.3 只用位运算不用算术运算实现整数的加减乘除运算(不考虑溢出)</h2><p>加法：只相加不进位时 $a+b=a^b$ ，向前进位的序列是 $(a\&amp;b)\ll 1$ ，再以异或序列和进位序列不断循环前两步，直到进位序列全是 $0$   </p><p>减法： $a-b=a+(-b)$ ， $b$ 的相反数是把 $b$ 取反加一得到补码，再和 $a$ 做上述加法  </p><p>乘法： $a\times b$ 本质是 $a$ 循环累加，把 $b$ 按位拆分，最低位是 $1$ 时结果加 $a$ ，高位都代表 $2$ 的乘方，通过对 $a$ 向左移位可以实现，最终 $a\times b=a\times b<em>0+\sum</em>{i=1}^n(a\ll i)\times b_i$ ，因为 $b_i$ 是 $0$ 或 $1$ ，所以式子里的乘法只是形式上的， $b$ 是负数也成立  </p><p>除法： $a\div b$ 本质是 $a$ 循环减去 $b$ ，因此可以对 $b$ 移位比大小得到比 $a$ 小的最大的数。如果 $a$ 、 $b$ 中有负数要先转成非负，最后再考虑符号。一个特例是， $int$ 的最小值的绝对值比最大值大 $1$ ，所以 $int$ 的最小值不能转成正数，当不能直接判断出结果，也就是最小值必须参与计算时，可以把最小值拆成几段分开算，最后用余数再算一次</p><h2 id="7-4-整数的二进制表达中有多少个-1"><a href="#7-4-整数的二进制表达中有多少个-1" class="headerlink" title="7.4 整数的二进制表达中有多少个 $1$"></a>7.4 整数的二进制表达中有多少个 $1$</h2><p>方法一：循环 $n=n\And(n-1)$ 或 $n-=n\And(1-n)$ 直到 $n=0$ ，这个操作本质上是去掉 $n$ 最右边的 $1$ ，两个式子右边一个返回去掉末尾 $1$ 的 $n$ ，一个直接返回末尾 $1$  </p><p>方法二：平行算法，统计 $1$ 的个数不用把整个二进制序列当成一个数，同时在每个bit上操作既提高了效率又排除了序列里高低位的影响，平行算法采用归并的思路，依次算出每 $2^k$ 位里有多少个 $1$ ，最后一步的结果就是整个序列里有多少个 $1$<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int function(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    n &#x3D; (n &amp; 0x55555555) + ((n&gt;&gt; 1) &amp; 0x55555555); #每2bit为一组相加 </span><br><span class="line">    n &#x3D; (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333); #每4bit为一组相加 </span><br><span class="line">    n &#x3D; (n &amp; 0x0f0f0f0f) + ((n&gt;&gt; 4) &amp; 0x0f0f0f0f); #每2bit为一组相加   </span><br><span class="line">    n &#x3D; (n &amp; 0xff00ff) + ((n&gt;&gt; 8) &amp; 0xff00ff); #每16bit为一组相加      </span><br><span class="line">    n &#x3D; (n &amp; 0xffff) + ((n&gt;&gt; 16) &amp; 0xffff) ; #每32bit为一组相加         </span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="7-5-在其他数都出现偶数次的数组中找到出现奇数次的数"><a href="#7-5-在其他数都出现偶数次的数组中找到出现奇数次的数" class="headerlink" title="7.5 在其他数都出现偶数次的数组中找到出现奇数次的数"></a>7.5 在其他数都出现偶数次的数组中找到出现奇数次的数</h2><p>一个数奇数次： $n\oplus0=n,n\oplus n=0$ ，所以只要用一个 $0$ 把所有数都异或一遍，剩下的值就是奇数次那个数  </p><p>两个数奇数次：用 $0$ 异或一遍结果是 $a\oplus b$ ，两个数不相等结果必有个第 $k$ 位是 $1$ ，再用 $0$ 与第 $k$ 位是 $1$ 的所有数异或一遍，得到的就是 $a$ 或 $b$ </p><h2 id="7-6-在其他数都出现-k-次的数组中找到只出现一次的数"><a href="#7-6-在其他数都出现-k-次的数组中找到只出现一次的数" class="headerlink" title="7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数"></a>7.6 在其他数都出现 $k$ 次的数组中找到只出现一次的数</h2><p>$k$ 个相同的 $k$ 进制的数无进位相加结果是 $0$ ，因为结果每一位都是 $(k\times a)\%k$ ，所以把所有数转为 $k$ 进制累加，得到的结果就是只出现一次的数</p><h1 id="第八章-数组和矩阵问题"><a href="#第八章-数组和矩阵问题" class="headerlink" title="第八章 数组和矩阵问题"></a>第八章 数组和矩阵问题</h1><h2 id="8-1-转圈打印矩阵"><a href="#8-1-转圈打印矩阵" class="headerlink" title="8.1 转圈打印矩阵"></a>8.1 转圈打印矩阵</h2><p>就是从外到内逐层打印，用每一圈的四个角的坐标判断</p><h2 id="8-2-将正方形矩阵顺时针旋转-90-deg"><a href="#8-2-将正方形矩阵顺时针旋转-90-deg" class="headerlink" title="8.2 将正方形矩阵顺时针旋转 90&deg;"></a>8.2 将正方形矩阵顺时针旋转 90&deg;</h2><p>方阵里一个数顺时针旋转 90&deg; 就是沿着他所在的一圈顺时针走一条边的距离，和上题一样逐圈操作</p><h2 id="8-3-之字形打印矩阵"><a href="#8-3-之字形打印矩阵" class="headerlink" title="8.3 之字形打印矩阵"></a>8.3 之字形打印矩阵</h2><p>算坐标，碰到边界再判断怎么移动</p><h2 id="8-4-找到无序数组中最小的-k-个数"><a href="#8-4-找到无序数组中最小的-k-个数" class="headerlink" title="8.4 找到无序数组中最小的 $k$ 个数"></a>8.4 找到无序数组中最小的 $k$ 个数</h2><p>$O(Nlogk)$ 方法：维护一个 $k$ 个节点的大根堆，遍历数组，如果元素小于堆顶就插入堆，其中遍历 $O(N)$ ，堆插入 $O(logk)$    </p><p>$O(N)$ 方法： $BFPRT$ 算法可以从数组中找到第 $k$ 小的数，把原数组每五个数分一组，分别求中位数，再递归求中位数的中位数，最终得到一个中位数 $x$ ，用 $x$ 划分原数组中大于 $x$ 和小于 $x$ 的数，在其中一边继续用中位数方法划分，最终能得到 $x$ 在数组中的位置是第 $k$ ，可以用数学证明该过程时间复杂度是 $O(N)$ ，大概意思就是用中位数划分数组效率高，所以能收敛到 $O(N)$ ，所以找到 $k$ 个最小的数总的时间复杂度也是 $O(N)$ </p><h2 id="8-5-需要排序的最短子数组长度"><a href="#8-5-需要排序的最短子数组长度" class="headerlink" title="8.5 需要排序的最短子数组长度"></a>8.5 需要排序的最短子数组长度</h2><p>从左到右、从右到左分别遍历，找边界</p><h2 id="8-6-在数组中找到出现次数大于-N-K-的数"><a href="#8-6-在数组中找到出现次数大于-N-K-的数" class="headerlink" title="8.6 在数组中找到出现次数大于 $N/K$ 的数"></a>8.6 在数组中找到出现次数大于 $N/K$ 的数</h2><p>遍历一遍数组，循环排除 $K$ 个不同的数，直到剩下的不足 $K$ ，剩下的就是出现次数大于 $N/K$ 的数。具体实现是建立两个长度为 $K-1$ 的数组， $A$ 数组存数组里的数， $B$ 数组存出现次数，当遍历到的 $x$ 与 $A$ 里的都不同时， $B$ 数组都减一同时遍历下一个，就相当于排除了 $K$ 个不同的数，次数归零时用遍历到的数补位，最终时间复杂度 $O(N\times K)$ ，空间复杂度 $O(K)$ </p><h2 id="8-7-在行列都排好序的矩阵中找数"><a href="#8-7-在行列都排好序的矩阵中找数" class="headerlink" title="8.7 在行列都排好序的矩阵中找数"></a>8.7 在行列都排好序的矩阵中找数</h2><p>$M\times N$ 的矩阵中，每个以对角线上一点为右下角的一行和一列的组合里，对角线上这个点都是最大的，相当于从左上角到右下角沿着对角线剥洋葱，遍历的最大长度是对角线+一行+一列，时间 $O(M+N)$ </p><h2 id="8-8-最长的可整合子数组的长度"><a href="#8-8-最长的可整合子数组的长度" class="headerlink" title="8.8 最长的可整合子数组的长度"></a>8.8 最长的可整合子数组的长度</h2><p>可整合数组就是元素不重复，最大值-最小值+1是元素个数的数组，从左到右以每个元素为起点遍历一次，时间 $O(N^2)$ </p><h2 id="8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><a href="#8-9-不重复打印排序数组中相加和为给定值的所有二元组和三元组" class="headerlink" title="8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组"></a>8.9 不重复打印排序数组中相加和为给定值的所有二元组和三元组</h2><p>二元组：一个左指针一个右指针向中间遍历，时间 $O(N)$   </p><p>三元组：从左到右遍历，每遍历到一个元素，就把他后面的当成一个二元组问题求解，时间 $O(N^2)$ </p><h2 id="8-10-未排序正数数组中累加和为给定值的最长子数组长度"><a href="#8-10-未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="8.10 未排序正数数组中累加和为给定值的最长子数组长度"></a>8.10 未排序正数数组中累加和为给定值的最长子数组长度</h2><p>左右两个指针从数组头遍历，变量 $sum$ 存两个指针标记的子数组累加和，变量 $len$ 存 $sum$ 为给定值 $k$ 时的最长子数组长度，右指针向右遍历， $sum\geq k$ 时左指针加一</p><p><span id="jump5"></span></p><h2 id="8-11-未排序数组中最长子数组系列问题"><a href="#8-11-未排序数组中最长子数组系列问题" class="headerlink" title="8.11 未排序数组中最长子数组系列问题"></a>8.11 未排序数组中最长子数组系列问题</h2><p>累加和为 $k$ ： $s[i]$ 表示子数组 $arr[0,i]$ 的累加和，则 $arr[j,i]$ 的累加和就是 $s[i]-s[j-1]$ ，从左到右遍历数组计算累加和，建立哈希表， $key$ 是累加和， $value$ 是最先产生该累加和的数组下标，若 $s[i]=k$ ，就得到了一个满足条件的子数组，若 $s[i]&gt;k$ ，就在表中查找 $s[i]-k$   </p><p>正数与负数个数相等：正数变 $1$ ，负数变 $-1$ ，相当于求累加和为 $0$ </p><p>数组里只有 $0$ 和 $1$ ，子数组 $0$ 和 $1$ 个数相等： $0$ 变 $-1$ ，求累加和为 $0$ </p><h2 id="8-12-未排序数组中累加和小于或等于给定值的最长子数组长度"><a href="#8-12-未排序数组中累加和小于或等于给定值的最长子数组长度" class="headerlink" title="8.12 未排序数组中累加和小于或等于给定值的最长子数组长度"></a>8.12 未排序数组中累加和小于或等于给定值的最长子数组长度</h2><p>建立数组 $s$ 记录累加和，建立数组 $h$ 记录 $s[0,i]$ 之间的最大值，遍历一遍原数组 $O(N)$ ，每遍历一个元素，如果 $s[i]\leq k$ 就更新最长子数组长度，反之就在 $0\sim i$ 之间搜索是否存在 $s[i]-s[j-1]\leq k$ ，即 $s[j-1]\geq s[i]-k$ ，由于 $h$ 是递增数组，结合数组 $s$ 可以实现 $O(logN)$ 的二分查找，最终时间 $O(NlogN)$ ， 空间 $O(N)$ </p><h2 id="8-13-计算数组的小和"><a href="#8-13-计算数组的小和" class="headerlink" title="8.13 计算数组的小和"></a>8.13 计算数组的小和</h2><p>在归并排序的过程中计算小和，因为每一步操作的两个数组都是排好序的，所以节省了遍历的时间，对于 $s_1[i]$ ，只要找到第一个 $s_1[i]&lt;s_2[j]$ ，直接给总数组小和加上 $s_1[i]*(len(s_2)-j+1)$ ，时间 $O(NlogN)$ ，空间 $O(N)$ </p><h2 id="8-14-自然数数组的排序"><a href="#8-14-自然数数组的排序" class="headerlink" title="8.14 自然数数组的排序"></a>8.14 自然数数组的排序</h2><p>前提是已经知道了一个数应该放在哪里，从左到右遍历，如果一个位置上的数不对，就把他放到正确的位置，替换掉那个位置上的数，然后循环修正替换下来的数，最后会回到原来遍历中止的位置，继续往后遍历</p><h2 id="8-15-奇数下标都是奇数或者偶数下标都是偶数"><a href="#8-15-奇数下标都是奇数或者偶数下标都是偶数" class="headerlink" title="8.15 奇数下标都是奇数或者偶数下标都是偶数"></a>8.15 奇数下标都是奇数或者偶数下标都是偶数</h2><p>两个指针从左到右分别遍历数组的奇数和偶数位置，循环检查数组最后一个数，放在相应指针标记的位置，把该位置替换下来的数放在数组尾部，对应指针加二</p><h2 id="8-16-子数组的最大累加和问题"><a href="#8-16-子数组的最大累加和问题" class="headerlink" title="8.16 子数组的最大累加和问题"></a>8.16 子数组的最大累加和问题</h2><p>从左到右累加，累加和变成负数就从下个数重新累加，用一个变量记录累加和的最大值</p><h2 id="8-17-子矩阵的最大累加和问题"><a href="#8-17-子矩阵的最大累加和问题" class="headerlink" title="8.17 子矩阵的最大累加和问题"></a>8.17 子矩阵的最大累加和问题</h2><p>把矩阵的 $k$ 行累加成一行，转化成子数组的最大累加和问题，结果就是以这 $k$ 行为基础搜索矩阵的列找到的子矩阵，从上到下以每行为起点遍历所有行数的矩阵，搜索最大累加和的子矩阵，最终时间 $O(N^3)$ ，空间 $O(N)$  </p><h2 id="8-18-在数组中找到一个局部最小的位置"><a href="#8-18-在数组中找到一个局部最小的位置" class="headerlink" title="8.18 在数组中找到一个局部最小的位置"></a>8.18 在数组中找到一个局部最小的位置</h2><p>先判断首尾有没有，没有就二分查找，如果 $arr[mid]&gt;arr[mid-1]$ ，因为左半边肯定不单调，所以一定存在局部最小，如果 $arr[mid]&gt;arr[mid+1]$ 就在右半边找，最终时间 $O(logN)$ </p><h2 id="8-19-数组中子数组的最大累乘积"><a href="#8-19-数组中子数组的最大累乘积" class="headerlink" title="8.19 数组中子数组的最大累乘积"></a>8.19 数组中子数组的最大累乘积</h2><p>从左到右遍历，分别求以每个 $arr[i]$ 结尾的最大累乘积 $max<em>i$ 和最小累乘积 $min_i$ ，通过比较 $max</em>{i-1}\times arr[i]$ 、 $min_{i-1}\times arr[i]$ 和  $arr[i]$ 三个数确定最大最小累乘积，再用一个变量保存整个过程中的最大累乘积，时间 $O(N)$ ，空间 $O(1)$ </p><h2 id="8-20-打印-N-个数组整体最大的-topK"><a href="#8-20-打印-N-个数组整体最大的-topK" class="headerlink" title="8.20 打印 $N$ 个数组整体最大的 $topK$"></a>8.20 打印 $N$ 个数组整体最大的 $topK$</h2><p>维护一个大根堆，因为数组都是有序的，取 $N$ 个数组的最大值建堆，时间 $O(N)$ ，每次把堆顶加入 $topK$ 并把堆顶元素所在数组的下一个最大值插入堆，每次插入 $O(logN)$ ，插入总时间 $O(KlogN)$ </p><h2 id="8-21-边界都是-1-的最大正方形大小"><a href="#8-21-边界都是-1-的最大正方形大小" class="headerlink" title="8.21 边界都是 $1$ 的最大正方形大小"></a>8.21 边界都是 $1$ 的最大正方形大小</h2><p>以每个点为正方形的左上角，对于所有可能的边长，检查正方形的四条边，时间 $O(N^4)$ ，空间 $O(1)$ 。可以通过预处理矩阵把检查四条边的时间变成 $O(1)$ ，预先生成两个矩阵，用来记录每个点向右和向下有多少个连续的 $1$ ，从右下角开始算，每次利用之前计算出的结果，可以把预处理时间降到 $O(N^2)$ ，优化后的总时间是 $O(N^3)$ ，空间 $O(N^2)$ </p><h2 id="8-22-不包含本位置值的累乘数组"><a href="#8-22-不包含本位置值的累乘数组" class="headerlink" title="8.22 不包含本位置值的累乘数组"></a>8.22 不包含本位置值的累乘数组</h2><p>使用除法：用总乘积除以每一位</p><p>不使用除法：创建两个数组分别存储从左到右和从右到左的累乘，不包含一个数的累乘相当于他的左累乘和右累乘的乘积；或者用异或代替除法</p><h1 id="8-23-数组的-partition-调整"><a href="#8-23-数组的-partition-调整" class="headerlink" title="8.23 数组的 $partition$ 调整"></a>8.23 数组的 $partition$ 调整</h1><p>从左到右遍历，交换数值，相当于用一个左指针把数组分成两个区，遍历过程中在区之间做交换。更复杂的问题可以用一个左指针一个右指针把数组分成三个区</p><h2 id="8-24-求最短通路值"><a href="#8-24-求最短通路值" class="headerlink" title="8.24 求最短通路值"></a>8.24 求最短通路值</h2><p>广度优先遍历，时间 $O(M\times N)$ </p><h2 id="8-25-数组中未出现的最小正整数"><a href="#8-25-数组中未出现的最小正整数" class="headerlink" title="8.25 数组中未出现的最小正整数"></a>8.25 数组中未出现的最小正整数</h2><p>理想情况是数组里存着 $1\sim N$ ，当发现不属于这个范围的数或有重复数时，说明坑位不够了。初始化 $l=0$ 和 $r=N$ 标记空余位置的范围。循环遍历范围头部：<br>若 $arr[l]=l+1$ ，说明正好占对了最左边的坑， $l++$<br>若 $arr[l]<l$ 或 $arr[l]>r$ ，说明有范围外的占坑了，把 $arr[r-1]$ 保存到 $arr[l]$ ，同时 $r—$ ，表示删除一个坑位<br>若 $arr[arr[l]-1]=arr[l]$ ，说明 $arr[l]$ 是合法范围内的数，但是他应该在的位置 $arr[l]-1$ 上已经有相同的数了，说明出现了重复，把 $arr[r-1]$ 保存到 $arr[l]$ ，同时 $r—$ ，表示删除一个坑位<br>若以上错误都没出现，说明 $arr[l]$ 是合法范围内的数，把他和 $arr[l]-1$ 位置上的数交换<br>最终左右指针相遇， $l+1$ 就是未出现的最小正整数</l$></p><h2 id="8-26-数组排序之后相邻数的最大差值"><a href="#8-26-数组排序之后相邻数的最大差值" class="headerlink" title="8.26 数组排序之后相邻数的最大差值"></a>8.26 数组排序之后相邻数的最大差值</h2><p>遍历一次找到最大最小值，做桶排序，时间 $O(N)$ </p><h1 id="第九章-其他题目"><a href="#第九章-其他题目" class="headerlink" title="第九章 其他题目"></a>第九章 其他题目</h1><h2 id="9-1-从-5-随机到-7-随机及其扩展"><a href="#9-1-从-5-随机到-7-随机及其扩展" class="headerlink" title="9.1 从 $5$ 随机到 $7$ 随机及其扩展"></a>9.1 从 $5$ 随机到 $7$ 随机及其扩展</h2><p>$rand1to5$ 实现 $rand1to7$ ：独立调用两次 $rand1to5$ ， $res=(rand1to5-1)*5+(rand1to5-1)$ 等概率随机生成 $0\sim 24$ 之间的数，当结果在 $0\sim 20$ 之间时， $res\%7+1$ 就等概率随机生成 $0\sim 27$ 之间的数 </p><p>$rand01p$ 实现 $rand1to6$ ：由于 $rand01p$ 生成 $01$ 和 $10$ 的概率都是 $p(1-p)$ ，所以先通过调用两次 $rand01p$ 实现等概率产生 $0$ 和 $1$ 的 $rand01$ 。 $rand0to3=rand01<em>2+rand01$ 等概率随机生成 $0\sim 3$ ， $res=rand0to3</em>4+rand0to3$ 等概率随机生成 $0\sim 15$ ，当结果在 $0\sim 11$ 之间时， $res\%6+1$ 就等概率随机生成 $0\sim 6$ 之间的数 </p><p>$rand1toM$ 实现 $rand1toN$ ：如果 $M&gt;N$ ，调用一次直接筛选 $res$ ，如果 $M&lt;N$ ，调用多次拼接成一个多位的 $M$ 进制数，再筛选 $res$ </p><h2 id="9-2-一行代码求两个数的最大公约数"><a href="#9-2-一行代码求两个数的最大公约数" class="headerlink" title="9.2 一行代码求两个数的最大公约数"></a>9.2 一行代码求两个数的最大公约数</h2><p>辗转相除法， $gcd(a,b)=gcd(b,a\%b)$ </p><h2 id="9-3-有关阶乘的两个问题"><a href="#9-3-有关阶乘的两个问题" class="headerlink" title="9.3 有关阶乘的两个问题"></a>9.3 有关阶乘的两个问题</h2><p>阶乘末尾 $0$ 的数量：遍历 $1\sim N$ 的所有数，累计每个数的因子 $5$ 的个数，遍历过程可以优化，一个数有多少 $5^k$ 的因子，就能提供多少个 $5$ ，所以因子 $5$ 总数为： $\sum_{k=1} N/5^k$ </p><p>阶乘的二进制表示中最右边的 $1$ 的位置：末尾 $0$ 的数量是因子 $2$ 的个数 $\sum_{k=1} N/2^k$ </p><h2 id="9-4-判断一个点是否在矩形内部"><a href="#9-4-判断一个点是否在矩形内部" class="headerlink" title="9.4 判断一个点是否在矩形内部"></a>9.4 判断一个点是否在矩形内部</h2><p>比较坐标位置；或者看横纵直线和矩形的交点，一个点在凸多边形的内部，从这个点引出的横纵两条直线与多边形的四个交点一定分布在这个点的上下左右</p><h2 id="9-5-判断一个点是否在三角形内部"><a href="#9-5-判断一个点是否在三角形内部" class="headerlink" title="9.5 判断一个点是否在三角形内部"></a>9.5 判断一个点是否在三角形内部</h2><p>同上</p><h2 id="9-6-折纸问题"><a href="#9-6-折纸问题" class="headerlink" title="9.6 折纸问题"></a>9.6 折纸问题</h2><p>找规律，每次折叠产生的新折痕都是在上次折叠新产生的每一条折痕前后生成下折痕和上折痕<br>第一次折叠：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;下<br>第二次折叠：&emsp;&emsp;&emsp;下&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;上<br>第三次折叠：&emsp;下&emsp;&emsp;&emsp;上&emsp;&emsp;&emsp;下&emsp;&emsp;&emsp;上<br>第四次折叠：下&emsp;上&emsp;下&emsp;上&emsp;下&emsp;上&emsp;下&emsp;上<br>中序遍历的结果就是折痕顺序</p><h2 id="9-7-蓄水池算法"><a href="#9-7-蓄水池算法" class="headerlink" title="9.7 蓄水池算法"></a>9.7 蓄水池算法</h2><p>前 $k$ 个球直接放入，对于第 $i(i&gt;k)$ 个球，以 $k/i$ 的概率决定放入，如果放入了就随机扔掉袋子里的一个球，可以数学证明每个球最终留在袋子里的概率都是 $k/N$ </p><h2 id="9-8-设计有-setAll-功能的哈希表"><a href="#9-8-设计有-setAll-功能的哈希表" class="headerlink" title="9.8 设计有 $setAll$ 功能的哈希表"></a>9.8 设计有 $setAll$ 功能的哈希表</h2><p>给每个值附加一个时间戳，创建一个 $key=setAll$ 的条目，每次调用 $setAll$ 方法就更新 $setAll$ 条目的值和时间戳，当查询的值的时间比 $setAll$ 早时，返回 $setAll$ 条目的值，从查询结果看是重置了所有值，其实只是把查询重定向了</p><h2 id="9-9-最大的-leftMax-与-rightMax-之差的绝对值"><a href="#9-9-最大的-leftMax-与-rightMax-之差的绝对值" class="headerlink" title="9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值"></a>9.9 最大的 $leftMax$ 与 $rightMax$ 之差的绝对值</h2><p>方法一：创建两个数组，从左到右和从右到左各遍历一遍，记录 $leftMax$ 和 $rightMax$ ，最后再遍历一次直接出结果，时间 $O(N)$ ，空间 $O(N)$ </p><p>方法二：遍历一遍找到数组最大值，再和数组首尾两个元素分别算差值，因为当最大值在一侧时，另一侧最小的最大值就是只有一个元素的情况，时间 $O(N)$ ，空间 $O(1)$ </p><h2 id="9-10-设计可以变更的缓存结构"><a href="#9-10-设计可以变更的缓存结构" class="headerlink" title="9.10 设计可以变更的缓存结构"></a>9.10 设计可以变更的缓存结构</h2><p>双向队列实现节点的排序，头部存旧节点，尾部存最近访问的节点，当一个节点被访问时就移到尾部，要淘汰节点时直接从头部删除，用哈希表映射节点实现 $O(1)$ 的时间复杂度</p><h2 id="9-11-设计-RandomPool-结构"><a href="#9-11-设计-RandomPool-结构" class="headerlink" title="9.11 设计 $RandomPool$ 结构"></a>9.11 设计 $RandomPool$ 结构</h2><p>数据只有 $key$ 没有 $value$ ，所以可以用哈希表给 $key$ 一个 $index$ ，一个哈希表的索引是 $key$ ，另一个的索引是 $index$ ， $getRandom$ 就是在 $0\sim index$ 之间生成一个随机数</p><h2 id="9-12-调整-0-x-区间上的数出现的概率"><a href="#9-12-调整-0-x-区间上的数出现的概率" class="headerlink" title="9.12 调整 $[0,x)$ 区间上的数出现的概率"></a>9.12 调整 $[0,x)$ 区间上的数出现的概率</h2><p>分别调用 $k$ 次 $random$ 函数，返回最大的值，因为只要有一次不在 $[0,x)$ 内，结果就不在 $[0,x)$ 内，说明随机到 $[0,x)$ 内的概率是 $x^k$ </p><h2 id="9-13-路径数组变为统计数组"><a href="#9-13-路径数组变为统计数组" class="headerlink" title="9.13 路径数组变为统计数组"></a>9.13 路径数组变为统计数组</h2><p>从左到右遍历 $path$ ，如果不是首都就跳到他指向的城市，最终要么跳到首都要么跳到一个已经遍历过的节点，然后反向跳回去，同时设置每一步到首都的距离，遍历一遍后 $path[i]$ 就表示城市 $i$ 到首都的距离。再从左到右遍历 $path$ ，还是用跳跃的方法赋值，先 $path[path[0]]=1$ ，对替换下来的 $path[path[0]]$ 再 $path[path[path[0]]]=1$ ，遍历完后 $path[i]$ 就表示到首都距离为 $i$ 的城市数。两次遍历期间可以用数值的正负来区分数值代表的含义</p><h2 id="9-14-正数数组的最小不可组成和"><a href="#9-14-正数数组的最小不可组成和" class="headerlink" title="9.14 正数数组的最小不可组成和"></a>9.14 正数数组的最小不可组成和</h2><p>动态规划，对数组求一次总和 $sum$ ，把 $dp$ 长度设成 $sum$ ， $dp[i]$ 表示存在子数组累加和是 $i$ ，从左到右遍历数组，对于每一个元素 $k$ ，遍历 $dp[i]=1$ 使 $dp[i+k]=1$ ，最后再扫一遍 $dp$ 找最小不可组成和，时间 $O(N\times sum)$ ，空间 $O(sum)$ </p><p>已知数组中有 $1$ 时：数组排序，遍历一遍求每个位置 $i$ 的 $range$ ，表示 $[1,range]$ 能够被 $arr[0,i-1]$ 表示，初始 $range=1$ ，如果 $arr[i]&gt;range+1$ ，说明 $range+1$ 无法组成，直接返回结果，如果 $arr[i]\leq range+1$ ，说明 $[1,range+arr[i]]$ 能够被 $arr[0,i]$ 表示，让 $range+=arr[i]$ ，时间 $O(NlogN)$ ，空间 $O(1)$ </p><p>$\color{red}{没明白已知有1到底影响了什么}$</p><h2 id="9-14-一种字符串和数字的对应关系"><a href="#9-14-一种字符串和数字的对应关系" class="headerlink" title="9.14 一种字符串和数字的对应关系"></a>9.14 一种字符串和数字的对应关系</h2><p>数字转字符串：把字符串看成是伪 $k$ 进制数，每位的范围是 $1\sim k$ ，先用目标数依次减去 $k$ 、 $k^2$ 、 $k^3$ 等，算出字符串需要的位数，再用剩下的数从高位到低位依次赋值</p><p>字符串转数字：第 $i$ 位的值表示有多少个 $k^i$ ，所有位求和</p><h2 id="9-15-1-到-n-中-1-出现的次数"><a href="#9-15-1-到-n-中-1-出现的次数" class="headerlink" title="9.15  $1$ 到 $n$ 中 $1$ 出现的次数"></a>9.15  $1$ 到 $n$ 中 $1$ 出现的次数</h2><p>找规律，分别算每一位上 $1$ 出现的次数，取右数第 $i$ 位左边的数字(没有就是0)，乘以 $10^{i−1}$ ，得到基础值 $a$ ，取第 $i$ 位数字，计算修正值：<br>如果大于 $1$ ，则结果为 $a+10^{i−1}$<br>如果小于 $1$ ，则结果为 $a$<br>如果等 $1$ ，则取第 $i$ 位右边数字，设为 $b$ ，最后结果为 $a+b+1$   </p><h2 id="9-16-从-N-个数中等概率打印-M-个数"><a href="#9-16-从-N-个数中等概率打印-M-个数" class="headerlink" title="9.16 从 $N$ 个数中等概率打印 $M$ 个数"></a>9.16 从 $N$ 个数中等概率打印 $M$ 个数</h2><p>随机打印 $[0,N-1]$ 的一个位置 $a$ 上的 $arr[a]$ ，把 $arr[a]$ 和 $arr[N-1]$ 交换，再随机打印 $[0,N-2]$ 的一个位置 $b$ 上的 $arr[b]$ ，循环该过程直到打印出 $N$ 个数，可以推出来每个数打印的概率都是 $1/N$ </p><h2 id="9-17-判断一个数是否是回文数"><a href="#9-17-判断一个数是否是回文数" class="headerlink" title="9.17 判断一个数是否是回文数"></a>9.17 判断一个数是否是回文数</h2><p>左右比较，剥洋葱法</p><h2 id="9-18-在有序旋转数组中找到最小值"><a href="#9-18-在有序旋转数组中找到最小值" class="headerlink" title="9.18 在有序旋转数组中找到最小值"></a>9.18 在有序旋转数组中找到最小值</h2><p>递增数组旋转过的数组中间有断点，如果子数组左小右大说明不包含断点，左大右小说明一定包含断点，左右相等时不确定，如 $[3,1,2,3]$ ，此时需要对子数组进行查找，整个过程尽量使用二分查找，最优情况 $O(logN)$ ，最坏情况 $O(N)$  </p><h2 id="9-19-在有序旋转数组中找到一个数"><a href="#9-19-在有序旋转数组中找到一个数" class="headerlink" title="9.19 在有序旋转数组中找到一个数"></a>9.19 在有序旋转数组中找到一个数</h2><p>二分查找，根据子数组左中右的值，判断断点可能的位置以及需要继续搜索的子数组</p><h2 id="9-20-数字的英文表达和中文表达"><a href="#9-20-数字的英文表达和中文表达" class="headerlink" title="9.20 数字的英文表达和中文表达"></a>9.20 数字的英文表达和中文表达</h2><p>英文三位一组(个十百)，中文四位一组(个十百千)</p><h2 id="9-21-分糖果问题"><a href="#9-21-分糖果问题" class="headerlink" title="9.21 分糖果问题"></a>9.21 分糖果问题</h2><p>从左到右遍历，每找到一个上下坡的组合就开始赋值，两个坡最低处都是 $1$ ，两侧上坡都是递增加一，直到两个坡交汇，交汇处的值由坡长的一侧决定</p><h2 id="9-22-一种消息接受并打印的结构设计"><a href="#9-22-一种消息接受并打印的结构设计" class="headerlink" title="9.22 一种消息接受并打印的结构设计"></a>9.22 一种消息接受并打印的结构设计</h2><p>创建长度为 $N$ 的数组，接受的数字对号入座，当打印到 $k$ 时就把 $k+1$ 当做下一次打印的标志，一旦接收到就向后打印连续区间值</p><h2 id="9-23-设计一个没有扩容负担的堆结构"><a href="#9-23-设计一个没有扩容负担的堆结构" class="headerlink" title="9.23 设计一个没有扩容负担的堆结构"></a>9.23 设计一个没有扩容负担的堆结构</h2><p>二叉树</p><h2 id="9-24-随时找到数据流的中位数"><a href="#9-24-随时找到数据流的中位数" class="headerlink" title="9.24 随时找到数据流的中位数"></a>9.24 随时找到数据流的中位数</h2><p>一个大根堆存较小的一半数，一个小根堆存较大的一半数，新的数通过比较堆顶决定加入哪个堆，每次插入后平衡两个堆的大小，保证中位数只和两个堆顶有关</p><h2 id="9-25-在两个长度相等的排序数组中找到上中位数"><a href="#9-25-在两个长度相等的排序数组中找到上中位数" class="headerlink" title="9.25 在两个长度相等的排序数组中找到上中位数"></a>9.25 在两个长度相等的排序数组中找到上中位数</h2><p>两个数组分别二分查找，结果是分成了四段数组，比较 $arr1[mid]$ 和 $arr2[mid]$ ，如果二者相等说明 $arr[mid]$ 就是合并后数组的上中位数，如果 $arr1[mid]&gt;arr2[mid]$ ，说明合并后的数组中， $arr1[mid:right]$ 在最右边， $arr2[left:mid]$ 在最左边，把这两部分排除，对 $arr1[left:mid]$ 和 $arr2[mid:right]$ 继续做二分查找，最终时间 $O(logN)$  </p><h2 id="9-26-在两个排序数组中找到第-K-小的数"><a href="#9-26-在两个排序数组中找到第-K-小的数" class="headerlink" title="9.26 在两个排序数组中找到第 $K$ 小的数"></a>9.26 在两个排序数组中找到第 $K$ 小的数</h2><p>仿照上题，看第 $K$ 小的数出现在哪部分里，每次对新的子数组二分查找要让 $K$ 减去左边排除掉的部分，最终时间 $O(log(min{M,N}))$ ，因为分别在两个数组上二分查找，复杂度由短的决定</p><h2 id="9-27-两个有序数组间相加和的-TOPK-问题"><a href="#9-27-两个有序数组间相加和的-TOPK-问题" class="headerlink" title="9.27 两个有序数组间相加和的 $TOPK$ 问题"></a>9.27 两个有序数组间相加和的 $TOPK$ 问题</h2><p>维护一个大根堆，先把 $arr1[M-1]+arr2[N-1]$ 插入堆，重复以下操作，弹出堆顶，假设是 $arr1[i]+arr2[j]$ ，同时把 $arr1[i-1]+arr2[j]$ 和 $arr1[i]+arr2[j-1]$ 插入堆，也就是每次从堆里弹出一个元素，同时保证还在堆里的元素是数组间相加和最大的几个，每次堆的大小加一，最终大小是 $K$ ，堆插入时间是 $O(logK)$ ，所以总时间 $O(KlogK)$ </p><h2 id="9-28-出现次数的-TOPK-问题"><a href="#9-28-出现次数的-TOPK-问题" class="headerlink" title="9.28 出现次数的 $TOPK$ 问题"></a>9.28 出现次数的 $TOPK$ 问题</h2><p>先用哈希表统计词频，再建立小根堆，堆的节点存储字符串和出现次数，遍历哈希表，依次把每条记录插入堆，当堆的大小是 $K$ 时，只有出现次数比堆顶元素多时才插入，最终堆里的元素就是出现次数 $TOPK$ ，时间 $O(NlogK)$  </p><p>没有数组，字符串动态添加，实时打印：也是维护一个大小为 $K$ 的小根堆，用一个哈希表 $A$ 存储字符串和节点的映射，再用一个哈希表 $B$ 存储节点到堆中位置的映射，每次添加字符串时，先更新 $A$ 中节点的频次属性，如果是新节点直接插入堆，否则然后通过 $B$ 找到节点在堆中的位置，更新节点的频次属性，调整节点的位置，期间保证哈希表和堆的修改同步，最终添加操作 $O(logK)$ ，打印操作直接按位置顺序打印，时间 $O(K)$  </p><h2 id="9-29-Manacher-算法"><a href="#9-29-Manacher-算法" class="headerlink" title="9.29  $Manacher$ 算法"></a>9.29  $Manacher$ 算法</h2><p>单独写</p><h2 id="9-30-KMP-算法"><a href="#9-30-KMP-算法" class="headerlink" title="9.30  $KMP$ 算法"></a>9.30  $KMP$ 算法</h2><p>单独写</p><h2 id="9-31-丢棋子问题"><a href="#9-31-丢棋子问题" class="headerlink" title="9.31 丢棋子问题"></a>9.31 丢棋子问题</h2><p>方法一： $P(N,K)$ 表示 $N$ 层楼有 $K$ 个棋子在最差情况下扔的最少次数，显然 $P(0,K)=0$ ， $P(N,1)=N$ ，一般情况时，当在第 $i$ 层扔下，如果碎了，结果就是 $1+P(i-1,K-1)$ ，如果没碎，结果就是 $1+P(N-i,K)$ ，最差情况是二者的最大值，所以用递归的方法， $P(N,K)=min{max{P(i-1,K-1),P(N-i,K)}}(1\leq i\leq N)+1$ ，时间复杂度 $O(N!)$</p><p>方法二：动态规划， $dp[i][j]=P(i,j)$ ，遍历数组时间 $O(N\times K)$ ，求 $min-max$ 过程 $O(N)$ ，所以总时间 $O(N^2\times K)$   </p><p>优化一：压缩空间， $P(N,K)$  的子问题只遍历 $N$ ，所以对于每个 $dp[i][j]$ 只需要维护左边一列和上边一行空间</p><p>优化二：用四边形不等式优化枚举，楼层数相同时，棋子少越少，第一个棋子扔的层数就越高，棋子数相同时，楼层数越多，第一个棋子扔的层数就越高，所以第一个棋子扔的位置可以作为边界来减少枚举</p><p>$\color{red}{四边形不等式的原理没太看懂}$</p><p>最优解： $map[i][j]$ 表示 $i$ 个棋子扔 $j$ 次最多能判断多高的楼层，第一行第一列直接赋值，扔了第一个棋子后，如果碎了就剩 $i-1$ 个棋子扔 $j-1$ 次，如果没碎就剩 $i$ 个棋子扔 $j-1$ 次，再加上第一次扔的这层，有 $map[i][j]=map[i-1][j-1]+map[i][j-1]+1$ ，之所以不需要 $min-max$ 的过程是因为 $map$ 表示能力的上限，第一次扔完以后要么只向下搜索要么只向上搜索，所以能力值应该是两个方向上的总和，而 $P(N,K)$ 表示运气最差的一种情况，所以必须要通过遍历确定唯一的子问题。在棋子数给定时，只需遍历 $map$ 的一行就能搜索到答案</p><h2 id="9-32-画匠问题"><a href="#9-32-画匠问题" class="headerlink" title="9.32 画匠问题"></a>9.32 画匠问题</h2><p>方法一： $dp[i][j]$ 表示 $i$ 个画家画 $j$ 幅画的最少时间，有 $dp[i][j]=min{max{dp[i-1][k]+sum[k+1..j]}}(0\leq k\leq j)$ ，时间 $O(N^2\times K)$ </p><p>优化：四边形不等式减少枚举，时间 $O(N^2)$  </p><p>最优解：规定每个画匠最大工作时间 $limit$ ，遍历一遍数组可以知道至少需要几个画匠， $limit$ 的范围是 $[0,sum(arr)]$ ，比较 $limit$ 限定下画匠人数与题目给出的人数，用二分法确定 $limit$ 的大小，时间 $O(NlogSum(arr))$   </p><h2 id="9-33-邮局选址问题"><a href="#9-33-邮局选址问题" class="headerlink" title="9.33 邮局选址问题"></a>9.33 邮局选址问题</h2><p>方法一：假设 $arr[i,j]$ 上只能建一个邮局，一定是建在中点上总距离最小， $w[i][j]$ 表示这个总距离，因为 $arr[i,j-1]$ 变成 $arr[i,j]$ 后中点位置不变，所以有 $w[i][j]=w[i][j-1]+arr[j]-arr[(i+j)/2]$ ，多的就是新增的点到中点的距离。 $dp[i][j]$ 表示在 $arr[0,j]$ 上建 $i+1$ 个邮局的最小总距离，首先有 $dp[0][j]=w[0][j]$ ，一般情况下 $dp[i][j]=min{dp[i-1][k]+w[k+1][j]}(0\leq k\leq N)$ ，表示在 $arr[0,k]$ 建 $i-1$ 个，在 $arr[k+1,j]$ 建 $1$ 个，枚举所有情况选择总距离最小的，时间 $O(N^2\times Num)$   </p><p>优化：四边形不等式，时间 $O(N^2)$ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://shivakasu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://shivakasu.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 7：函数装饰器和闭包</title>
    <link href="http://shivakasu.github.io/2019/02/10/fpy4/"/>
    <id>http://shivakasu.github.io/2019/02/10/fpy4/</id>
    <published>2019-02-09T17:56:20.000Z</published>
    <updated>2020-01-15T10:52:15.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、python中的函数装饰器(Function decorator)用来“标记函数”，以某种方式增强函数的行为，其实就是一种语法糖(syntactic sugar)，用来简化复杂的代码。如下：</p><p><a href="https://file.shivakasu.cn/8c1032b5313113d9b58d/fpy4-0.png" data-fancybox="group" data-caption="fpy4-0" class="fancybox"><img alt="fpy4-0" title="fpy4-0" data-src="https://file.shivakasu.cn/8c1032b5313113d9b58d/fpy4-0.png" class="lazyload"></a></p><p>可以用装饰器实现函数的替换，虽然这么做没什么意义：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def deco(func):</span><br><span class="line">...     def inner():</span><br><span class="line">...print(&#39;running inner()&#39;)</span><br><span class="line">...     return inner #1</span><br><span class="line">&gt;&gt;&gt; @deco</span><br><span class="line">... def target(): #2</span><br><span class="line">...     print(&#39;running target()&#39;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; target() #3</span><br><span class="line">running inner()</span><br><span class="line">&gt;&gt;&gt; target #4</span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at 0x10063b598&gt;</span><br></pre></td></tr></table></figure></div></p><p>还可以用作注册函数，对于新增的函数，只需要添加装饰器，而不用手动进行注册：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">registry &#x3D; []</span><br><span class="line"></span><br><span class="line">def register(func):</span><br><span class="line">  print(&#39;running register(%s)&#39; % func) </span><br><span class="line">    registry.append(func)</span><br><span class="line">  return func</span><br><span class="line"></span><br><span class="line">@register</span><br><span class="line">def f1():</span><br><span class="line">    print(&#39;running f1()&#39;)</span><br><span class="line"></span><br><span class="line">@register</span><br><span class="line">def f2():</span><br><span class="line">    print(&#39;running f2()&#39;)</span><br><span class="line"></span><br><span class="line">def f3():</span><br><span class="line">    print(&#39;running f3()&#39;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    print(&#39;running main()&#39;) </span><br><span class="line">    print(&#39;registry -&gt;&#39;, registry) </span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line">    </span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;: </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div></p><p>装饰器在函数定义后立即运行，这通常是在导入(import)时，例如上面代码的执行结果是：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python3 registration.py</span><br><span class="line">running register(&lt;function f1 at 0x100631bf8&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x100631c80&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x100631bf8&gt;, &lt;function f2 at 0x100631c80&gt;] running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure></div></p><p>单独执行import操作，得到的结果是：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import registration</span><br><span class="line">running register(&lt;function f1 at 0x10063b1e0&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x10063b268&gt;)</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;2、闭包(closures)指的是嵌套函数的作用于问题，如图，内层函数可以直接使用上层函数定义的变量，这种变量又叫做自由变量。</p><p><a href="https://file.shivakasu.cn/1a649177761a4cfd26cd/fpy4-1.png" data-fancybox="group" data-caption="fpy4-1" class="fancybox"><img alt="fpy4-1" title="fpy4-1" data-src="https://file.shivakasu.cn/1a649177761a4cfd26cd/fpy4-1.png" class="lazyload"></a></p><p>但自由变量只能使用，如果对自由变量进行赋值，就会被解释器当做局部变量而抛出“变量未定义”的异常，如下，这是由于python不要求像C一样先声明变量再使用变量，所以遇到对非全局变量的赋值操作会直接看作局部变量。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    total &#x3D; 0</span><br><span class="line">    def averager(new_value):</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        total +&#x3D; new_value</span><br><span class="line">        return total &#x2F; count</span><br><span class="line">    return averager</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; avg &#x3D; make_averager()</span><br><span class="line">&gt;&gt;&gt; avg(10)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">UnboundLocalError: local variable &#39;count&#39; referenced before assignment</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></div></p><p>这种情况下不能使用<code>global</code>关键字，因为没有涉及全局变量，而是嵌套函数中因为层次关系产生的相对外层的变量，这时候就要用<code>nonlocal</code>关键字，用法和<code>global</code>一样。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def make_averager():</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    total &#x3D; 0</span><br><span class="line">    def averager(new_value):</span><br><span class="line">        nonlocal count, total</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        total +&#x3D; new_value</span><br><span class="line">        return total &#x2F; count</span><br><span class="line">    return averager</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;3、functools模块有两个实用的装饰器。<code>lru_cache</code>用来缓存函数的中间结果，LRU即Least Recently Used，如下，在计算斐波那契数的递归过程中，计算过的值会保存在缓存中，减少重复计算。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">@functools.lru_cache()</span><br><span class="line">def fibonacci(n):</span><br><span class="line">    if n&lt;2:</span><br><span class="line">        return n</span><br><span class="line">    return fibonacci(n-2) + fibonacci(n-1)</span><br></pre></td></tr></table></figure></div></p><p><code>singledispatch</code>装饰器用来生成泛函数(generic function)，指的是根据函数参数的类型以不同方式执行操作。由于<code>singledispatch</code>只根据函数第一个参数，所以称作单分派泛函数，与之对应的是多分派(multiple-dispatch)。用法如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from functools import singledispatch</span><br><span class="line">from collections import abc</span><br><span class="line">import numbers</span><br><span class="line">import html</span><br><span class="line"></span><br><span class="line">@singledispatch</span><br><span class="line">def htmlize(obj):</span><br><span class="line">    content &#x3D; html.escape(repr(obj))</span><br><span class="line">    return &#39;&lt;pre&gt;&#123;&#125;&lt;&#x2F;pre&gt;&#39;.format(content)</span><br><span class="line"></span><br><span class="line">@htmlize.register(str) </span><br><span class="line">def _(text):        </span><br><span class="line">    content &#x3D; html.escape(text).replace(&#39;\n&#39;, &#39;&lt;br&gt;\n&#39;)</span><br><span class="line">    return &#39;&lt;p&gt;&#123;0&#125;&lt;&#x2F;p&gt;&#39;.format(content)</span><br><span class="line"></span><br><span class="line">@htmlize.register(numbers.Integral)</span><br><span class="line">def _(n):</span><br><span class="line">    return &#39;&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;&#x2F;pre&gt;&#39;.format(n)</span><br><span class="line"></span><br><span class="line">@htmlize.register(tuple)</span><br><span class="line">@htmlize.register(abc.MutableSequence)</span><br><span class="line">def _(seq):</span><br><span class="line">    inner &#x3D; &#39;&lt;&#x2F;li&gt;\n&lt;li&gt;&#39;.join(htmlize(item) for item in seq)</span><br><span class="line">    return &#39;&lt;ul&gt;\n&lt;li&gt;&#39; + inner + &#39;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;&#39;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;4、闭包是静态作用域(static scope)下的概念，与之相对的是动态作用域(dynamic scope)。静态作用域又叫做词法作用域(lexical scope)，C、C++、Python、Java等大多数现在程序设计语言都是采用静态作用域规则，指的是变量的作用域是确定的，词法分析时不会逐层检查函数的调用链，而是检查函数定义时的外部环境，从当前作用域由内而外寻找最近的该变量的定义。动态作用域完全相反，变量的作用域是不确定的，根据函数的调用层次确定变量的定义，也就是说只要在调用函数之前在当前环境重新定义变量，函数就能使用新定义的变量，不关注结构上的层次。个人理解动态作用域的缺点就是变量随意覆盖可能引起意外bug，而且代码中一个变量有多个版本也会大大降低可读性吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 5：一等函数</title>
    <link href="http://shivakasu.github.io/2019/02/10/fpy3/"/>
    <id>http://shivakasu.github.io/2019/02/10/fpy3/</id>
    <published>2019-02-09T16:45:20.000Z</published>
    <updated>2020-01-15T10:51:40.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、在python中，函数是一等对象(first-class object)，一等对象的特征有：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ul><p>接受函数为参数或把函数作为结果返回的函数又叫高阶函数(higher-order function)，常见的高阶函数例如python内置的<code>sorted</code>，其接收一个参数key，当想根据长度排序时，可以写成<code>sorted(xxx,key=len)</code>，这就是把<code>len()</code>函数作为参数传给<code>sorted()</code>。在函数式编程范式中，常用的高阶函数有<code>map</code>、<code>filter</code>、<code>reduce</code>和<code>apply</code>，然而在python中不常用这些函数，因为已经有了更简单的替代方式。</p><ul><li><code>map</code>函数用来求一个序列或者多个序列进行函数映射之后的值，<code>filter</code>函数用来过滤掉序列中不符合函数条件的元素，二者完全可以用列表推导式替代，对应for循环和if条件判定。</li><li><code>reduce</code>函数用来对一个序列进行压缩运算，在python3中已经移到了functools模块，该方法最常用于序列求和，因此可以用python内置的<code>sum</code>函数替代。</li><li><code>apply(func [, args [, kwargs ]])</code>函数用于当函数参数已经存在于一个元组或字典中时，间接地调用函数。因为python本来就支持函数定义中包含不定量参数，所以<code>apply</code>函数反而多此一举，python3中已经移除了。但在第三方库例如pandas中还在使用。</li></ul><p>&emsp;&emsp;2、python中能使用调用符号“()”的对象称为可调用对象(Callable Objects)，有7种可调用对象：</p><ul><li>用户用<code>def</code>或<code>lambda</code>定义的函数</li><li>内置函数：使用C语言实现的函数，如<code>len</code>或<code>time.strftime</code></li><li>内置方法：使用C语言实现的方法，如<code>dict.get</code></li><li>方法：在类的定义体中定义的函数</li><li>类：由于python没有new函数，所以创建实例时直接调用类</li><li>类的实例：如果类定义了<code>__call__</code>方法，它的实例就可以作为函数调用</li><li>生成器函数：使用<code>yield</code>关键字的函数或方法</li></ul><p>&emsp;&emsp;3、有必要理解一下关键字、方法、函数的区别：</p><ul><li>关键字：内置的、具有特殊意义的表示符，使用时不加“()”</li><li>方法：封装了独立的功能，需要用对象调用，对象.方法名(参数)</li><li>函数：也是封装了独立的功能，直接调用或使用模块名调用</li></ul><p>&emsp;&emsp;4、operator模块提供了对函数式编程的支持。例如在使用<code>reduce</code>函数对序列求和时，需要传入一个函数，因此不能直接使用“+”，所以需要另外定义表示加减乘除这类运算的函数，operator模块内置了这些函数，所以就没必要自己定义了。</p><p>&emsp;&emsp;operator模块的<code>itemgetter</code>和<code>attrgetter</code>函数可用于替代从序列中取出元素或读取对象属性的lambda表达式，如下：</p><p><a href="https://file.shivakasu.cn/40f22754538470b8b094/fpy3-0.png" data-fancybox="group" data-caption="fpy3-0" class="fancybox"><img alt="fpy3-0" title="fpy3-0" data-src="https://file.shivakasu.cn/40f22754538470b8b094/fpy3-0.png" class="lazyload"></a></p><p>&emsp;&emsp;5、第六章讲的是用一等函数实现设计模式，思想很简单，因为函数也能作为参数，所以就可以简化代码，不必为了实现特定功能而创建一个类，再用类的实例调用方法，而是可以直接定义函数，把函数作为参数传进方法里调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 3：字典和集合</title>
    <link href="http://shivakasu.github.io/2019/02/07/fpy2/"/>
    <id>http://shivakasu.github.io/2019/02/07/fpy2/</id>
    <published>2019-02-07T07:35:20.000Z</published>
    <updated>2020-01-15T10:51:17.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、collections.abc模块中有Mapping和MutableMapping两个抽象基类，它们的作用是为dict和其他类似的类型定义形式接口。</p><p><a href="https://file.shivakasu.cn/0f9a7c1e0a2a1f236e69/fpy2-0.png" data-fancybox="group" data-caption="fpy2-0" class="fancybox"><img alt="fpy2-0" title="fpy2-0" data-src="https://file.shivakasu.cn/0f9a7c1e0a2a1f236e69/fpy2-0.png" class="lazyload"></a></p><p>&emsp;&emsp;2、标准库里的所有映射类型都是利用dict实现的，只有可散列(hashable)的数据类型才能用作这些映射里的键。如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现<code>__hash__()</code>方法进行散列，也要实现<code>__eq__()</code>方法进行键的比较。python的原子不可变类型(str、bytes和数值类型)是可散列的，一个元组是可散列的当且仅当其包含的元素都是可散列的。所以严格来说不可变类型不都是可散列的，元组不一定。</p><p>&emsp;&emsp;3、和列表推导式类似，字典也有推导构建法：</p><p><a href="https://file.shivakasu.cn/e836fd38437371f66c90/fpy2-1.png" data-fancybox="group" data-caption="fpy2-1" class="fancybox"><img alt="fpy2-1" title="fpy2-1" data-src="https://file.shivakasu.cn/e836fd38437371f66c90/fpy2-1.png" class="lazyload"></a></p><p>&emsp;&emsp;4、处理字典可能找不到键的情况：</p><ul><li>使用<code>setdefault()</code>方法，如下图。这样做的好处是减少了查询字典的次数，如果键不存在，不使用<code>setdefault()</code>就需要查三次字典。</li></ul><p><a href="https://file.shivakasu.cn/46667e1b2d7ac26c5a89/fpy2-2.png" data-fancybox="group" data-caption="fpy2-2" class="fancybox"><img alt="fpy2-2" title="fpy2-2" data-src="https://file.shivakasu.cn/46667e1b2d7ac26c5a89/fpy2-2.png" class="lazyload"></a></p><ul><li><p>使用<code>collections.defaultdict</code>字典，提供一个可调用对象作为参数。例如当用语句<code>index = collections.defaultdict(list)</code>创建字典后，执行<code>index[&#39;new_key&#39;]</code>找不到键，则会自动调用<code>list()</code>方法生成空列表，并以<code>new_key</code>为键添加到字典中，最后返回该列表的引用。</p></li><li><p>上述两种方法的原理都是实现了<code>__missing__</code>方法，字典使用<code>__getitem__</code>方法进行查询，当找不到键时，如果实现了<code>__missing__</code>方法，<code>__getitem__</code>会直接调用，否则抛出异常。原始的dict没有实现<code>__missing__</code>方法，但它知道有了<code>__missing__</code>方法就可以用。所以第三种方法是创建dict的子类，实现<code>__missing__</code>方法。</p></li></ul><p>&emsp;&emsp;5、types模块有一个封装类MappingProxyType，用于返回一个字典的不可变的视图，这个视图是动态的，原字典改变视图也会随之改变，所以如果不想字典在使用过程中被修改，可能会用到这个类。</p><p><a href="https://file.shivakasu.cn/abfb07d5347032214e78/fpy2-3.png" data-fancybox="group" data-caption="fpy2-3" class="fancybox"><img alt="fpy2-3" title="fpy2-3" data-src="https://file.shivakasu.cn/abfb07d5347032214e78/fpy2-3.png" class="lazyload"></a></p><p>&emsp;&emsp;6、python的集合类型有set和frozenset，集合中的元素必须是可散列的，set本身是不可散列的，但frozenset是可散列的。</p><p>&emsp;&emsp;7、set集合除了可以从列表生成，还可以使用集合字面量(set literals)定义。比如<code>s=set([1,2,3])</code>和<code>s={1,2,3}</code>是等价的，但字面量方式更高效。需要注意，空集只能用<code>s=set()</code>生成，字面量形式的<code>s={}</code>是生成空字典。此外，frozenset不支持字面量操作，所以只能从列表生成。由于支持字面量定义，set集合还能用推导式生成，和列表推导式类似，只不过两端是大括号。</p><p>&emsp;&emsp;8、集合类的继承关系如下：</p><p><a href="https://file.shivakasu.cn/86d91f935448abd03439/fpy2-4.png" data-fancybox="group" data-caption="fpy2-4" class="fancybox"><img alt="fpy2-4" title="fpy2-4" data-src="https://file.shivakasu.cn/86d91f935448abd03439/fpy2-4.png" class="lazyload"></a></p><p>&emsp;&emsp;9、dict是用散列表实现的，理论上只要字典不超过内存大小，查询操作耗费的时间都能忽略不计。散列表的查询流程如下，其中bucket指的是散列表中的单元，即表元，dict的每个键值对占用一个表元。由于流程中使用散列值的一部分进行匹配，可能会发生匹配部分相同但整体键不相等，这就叫散列冲突(hash collision)，这时就会取散列值的另一部分再进行匹配。虽然看似效率低下，但散列函数的特性是不相等的对象散列值差别很大，所以实际上发生散列冲突的概率非常小。</p><p><a href="https://file.shivakasu.cn/bdf6d1f9ffd1823a2b1e/fpy2-5.png" data-fancybox="group" data-caption="fpy2-5" class="fancybox"><img alt="fpy2-5" title="fpy2-5" data-src="https://file.shivakasu.cn/bdf6d1f9ffd1823a2b1e/fpy2-5.png" class="lazyload"></a></p><p>&emsp;&emsp;10、字典提供了无视数据量大小的快速访问，代价是空间效率低下，因为散列表必须是稀疏的，需要占用大量空间。此外，不能对字典同时进行迭代和修改，如果往字典里添加新键，解释器可能会做出为字典扩容的决定，将当前散列表迁移到更大的散列表中，在这个过程中对字典进行迭代，可能会出现问题。</p><p>&emsp;&emsp;11、set和frozenset集合也是基于散列表实现的，只不过表元是对单个元素的引用。所以集合类型也有时间效率高、空间效率低的特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 2：序列构成的数组</title>
    <link href="http://shivakasu.github.io/2019/02/06/fpy1/"/>
    <id>http://shivakasu.github.io/2019/02/06/fpy1/</id>
    <published>2019-02-06T15:13:20.000Z</published>
    <updated>2020-01-15T10:49:51.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;1、python标准库用C实现了丰富的序列类型：</p><ul><li>容器序列(Container sequences)：list、tuple、collections.deque这些序列能存放不同类型数据。</li><li>扁平序列(Flat sequences)：str、bytes、bytearray、memoryview、array.array这些序列只能容纳一种类型。</li><li>可变序列(Mutable sequences)：list、bytearray、array.array、collections.deque、memoryview这些序列可以原地修改。</li><li>不可变序列(Immutable sequences)：tuple、str、bytes这些序列不能原地修改。</li></ul><p>&emsp;&emsp;下图是序列对象的继承关系，箭头从子类指向父类，可以看到可变对象之所以能够修改是因为实现了<code>__setitem__</code>、<code>__delitem__</code>等方法。</p><p><a href="https://file.shivakasu.cn/30693800bf9c8aaec269/fpy1-0.png" data-fancybox="group" data-caption="fpy1-0" class="fancybox"><img alt="fpy1-0" title="fpy1-0" data-src="https://file.shivakasu.cn/30693800bf9c8aaec269/fpy1-0.png" class="lazyload"></a></p><p>&emsp;&emsp;2、python会忽略代码里[]、()、{}中的换行，所以写列表推导时直接回车换行，不用加续行符“\”。</p><p>&emsp;&emsp;3、当使用“*”对序列进行复制时，要保证序列里没有对其他可变对象的引用，引用只能浅复制，当修改其中一个引用时，其他的也会改变。如下：</p><p><a href="https://file.shivakasu.cn/5c7b7afa5830505936ad/fpy1-1.png" data-fancybox="group" data-caption="fpy1-1" class="fancybox"><img alt="fpy1-1" title="fpy1-1" data-src="https://file.shivakasu.cn/5c7b7afa5830505936ad/fpy1-1.png" class="lazyload"></a></p><p>&emsp;&emsp;4、不要把可变对象放到元组里，修改元组里的可变对象虽然会抛出异常，但对象可能会真的被修改。</p><p>&emsp;&emsp;5、<code>list.sort()</code>原地排序，<code>sorted()</code>创建新列表排序并返回。</p><p>&emsp;&emsp;6、如果需要一个只包含数字的列表，使用array.array比list更高效，因为list将数字存成python的整形和浮点型，而array.array把数字直接存成机器翻译，也就是字节表述。道理是这样，用的时候还是对比一下速度吧，list、array和numpy的array。</p><p>&emsp;&emsp;7、python内置的排序函数使用了Timsort排序算法。Timsort混合了插入排序和归并排序，因为真实世界中的数据往往带有一定的顺序，所以根据输入的特点进行分区，分区内插入排序，分区间归并排序。</p><p><a href="https://file.shivakasu.cn/07961a9a7b4f7d22bf62/fpy1-2.png" data-fancybox="group" data-caption="fpy1-2" class="fancybox"><img alt="fpy1-2" title="fpy1-2" data-src="https://file.shivakasu.cn/07961a9a7b4f7d22bf62/fpy1-2.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>流畅的Python Chapter 1：Python 数据模型</title>
    <link href="http://shivakasu.github.io/2019/02/04/fpy0/"/>
    <id>http://shivakasu.github.io/2019/02/04/fpy0/</id>
    <published>2019-02-04T07:08:20.000Z</published>
    <updated>2020-01-15T10:49:04.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;这一章写的是python的特殊方法(special method)，又叫作魔术方法(magic method)。最常见的就是面向对象编程时的初始化方法<code>__init__</code>，这类方法的特点有：</p><ul><li>方法名首尾有两个下划线。</li><li>所有特殊方法都是python内置的，使用时只需要在类里重写，最好不要自己定义新的特殊方法。</li><li>特殊方法都与特殊操作绑定，不需要显式调用。如<code>__init__</code>与对象初始化绑定，<code>__len__</code>与<code>len()</code>方法绑定，<code>__add__</code>与<code>+</code>运算绑定。</li></ul><p>&emsp;&emsp;部分特殊方法如下，首先是与运算符无关的特殊方法：<br><a href="https://file.shivakasu.cn/8836120fad62e60bb92d/fpy0-0.png" data-fancybox="group" data-caption="fpy0-0" class="fancybox"><img alt="fpy0-0" title="fpy0-0" data-src="https://file.shivakasu.cn/8836120fad62e60bb92d/fpy0-0.png" class="lazyload"></a></p><p>然后是与运算符有关的特殊方法：<br><a href="https://file.shivakasu.cn/f0816f76a0187e1073fd/fpy0-1.png" data-fancybox="group" data-caption="fpy0-1" class="fancybox"><img alt="fpy0-1" title="fpy0-1" data-src="https://file.shivakasu.cn/f0816f76a0187e1073fd/fpy0-1.png" class="lazyload"></a></p><p>&emsp;&emsp;<code>__repr__</code>和<code>__str__</code>都是用于定义对象的字符串表示形式。区别是前者用于在命令行直接输入一个对象时返回的字符串，后者是调用<code>str()</code>方法或<code>print()</code>时返回的字符串。如果只想实现其中一个特殊方法，就实现<code>__repr__</code>，因为没有<code>__str__</code>时解释器会自动调用<code>__repr__</code>。</p><p>&emsp;&emsp;<code>__bool__</code>用于定义一个对象的真值，如果对象需要参与条件判定的话，可以用<code>bool()</code>方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 6：文档-语言及属性</title>
    <link href="http://shivakasu.github.io/2019/02/03/mir4/"/>
    <id>http://shivakasu.github.io/2019/02/03/mir4/</id>
    <published>2019-02-02T18:20:20.000Z</published>
    <updated>2020-01-15T10:57:35.651Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-文本相似度"><a href="#1-文本相似度" class="headerlink" title="1 文本相似度"></a>1 文本相似度</h2><p>&emsp;&emsp;文本的相似度依靠距离函数度量，距离函数应该是对称的，即不受参数顺序影响，并且应该满足三角不等式：</p><script type="math/tex; mode=display">distance(a,c)\leq distance(a,b)+distance(b,c)</script><p>&emsp;&emsp;常见的距离函数如下：</p><ul><li>海明距离(Hamming distance)：对于相同长度的字符串，定义它们之间的距离为他们拥有不同字符的位置的个数。</li><li>编辑距离(Edit distance)：使两个字符串相同而在其中任何一个字符串上进行字符插入、删除和替换操作的最少次数。如“color”和“colour”的编辑距离是1。编辑距离是处理语法错误的首选模型。</li><li>最长公共子序列(longest common subsequence, LCS)：如“survey”和“surgery”的最长公共子序列是“surey”。</li><li>余弦相似度：第三章提到过。</li><li>类似度(resemblance)：两个文档词汇表的重合度。定义 <script type="math/tex">W(d_j)</script> 是 <script type="math/tex">d_j</script> 中所有不同词的集合，两个文档的类似度定义为：<script type="math/tex; mode=display">R(d_i,d_j)=\frac{|W(d_i)\cap W(d_j)|}{|W(d_i)\cup W(d_j)|}</script></li></ul><p>&emsp;&emsp;任何在 <script type="math/tex">[0,1]</script> 范围内的相似度度量都可以通过以下方式方便地转换为距离函数：</p><script type="math/tex; mode=display">D(d_i,d_j)=1-Sim(d_i,d_j)</script><h2 id="2-文档预处理"><a href="#2-文档预处理" class="headerlink" title="2 文档预处理"></a>2 文档预处理</h2><p>&emsp;&emsp;文档预处理阶段的逻辑视图如下，主要分为五个步骤：<br><a href="https://file.shivakasu.cn/655c2c17308c95635b27/mir4-0.png" data-fancybox="group" data-caption="mir4-0" class="fancybox"><img alt="mir4-0" title="mir4-0" data-src="https://file.shivakasu.cn/655c2c17308c95635b27/mir4-0.png" class="lazyload"></a></p><h3 id="2-1-词汇分析"><a href="#2-1-词汇分析" class="headerlink" title="2.1 词汇分析"></a>2.1 词汇分析</h3><p>&emsp;&emsp;词汇分析(Lexical analysis)是将字符流转化为单词流的过程，就是分词。主要考虑以下几种情况：</p><ul><li>空格(Space)：最常见的分词符。</li><li>数字(Numbers)：根据上下文确定数字代表的意义，如量化数值、时间点，或是“512B.C.”这样的混合词。</li><li>连字符(Hyphens)：要不要拆，像“state-of-the-art”可拆可不拆，像表示序号的“A-3”最好不要拆。</li><li>标点符号(Punctuation marks)：区别对待句间分隔符、词间分隔符和词内分隔符。</li><li>大小写：要不要区分单词大小写，通常会影响到一些专有名词，如人名、地名、组织名。</li></ul><h3 id="2-2-去除停用词"><a href="#2-2-去除停用词" class="headerlink" title="2.2 去除停用词"></a>2.2 去除停用词</h3><p>&emsp;&emsp;停用词(Stopwords)通常是出现频率较多的词，被认为没有什么区分度，常见的是冠词、介词和连词。去除停用词可以减少索引结构的大小，但也会造成召回率的降低，也就是把一些相关的文本删到识别不出。所以有些Web搜索引擎会采用全文检索，不去除停用词。</p><h3 id="2-3-词干提取"><a href="#2-3-词干提取" class="headerlink" title="2.3 词干提取"></a>2.3 词干提取</h3><p>&emsp;&emsp;词干(stem)提取就是所谓的词形还原，把名词复数、动词过去式等还原。我觉得比较靠谱的方法也就是根据语法规则和查词表两种，但是词干提取对检索性能是否有帮助仍然存在争论。</p><h3 id="2-4-关键词选择"><a href="#2-4-关键词选择" class="headerlink" title="2.4 关键词选择"></a>2.4 关键词选择</h3><p>&emsp;&emsp;和全文索引相对立，只选取文本中一部分代表性的词作为索引项，因此这种索引项也叫作关键词。关键词通常都是名词或者名词组，因为名词能够携带更多的信息。</p><h3 id="2-5-同义词典"><a href="#2-5-同义词典" class="headerlink" title="2.5 同义词典"></a>2.5 同义词典</h3><p>&emsp;&emsp;好像没什么用。</p><h2 id="3-组织文档"><a href="#3-组织文档" class="headerlink" title="3 组织文档"></a>3 组织文档</h2><p>&emsp;&emsp;顾名思义，就是文档的组织方式。主要有分类体系法(Taxonomies)和分众分类法(Folksonomies)。</p><p>&emsp;&emsp;分类体系法的核心是层次化，需要有一个清晰的分类层次，也需要对文档的类别有准确的描述，如下图：<br><a href="https://file.shivakasu.cn/8deff9e5f5b1bae97655/mir4-1.png" data-fancybox="group" data-caption="mir4-1" class="fancybox"><img alt="mir4-1" title="mir4-1" data-src="https://file.shivakasu.cn/8deff9e5f5b1bae97655/mir4-1.png" class="lazyload"></a></p><p>&emsp;&emsp;分众分类法的核心是扁平化，最常见的是标签云，如下图。因为不能准确、完全地描述文档，所以只提取一些用户感兴趣的关键词作为标签。<br><a href="https://file.shivakasu.cn/492e5812293591e5228f/mir4-2.png" data-fancybox="group" data-caption="mir4-2" class="fancybox"><img alt="mir4-2" title="mir4-2" data-src="https://file.shivakasu.cn/492e5812293591e5228f/mir4-2.png" class="lazyload"></a></p><h2 id="4-文本压缩"><a href="#4-文本压缩" class="headerlink" title="4 文本压缩"></a>4 文本压缩</h2><p>&emsp;&emsp;文本压缩的目的是减少空间开销、输入/输出开销和通信时延。选择压缩方法时需要考虑的因素有：</p><ul><li>压缩比，即压缩后大小与压缩前大小之比。</li><li>压缩和解压缩的速度，通常解压缩的速度更重要，因为只有在存储文档的时候需要压缩，而后续每次访问文档时都需要进行解压。</li><li>压缩文本是否支持搜索，即检索过程可以直接在压缩文档上进行，不需要预先解压缩，直接搜索压缩文档的速度会更快。</li></ul><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>&emsp;&emsp;文本压缩有两个通用方法：统计方法(statistical)和基于字典的方法(dictionary based)。统计方法估计每个文本符号出现的概率，根据出现概率将文本符号转换为二进制编码。字典方法从文档中识别出一系列可以被引用的短语，短语的集合称为字典，压缩的过程就是把文本中的短语替换成相应字典条目的指针。虽然压缩分为无损压缩和有损压缩，但在文档存储和检索的任务中，使用的基本都是无损压缩。</p><h3 id="4-2-统计方法"><a href="#4-2-统计方法" class="headerlink" title="4.2 统计方法"></a>4.2 统计方法</h3><p>&emsp;&emsp;统计方法定义为两个任务的组合：建模和编码。前者估计每个后续字符的概率，后者把后续符号编码成模型分配给他的概率函数，把每个符号表示成码字(codeword)。统计方法的理论基础是香农的信息论，信息压缩的下界是信息熵，文本的熵定义为：</p><script type="math/tex; mode=display">E=\sum p_ilog_2\frac{1}{p_i}</script><p>也就是出现概率为 <script type="math/tex">p_i</script> 的符号至少需要长度为 <script type="math/tex">log_2\frac{1}{p_i}</script> 的码字表示，由于码字通常是整数个编码单元，实际长度往往会大于这个理论值。同时，编码需要给出现概率高的符号尽可能短的码字，这样才能保证较低的压缩率。</p><h3 id="4-3-统计方法：建模"><a href="#4-3-统计方法：建模" class="headerlink" title="4.3 统计方法：建模"></a>4.3 统计方法：建模</h3><p>&emsp;&emsp;压缩模型分为自适应模型(adaptive model)、静态模型(static model)和半静态模型(semi-static model)。</p><ul><li>自适应模型：不需要关于文本的先验知识，只需要处理文本一遍，在处理过程中根据读入的新文档动态调整字符的概率分布。有两个缺点，一是速度慢，因为需要动态更新，二是只能从压缩文档的开头进行解压，因为关于分布的信息数据实在文件中增量存储的。</li><li>静态模型：对所有输入的文本假设一个分布，只需要处理文本一遍，对所有要压缩的文本都使用这个分布。缺点是不使用，假设的分布在新的文档上往往效果很差。</li><li>半静态模型：不需要假设分布，但是要处理文本两遍。第一遍学习字符的概率分布，第二遍进行压缩，优缺点也很明显。</li></ul><p>&emsp;&emsp;模型的阶(order)指的是用来估计下一个符号的概率而使用的前面符号的个数。 <script type="math/tex">0</script> 阶模型就是所谓的上下文无关模型，每个符号概率的计算都是独立的。高阶模型压缩效果更好，但是需要更大的空间存储和运行，此外，任一位置的解压都需要知道前面 <script type="math/tex">k</script> 个符号，所以高阶模型只能从开头进行解压，不支持随机访问。</p><p>&emsp;&emsp;除了基于字符的模型，还有基于词的模型，也就是直接对单词进行编码。词模型的理论基础是两个统计法则。一是 <script type="math/tex">Heaps</script> 法则，指出 <script type="math/tex">n</script> 个词的自然语言文本的词汇表大小 <script type="math/tex">V</script> 的增长是 <script type="math/tex">V=O(n^\beta)</script> ，其中 <script type="math/tex">\beta <1</script> 是一个依赖于特定文本的常数。第二个法则是 <script type="math/tex">Zipf</script> 法则，指出最常出现的第 <script type="math/tex">i</script> 个单词出现 <script type="math/tex">O(n/i^\alpha)</script> 次，其中 <script type="math/tex">\alpha >1</script> 是依赖于文本的常数。这两个法则保证了基于词的模型不会产生量级的爆炸，同时概率分布具有良好的偏斜性。</p><h3 id="4-4-统计方法：编码"><a href="#4-4-统计方法：编码" class="headerlink" title="4.4 统计方法：编码"></a>4.4 统计方法：编码</h3><p>&emsp;&emsp;霍夫曼编码(Huffman coding)是基于二叉树的前缀无关编码，通常使用霍夫曼树的规范树(canonical tree)形式，规范树规定任何结点的右子树不能高于他的左子树，因此给出有序的叶节点可以方便地还原规范树的结构。霍夫曼编码的缺点是只能从开头解码，因此不支持随机检索，例如考虑以下编码：A(0)、B(10)、C(110)、D(111)，若随机检索到编码片段 “11110”，就无法确定是“DB”还是开头少了一个1的“DC”，也就是两个码字的结合包含了第三个码字。更严谨的说法是不支持从任意位置解码，支持从任意码字的开头进行解码，虽然这么说没什么意义吧。</p><p>&emsp;&emsp;字节霍夫曼编码(Byte-Huffman coding)是基于词的模型，使用字节代替位进行编码，因此编码树不是二叉树，而是256叉树。好像用的不是很多。</p><p>&emsp;&emsp;密集编码(Dense coding)也是基于字节的编码，如下图，其中“<128>”指的是该字节的值是128。密集编码比字节霍夫曼编码更简单，在各个方面都优于字节霍夫曼编码，更重要的是密集编码支持从任意位置解码。因为密集编码可以很好地区分码头和码尾，整个字节的识别是很简单的，而观察到密集编码的结束字节值是在128到255之间的，这种属性称作自同步(self-synchronizing)，结束的字节称为停止符，之前的所有字节都称为持续符。更广义的密集编码记作 <script type="math/tex">(s,c)</script> 密集编码，不把128作为持续符和停止符的界限，只要保证 <script type="math/tex">s+c=256</script> ，可以修改为 <script type="math/tex">c</script> 个持续符和 <script type="math/tex">s</script> 个停止符，选择最优的组合。<br><a href="https://file.shivakasu.cn/041fc0ed18d81d8d73cc/mir4-3.png" data-fancybox="group" data-caption="mir4-3" class="fancybox"><img alt="mir4-3" title="mir4-3" data-src="https://file.shivakasu.cn/041fc0ed18d81d8d73cc/mir4-3.png" class="lazyload"></a></128></p><p>&emsp;&emsp;算术编码，只写了一段，细节太少，没看懂。</p><h3 id="4-5-字典方法"><a href="#4-5-字典方法" class="headerlink" title="4.5 字典方法"></a>4.5 字典方法</h3><p>&emsp;&emsp;字典方法就不区分建模和编码的环节了，核心就是查字典而已。唯一需要考虑的问题是如何选择字典条目，同样也分成静态、半静态和自适应的方法，缺点也和上面说的类似。静态方法泛化性差，自适应方法的代表是 Ziv-Lempel 算法，字典随着压缩过程动态创建，问题就是不支持随机访问，半静态的方法最好，代表是 Re-Pair 算法。 Re-Pair 算法的核心简单说就是消除所有的重复符号对，首先给每个符号赋予一个整数，如果有重复的整数对“AB”，就用新的整数“C”替换“AB”，替换规则也可以嵌套，比如“CD”又重复了，就用“E”替换“CD”。缺点其实就是半静态方法的缺点，慢。</p><h3 id="4-6-压缩预处理"><a href="#4-6-压缩预处理" class="headerlink" title="4.6 压缩预处理"></a>4.6 压缩预处理</h3><p>&emsp;&emsp;文本压缩的最新趋势是压缩前的预处理，比较著名的方法是 Burrows-Wheeler 变换，简称BWT。流程就看下面两张图，原始字符串是“mississippi$”，其中“$”是可以是别的特殊终结符。首先列出原始字符串循环移位的矩阵，矩阵的每一行是上一行左移一位后的字符串。然后根据矩阵第一列按字典序排序，排序后矩阵的最后一列就是变换后的字符串。BWT的优点有两个，一是可逆，根据变换后的字符串可以还原出原始字符串，二是能够保证原始字符串中重复出现的字符可以在变换后的字符串中连续出现或至少离得比较近，图中的例子不太明显，比如“SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES”经过变换后成了“TEXYDST.E.IXIXIXXSSMPPS.B..E.S.EUSFXDIIOIIIT”，就很明显了。<br><a href="https://file.shivakasu.cn/e409e20e6c49f4193eca/mir4-4.png" data-fancybox="group" data-caption="mir4-4" class="fancybox"><img alt="mir4-4" title="mir4-4" data-src="https://file.shivakasu.cn/e409e20e6c49f4193eca/mir4-4.png" class="lazyload"></a><br><a href="https://file.shivakasu.cn/a900368af7421d8f37f4/mir4-5.png" data-fancybox="group" data-caption="mir4-5" class="fancybox"><img alt="mir4-5" title="mir4-5" data-src="https://file.shivakasu.cn/a900368af7421d8f37f4/mir4-5.png" class="lazyload"></a></p><h3 id="4-7-压缩方法的比较"><a href="#4-7-压缩方法的比较" class="headerlink" title="4.7 压缩方法的比较"></a>4.7 压缩方法的比较</h3><p><a href="https://file.shivakasu.cn/566ac26954b7e304e60d/mir4-6.png" data-fancybox="group" data-caption="mir4-6" class="fancybox"><img alt="mir4-6" title="mir4-6" data-src="https://file.shivakasu.cn/566ac26954b7e304e60d/mir4-6.png" class="lazyload"></a></p><h3 id="4-8-结构化文本压缩"><a href="#4-8-结构化文本压缩" class="headerlink" title="4.8 结构化文本压缩"></a>4.8 结构化文本压缩</h3><p>&emsp;&emsp;结构化文本就是XML一类的文本，区分属性、元素这种层次。压缩方法其实就是根据文本的结构修改或者组合上面提到的这些方法，本质上没什么特别的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 4：检索评价</title>
    <link href="http://shivakasu.github.io/2019/02/01/mir3/"/>
    <id>http://shivakasu.github.io/2019/02/01/mir3/</id>
    <published>2019-02-01T10:09:20.000Z</published>
    <updated>2020-01-15T10:56:03.630Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>&emsp;&emsp;检索评价针对信息检索系统响应用户查询的返回结果，系统化地给出了一个量化的指标。这个指标应该和检索结果与用户的相关性直接联系。计算这个指标的通常方法是，对于给定的一组查询，比较由系统产生的结果和由人产生的结果。这里的检索评价仅针对检索系统的结果质量，不考虑界面设计、系统性能等因素的影响。</p><h2 id="2-检索指标"><a href="#2-检索指标" class="headerlink" title="2 检索指标"></a>2 检索指标</h2><h3 id="2-1-精度和召回率"><a href="#2-1-精度和召回率" class="headerlink" title="2.1 精度和召回率"></a>2.1 精度和召回率</h3><p>&emsp;&emsp;精度(Precison)是检出文档中相关文档的比例，召回率(Recall)是相关文档集中被检出的比率。将相关文档集记作 <script type="math/tex">R</script> ，系统得出的结果集为 <script type="math/tex">A</script> ，则：</p><script type="math/tex; mode=display">精度=p=\frac{|R\cap A|}{|A|}</script><script type="math/tex; mode=display">召回率=r=\frac{|R\cap A|}{|R|}</script><p>以横坐标为召回率，纵坐标为精度可绘制精度-召回率曲线，曲线下面积(Area Unser the Curve, AUC)可用于评估不同答案集的质量，面积越大表明质量越好。</p><p>&emsp;&emsp;缺点：</p><ul><li>召回率无法准确估计。</li><li>精度和召回率是相关联的指标，将二者结合为单一指标会更合适。</li><li>只能度量批处理状态下对一组查询进行处理的结果。</li><li>对于只需要弱偏序关系的系统来说，精度和召回率可能不适合。(?)</li></ul><h3 id="2-2-单值总结"><a href="#2-2-单值总结" class="headerlink" title="2.2 单值总结"></a>2.2 单值总结</h3><p>&emsp;&emsp;(1) 前 <script type="math/tex">n</script> 平均精度 <script type="math/tex">P@n</script> ：大部分搜索不需要高的召回率，绝大部分用户只需要顶部的几篇相关文档，通常计算前5篇或前10篇文档的平均精度(不管是相关还是不相关)， <script type="math/tex">P@n</script> 提供了可靠的指标来评价Web搜索引擎的用户是否在排序的顶部得到了相关文档。</p><p>&emsp;&emsp;(2) 平均精度均值(Mean Average Precision, MAP)：通过对每个新观察到的相关文档计算精度并做平均来得到关于排序的总结性的单一指标。查询 <script type="math/tex">q_i</script> 的平均精度定义为：</p><script type="math/tex; mode=display">MAP_i=\frac{1}{|R_i|}\sum_{k=1}^{|R_i|}P(R_i[k])</script><p>其中 <script type="math/tex">R_i</script> 是 <script type="math/tex">q_i</script> 对应的相关文档的集合， <script type="math/tex">P(R_i[k])</script> 是从头遍历结果集的排序队列直到观察到 <script type="math/tex">R_i</script> 中第 <script type="math/tex">k</script> 篇文档时的精度，如果没有观察到就记作0。此外，在一组查询上的平均精度均值定义为：</p><script type="math/tex; mode=display">MAP=\frac{1}{|N_q|}\sum_{i=1}^{|N_q|}MAP_i</script><p>其中 <script type="math/tex">N_q</script> 是查询的总数目。</p><p>&emsp;&emsp;(3) <script type="math/tex">R</script> 精度：设当前查询的相关文档集 <script type="math/tex">R</script> 的容量为 <script type="math/tex">n</script> ，取排序队列的前 <script type="math/tex">n</script> 篇文档计算精度，简单粗暴。但是对于一组查询，计算每个查询的 <script type="math/tex">R</script> 精度再取平均效果可能不好。</p><p>&emsp;&emsp;(4) 精度直方图：核心思想就是对于一组查询，可以分别比较每个查询在不同算法上的 <script type="math/tex">R</script> 精度，来比较两个算法的检索质量，废话。</p><p>&emsp;&emsp;(5) 平均排序倒数：适用于QA系统、特定主页查询等任务，更关注第一个正确的结果，而不是整个排序的结果集。设 <script type="math/tex">R_i</script> 是相对于查询 <script type="math/tex">q_i</script> 的排序， <script type="math/tex">S_{correct}(R_i)</script> 函数返回在 <script type="math/tex">R_i</script> 中第一个正确答案的位置，给定一个排序位置阈值 <script type="math/tex">S_h</script> ， <script type="math/tex">R_i</script> 的排序倒数定义为：</p><script type="math/tex; mode=display">\begin{cases}\frac{1}{S_{correct}(R_i)} & S_{correct}(R_i)\leq S_h \\0 & otherwise\end{cases}</script><p>对于由 <script type="math/tex">N_q</script> 个查询组成的集合 <script type="math/tex">Q</script> 来说，平均排序倒数(Mean Reciproach Rank, MRR)是所有排序倒数的均值，即：</p><script type="math/tex; mode=display">MRR(Q)=\frac{1}{N_q}\cdot\sum_{i=1}^{N_q}\frac{1}{S_{correct}(R_i)}</script><script type="math/tex; mode=display">MRR$$ 是倾向于那些第一个正确的结果出现在排序顶部的指标。&emsp;&emsp;(6) E值：结合精度和召回率，公式为：$$E(j)=1-\frac{1+b^2}{\frac{b^2}{r(j)}+\frac{1}{P(j)}}</script><p>其中 <script type="math/tex">r(j)</script> 是在排序中第 <script type="math/tex">j</script> 个位置的召回率， <script type="math/tex">P(j)</script> 是在排序中第 <script type="math/tex">j</script> 个位置的精度， <script type="math/tex">b(b\geq 0)</script> 是用户定义的参数。</p><p>&emsp;&emsp;(7) F值：同样是结合精度和召回率，公式为：</p><script type="math/tex; mode=display">F(j)=\frac{2}{\frac{1}{r(j)}+\frac{1}{P(j)}}</script><p>注意到，当E值的 <script type="math/tex">b=1</script> 时， <script type="math/tex">F(j)=1-E(j)</script> 。</p><p>&emsp;&emsp;(8) 摘要统计表：就是把查询数、文档数等统计特征列个表，没什么用。</p><h3 id="2-3-面向用户的指标"><a href="#2-3-面向用户的指标" class="headerlink" title="2.3 面向用户的指标"></a>2.3 面向用户的指标</h3><p>&emsp;&emsp;在相关文档集 <script type="math/tex">R</script> 和结果集 <script type="math/tex">A</script> 之外，考虑用户的认知范围，即用户已知的文档 <script type="math/tex">K</script> ，如下图：<br><a href="https://file.shivakasu.cn/33c0aa6ab8cd06c8bce7/mir3-0.png" data-fancybox="group" data-caption="mir3-0" class="fancybox"><img alt="mir3-0" title="mir3-0" data-src="https://file.shivakasu.cn/33c0aa6ab8cd06c8bce7/mir3-0.png" class="lazyload"></a></p><p>定义覆盖率为：</p><script type="math/tex; mode=display">coverage=\frac{|K\cap R\cap A|}{|K\cap R|}</script><p>定义新颖率为：</p><script type="math/tex; mode=display">novelty=\frac{|(R\cap A)-K|}{|K\cap R|}</script><p>高覆盖率表明系统找到了用户期望看到的大部分相关文档，高新颖率表明系统向用户展示了许多之前未知的新的相关文档。</p><h3 id="2-4-折扣累计增益"><a href="#2-4-折扣累计增益" class="headerlink" title="2.4 折扣累计增益"></a>2.4 折扣累计增益</h3><p>&emsp;&emsp;上述基于相关文档集和结果集计算的指标只考虑文档与查询的相关与否，而没有考虑到相关性的强弱。当检查查询的结果时，可以观察到两个重要的现象：</p><ul><li>在排序的顶部我们更希望是高度相关的文档，而不是轻度相关的文档。</li><li>出现在排序底部的相关文档的价值不高。</li></ul><p>&emsp;&emsp;针对第一个现象，赋予每个相关文档相关性强度，0表示不相关，值越大表示相关性越强，对系统返回的排序列表，增益向量(gain vector) <script type="math/tex">G</script> 定义为其中每个元素的相关性强度组成的向量，如：</p><script type="math/tex; mode=display">G=(1,0,1,0,0,3,0,0,0,2,0,0,0,0,3)</script><p>累计增益(Cumulated Gain) $CG$ 定义为：</p><script type="math/tex; mode=display">CG[i]=\begin{cases}G[1] & i=1 \\G[i]+CG[i-1] & i>1\end{cases}</script><p>则对于上面的增益向量：</p><script type="math/tex; mode=display">CG=(1,1,2,2,2,5,5,5,5,7,7,7,7,7,10)</script><p>&emsp;&emsp;针对第二个问题，按照文档在排序列表中的位置进行价值衰减，定义折扣累计增益(Discounted Cumulated Gain) $DCG$ 为：</p><script type="math/tex; mode=display">DCG[i]=\begin{cases}G[1] & i=1 \\\frac{G[i]}{log_2i}+DCG[i-1] & i>1\end{cases}</script><p>则对于上面的增益向量：</p><script type="math/tex; mode=display">DCG=(1.0,1.0,1.6,1.6,1.6,2.8,2.8,2.8,2.8,3.4,3.4,3.4,3.4,3.4,4.2)</script><p>同理，对于由多个查询组成的集合，可计算平均累计增益 <script type="math/tex">\overline{CG}</script> 和平均折扣累计增益 <script type="math/tex">\overline{DCG}</script> 。</p><p>&emsp;&emsp;由于累计增益没有参照，定义理想 <script type="math/tex">CG</script> 和 <script type="math/tex">DCG</script> 为最优排序列表得到的结果，即文档相关性强度从大到小排列，记作 <script type="math/tex">ICG</script> 和 <script type="math/tex">IDCG</script> 。将原始的 <script type="math/tex">CG</script> 和 <script type="math/tex">DCG</script> 进行归一化：</p><script type="math/tex; mode=display">NCG[i]=\frac{\overline{CG[i]}}{\overline{ICG[i]}}</script><script type="math/tex; mode=display">NDCG[i]=\frac{\overline{DCG[i]}}{\overline{IDCG[i]}}</script><p>得到了在区间 <script type="math/tex">[0,1]</script> 上的累计增益指标，可用于不同排序算法之间的比较。</p><h3 id="2-5-二元偏好"><a href="#2-5-二元偏好" class="headerlink" title="2.5 二元偏好"></a>2.5 二元偏好</h3><p>&emsp;&emsp;Todo</p><h3 id="2-6-排序相关性测度"><a href="#2-6-排序相关性测度" class="headerlink" title="2.6 排序相关性测度"></a>2.6 排序相关性测度</h3><p>&emsp;&emsp;当没有参照或没有评测人员时，很难计算出上述指标，则可以直接度量两个排序函数产生的结果的相关性，若对其中一个排序函数有一定的了解，就可以根据二者的相关性分析另一个排序函数的优劣。</p><p>&emsp;&emsp;斯皮尔曼系数(Spearman coefficient)根据相同文档在不同排序中的位置差值计算相关性。设 <script type="math/tex">s_{1,j}</script> 是文档 <script type="math/tex">d_j</script> 在排序 <script type="math/tex">R_1</script> 中的位置， <script type="math/tex">s_{2,j}</script> 是文档 <script type="math/tex">d_j</script> 在排序 <script type="math/tex">R_2</script> 中的位置，则位置差值是 <script type="math/tex">|s_{1,j}-s_{2,j}|</script> ，或计算差值平方和 <script type="math/tex">(s_{1,j}-s_{2,j})^2</script> 。如果有K篇排序文档，对排序差值求平方和，则差值平方和的最大值是 <script type="math/tex">\frac{K\times(K^2-1)}{3}</script> ，即两个排序互为反序。使用该最大值进行差值平方和的归一化，即：</p><script type="math/tex; mode=display">\frac{\sum_{j=1}^K(s_{1,j}-s_{2,j})^2}{\frac{K\times(K^2-1)}{3}}</script><p>将该分式乘2，再用1减去结果，就得到了在区间 <script type="math/tex">[-1,1]</script> 上的斯皮尔曼系数：</p><script type="math/tex; mode=display">S(R_1,R_2)=1-\frac{6\times\sum_{j=1}^K(s_{1,j}-s_{2,j})^2}{K\times(K^2-1)}</script><p>值越大表明相关性越强。然而，通常两个排序文档集的大小和内容是不同的，这时的做法是取并集，将 <script type="math/tex">R_2</script> 中不属于 <script type="math/tex">R_1</script> 的文档添加在 <script type="math/tex">R_1</script> 尾部，同时将 <script type="math/tex">R_1</script> 中不属于 <script type="math/tex">R_2</script> 的文档添加在 <script type="math/tex">R_2</script> 尾部，之后再对这两个增广排序计算斯皮尔曼系数。</p><p>&emsp;&emsp;肯德尔系数(Kendall Tau coefficient)比斯皮尔曼系数代数结构简单，有更清楚和直观的解释。给定两篇文档 <script type="math/tex">d_j</script> 和 <script type="math/tex">d_k</script> ，若在两个排序列表 <script type="math/tex">R_1</script> 和 <script type="math/tex">R_2</script> 中， <script type="math/tex">s_{1,j}-s_{1,k}</script> 和 <script type="math/tex">s_{2,j}-s_{2,k}</script> 同号，那么就说文档二元组 <script type="math/tex">[d_j,d_k]</script> 在这两个排序中是协调的，反之则是不协调的。如果有K篇排序文档，则共有 <script type="math/tex">K(K-1)</script> 个文档二元组，肯德尔系数定义为：</p><script type="math/tex; mode=display">\tau(R_1,R_2)=1-\frac{2\times\Delta(R_1,R_2)}{K(K-1)}</script><p>和斯皮尔曼系数的形式是几近相同的，当两个排序文档集不同时，也可以用相同的方式增广排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 3：信息检索建模</title>
    <link href="http://shivakasu.github.io/2019/01/24/mir2/"/>
    <id>http://shivakasu.github.io/2019/01/24/mir2/</id>
    <published>2019-01-24T05:40:20.000Z</published>
    <updated>2020-01-15T10:55:43.840Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-信息检索模型"><a href="#1-信息检索模型" class="headerlink" title="1 信息检索模型"></a>1 信息检索模型</h2><p>&emsp;&emsp;信息检索模型是一个四元组 <script type="math/tex">[D,Q,F,R(q_i,d_i)]</script> 。其中D(Document)是文档表示的集合，Q(Query)是查询表示的集合，F(Framework)是对文档、查询及其关系建模的框架，例如布尔框架、线性框架，R(Ranking)是排序函数，对于查询表达式 <script type="math/tex">q_i\in Q</script> 和文档表达式 <script type="math/tex">d_i\in D</script> ，函数返回文档 <script type="math/tex">d_i</script> 关于查询<script type="math/tex">q_i</script>的文档次序。</p><p>&emsp;&emsp;信息检索主要基于文本，文本模型也细分为是否考虑文本结构，所谓考虑文本结构就是区别对待标题、段落等文档不同结构处的内容。在web中，由于文档数量巨大，还需要考虑网页之间的链接，如今的web排序函数结合了经典的信息检索模型和基于链接模型的特征来提高检索性能。信息检索还可基于图像、音频等多媒体数据，检索策略更复杂。信息检索模型的分类体系见下图：<br><a href="https://file.shivakasu.cn/648d8d4d85d3f6ed9f89/mir2-0.png" data-fancybox="group" data-caption="mir2-0" class="fancybox"><img alt="mir2-0" title="mir2-0" data-src="https://file.shivakasu.cn/648d8d4d85d3f6ed9f89/mir2-0.png" class="lazyload"></a></p><h2 id="2-经典信息检索"><a href="#2-经典信息检索" class="headerlink" title="2 经典信息检索"></a>2 经典信息检索</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><ul><li>索引项(index term)：文档里的一个词或一组连续的词，主要是名词，因为名词相比于形容词、副词等往往能包含更多信息，具体的选择策略因人而异。</li><li>词汇表(vocabulary)： <script type="math/tex">V=(k_1,k_2,\cdots ,k_t)</script> ，其中 <script type="math/tex">t</script> 是文档集中索引项的数量， <script type="math/tex">k_i</script> 是某个索引项。</li><li>文档表示：就是简单的词袋方法，表示成和词汇表一样长的向量，其中每个元素是0或1，0表示对应的索引项在文档中未出现，1表示对应的索引项在文档中出现。</li><li>查询表示：和文档表示相同，每个元素表示相应索引项是否在查询中出现。</li><li>项-文档矩阵：行数是索引项个数，列数是文档个数，元素 <script type="math/tex">f_{i,j}</script> 表示第 <script type="math/tex">i</script> 个索引项在第 <script type="math/tex">j</script> 个文档中出现的频数。显然，在词袋方法中是0-1矩阵。</li><li>文档的逻辑视图：大概就是表示文档的方式。通常是把文档全文转变成索引项集合，流程如下图：<br><a href="https://file.shivakasu.cn/4433d3fae9363c920f64/mir2-1.png" data-fancybox="group" data-caption="mir2-1" class="fancybox"><img alt="mir2-1" title="mir2-1" data-src="https://file.shivakasu.cn/4433d3fae9363c920f64/mir2-1.png" class="lazyload"></a></li></ul><h3 id="2-2-布尔模型"><a href="#2-2-布尔模型" class="headerlink" title="2.2 布尔模型"></a>2.2 布尔模型</h3><p>&emsp;&emsp;使用词袋方法表示文档，用析取范式(disjunct normal form)表示查询。例如对于词汇表 <script type="math/tex">V=(k_a,k_b,k_c,k_d)</script> 和查询 <script type="math/tex">q=k_a\wedge (k_b\vee k_c)</script> ，用析取范式表示查询为：</p><script type="math/tex; mode=display">q_{DNF}=(1,1,1,0)\vee(1,1,1,1)\vee(1,1,0,0)\vee(1,1,0,1)\vee(1,0,0,0)\vee(1,0,0,1)</script><p>文档与查询的相关度定义为析取范式中是否有一项与文档表示相同，因此也是二值的。</p><p>&emsp;&emsp;布尔模型的优点是简单，缺点是不支持排序。因为相关度是二值的，只能表示相关与否，而不能表示相关的程度。</p><h3 id="2-3-项权重"><a href="#2-3-项权重" class="headerlink" title="2.3 项权重"></a>2.3 项权重</h3><p>&emsp;&emsp;提高检索质量的一个方法是给每个索引项设置权重，通常根据索引项在整个文档集中出现的频次设置权重。如果不假设索引项之间相互独立，还要考虑索引项之间的相关性，因为索引项之间的关联往往会反映文档之间的关联，一种计算项间相关性的方法是项-文档矩阵乘他的转置矩阵，如下图：<br><a href="https://file.shivakasu.cn/0149fd92db89c2e04630/mir2-2.png" data-fancybox="group" data-caption="mir2-2" class="fancybox"><img alt="mir2-2" title="mir2-2" data-src="https://file.shivakasu.cn/0149fd92db89c2e04630/mir2-2.png" class="lazyload"></a><br>假设项间相互独立可以简化模型、提高计算效率，而利用项间相关性提高排序水平也是十分复杂的工作，考虑了项间相关性并不能保证排序水平的提高，因此是否假设项间相互独立没有固定的标准。</p><h3 id="2-4-TD-IDF"><a href="#2-4-TD-IDF" class="headerlink" title="2.4 TD-IDF"></a>2.4 TD-IDF</h3><p>&emsp;&emsp;TF-IDF是一个常用的计算项权重的指标，其中TF(Term frequency)表示项频，IDF(Inverse document frequency)表示反比文档频率。</p><p>&emsp;&emsp;使用项频是基于Luhn假设，即高频项对描述文档的关键主题是重要的。可以直接将索引项的频次作为TF权重，即 <script type="math/tex">tf_{i,j}=f_{i,j}</script> ，但考虑到要与IDF权重结合，而IDF使用了对数运算，因此通常使用TF权重的一个变种：</p><script type="math/tex; mode=display">tf_{i,j}=\begin{cases}1+log_2f_{i,j} & f_{i,j}>0 \\0 & otherwise\end{cases}</script><p>&emsp;&emsp;TF权重倾向于给频次高的索引项更大的权重，但也要考虑索引项的区分度，即索引项特异性(term specificity)。如果一个索引项在每个文档中都出现，虽然出现频次高，但是对于文档排序等任务没有太大帮助，最常见的就是a、the这样的冠词、连词和介词。因此不仅要考虑高频项，还要考虑区分度大的索引项。IDF权重考虑的就是某个索引项在多少个文档中出现，即相对文档频率 <script type="math/tex">n_i/N</script> ， <script type="math/tex">IDF_i=log_2\frac{N}{n_i}</script> ，其中 <script type="math/tex">N</script> 是文档集中的文档数量， <script type="math/tex">n_i</script> 是出现索引项 <script type="math/tex">k_i</script> 的文档数量，因为相对文档频率越小的索引项区分度越大，所以IDF使用了相对文档频率的倒数，称作反比文档频率。</p><p>&emsp;&emsp;TF-IDF将二者结合起来，计算方法如下：</p><script type="math/tex; mode=display">w_{i,j}=\begin{cases}(1+log_2f_{i,j})*log_2\frac{N}{n_i} & f_{i,j}>0 \\0 & otherwise\end{cases}</script><p>&emsp;&emsp;TF、IDF和TF-IDF有多种变体。TF变体如下：<br><a href="https://file.shivakasu.cn/6a3557149d63d9d07c8d/mir2-3.png" data-fancybox="group" data-caption="mir2-3" class="fancybox"><img alt="mir2-3" title="mir2-3" data-src="https://file.shivakasu.cn/6a3557149d63d9d07c8d/mir2-3.png" class="lazyload"></a></p><p>IDF变体如下：<br><a href="https://file.shivakasu.cn/9b5b06f2b588a7e7566c/mir2-4.png" data-fancybox="group" data-caption="mir2-4" class="fancybox"><img alt="mir2-4" title="mir2-4" data-src="https://file.shivakasu.cn/9b5b06f2b588a7e7566c/mir2-4.png" class="lazyload"></a></p><p>TF-IDF变体如下：<br><a href="https://file.shivakasu.cn/4a396f3ce65a26f1b49a/mir2-5.png" data-fancybox="group" data-caption="mir2-5" class="fancybox"><img alt="mir2-5" title="mir2-5" data-src="https://file.shivakasu.cn/4a396f3ce65a26f1b49a/mir2-5.png" class="lazyload"></a></p><p>&emsp;&emsp;通过下图可以分析出TF-IDF的性质。TF和IDF权重表现出的幂律特性会相互平衡，高TF权重趋于和低IDF权重结合，低TF权重趋于和高IDF权重结合，结果是TF-IDF权重最高的索引项往往具有中等TF和IDF权重，而项频太高的项和文档频率太低的项经过平衡后都具有较低的TF-IDF权重。妙啊！<br><a href="https://file.shivakasu.cn/ded9527fd90145d96807/mir2-6.png" data-fancybox="group" data-caption="mir2-6" class="fancybox"><img alt="mir2-6" title="mir2-6" data-src="https://file.shivakasu.cn/ded9527fd90145d96807/mir2-6.png" class="lazyload"></a></p><h3 id="2-5-文档长度归一化"><a href="#2-5-文档长度归一化" class="headerlink" title="2.5 文档长度归一化"></a>2.5 文档长度归一化</h3><p>&emsp;&emsp;对于给定的查询，较长的文档仅仅因为包含更多的索引项而更可能被检出，为了消除这一影响，可以把文档的排序除以其长度，这个过程称为文档长度归一化，如何计算文档长度取决于文档的表示形式。</p><h3 id="2-6-向量模型"><a href="#2-6-向量模型" class="headerlink" title="2.6 向量模型"></a>2.6 向量模型</h3><p>&emsp;&emsp;布尔模型使用析取范式的每一项和文档表示进行严格匹配，难以得到理想的结果。向量模型将文档和查询表示为向量形式，使用向量夹角的余弦值衡量相似度，成功将相似度量化为可用于比较和排序的数值，基于相似度的排序可以理解为一种部分匹配策略。文档的向量表示为 <script type="math/tex">\vec{d_j}=(w_{1,j},w_{2,j},\cdots,w_{t,j})</script> ，其中 <script type="math/tex">t</script> 是索引项总个数， <script type="math/tex">w_{i,j}</script>是项-文档对 <script type="math/tex">(k_i,d_j)</script> 的权重，一般采用TF-IDF权重，查询的向量表示为 <script type="math/tex">\vec{q}=(w_{1,q},w_{2,q},\cdots,w_{t,q})</script> , <script type="math/tex">w_{i,q}</script>是项-查询对 <script type="math/tex">(k_i,q)</script> 的权重。文档-查询余弦相似度公式为：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{\vec{d_j}\cdot\vec{q}}{|\vec{d_j}|\times|\vec{q}|}</script><p>注意到余弦公式分母的向量范数恰好也起到了文档长度归一化的作用。</p><h3 id="2-7-概率模型"><a href="#2-7-概率模型" class="headerlink" title="2.7 概率模型"></a>2.7 概率模型</h3><p>&emsp;&emsp;概率模型的目标是估计文档与查询相关的概率，他假定这种相关性仅依赖于文档和查询本身的表示，并假定存在一个理想答案集，仅包含所有与查询相关的文档，因此能够最大化与用户相关的总体概率。显然，这种假设是对真实情况的简化，所以必然会存在一些缺陷。</p><p>&emsp;&emsp;概率模型计算相关度的公式是：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{P(R|\vec{d_j})}{P(\overline{R}|\vec{d_j})}</script><p>其中 <script type="math/tex">R</script> 是与查询 <script type="math/tex">q</script> 相关的文档的集合， <script type="math/tex">\overline{R}</script> 是与查询 <script type="math/tex">q</script> 不相关的文档的集合， <script type="math/tex">P(R|\vec{d_j})</script>是文档 <script type="math/tex">d_j</script> 与查询 <script type="math/tex">q</script> 相关的概率， <script type="math/tex">P(\overline{R}|\vec{d_j})</script>是文档 <script type="math/tex">d_j</script> 与查询 <script type="math/tex">q</script> 不相关的概率。根据贝叶斯公式：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{P(\vec{d_j}|R,q)\times P(R,q)}{P(\vec{d_j}|\overline{R},q)\times P(\overline{R},q)}\sim\frac{P(\vec{d_j}|R,q)}{P(\vec{d_j}|\overline{R},q)}</script><p>其中 <script type="math/tex">P(\vec{d_j}|R,q)</script> 表示从查询 <script type="math/tex">q</script> 的相关文档集 <script type="math/tex">R</script> 中随机选择的一偏文档表示为 <script type="math/tex">\vec{d_j}</script> 的概率， <script type="math/tex">P(R,q)</script> 表示从整个文档集中随机选择的文档和查询 <script type="math/tex">q</script> 相关的概率， <script type="math/tex">P(\vec{d_j}|\overline{R},q)</script> 和 <script type="math/tex">P(\overline{R},q)</script> 的含义是相似且互补的。概率模型中不考虑项权重，所以 <script type="math/tex">\vec{d_j}</script> 是一个二值向量，如果假设索引项间的独立性，即所谓的二值独立假设，可以得到：</p><script type="math/tex; mode=display">sim(d_j,q)\sim\frac{(\prod_{k_i|w_{i,j}=1}p_{iR})\times(\prod_{k_i|w_{i,j}=0}(1-p_{iR}))}{(\prod_{k_i|w_{i,j}=1}q_{iR})\times(\prod_{k_i|w_{i,j}=0}(1-q_{iR}))}</script><p>其中 <script type="math/tex">p_{iR}</script> 表示索引项 <script type="math/tex">k_i</script> 出现在从查询 <script type="math/tex">q</script> 的相关文档集 <script type="math/tex">R</script> 中随机选择的一偏文档内的概率， <script type="math/tex">q_{iR}</script> 表示索引项 <script type="math/tex">k_i</script> 出现在从查询 <script type="math/tex">q</script> 的不相关文档集 <script type="math/tex">\overline{R}</script> 中随机选择的一偏文档内的概率。使用对数函数只改变数值而不改变排序结果，所以可以进一步简化为：</p><script type="math/tex; mode=display">sim(d_j,q)\sim\sum_{k_i\in q\wedge k_i\in d_j}log(\frac{p_{iR}}{1-p_{iR}})+log(\frac{1-q_{iR}}{q_{iR}})</script><p>得到了相似度公式，接下来就是如何计算 <script type="math/tex">p_{iR}</script> 和 <script type="math/tex">q_{iR}</script> 。</p><p>&emsp;&emsp;一种计算方法是使用索引项出现列联表，如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">相关文档数</th><th style="text-align:center">不相关文档数</th><th style="text-align:center">总文档数</th></tr></thead><tbody><tr><td style="text-align:center">包含 $k_i$ 的文档</td><td style="text-align:center">$r_i$</td><td style="text-align:center">$n_i-r_i$</td><td style="text-align:center">$n_i$</td></tr><tr><td style="text-align:center">不包含 $k_i$ 的文档</td><td style="text-align:center">$R-r_i$</td><td style="text-align:center">$N-n_i-(R-r_i)$</td><td style="text-align:center">$N-n_i$</td></tr><tr><td style="text-align:center">所有文档</td><td style="text-align:center">$R$</td><td style="text-align:center">$N-R$</td><td style="text-align:center">$N$</td></tr></tbody></table></div><p>那么可以得到，</p><script type="math/tex; mode=display">p_{iR}=\frac{r_i}{R}\quad, \quad q_{iR}=\frac{n_i-r_i}{N-R}</script><script type="math/tex; mode=display">sim(d_j,q)\sim\sum_{k_i\in q\wedge k_i\in d_j}log(\frac{(r_i+0.5)(N-n_i-R+r_i+0.5)}{(R-r_i+0.5)(n_i-r_i+0.5)})</script><p>之所以给每个包含 <script type="math/tex">r_i</script> 的项加0.5，是为了减小极端情况下过小的 <script type="math/tex">r_i</script> 对 <script type="math/tex">log</script> 计算的影响。这种方法需要人工估计 <script type="math/tex">r_i</script> 和 <script type="math/tex">R</script> 值，所以不实用，同时缺少文档长度归一化的操作，使得排序效果也不是很好。</p><p>&emsp;&emsp;另一种方法是在避免人工估计的条件下，基于几条假设来自动更新 <script type="math/tex">r_i</script> 和 <script type="math/tex">R</script> 值，个人认为这里的假设太牵强，理解不了。</p><p>&emsp;&emsp;概率模型的优点是能按照相关概率进行排序，但其认为相关性仅与文档和查询的内容有关，所以实际应用时效果难以保证。此外，概率模型不可避免地要做初始估计将文档分为相关和不相关集合，不太好操作。观察上面计算 <script type="math/tex">sim(d_j,q)</script> 的公式，与IDF权重的公式是相似的，从这个角度看，概率模型的另一个缺点是没有用到TF特征，也没有进行文档长度归一化。</p><h2 id="3-其他集合论模型"><a href="#3-其他集合论模型" class="headerlink" title="3 其他集合论模型"></a>3 其他集合论模型</h2><h3 id="3-1-基于集合的模型"><a href="#3-1-基于集合的模型" class="headerlink" title="3.1 基于集合的模型"></a>3.1 基于集合的模型</h3><p>&emsp;&emsp;基于集合的模型不考虑单独的索引项，而是考虑索引项之间的相互依赖性，通过引入项集的概念表示索引项之间的关联。</p><p>&emsp;&emsp;项集(Termset)：项集 <script type="math/tex">S_i=\{k_a,k_b,\cdots,k_n\}</script> 是文档集中索引项的子集。若 <script type="math/tex">S_i</script> 中所有的索引项都出现在文档 <script type="math/tex">d_j</script> 中，就称项集 <script type="math/tex">S_i</script> 出现在 <script type="math/tex">d_j</script> 中。</p><p>&emsp;&emsp;显然，若文档集中有 <script type="math/tex">t</script> 个索引项，则理论上有 <script type="math/tex">2^t</script> 个项集，但实际数据集中一般仅包含部分项集。同时，用项集表示替代索引项表示就需要把项的词汇表改为项集的词汇表，即 <script type="math/tex">V_S=\{S_1,S_2,\cdots,S_{2^t}\}</script> 。</p><p>&emsp;&emsp;频繁项集(Frequent termsets)：由 <script type="math/tex">n</script> 个项构成的项集称为 <script type="math/tex">n</script> 项集，如果包含某个 <script type="math/tex">n</script> 项集的文档数 <script type="math/tex">\mathcal{N}_i</script> 高于某个给定的阈值，那么这个 <script type="math/tex">n</script> 项集 <script type="math/tex">S_i</script> 称为是频繁的。显然，一个 <script type="math/tex">n</script> 项集是频繁的当且仅当他的所有 <script type="math/tex">(n-1)</script> 项集都是频繁地。</p><p>&emsp;&emsp;在TF-IDF中，计算的权重是项-文档矩阵的元素，在集合模型中与之类似，计算的权重是项集-文档矩阵的元素。对于 <script type="math/tex">(S_i,d_j)</script> ，令 <script type="math/tex">N</script> 是文档集中文档总数，<script type="math/tex">\mathcal{F}_{i,j}</script> 是项集 <script type="math/tex">S_i</script> 在文档 <script type="math/tex">d_j</script> 中的原始出现频率，赋予项集权重：</p><script type="math/tex; mode=display">\mathcal{W}_{i,j}=\begin{cases}(1+log_2\mathcal{F}_{i,j})*log_2(1+\frac{N}{\mathcal{N}_i}) & \mathcal{F}_{i,j}>0 \\0 & otherwise\end{cases}</script><p>同理， <script type="math/tex">\vec{d_j}=(\mathcal{W}_{1,j},\mathcal{W}_{2,j},\cdots,\mathcal{W}_{2^t,j})</script> ， <script type="math/tex">\vec{q}=(\mathcal{W}_{1,q},\mathcal{W}_{2,q},\cdots,\mathcal{W}_{2^t,q})</script>，相似度计算公式为：</p><script type="math/tex; mode=display">sim(d_j,q)=\frac{\vec{d_j}\cdot\vec{q}}{|\vec{d_j}|\times|\vec{q}|}=\frac{\sum_{S_i}\mathcal{W}_{i,j}\times\mathcal{W}_{i,q}}{|\vec{d_j}|\times|\vec{q}|}</script><p>由于项集空间是项空间的指数级大小，所以相似度的计算十分复杂，需要进行计算简化。例如在计算向量范数时只考虑 <script type="math/tex">1</script> 项集。或是进一步缩小项集的范围，只考虑频繁闭项集，闭项集(Closed termset)就是项集的闭包，比如项集 <script type="math/tex">\{k_1\}</script> 、 <script type="math/tex">\{k_2\}</script> 、 <script type="math/tex">\{k_1,k_2\}</script>出现在相同的文档子集中，那么可以只计算 <script type="math/tex">\{k_1,k_2\}</script>，大大减小了计算量，除了频繁闭项集，还可选择最大频繁集，即添加任何索引项都不能使其保持频繁性。从项集数目上看，频繁项集&gt;频繁闭项集&gt;最大频繁集，需要注意的是，减少计算必然伴随着信息的损失，因此需要根据实际情况进行权衡。</p><h3 id="3-2-扩展布尔模型"><a href="#3-2-扩展布尔模型" class="headerlink" title="3.2 扩展布尔模型"></a>3.2 扩展布尔模型</h3><p>&emsp;&emsp;用向量模型的特征扩展布尔模型，狗尾续貂？</p><h3 id="3-3-模糊集模型"><a href="#3-3-模糊集模型" class="headerlink" title="3.3 模糊集模型"></a>3.3 模糊集模型</h3><p>&emsp;&emsp;模糊集模型基于模糊集理论，对于每一个索引项 <script type="math/tex">k_i</script> ，为其分配一个模糊集(fuzzy set) <script type="math/tex">D_i</script> ，模糊集为每一个文档 <script type="math/tex">d_j</script> 分配一个介于区间 <script type="math/tex">[0,1]</script> 之间的隶属度(degree of membership)  <script type="math/tex">\mu_{i,j}</script> ，若 <script type="math/tex">\mu_{i,j}\sim 1</script> 表明 <script type="math/tex">k_i</script> 是 <script type="math/tex">d_j</script> 的良好模糊索引项，若 <script type="math/tex">\mu_{i,j}\sim 0</script> 表明 <script type="math/tex">k_i</script> 不是 <script type="math/tex">d_j</script> 的良好模糊索引项。隶属度可以通过项间相关性矩阵 <script type="math/tex">C</script> 来计算，索引项 <script type="math/tex">k_i</script> 和 <script type="math/tex">k_l</script> 的相关性计算公式为：</p><script type="math/tex; mode=display">c_{i,l}=\frac{n_{i,l}}{n_i+n_l-n_{i,l}}</script><p>其中 <script type="math/tex">n_i</script> 是含有索引项 <script type="math/tex">k_i</script> 的文档数， <script type="math/tex">n_l</script> 是含有索引项 <script type="math/tex">k_l</script> 的文档数， <script type="math/tex">n_{i,l}</script> 是同时含有这两个索引项的文档数，这种相关性度量被广泛应用在聚类算法中。有了相关性度量，就可以计算隶属度：</p><script type="math/tex; mode=display">\mu_{i,j}=1-\prod_{k_l\in d_j}(1-c_{i,l})</script><p>这其实就是在考虑 <script type="math/tex">k_i</script> 和 <script type="math/tex">d_j</script> 中每一个索引项的相关性，可以看出，只要 <script type="math/tex">d_j</script> 中至少有一个索引项 <script type="math/tex">k_l</script> 与 <script type="math/tex">k_i</script> 关系密切(即 <script type="math/tex">c_{i,l}\sim 1</script> )，则 <script type="math/tex">\mu_{i,j}\sim 1</script> 。此外，采用代数和的方式计算而不是对所有相关性使用 <script type="math/tex">max</script> 函数，可以使 <script type="math/tex">\mu_{i,j}</script> 的值变得平滑。</p><p>&emsp;&emsp;有了文档相对索引项的隶属度，就可以进一步计算文档相对于查询的隶属度，因为借鉴布尔模型的方法，查询可以表示成索引项组成的逻辑表达式。例如对于查询 <script type="math/tex">q=k_a\wedge (k_b\vee\neg k_c)</script> ，可以写成析取范式 <script type="math/tex">\vec{q}_{dnf}=(1,1,1)\vee(1,1,0)\vee(1,0,0)</script> ，设 <script type="math/tex">D_a</script> 、 <script type="math/tex">D_b</script> 、 <script type="math/tex">D_c</script> 分别是 <script type="math/tex">k_a</script> 、 <script type="math/tex">k_b</script> 、 <script type="math/tex">k_c</script> 的模糊集，查询的模糊集 <script type="math/tex">D_q</script> 可以从下图理解：<br><a href="https://file.shivakasu.cn/3d166e41cb81bea90ac8/mir2-7.png" data-fancybox="group" data-caption="mir2-7" class="fancybox"><img alt="mir2-7" title="mir2-7" data-src="https://file.shivakasu.cn/3d166e41cb81bea90ac8/mir2-7.png" class="lazyload"></a><br>其中， <script type="math/tex">cc_1=\mu_{a,j}\mu_{b,j}\mu_{c,j}</script> 、 <script type="math/tex">cc_2=\mu_{a,j}\mu_{b,j}(1-\mu_{c,j})</script> 、 <script type="math/tex">cc_3=\mu_{a,j}(1-\mu_{b,j})(1-\mu_{c,j})</script> ，则：</p><script type="math/tex; mode=display">\mu_{q,j}=1-\prod_{i=1}^3(1-cc_i)</script><p>同样，采用代数和的方式计算而不是对所有相关性使用 <script type="math/tex">max</script> 函数，可以使<script type="math/tex">\mu_{q,j}</script> 的值变得平滑。</p><h2 id="4-其他代数模型"><a href="#4-其他代数模型" class="headerlink" title="4 其他代数模型"></a>4 其他代数模型</h2><h3 id="4-1-广义向量空间模型"><a href="#4-1-广义向量空间模型" class="headerlink" title="4.1 广义向量空间模型"></a>4.1 广义向量空间模型</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 2：用户搜索界面</title>
    <link href="http://shivakasu.github.io/2019/01/19/mir1/"/>
    <id>http://shivakasu.github.io/2019/01/19/mir1/</id>
    <published>2019-01-19T09:26:20.000Z</published>
    <updated>2020-01-10T04:09:24.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="人们如何搜索"><a href="#人们如何搜索" class="headerlink" title="人们如何搜索"></a>人们如何搜索</h3><ul><li><p>信息查找(information lookup)类似于事实检索或问题回答，只需要简短而离散的信息。</p></li><li><p>探索式搜索(exploratory search)分为学习和调查两类，需要花费更长的时间并整合更多内容。</p></li><li><p>信息搜寻过程是由一系列相互关联但又不完全相同的搜索所组成的，搜索带来的主要价值体现在搜索过程中持续的学习和所获得的信息，而不只是最后的搜索结果。</p></li><li><p>信息搜寻过程的经典模型：明确问题-&gt;表达信息需求-&gt;构造查询-&gt;评价结果。经典模型假设用户的信息需求是静态的，最近的模型强调搜索过程的动态性，认为用户会根据搜索结果动态调整信息需求，这种动态过程有时称为搜索的采摘模型(berry picking model)。例如，用户给出一个快速、不精确的查询，近似得到信息空间的一部分内容，再进行一系列本地导航操作，从而获得更贴近用户兴趣的信息。有些搜索模型关注搜索策略，对搜索策略建模，预测用户的搜索行为。</p></li><li><p>除了传统的搜索框查询，还可以使用导航界面，让用户通过浏览导航和点击链接搜寻信息。</p></li></ul><h3 id="现今的搜索界面"><a href="#现今的搜索界面" class="headerlink" title="现今的搜索界面"></a>现今的搜索界面</h3><ul><li><p>启动搜寻：通常使用Web搜索引擎。导航网站逐渐被淘汰，一是因为网络规模变大，无法手动构造目录，二是因为Web搜索的精度提高。</p></li><li><p>查询描述：解析查询项，Web排序</p></li><li><p>查询描述界面：搜索框placeholder提示，自动补全建议列表。根据用户搜索历史或其他用户的热门搜索。</p></li><li><p>检索结果显示：文档摘要，查询项高亮。</p></li><li><p>查询重构：拼写校对或建议，相关查询项推荐。</p></li><li><p>组织搜索结果：分类和聚类。区别在于是否需要人工组织层次结构。</p></li></ul><p>(这章真的是看不下去了，一个搜索界面说了这么多废话，太无聊了)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>现代信息检索 Chapter 1：引言</title>
    <link href="http://shivakasu.github.io/2019/01/18/mir0/"/>
    <id>http://shivakasu.github.io/2019/01/18/mir0/</id>
    <published>2019-01-18T08:36:26.000Z</published>
    <updated>2020-01-15T10:53:20.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>信息检索涉及对文档、网页、联机目录、结构化和半结构化记录及多媒体对象等信息项的表示、存储、组织和访问。信息项的表示和组织必须便于用户访问他们感兴趣的信息。</p></li><li><p>信息检索发展的关键阶段：书籍-&gt;图书馆-&gt;索引-&gt;计算机-&gt;排序技术和搜索引擎等现代研究内容</p></li><li><p>信息检索系统的主要目标是检出所有和用户查询相关的文档，并且把检出的不相关文档控制在最低限度。相关性的概念对信息检索至关重要。对相关性的评估没有固定标准，不存在能在任何时间给任何用户提供完美答案的检索系统。</p></li><li><p>检索任务可分为浏览和搜索，浏览是探索式检索，目标不太明确，搜索则相反。</p></li><li><p>信息检索系统的高层软件架构：<br><a href="https://file.shivakasu.cn/6ffe81624404da41f82a/mir0-0.png" data-fancybox="group" data-caption="mir0-0" class="fancybox"><img alt="mir0-0" title="mir0-0" data-src="https://file.shivakasu.cn/6ffe81624404da41f82a/mir0-0.png" class="lazyload"></a></p></li><li><p>文档的索引、检索和排序过程：<br><a href="https://file.shivakasu.cn/69f58a9d8db7b0682f6e/mir0-1.png" data-fancybox="group" data-caption="mir0-1" class="fancybox"><img alt="mir0-1" title="mir0-1" data-src="https://file.shivakasu.cn/69f58a9d8db7b0682f6e/mir0-1.png" class="lazyload"></a></p></li><li><p>Web流行的根源：出版自由。</p></li><li><p>Web对搜索的影响：网页爬取新技术，海量文档集和海量查询流量，相关性预测更复杂，从文字搜索转向结构化数据搜索，垃圾信息泛滥。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shivakasu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机理论" scheme="http://shivakasu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>解决 anaconda3 安装 xgboost：/usr/lib/libstdc++.so.6：version &#39;GLIBCXX_3.4.14&#39; not found问题</title>
    <link href="http://shivakasu.github.io/2017/07/01/bugfix0/"/>
    <id>http://shivakasu.github.io/2017/07/01/bugfix0/</id>
    <published>2017-07-01T15:00:20.000Z</published>
    <updated>2020-01-10T04:11:29.079Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda install libgcc</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda中关于Qt的bug</title>
    <link href="http://shivakasu.github.io/2016/10/27/bugfix3/"/>
    <id>http://shivakasu.github.io/2016/10/27/bugfix3/</id>
    <published>2016-10-27T12:59:20.000Z</published>
    <updated>2020-01-10T04:11:10.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>先安装了anaconda，可以使用。<br>之后使用conda命令安装了Orange，由于Orange会安装Qt，可能会导致与anaconda自带的Qt冲突，然后我惊喜的发现anaconda-navigator打不开了，报出以下错误：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;bin&#x2F;anaconda-navigator&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    import anaconda_navigator.app.main</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#x2F;anaconda_navigator&#x2F;app&#x2F;main.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    from anaconda_navigator.widgets.dialogs.splash import SplashScreen</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#x2F;anaconda_navigator&#x2F;widgets&#x2F;__init__.py&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    from anaconda_navigator.utils.analytics import GATracker</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shiva&#x2F;anaconda3&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#x2F;anaconda_navigator&#x2F;utils&#x2F;analytics.py&quot;, line 33, in &lt;module&gt;</span><br><span class="line">    from qtpy.QtCore import QT_VERSION_STR, QObject, QThread, QTimer, Signal</span><br><span class="line">ImportError: cannot import name &#39;QT_VERSION_STR&#39;</span><br></pre></td></tr></table></figure></div><p>参照了<a href="https://github.com/ContinuumIO/anaconda-issues/issues/1095的解决方法成功修复，具体方法是：" target="_blank" rel="noopener">https://github.com/ContinuumIO/anaconda-issues/issues/1095的解决方法成功修复，具体方法是：</a><br>打开 /anaconda3/pkgs/anaconda-navigator-1.2.3-py35_0/lib/python3.5/site-packages/anaconda_navigator/utils/analytics.py<br>把</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from qtpy.QtCore import QT_VERSION_STRING , QObject, QThread, QTimer, Signal</span><br></pre></td></tr></table></figure></div><p>改成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from qtpy.QtCore import __version__ as qt_version , QObject, QThread, QTimer, Signal</span><br></pre></td></tr></table></figure></div><p>把</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.info &#x3D; &#123;&#39;python&#39;: python_version, &#39;language&#39;: self.get_language(),</span><br><span class="line">             &#39;os&#39;: operating_system, &#39;version&#39;: app_version,</span><br><span class="line">             &#39;platform&#39;: self.api.conda_platform(),</span><br><span class="line">             &#39;qt&#39;: QT_VERSION_STR, &#39;pyqt&#39;: pyqt_version,</span><br><span class="line">             &#39;conda&#39;: conda_version&#125;</span><br></pre></td></tr></table></figure></div><p>改成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.info &#x3D; &#123;&#39;python&#39;: python_version, &#39;language&#39;: self.get_language(),</span><br><span class="line">             &#39;os&#39;: operating_system, &#39;version&#39;: app_version,</span><br><span class="line">             &#39;platform&#39;: self.api.conda_platform(),</span><br><span class="line">             &#39;qt&#39;: qt_version, &#39;pyqt&#39;: pyqt_version,</span><br><span class="line">             &#39;conda&#39;: conda_version&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下安装scrapy遇到的问题及解决过程</title>
    <link href="http://shivakasu.github.io/2016/10/07/bugfix2/"/>
    <id>http://shivakasu.github.io/2016/10/07/bugfix2/</id>
    <published>2016-10-06T16:13:20.000Z</published>
    <updated>2020-01-10T04:11:16.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用 pip install scrapy 来安装scrapy时，遇到以下输出：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collecting cffi&gt;&#x3D;1.4.1 (from cryptography&gt;&#x3D;1.3.4-&gt;pyOpenSSL-&gt;scrapy)</span><br><span class="line">  Downloading cffi-1.8.3-cp27-cp27mu-manylinux1_x86_64.whl (386kB)</span><br><span class="line">    100% |████████████████████████████████| 389kB 454kB&#x2F;s </span><br><span class="line">Collecting pycparser (from cffi&gt;&#x3D;1.4.1-&gt;cryptography&gt;&#x3D;1.3.4-&gt;pyOpenSSL-&gt;scrapy)</span><br><span class="line">  Downloading pycparser-2.14.tar.gz (223kB)</span><br><span class="line">    100% |████████████████████████████████| 225kB 609kB&#x2F;s </span><br><span class="line">Building wheels for collected packages: Twisted, PyDispatcher, cryptography, zope.interface, pycparser</span><br><span class="line">  Running setup.py bdist_wheel for Twisted ... done</span><br><span class="line">  Stored in directory: &#x2F;home&#x2F;shiva&#x2F;.cache&#x2F;pip&#x2F;wheels&#x2F;0e&#x2F;53&#x2F;62&#x2F;e7b4cea7df9113fb2818b224eb5d143be981568d9c43057a0a</span><br><span class="line">  Running setup.py bdist_wheel for PyDispatcher ... done</span><br><span class="line">  Stored in directory: &#x2F;home&#x2F;shiva&#x2F;.cache&#x2F;pip&#x2F;wheels&#x2F;86&#x2F;02&#x2F;a1&#x2F;5857c77600a28813aaf0f66d4e4568f50c9f133277a4122411</span><br><span class="line">  Running setup.py bdist_wheel for cryptography ... error</span><br><span class="line">  Complete output from command &#x2F;usr&#x2F;bin&#x2F;python -u -c &quot;import setuptools, tokenize;__file__&#x3D;&#39;&#x2F;tmp&#x2F;pip-build-UDAHL4&#x2F;cryptography&#x2F;setup.py&#39;;exec(compile(getattr(tokenize, &#39;open&#39;, open)(__file__).read().replace(&#39;\r\n&#39;, &#39;\n&#39;), __file__, &#39;exec&#39;))</span><br></pre></td></tr></table></figure></div><p>可以看到是在安装cryptography时出的问题，报错信息为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build&#x2F;temp.linux-x86_64-2.7&#x2F;_openssl.c:433:30: fatal error: openssl&#x2F;opensslv.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure></div><p>于是又可以追踪到是openssl的问题，通过百度安装过程，发现执行以下命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libssl-dev</span><br></pre></td></tr></table></figure></div><p>即可解决报错问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Python" scheme="http://shivakasu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决安装rails时出现 ERROR：Failed to build gem native extension. 的问题</title>
    <link href="http://shivakasu.github.io/2016/10/03/bugfix1/"/>
    <id>http://shivakasu.github.io/2016/10/03/bugfix1/</id>
    <published>2016-10-03T10:36:20.000Z</published>
    <updated>2020-01-10T04:11:22.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>执行 gem install rails 时出现了错误，错误信息如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Fetching: pkg-config-1.1.7.gem (100%)</span><br><span class="line">Successfully installed pkg-config-1.1.7</span><br><span class="line">Fetching: nokogiri-1.6.8.gem (100%)</span><br><span class="line">Building native extensions.  This could take a while...</span><br><span class="line">ERROR:  Error installing rails:</span><br><span class="line">ERROR: Failed to build gem native extension.</span><br><span class="line"></span><br><span class="line">    current directory: &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;nokogiri-1.6.8&#x2F;ext&#x2F;nokogiri</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby2.3 -r .&#x2F;siteconf20161003-4423-1bf9irh.rb extconf.rb</span><br><span class="line">Using pkg-config version 1.1.7</span><br><span class="line">checking if the C compiler accepts ... yes</span><br><span class="line">Building nokogiri using packaged libraries.</span><br><span class="line">Using mini_portile version 2.1.0</span><br><span class="line">checking for gzdopen() in -lz... no</span><br><span class="line">zlib is missing; necessary for building libxml2</span><br><span class="line">*** extconf.rb failed ***</span><br><span class="line">Could not create Makefile due to some reason, probably lack of necessary</span><br><span class="line">libraries and&#x2F;or headers.  Check the mkmf.log file for more details.  You may</span><br><span class="line">need configuration options.</span><br><span class="line"></span><br><span class="line">Provided configuration options:</span><br><span class="line">--with-opt-dir</span><br><span class="line">--without-opt-dir</span><br><span class="line">--with-opt-include</span><br><span class="line">--without-opt-include&#x3D;$&#123;opt-dir&#125;&#x2F;include</span><br><span class="line">--with-opt-lib</span><br><span class="line">--without-opt-lib&#x3D;$&#123;opt-dir&#125;&#x2F;lib</span><br><span class="line">--with-make-prog</span><br><span class="line">--without-make-prog</span><br><span class="line">--srcdir&#x3D;.</span><br><span class="line">--curdir</span><br><span class="line">--ruby&#x3D;&#x2F;usr&#x2F;bin&#x2F;$(RUBY_BASE_NAME)2.3</span><br><span class="line">--help</span><br><span class="line">--clean</span><br><span class="line">--use-system-libraries</span><br><span class="line">--enable-static</span><br><span class="line">--disable-static</span><br><span class="line">--with-zlib-dir</span><br><span class="line">--without-zlib-dir</span><br><span class="line">--with-zlib-include</span><br><span class="line">--without-zlib-include&#x3D;$&#123;zlib-dir&#125;&#x2F;include</span><br><span class="line">--with-zlib-lib</span><br><span class="line">--without-zlib-lib&#x3D;$&#123;zlib-dir&#125;&#x2F;lib</span><br><span class="line">--enable-cross-build</span><br><span class="line">--disable-cross-build</span><br><span class="line"></span><br><span class="line">To see why this extension failed to compile, please check the mkmf.log which can be found here:</span><br><span class="line"></span><br><span class="line">  &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;extensions&#x2F;x86_64-linux&#x2F;2.3.0&#x2F;nokogiri-1.6.8&#x2F;mkmf.log</span><br><span class="line"></span><br><span class="line">extconf failed, exit code 1</span><br><span class="line"></span><br><span class="line">Gem files will remain installed in &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;gems&#x2F;nokogiri-1.6.8 for inspection.</span><br><span class="line">Results logged to &#x2F;var&#x2F;lib&#x2F;gems&#x2F;2.3.0&#x2F;extensions&#x2F;x86_64-linux&#x2F;2.3.0&#x2F;nokogiri-1.6.8&#x2F;gem_make.out</span><br></pre></td></tr></table></figure></div><p>可以看出是在安装nokogiri时遇到了问题，此时执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libxml2-dev libxslt-dev</span><br></pre></td></tr></table></figure></div><p>即可解决问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="bugfix" scheme="http://shivakasu.github.io/categories/bugfix/"/>
    
    
      <category term="Rails" scheme="http://shivakasu.github.io/tags/Rails/"/>
    
  </entry>
  
</feed>
