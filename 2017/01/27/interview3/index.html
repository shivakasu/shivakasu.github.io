<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>无聊的知识点之 Python | SHIVAKASU</title><meta name="description" content="Python2 &amp; Python3 py2的不等于可以用 !&#x3D; 和 &lt;&gt; 。py3 只能用 !&#x3D;  py2的 print 是特殊语句，不用加括号。py3的 print 是函数，必须加括号。 py2默认编码是ASCII。py3默认编码是utf-8。使用 print sys.getdefaultencoding() 可以查看。 py2有Unicode数据类型，py3取消了。 py2"><meta name="keywords" content="面试,Python"><meta name="author" content="w.k.x.,wkx1996@foxmail.com"><meta name="copyright" content="w.k.x."><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://file.shivakasu.cn/eb8581b76ec032ab0db8/favicon.ico"><link rel="canonical" href="https://shivakasu.cn/2017/01/27/interview3/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="无聊的知识点之 Python"><meta property="og:url" content="https://shivakasu.cn/2017/01/27/interview3/"><meta property="og:site_name" content="SHIVAKASU"><meta property="og:description" content="Python2 &amp; Python3 py2的不等于可以用 !&#x3D; 和 &lt;&gt; 。py3 只能用 !&#x3D;  py2的 print 是特殊语句，不用加括号。py3的 print 是函数，必须加括号。 py2默认编码是ASCII。py3默认编码是utf-8。使用 print sys.getdefaultencoding() 可以查看。 py2有Unicode数据类型，py3取消了。 py2"><meta property="og:image" content="https://file.shivakasu.cn/2e594da7dae7aed97c58/python.jpg"><meta property="article:published_time" content="2017-01-26T16:43:20.000Z"><meta property="article:modified_time" content="2017-01-27T15:34:20.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="无聊的知识点之大数据" href="https://shivakasu.cn/2017/01/28/interview5/"><link rel="next" title="无聊的知识点之数据库" href="https://shivakasu.cn/2017/01/26/interview4/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: w.k.x.","link":"链接: ","source":"来源: SHIVAKASU","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: true    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="SHIVAKASU" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://file.shivakasu.cn/cb7049104af4685e7289/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">46</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python2-amp-Python3"><span class="toc-text">Python2 &amp; Python3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-中的作用域"><span class="toc-text">Python 中的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包-Closure"><span class="toc-text">闭包(Closure)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包的使用"><span class="toc-text">闭包的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包调用自由变量的原理"><span class="toc-text">闭包调用自由变量的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包的优点"><span class="toc-text">闭包的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包的应用"><span class="toc-text">闭包的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰器"><span class="toc-text">装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包的一种应用"><span class="toc-text">闭包的一种应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装饰器-1"><span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向切片编程"><span class="toc-text">面向切片编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC"><span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引用计数"><span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-清理"><span class="toc-text">标记-清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代回收"><span class="toc-text">分代回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GIL"><span class="toc-text">GIL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GIL-是什么？"><span class="toc-text">GIL 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么没有移除-GIL？"><span class="toc-text">为什么没有移除 GIL？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程的替代方案"><span class="toc-text">多线程的替代方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#鸭子类型-Duck-Typing"><span class="toc-text">鸭子类型(Duck Typing)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#猴子补丁-Monkey-Patch"><span class="toc-text">猴子补丁(Monkey Patch)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程"><span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce"><span class="toc-text">reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可迭代对象、迭代器、生成器"><span class="toc-text">可迭代对象、迭代器、生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程"><span class="toc-text">协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多继承"><span class="toc-text">多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MRO"><span class="toc-text">MRO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C3-算法"><span class="toc-text">C3 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例外"><span class="toc-text">例外</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可变对象-amp-不可变对象"><span class="toc-text">可变对象 &amp; 不可变对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#staticmethod-和-classmethod"><span class="toc-text">@staticmethod 和 @classmethod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射-amp-自省"><span class="toc-text">反射 &amp; 自省</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下划线命名法"><span class="toc-text">下划线命名法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#args-和-kwargs"><span class="toc-text">args 和 *kwargs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新式类-amp-旧式类-经典类"><span class="toc-text">新式类 &amp; 旧式类(经典类)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-和-init"><span class="toc-text">__new__ 和 __init__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量池"><span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object-和-type"><span class="toc-text">object 和 type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元类-metaclass"><span class="toc-text">元类(metaclass)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list、tuple、dict、set-的底层实现原理"><span class="toc-text">list、tuple、dict、set 的底层实现原理</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://file.shivakasu.cn/2e594da7dae7aed97c58/python.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">SHIVAKASU</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Book</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">无聊的知识点之 Python</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2017-01-27 00:43:20"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2017-01-27</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2017-01-27 23:34:20"><i class="fas fa-history fa-fw"></i> 更新于 2017-01-27</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E6%97%A5%E5%B8%B8%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/">日常专业学习</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">8k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 29 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/2017/01/27/interview3/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2017/01/27/interview3/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="Python2-amp-Python3"><a href="#Python2-amp-Python3" class="headerlink" title="Python2 &amp; Python3"></a>Python2 &amp; Python3</h2><ul>
<li>py2的不等于可以用 <code>!=</code> 和 <code>&lt;&gt;</code> 。py3 只能用 <code>!=</code> </li>
<li>py2的 <code>print</code> 是特殊语句，不用加括号。py3的 <code>print</code> 是函数，必须加括号。</li>
<li>py2默认编码是ASCII。py3默认编码是utf-8。使用 <code>print sys.getdefaultencoding()</code> 可以查看。</li>
<li>py2有Unicode数据类型，py3取消了。</li>
<li>py2有long类型，所以整数后面可以加L。py3取消了long类型。</li>
<li>py2有 <code>input</code> 和 <code>raw_input</code> 。py3中取消了py2的 <code>input</code> ，把 <code>raw_input</code> 更名为 <code>input</code> 。</li>
<li>py2的 <code>range()</code> 直接返回列表。py3的 <code>range()</code> 返回的是 range 类型的迭代器。</li>
<li>py2的 “/” 是整除，想得到浮点型的精确商需要把被除数或除数变成浮点数。py3的 “/” 是精确除法，“//” 是整除，即使把整除的两个数换成浮点数，结果也只是整除结果的浮点数表示，不是精确商。</li>
<li>py2有经典类和新式类。py3只有新式类。</li>
<li>py2的 <code>super()</code> 需要输入本身类名和自身作为参数。py3的 <code>super()</code> 不用输入参数，可以直接使用替代上一级父类。</li>
</ul>
<h2 id="Python-中的作用域"><a href="#Python-中的作用域" class="headerlink" title="Python 中的作用域"></a>Python 中的作用域</h2><ul>
<li>Python的作用域一共有4种: L (Local, 局部作用域)，E (Enclosing, 闭包函数外的函数)，G (Global, 全局作用域)，B (Built-in, 内建作用域)。以 L –&gt; E –&gt; G –&gt;B 的规则查找。</li>
</ul>
<h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h2><h3 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h3><ul>
<li>如下，b 是 a 的内部函数，b 调用了 a 的局部变量 x，a 的返回值是函数 b，当调用函数 a 的时候，得到的 c 就是所谓的闭包。闭包包括两部分，一是函数 b，二是 b 所调用的外部变量 x，称为自由变量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">c = a()</span><br><span class="line">c()</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数 b 查询变量 x 的顺序是：b 的内部变量 -&gt; a 的内部变量 -&gt; 全局变量。如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">        x = <span class="number">3</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">c = a()</span><br><span class="line">c()</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">c = a()</span><br><span class="line">c()</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">c = a()</span><br><span class="line">c()</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数 b 中仅能使用自由变量 x，而不能修改 x 的值，一旦对 x 赋值，x 就会被当做 b 的内部变量。解决办法是在 b 中声明 <code>nonlocal x</code> ，就可以对自由变量 x 进行修改。如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">        x = x+<span class="number">1</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">c = a()</span><br><span class="line">c()</span><br><span class="line">输出：UnboundLocalError: local variable <span class="string">'x'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x = x+<span class="number">1</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">c = a()</span><br><span class="line">c()</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>global 关键字</strong>可以无视变量的查找顺序，直接声明对全局变量的引用。如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">global</span> x</span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">c = a()</span><br><span class="line">c()</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包调用自由变量的原理"><a href="#闭包调用自由变量的原理" class="headerlink" title="闭包调用自由变量的原理"></a>闭包调用自由变量的原理</h3><ul>
<li>Python 的函数都有一个 <code>__closure__</code> 属性，如果该函数是闭包的话，这个参数里就会保存可使用的自由变量，存储形式是 Cell 对象。如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">c = a()</span><br><span class="line">print(c.__closure__)</span><br><span class="line">print(c.__closure__[<span class="number">0</span>].cell_contents)</span><br><span class="line">输出：</span><br><span class="line">(&lt;cell at <span class="number">0x0000018D1E9E3828</span>: int object at <span class="number">0x00007FFF1513A1B0</span>&gt;,)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包的优点"><a href="#闭包的优点" class="headerlink" title="闭包的优点"></a>闭包的优点</h3><ul>
<li>封装性好，可以不使用全局变量来为内部函数提供可使用的外部变量。函数 a 就像一个工厂函数，如果其中有多个内部函数 b1、b2、b3，就可以根据用户提供的参数，包装指定的内部函数，提供用户需要的闭包，而这一切都被封装在函数 a 中，不需要泄露到全局。基于同一函数的两个闭包的自由变量是独立、互不影响的，从而提高了闭包的可用性，如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x = x+<span class="number">1</span></span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">c = a()</span><br><span class="line">d = a()</span><br><span class="line">c()</span><br><span class="line">c()</span><br><span class="line">d()</span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ul>
<li>装饰器</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="闭包的一种应用"><a href="#闭包的一种应用" class="headerlink" title="闭包的一种应用"></a>闭包的一种应用</h3><ul>
<li>因为闭包返回的是一个函数，所以可以用闭包的原理去包装函数，然后返回包装后的函数。如下，实现的是在每个函数运行前都输出日志，只需要把函数传给 use_logging，用其内部函数 wrapper 进行包装，这样就避免了在每个函数中都加一行 print，方便维护。有两种使用方式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="comment"># 返回的是 func 的执行结果</span></span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br><span class="line"><span class="comment"># 实际使用的是 wrapper 函数，每次调用 foo 都输出一次日志，并自动执行 foo 函数。巧妙之处在于，包装前后的函数名都是 foo，看上去调用的是 foo，但实际上是在原函数上加了一层 wrapper 。</span></span><br><span class="line">foo = use_logging(foo) </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="comment"># 返回的是 func 函数本身</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo'</span>)</span><br><span class="line"><span class="comment"># 实际使用的是 wrapper 返回的 func 函数，仅在调用 foo 的时候输出一次日志并返回最初的函数 foo，之后调用 d 的时候不再输出日志，直接当做最初的函数 foo 使用。</span></span><br><span class="line">foo = use_logging(foo) </span><br><span class="line">d = foo()</span><br><span class="line">d()</span><br></pre></td></tr></table></figure>
<h3 id="装饰器-1"><a href="#装饰器-1" class="headerlink" title="装饰器"></a>装饰器</h3><ul>
<li>所谓的装饰器就是这种闭包应用的语法糖，下面的代码和上面第一段代码是等价的。好处就是省略了调用 use_logging 对 foo 赋值的步骤，把闭包的应用实现在了函数的定义阶段，而不是使用阶段。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"i am foo"</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<h3 id="面向切片编程"><a href="#面向切片编程" class="headerlink" title="面向切片编程"></a>面向切片编程</h3><ul>
<li>Aspect Oriented Programming(AOP) 是一种编程范式，和 OOP 一样，只是一种设计理念，并没有指定实现的具体方式。AOP 的初衷是将日志记录、性能统计、安全控制、事务处理、异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。显然，AOP 可以基于装饰器实现。</li>
</ul>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><ul>
<li>Python中的垃圾回收器主要使用<strong>引用计数</strong>进行垃圾回收，通过<strong>标记-清理</strong>解决容器对象产生循环引用的问题，再通过<strong>分代回收</strong>以空间换时间的方式来提高垃圾回收的效率。</li>
</ul>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><ul>
<li>在 CPython 源码中，Python 对象的核心是 PyObject 这个结构体，该结构体内部通过 ob_refcnt 变量实现引用计数。对象在创建时引用计数值为 1，当对象的引用计数值为 0 时, 它的内存就会被立即释放掉，即被垃圾回收。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_object &#123;</span><br><span class="line">    <span class="keyword">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用加一的情况：<ul>
<li>对象被创建，<code>a = 1</code></li>
<li>对象被引用，<code>b = a</code></li>
<li>对象被作为参数，传入到一个函数中</li>
<li>对象作为一个元素，存储在容器中</li>
</ul>
</li>
<li>引用减一的情况：<ul>
<li>对象被显式销毁，<code>del a</code></li>
<li>对象的引用被赋予新的对象，<code>b=123</code></li>
<li>一个对象离开他的作用域，比如函数返回后会释放局部变量</li>
<li>对象所在的容器被销毁或者是从容器中删除对象</li>
</ul>
</li>
</ul>
<h3 id="标记-清理"><a href="#标记-清理" class="headerlink" title="标记-清理"></a>标记-清理</h3><ul>
<li>引用计数的一个问题是循环引用，如下。a 和 b 通过循环嵌套，都成为了嵌套深度无穷无尽的两个列表，二者的引用计数值永远不可能为 0 ，所以单凭引用计数无法回收。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: a=[]</span><br><span class="line">In [<span class="number">1</span>]: b=[]</span><br><span class="line">In [<span class="number">2</span>]: a.append(b)</span><br><span class="line">In [<span class="number">3</span>]: b.append(a)</span><br><span class="line">In [<span class="number">4</span>]: a</span><br><span class="line">Out[<span class="number">4</span>]: [[[...]]]</span><br><span class="line">In [<span class="number">5</span>]: b</span><br><span class="line">Out[<span class="number">5</span>]: [[[...]]]</span><br></pre></td></tr></table></figure>
<ul>
<li>只有<strong>容器对象</strong>才会产生循环引用的情况，因为 Python 里引用和赋值的语法相同，两个变量之间的相互引用要么是交换二者的值，要么是变成一个对象的引用，总之简单类型不会出现循环引用。</li>
<li><strong>标记-清理</strong>的原理很简单，直接把所有对象的引用计数值复制一份，再把所有副本的值减一。此时把副本当做引用值来考虑，如果存在两个容器对象循环引用，一定表现为一个引用值为 0 的对象引用了一个引用值为 0 的对象(两个对象可以相同，也就是自引用)，所以就很容易辨认出了。的阶段，标记-清理过程会暂停整个应用程序，等待结束后才会恢复应用程序的运行。</li>
</ul>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><ul>
<li>引用计数和标记-清理的过程速度很慢，所以 Python 采用了和 Java 差不多的分代回收策略，把存活对象分为了三代。对象每逃过一轮的 gc ，就会移动到下个世代，当某一世代被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发 gc 对某一世代的扫描，查看每个世代阈值的方法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="keyword">import</span> gc</span><br><span class="line">In [<span class="number">1</span>]: gc.get_threshold()</span><br><span class="line">Out[<span class="number">1</span>]: (<span class="number">700</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>分代回收所依据的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。出于信任和效率，对于相对长寿的对象，我们相信它们的用处，所以会减少在垃圾回收中扫描它们的频率。</li>
</ul>
<h2 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h2><h3 id="GIL-是什么？"><a href="#GIL-是什么？" class="headerlink" title="GIL 是什么？"></a>GIL 是什么？</h3><ul>
<li>全局解释器锁(Global Interpreter Lock) 不是 Python 语言本身的特性，而是 CPython 解释器所采用的一种机制，CPython 只是一种 Python 解释器的实现，其他的有 Jython、IronPython 等。</li>
<li>采用 GIL 的人正是 Python 的创始者 Guido van Rossum，当时多核芯片与并发编程刚刚兴起，编程语言的开发者需要考虑如何快速适应多核硬件，来提高软件性能和编程语言的市场占有率，Python也不例外受到冲击。但当年依然是单核计算机占绝对的主导地位，所以 Guido van Rossum 真正考虑的并不是如何提升多核 cpu 的利用率，而是如何保证并发编程在单核 cpu 下的线程安全。于是他采用了 GIL，一把在解释器层面的全局互斥锁，使得单个程序只能在单核上运行，同一时刻也只能有一个线程在运行，这是一种最简洁、最优雅的实现线程安全的方法。</li>
<li>GIL 带来的直接好处是可靠性，开发者不需要再加任何细粒度的锁，就能保证线程安全，保证了单线程性能的最优化。但随着多核 cpu 的广泛应用，GIL 的缺点愈发突出，由于只能在一个核上运行，多线程的程序并没有比单线程程序多利用了 cpu 资源，同时多线程的程序还有额外的线程切换的时间消耗，所以在 GIL 的禁锢下，Python 的多线程反而比单线程还要慢，多个任务并发执行反倒比串行执行的效率低。</li>
<li>对于I/O密集型的多线程程序，如网络爬虫，多线程的性能也许不会比单线程低太多。但对于CPU密集型的多线程程序，GIL 就是灾难。</li>
</ul>
<h3 id="为什么没有移除-GIL？"><a href="#为什么没有移除-GIL？" class="headerlink" title="为什么没有移除 GIL？"></a>为什么没有移除 GIL？</h3><ul>
<li>GIL 对单线程的性能优化是显著的。尽管并发编程已经相当普及，单线程的程序依然是广泛使用、不可替代的。如果移除了 GIL，很多常用的函数库都要进行重写，使用细粒度的锁做并发控制，一定会影响程序的性能。作为一种解释型语言，Python 的速度本身就是性能瓶颈，再慢的话恐怕就真的没人用了。因此没有必要牺牲单线程的性能去提升多线程的效率，这种取长补短反而会让 Python 丧失优势。</li>
<li>GIL 采用地太早了，后来开发出的很多第三方库都显式或隐式地依赖了 GIL 的存在，移除 GIL 势必要重构整个 Python 生态，实在是划不来。</li>
</ul>
<h3 id="多线程的替代方案"><a href="#多线程的替代方案" class="headerlink" title="多线程的替代方案"></a>多线程的替代方案</h3><ul>
<li>GIL 的影响无非是多线程无法运行在多核上，其实可以有多种替代方案。</li>
<li>换语言：没有什么是只能用 Python 写的，想用多线程就换 Java。</li>
<li>多进程：Python2.6引入了MultiProcess库来弥补Threading库中GIL带来的缺陷，基于此开发多进程程序，每个进程有单独的GIL，避免了多进程之间对GIL的竞争，从而实现多核的利用。虽然也带来一些同步和通信问题，但至少逃离了GIL的禁锢。</li>
<li>协程：相当于单核上的多线程，但协程的切换代价没有线程大，因为协程是在应用程序层面进行切换，而不是在操作系统层面。如果不是非要用到多核，可以使用协程。</li>
<li>换解释器：GIL 只是 CPython 的问题，可以换 JPython，JPython 基于 JVM，可能也有自己的鸡肋之处吧。或者用 PyPy，支持 JIT，速度据说比 CPython 快。</li>
<li>Ctypes：CPython的优势就是与C模块的结合，而 ctypes 库可以让 Python 直接调用任意的 C 动态库的导出函数，关键在于，ctypes 会在调用 C 函数前释放 GIL，从而摆脱单核的限制。因此，通过把计算任务丢给 ctypes 也可以有效利用到多核。</li>
</ul>
<h2 id="鸭子类型-Duck-Typing"><a href="#鸭子类型-Duck-Typing" class="headerlink" title="鸭子类型(Duck Typing)"></a>鸭子类型(Duck Typing)</h2><ul>
<li>如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子(If it walks like a duck and quacks like a duck, it must be a duck)。鸭子类型是动态类型语言中的一种设计风格，不关注对象的类型，而是关注对象具有的行为。</li>
<li>比如在下面的函数 a 中，因为Python是动态类型语言，所以不需要声明参数 b 的类型。无论 b 是什么类型，只要它能调用 foo 函数，函数 a 就能正常执行，相反，只要 b 不能调用 foo 函数，不管它是什么类型，运行到 <code>b.foo()</code> 都会报错。这就是所谓的关注行为而不关注类型。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(b)</span>:</span></span><br><span class="line">    b.foo()</span><br></pre></td></tr></table></figure>
<h2 id="猴子补丁-Monkey-Patch"><a href="#猴子补丁-Monkey-Patch" class="headerlink" title="猴子补丁(Monkey Patch)"></a>猴子补丁(Monkey Patch)</h2><ul>
<li>在运行时对已有的代码进行修改，达到hot patch的目的。虽然很便利，但也确实搞乱了源代码，感觉没啥用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Foo.bar'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Modified bar'</span>)</span><br><span class="line"></span><br><span class="line">Foo.bar = bar</span><br></pre></td></tr></table></figure>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li>map 函数接收两个参数，一个是函数，一个是可迭代对象，map将传入的函数依次作用到序列的每个元素，返回结果的迭代器。可以用 next 函数逐个取出迭代器中的元素，也可以直接把迭代器对象转换成列表对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: r = map(<span class="keyword">lambda</span> x:x*x, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">In [<span class="number">1</span>]: r</span><br><span class="line">Out[<span class="number">1</span>]: &lt;map at <span class="number">0x18d1ede57c8</span>&gt;</span><br><span class="line">In [<span class="number">2</span>]: next(r)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">1</span></span><br><span class="line">In [<span class="number">3</span>]: next(r)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">4</span></span><br><span class="line">In [<span class="number">4</span>]: next(r)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">9</span></span><br><span class="line">In [<span class="number">5</span>]: list(r)</span><br><span class="line">Out[<span class="number">5</span>]: [<span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul>
<li>reduce 函数 把一个函数作用在一个序列上，这个函数必须接收两个参数，reduce 把结果继续和序列的下一个元素做累积计算。在 Python3 中，reduce不再是内建函数，需要从 functools 模块导入。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">In [<span class="number">1</span>]: r = reduce(<span class="keyword">lambda</span> x,y:x*y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">In [<span class="number">2</span>]: r</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">120</span></span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul>
<li>filter 函数用于过滤序列，接收一个函数和一个序列，把传入的函数依次作用于每个元素，然后根据返回值是 True 还是 False 决定保留还是丢弃该元素。返回值是个迭代器。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: r = filter(<span class="keyword">lambda</span> x:x&gt;<span class="number">3</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">In [<span class="number">1</span>]: r</span><br><span class="line">Out[<span class="number">1</span>]: &lt;filter at <span class="number">0x18d1fb0d148</span>&gt;</span><br><span class="line">In [<span class="number">2</span>]: next(r)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">4</span></span><br><span class="line">In [<span class="number">3</span>]: next(r)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">5</span></span><br><span class="line">In [<span class="number">4</span>]: next(r)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;ipython-input-97-8ebe59a56b1d&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    next(r)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<h2 id="可迭代对象、迭代器、生成器"><a href="#可迭代对象、迭代器、生成器" class="headerlink" title="可迭代对象、迭代器、生成器"></a>可迭代对象、迭代器、生成器</h2><p><img src= "/img/loading.gif" data-src="https://file.shivakasu.cn/ef1c837cd2b38d3997cb/py0.png" alt=""></p>
<p><img src= "/img/loading.gif" data-src="https://file.shivakasu.cn/ea8e8ea6b83e083e5ed2/py1.png" alt=""></p>
<ul>
<li><strong>可迭代对象</strong>只有 <code>__iter__</code> 方法，<strong>迭代器</strong>有 <code>__iter__</code> 和 <code>__next__</code> 方法，可以使用 iter 函数把可迭代对象转换成迭代器。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">In [<span class="number">1</span>]: a.__iter__</span><br><span class="line">Out[<span class="number">1</span>]: &lt;method-wrapper <span class="string">'__iter__'</span> of list object at <span class="number">0x0000018D1EDEC948</span>&gt;</span><br><span class="line">In [<span class="number">2</span>]: a.__next__</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;ipython-input-103-1c26af1277ad&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a.__next__</span><br><span class="line">AttributeError: <span class="string">'list'</span> object has no attribute <span class="string">'__next__'</span></span><br><span class="line">In [<span class="number">3</span>]: a = iter(a)</span><br><span class="line">In [<span class="number">4</span>]: a</span><br><span class="line">Out[<span class="number">4</span>]: &lt;list_iterator at <span class="number">0x18d1edf3548</span>&gt;</span><br><span class="line">In [<span class="number">5</span>]: a.__iter__</span><br><span class="line">Out[<span class="number">5</span>]: &lt;method-wrapper <span class="string">'__iter__'</span> of list_iterator object at <span class="number">0x0000018D1EDF3548</span>&gt;</span><br><span class="line">In [<span class="number">6</span>]: a.__next__</span><br><span class="line">Out[<span class="number">6</span>]: &lt;method-wrapper <span class="string">'__next__'</span> of list_iterator object at <span class="number">0x0000018D1EDF3548</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>生成器</strong>是一种特殊的迭代器，用 <strong>yield 关键字</strong>来实现迭代数据，但迭代器仍然有 <code>__next__</code> 方法。只要有 yield 的函数就是生成器函数，生成器函数的返回值是一个生成器。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">In [<span class="number">1</span>]: a = d()</span><br><span class="line">In [<span class="number">2</span>]: a</span><br><span class="line">Out[<span class="number">2</span>]: &lt;generator object d at <span class="number">0x0000018D1FAFD7C8</span>&gt;</span><br><span class="line">In [<span class="number">3</span>]: a.__next__</span><br><span class="line">Out[<span class="number">3</span>]: &lt;method-wrapper <span class="string">'__next__'</span> of generator object at <span class="number">0x0000018D1FAFD7C8</span>&gt;</span><br><span class="line">In [<span class="number">4</span>]: next(a)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">1</span></span><br><span class="line">In [<span class="number">5</span>]: next(a)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">2</span></span><br><span class="line">In [<span class="number">6</span>]: list(a)</span><br><span class="line">Out[<span class="number">6</span>]: [<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>生成器的强悍之处在于可以传入数据进行计算，当 yield 关键字前有赋值语句时，必须使用 send 函数传入参数，否则赋值失败将抛出 error 。特别的，在执行第一次迭代时，由于只执行到第一个 yield 处就中断了，并没有执行 yield 左侧的赋值语句，所以第一次迭代可以使用原来的 <code>next</code> 函数或 <code>send(None)</code> 来实现，而第二次迭代时用 send 传进的参数，其实就是为第一个 yield 所在的赋值语句提供右值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">()</span>:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        value = <span class="keyword">yield</span> sum</span><br><span class="line">        sum = sum + value</span><br><span class="line">        value = <span class="keyword">yield</span> sum</span><br><span class="line">        sum = sum + value</span><br><span class="line">        value = <span class="keyword">yield</span> sum</span><br><span class="line">        sum = sum + value</span><br><span class="line">        <span class="keyword">yield</span> sum+<span class="number">1</span></span><br><span class="line">In [<span class="number">1</span>]: c = d()</span><br><span class="line">In [<span class="number">2</span>]: c</span><br><span class="line">Out[<span class="number">2</span>]: &lt;generator object d at <span class="number">0x0000018D1FAFD0C8</span>&gt;</span><br><span class="line">In [<span class="number">3</span>]: c.send(<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;ipython-input-149-faf615a598ef&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    c.send(<span class="number">2</span>)</span><br><span class="line">TypeError: can<span class="string">'t send non-None value to a just-started generator</span></span><br><span class="line"><span class="string">In [4]: c.send(None)</span></span><br><span class="line"><span class="string">Out[4]: 0</span></span><br><span class="line"><span class="string">In [5]: c.send(2)</span></span><br><span class="line"><span class="string">Out[5]: 2</span></span><br><span class="line"><span class="string">In [6]: c.send(3)</span></span><br><span class="line"><span class="string">Out[6]: 5</span></span><br><span class="line"><span class="string">In [7]: c.send(5)</span></span><br><span class="line"><span class="string">Out[7]: 11</span></span><br><span class="line"><span class="string">In [8]: c.send(6) # 迭代器已经空了</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "&lt;ipython-input-154-085a6ed6efc0&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    c.send(6)</span></span><br><span class="line"><span class="string">StopIteration</span></span><br></pre></td></tr></table></figure>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul>
<li>协程就是利用了生成器的原理，因为 yield 相当于中断程序，而调用 next 和 send 函数又相当于回到此前中断的位置继续执行，所以能够用这种机制实现多个任务之间的切换。协程的切换只是单纯地操作CPU的上下文，而线程的切换除了保存和恢复CPU上下文，系统还要处理缓存Cache、数据恢复等问题，所以十分耗时。这就是协程相对于线程的优势。</li>
<li>协程的并发本质上和多线程一样，还是只能在单核上运行，同一时刻只能有一个协程在运行，所以对于CPU密集型任务，使用协程还是一样的鸡肋，协程并发主要用于优化IO密集型任务。比如在并发运行多个网络爬虫时，若某个爬虫访问URL后由于网络问题陷入等待，就可以切换到其它爬虫执行，这样就高效利用了IO阻塞的时间，往往可以比单线程串行执行速度更快。</li>
<li>当协程数过多时，手动使用 yield 和 send 进行切换十分复杂，于是就有了asyncio，一个基于协程原理实现异步IO通信的第三方库，类似的还有tornado、gevent等库。</li>
<li>下面用一个例子对比一下串行和并发协程的速度：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello1</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(<span class="string">"Task 01 begin"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>) <span class="comment">#模拟耗时任务3秒</span></span><br><span class="line">    print(<span class="string">"Task 01 end"</span>)</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello2</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(<span class="string">"Task 02 begin"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>) <span class="comment">#模拟耗时任务2秒</span></span><br><span class="line">    print(<span class="string">"Task 02 end"</span>)</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello3</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(<span class="string">"Task 03 begin"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>) <span class="comment">#模拟耗时任务4秒</span></span><br><span class="line">    print(<span class="string">"Task 03 end"</span>)</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    results=<span class="keyword">await</span> asyncio.gather(hello1(<span class="number">10</span>,<span class="number">5</span>),hello2(<span class="number">10</span>,<span class="number">5</span>),hello3(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">asyncio.run(main())</span><br><span class="line">print(<span class="string">"执行时间："</span>,time.time()-start)</span><br><span class="line"></span><br><span class="line"><span class="comment">#######运行结果#########</span></span><br><span class="line">Task <span class="number">01</span> begin</span><br><span class="line">Task <span class="number">02</span> begin</span><br><span class="line">Task <span class="number">03</span> begin</span><br><span class="line">Task <span class="number">02</span> end</span><br><span class="line">Task <span class="number">01</span> end</span><br><span class="line">Task <span class="number">03</span> end</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line">执行时间： <span class="number">4.002401351928711</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello1</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(<span class="string">"Task 01 begin"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"Task 01 end"</span>)</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello2</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(<span class="string">"Task 02 begin"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"Task 02 end"</span>)</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello3</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(<span class="string">"Task 03 begin"</span>)</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"Task 03 end"</span>)</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">hello1(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">hello2(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">hello3(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">print(<span class="string">"执行时间："</span>,time.time()-start)</span><br><span class="line"></span><br><span class="line"><span class="comment">#######运行结果#########</span></span><br><span class="line">Task <span class="number">01</span> begin</span><br><span class="line">Task <span class="number">01</span> end</span><br><span class="line">Task <span class="number">02</span> begin</span><br><span class="line">Task <span class="number">02</span> end</span><br><span class="line">Task <span class="number">03</span> begin</span><br><span class="line">Task <span class="number">03</span> end</span><br><span class="line">执行时间： <span class="number">9.033108234405518</span></span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>重写：和其他面向对象语言一样，子类可以重写父类的方法。</li>
<li>重载：Python 采用鸭子类型的设计理念，不需要支持重载。单个函数就可以支持任何类型的参数，同时可以使用 <em>args 和 *</em>kwargs 进行参数打包，所以也能支持任意数量的参数，只需要在函数内部添加对参数的判别逻辑就够了。</li>
</ul>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><h3 id="MRO"><a href="#MRO" class="headerlink" title="MRO"></a>MRO</h3><ul>
<li>Python 支持多继承，为了避免父类同名方法导致的二义性问题，Python 使用 C3 算法给每个类生成了一个方法解析顺序列表(Method Resolution Order, MRO)，MRO 规定了类继承的顺序，调用某个方法时，会按照 MRO 的顺序逐个访问父类，所以不会出现二义性。换言之，继承的多个父类看似是同一级别的，但 MRO 已经偷偷给他们排好了顺序，分出了亲爹干爹。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"enter A"</span>)</span><br><span class="line">                print(<span class="string">"leave A"</span>)</span><br><span class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"enter B"</span>)</span><br><span class="line">                super().__init__()</span><br><span class="line">                print(<span class="string">"leave B"</span>)</span><br><span class="line">In [<span class="number">2</span>]: <span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"enter C"</span>)</span><br><span class="line">                super().__init__()</span><br><span class="line">                print(<span class="string">"leave C"</span>)</span><br><span class="line">In [<span class="number">3</span>]: <span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"enter D"</span>)</span><br><span class="line">                super().__init__()</span><br><span class="line">                print(<span class="string">"leave D"</span>)</span><br><span class="line">In [<span class="number">4</span>]: d = D()</span><br><span class="line">enter D</span><br><span class="line">enter B</span><br><span class="line">enter C</span><br><span class="line">enter A</span><br><span class="line">leave A</span><br><span class="line">leave C</span><br><span class="line">leave B</span><br><span class="line">leave D</span><br><span class="line">In [<span class="number">5</span>]: D.mro()</span><br><span class="line">Out[<span class="number">5</span>]: [__main__.D, __main__.B, __main__.C, __main__.A, object]</span><br></pre></td></tr></table></figure>
<h3 id="C3-算法"><a href="#C3-算法" class="headerlink" title="C3 算法"></a>C3 算法</h3><ul>
<li>MRO 的计算流程如下。注意，表头是指列表的第一个元素，表尾是指列表第一个元素之后的所有元素。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://file.shivakasu.cn/cd7ccb8942a010c6ca10/py2.png" alt=""></p>
<ul>
<li><p>对于上面的例子，MRO 的计算公式为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
mro(object) &= [object]\\
mro(A) &= [A] + merge(mro(object), [object])\\
&= [A] + merge([object], [object])\\
&= [A] + [object]\\
&= [A,object]\\
mro(B) &= [B] + merge(mro(A), [A])\\
&= [B] + merge([A,object], [A])\\
&= [B,A] + merge([object], [])\\
&= [B,A] + [object]\\
&= [B,A,object]\\
mro(C) &= [C,A,object]\\
mro(D) &= [D] + merge(mro(B), mro(C), [B,C])\\
&= [D] + merge([B,A,object], [C,A,object], [B,C])\\
&= [D,B] + merge([A,object], [C,A,object], [C])\\
&= [D,B,C] + merge([A,object], [A,object])\\
&= [D,B,C,A] + merge([object], [object])\\
&= [D,B,C,A,object]
\end{aligned}</script></li>
<li><p>可以看出，merge操作是C3算法的核心，正是由于删表头的操作，使得菱形继承的情况下 MRO 中不会有重复的类。</p>
</li>
</ul>
<h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h3><ul>
<li>虽然Python支持多继承，但对于内置类型的继承却是有限制的，通常情况下，对于list、set、dict等内置类型，至多可以继承一个。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(list,set)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;ipython-input-43-d3f9bb1ae2c7&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(list,set)</span>:</span></span><br><span class="line">TypeError: multiple bases have instance lay-out conflict</span><br></pre></td></tr></table></figure>
<h2 id="可变对象-amp-不可变对象"><a href="#可变对象-amp-不可变对象" class="headerlink" title="可变对象 &amp; 不可变对象"></a>可变对象 &amp; 不可变对象</h2><ul>
<li>可变对象(mutable)：对象指向的内存中的值可以改变，当更改这个变量的时候，还是指向原来内存中的值，并且在原来的内存值进行原地修改，并没有开辟新的内存。list、dict、set是可变对象。</li>
<li>不可变对象(immutable)：对象指向的内存中的值不可以改变，当改变这个变量的时候，原来指向的内存中的值不变，变量不再指向原来的值，而是开辟一块新的内存，变量指向新的内存。int、float、str 、tuple、bool 是不可变对象。</li>
</ul>
<h2 id="staticmethod-和-classmethod"><a href="#staticmethod-和-classmethod" class="headerlink" title="@staticmethod 和 @classmethod"></a>@staticmethod 和 @classmethod</h2><ul>
<li>@staticmethod 或 @classmethod 修饰的函数，可以不需要类的实例，直接类名.方法名()来调用。</li>
<li>以下所说的 self 和 cls 只是约定俗成的参数名，并不是Python强制规定的，其实用什么参数名都可以，只要保证是第一个参数就够了。</li>
<li>@staticmethod 不需要表示自身对象的self或自身类的cls参数，就跟使用函数一样。</li>
<li>@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。</li>
<li>如果在 @staticmethod 中调用这个类的一些属性方法，只能用类名.属性名或类名.方法名。而 @classmethod 因为持有cls参数，因此既可以用 cls 来调用类的属性和方法，也可以用类名来调用。</li>
</ul>
<h2 id="反射-amp-自省"><a href="#反射-amp-自省" class="headerlink" title="反射 &amp; 自省"></a>反射 &amp; 自省</h2><ul>
<li>反射(Reflection)包括自省(Introspection)和调解(Intercession)。自省的作用是运行的时候检查程序本身，调解的作用是运行的时候修改程序本身，所以反射和自省可以看成是一回事，只是提到自省时一般指的是读取属性，提到反射时一般指的是修改属性。</li>
<li>反射就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，是一种基于字符串的事件驱动。</li>
<li>反射的相关方法：<ul>
<li>getattr：获取指定字符串名称的对象属性</li>
<li>setattr：为对象设置一个属性或方法</li>
<li>hasattr：判断对象是否有对应的属性或方法</li>
<li>delattr：删除指定属性或方法</li>
</ul>
</li>
<li>自省的相关方法：<ul>
<li>dir：返回对象的属性名称经过排序的列表</li>
<li>type：返回对象的类型</li>
<li>isinstance：判断对象是否是某个特定类型或定制类的实例</li>
</ul>
</li>
</ul>
<h2 id="下划线命名法"><a href="#下划线命名法" class="headerlink" title="下划线命名法"></a>下划线命名法</h2><ul>
<li><strong>单下划线开头</strong>：在一个模块中以单下划线开头的变量和函数被默认当作内部变量和函数，无法用 <code>from a_module import *</code> 的方式导入，但如果使用 <code>import a_module</code> 方式导入了整个模块，仍然可以用 <code>a_module._some_var</code> 的形式访问到内部对象。</li>
<li><strong>单下划线结尾</strong>：Python 官方推荐的一种代码样式，用来避免与关键字冲突，比如想定义一个叫 class 的变量，就可以定义成 class_</li>
<li><strong>双下划线开头但非双下划线结尾</strong>：称为名称改写(Name Mangling)，会给成员自动加上类名前缀，使其不能被子类和类外直接访问，但如果手动加上类名就可以访问，所以感觉没什么用，如下。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">            __a = <span class="number">1</span></span><br><span class="line">            __b_ = <span class="number">2</span></span><br><span class="line">            c_ = <span class="number">3</span></span><br><span class="line">            __d__ = <span class="number">4</span></span><br><span class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">In [<span class="number">2</span>]: A.__a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;ipython-input-13-aca55768bfd2&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    A.__a</span><br><span class="line">AttributeError: type object <span class="string">'A'</span> has no attribute <span class="string">'__a'</span></span><br><span class="line">In [<span class="number">3</span>]: A.__b_</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;ipython-input-14-4ebf831525fb&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    A.__b_</span><br><span class="line">AttributeError: type object <span class="string">'A'</span> has no attribute <span class="string">'__b_'</span></span><br><span class="line">In [<span class="number">4</span>]: A.c_</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">3</span></span><br><span class="line">In [<span class="number">5</span>]: A.__d__</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">4</span></span><br><span class="line">In [<span class="number">6</span>]: B.__a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;ipython-input-17-bc65bca5c07a&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    B.__a</span><br><span class="line">AttributeError: type object <span class="string">'B'</span> has no attribute <span class="string">'__a'</span></span><br><span class="line">In [<span class="number">7</span>]: B.__b_</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;ipython-input-18-8f45e964d12c&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    B.__b_</span><br><span class="line">AttributeError: type object <span class="string">'B'</span> has no attribute <span class="string">'__b_'</span></span><br><span class="line">In [<span class="number">8</span>]: B.c_</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">3</span></span><br><span class="line">In [<span class="number">9</span>]: B.__d__</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">4</span></span><br><span class="line">In [<span class="number">10</span>]: A._A__a</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">1</span></span><br><span class="line">In [<span class="number">11</span>]: B._A__a</span><br><span class="line">Out[<span class="number">11</span>]: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>双下划线开头且双下划线结尾</strong>：Python约定俗成的魔术对象的命名方法，虽然也可以用作自定义的变量和函数名，但官方不推荐这么用。</li>
</ul>
<h2 id="args-和-kwargs"><a href="#args-和-kwargs" class="headerlink" title="args 和 *kwargs"></a><em>args 和 *</em>kwargs</h2><ul>
<li>都用于函数参数的打包。<em>args 把参数打包成元组，**kwargs 把参数打包成字典，同时使用时 </em>args 必须在 **kwargs 的前面。当然，args 和 kwargs 都是约定俗成的名字，换成任何名字都可以。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(x, *y, **z)</span>:</span></span><br><span class="line">            print(x)</span><br><span class="line">            print(y,type(y))</span><br><span class="line">            print(z,type(z))</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: a(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line">&#123;&#125; &lt;class 'dict'&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a(<span class="number">1</span>,<span class="number">2</span>,q=<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">  File <span class="string">"&lt;ipython-input-33-b28d4087f846&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    a(<span class="number">1</span>,<span class="number">2</span>,q=<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">             ^</span><br><span class="line">SyntaxError: positional argument follows keyword argument</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: a(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,q=<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line">&#123;'q': 1&#125; &lt;class 'dict'&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>此外，也可以反向使用 <em> 和 *</em> ，在调用函数时对参数进行解包，然后分发给函数。如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(y)</span><br><span class="line">    print(z)</span><br><span class="line">    </span><br><span class="line">In [<span class="number">1</span>]: a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;ipython-input-36-6d50bc4c7818&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">TypeError: a() missing <span class="number">2</span> required positional arguments: <span class="string">'y'</span> <span class="keyword">and</span> <span class="string">'z'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: a(*(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: a(**&#123;<span class="string">'x'</span>:<span class="number">1</span>,<span class="string">'y'</span>:<span class="number">2</span>,<span class="string">'z'</span>:<span class="number">3</span>&#125;)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="新式类-amp-旧式类-经典类"><a href="#新式类-amp-旧式类-经典类" class="headerlink" title="新式类 &amp; 旧式类(经典类)"></a>新式类 &amp; 旧式类(经典类)</h2><ul>
<li>Python3 全部是新式类，反正 Python2 已经被彻底淘汰了，没必要关心旧式类。</li>
</ul>
<h2 id="new-和-init"><a href="#new-和-init" class="headerlink" title="__new__ 和 __init__"></a><code>__new__</code> 和 <code>__init__</code></h2><ul>
<li>new 是一个静态方法，init 是一个实例方法</li>
<li>new 方法会返回一个创建的实例，init 什么都不返回，负责对 new 创建出的实例做初始化</li>
<li>只有在 new 返回一个 cls 的实例时后面的 init 才能被调用</li>
</ul>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><ul>
<li>和 Java 一样，Python 也有基本类型的常量池。</li>
<li>is 比较对象的地址，== 比较对象的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: a = <span class="number">123</span></span><br><span class="line">In [<span class="number">1</span>]: b = <span class="number">123</span></span><br><span class="line">In [<span class="number">2</span>]: id(a)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">140733547000016</span></span><br><span class="line">In [<span class="number">3</span>]: id(b)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">140733547000016</span></span><br><span class="line">In [<span class="number">4</span>]: a==b</span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">5</span>]: a <span class="keyword">is</span> b</span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">6</span>]: a = <span class="number">123456789</span></span><br><span class="line">In [<span class="number">7</span>]: b = <span class="number">123456789</span></span><br><span class="line">In [<span class="number">8</span>]: id(a)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">2204199166896</span></span><br><span class="line">In [<span class="number">9</span>]: id(b)</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">2204199167888</span></span><br><span class="line">In [<span class="number">10</span>]: a==b</span><br><span class="line">Out[<span class="number">10</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">11</span>]: a <span class="keyword">is</span> b</span><br><span class="line">Out[<span class="number">11</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="object-和-type"><a href="#object-和-type" class="headerlink" title="object 和 type"></a>object 和 type</h2><ul>
<li>面向对象思想中有两条主线关系，一条是类与类的关系，即继承，另一条是类与实例的关系，即实例化。object 是继承关系的顶峰，是所有类的基类(父类)，而 type 是实例化关系的顶峰，Python 中的一切都是 type 类的实例(包括 type 本身)。</li>
<li>因为这两条线无法合并，所以作为各自主线的顶峰，object 和 type 的关系十分尴尬。从继承关系的角度看，type 是 object 的子类，从实例化角度看，object 又是 type 的一个实例，二者就像鸡生蛋蛋生鸡的关系一样。究其原因，还是因为在底层C的实现中没有把这两条线统一。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://file.shivakasu.cn/ec31c92986eef3f0dfed/py2.jpg" alt=""></p>
<p><img src= "/img/loading.gif" data-src="https://file.shivakasu.cn/7d4c9a3e14ed0cc9f58a/py3.png" alt=""></p>
<h2 id="元类-metaclass"><a href="#元类-metaclass" class="headerlink" title="元类(metaclass)"></a>元类(metaclass)</h2><ul>
<li>元类，顾名思义，就是创建类的类。除了一般的定义类的方式，Python中还有两种创建类的方式，一种是使用type函数，另一种是使用元类。</li>
<li>type一般用于获取对象的类型，但由于Python中的一切都是type的实例，所以自然能够通过type来创建新的类。如下，type有三个参数，第一个参数是类的 <code>__name__</code> 属性，一般定义类的时候，<code>__name__</code> 默认和类的标识符同名，但这里可以更改，类的标识符是A，类的名字是 newClass，第二个参数是父类(mro 元组)，第三个参数是类的属性和方法的字典。根据结果来看，A 是创建出来的一个类，类型是type，对A进行实例化得到a，a的类型是newClass。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: A = type(<span class="string">'newClass'</span>,(object,),&#123;&#125;)</span><br><span class="line">In [<span class="number">1</span>]: a = A()</span><br><span class="line">In [<span class="number">2</span>]: type(A)</span><br><span class="line">Out[<span class="number">2</span>]: type</span><br><span class="line">In [<span class="number">3</span>]: type(a)</span><br><span class="line">Out[<span class="number">3</span>]: __main__.newClass</span><br></pre></td></tr></table></figure>
<ul>
<li>元类创建类的原理和type函数完全一样，如下。A就是元类，元类必须继承自type，new函数用于创建实例，而所有的类都是type的实例，所以A的new函数就是用来创建类的，三个参数和上面所说的type函数的三个参数完全一样。这里通过给attrs字典赋值，为新的类添加了一个foo方法。而在B中，通过指定 <code>metaclass=A</code> ，就可以获得A赋予的foo方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">0</span>]: <span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(type)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,name,bases,attrs)</span>:</span></span><br><span class="line">                attrs[<span class="string">'foo'</span>] = <span class="keyword">lambda</span> self:print(<span class="string">"calling foo"</span>)</span><br><span class="line">                <span class="keyword">return</span> type.__new__(cls,name,bases,attrs)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(metaclass=A)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">In [<span class="number">0</span>]: b=B()</span><br><span class="line">In [<span class="number">0</span>]: b.foo()</span><br><span class="line">calling foo</span><br></pre></td></tr></table></figure>
<ul>
<li>继承元类与继承一般类的区别在于，继承一般类时，子类只是复制了父类的全部属性和方法，父类并不能干预子类的创建过程。而在继承元类时，元类的new方法中可以指定子类的名字、mro 元组、属性与方法，相当于完全操纵着子类的创建过程。</li>
</ul>
<h2 id="list、tuple、dict、set-的底层实现原理"><a href="#list、tuple、dict、set-的底层实现原理" class="headerlink" title="list、tuple、dict、set 的底层实现原理"></a>list、tuple、dict、set 的底层实现原理</h2><ul>
<li>有时间再看源码吧~</li>
<li>留坑~</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:wkx1996@foxmail.com">w.k.x.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shivakasu.cn/2017/01/27/interview3/">https://shivakasu.cn/2017/01/27/interview3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shivakasu.cn" target="_blank">SHIVAKASU</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="http://file.shivakasu.cn/2f6de001e698ed5939de/arg.jpg" data-sites="facebook,twitter,wechat,weibo,qq,qzone,douban,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://file.shivakasu.cn/4a84dcfb31806db98b2a/wechat.png" alt="微信" onclick="window.open('https://file.shivakasu.cn/4a84dcfb31806db98b2a/wechat.png')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://file.shivakasu.cn/982f781ef31cbc46968b/alipay.jpg" alt="支付宝" onclick="window.open('https://file.shivakasu.cn/982f781ef31cbc46968b/alipay.jpg')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2017/01/28/interview5/"><img class="prev-cover" data-src="https://file.shivakasu.cn/f9090341835f7511eae5/bigdata.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">无聊的知识点之大数据</div></div></a></div><div class="next-post pull-right"><a href="/2017/01/26/interview4/"><img class="next-cover" data-src="https://file.shivakasu.cn/7374683f987a24a05180/sql.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">无聊的知识点之数据库</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2017/01/26/interview2/" title="无聊的知识点之设计模式"><img class="relatedPosts_cover" data-src="https://file.shivakasu.cn/43003cda4506046a2bdd/design.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-01-26</div><div class="relatedPosts_title">无聊的知识点之设计模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/10/arg0/" title="《程序员代码面试指南》"><img class="relatedPosts_cover" data-src="http://file.shivakasu.cn/5f37cb297aa622ca620e/interview0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-10</div><div class="relatedPosts_title">《程序员代码面试指南》</div></div></a></div><div class="relatedPosts_item"><a href="/2017/01/24/interview0/" title="无聊的知识点之系统"><img class="relatedPosts_cover" data-src="https://file.shivakasu.cn/48b4c92f979726d97437/cs.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-01-24</div><div class="relatedPosts_title">无聊的知识点之系统</div></div></a></div><div class="relatedPosts_item"><a href="/2017/01/26/interview4/" title="无聊的知识点之数据库"><img class="relatedPosts_cover" data-src="https://file.shivakasu.cn/7374683f987a24a05180/sql.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-01-26</div><div class="relatedPosts_title">无聊的知识点之数据库</div></div></a></div><div class="relatedPosts_item"><a href="/2017/01/28/interview5/" title="无聊的知识点之大数据"><img class="relatedPosts_cover" data-src="https://file.shivakasu.cn/f9090341835f7511eae5/bigdata.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-01-28</div><div class="relatedPosts_title">无聊的知识点之大数据</div></div></a></div><div class="relatedPosts_item"><a href="/2017/01/25/interview1/" title="无聊的知识点之 Java"><img class="relatedPosts_cover" data-src="https://file.shivakasu.cn/47ac8cadfbd9da344fc9/java.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-01-25</div><div class="relatedPosts_title">无聊的知识点之 Java</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'qIfwEiuSjlc5vyminB1rx2qX-gzGzoHsz',
  appKey: 'erfVXuW3AybzbWGqxSGxnBRp',
  placeholder: '来都来了，说点儿什么吧~',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: true,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By w.k.x.</div><div class="framework-info"><span>DrivenBy </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>京ICP备19001969号-1</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
  pangu.autoSpacingPage()
})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>